// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: teleport/lib/teleterm/v1/auth_settings.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
// Teleport
// Copyright (C) 2023  Gravitational, Inc.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// ClientVersionStatus describes the compatibility status of the client version when compared
/// against the version of the server.
enum Teleport_Lib_Teleterm_V1_ClientVersionStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case compatUnspecified // = 0

  /// CLIENT_VERSION_STATUS_OK means that the client is on the same major version as the server or at
  /// most one major version behind.
  /// For example, the server is on v17.1.0 and the client is on v16.0.4.
  case ok // = 1

  /// CLIENT_VERSION_STATUS_TOO_OLD means that the client is at least two major versions behind the
  /// server.
  /// For example, the server is on v19.3.2 and the client is on v17.4.1.
  case tooOld // = 2

  /// CLIENT_VERSION_STATUS_TOO_NEW means that the client is at least one major version ahead of the
  /// server.
  /// For example, the server is on v18.2.1 and the client is on v19.0.0.
  case tooNew // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .compatUnspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .compatUnspecified
    case 1: self = .ok
    case 2: self = .tooOld
    case 3: self = .tooNew
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .compatUnspecified: return 0
    case .ok: return 1
    case .tooOld: return 2
    case .tooNew: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Teleport_Lib_Teleterm_V1_ClientVersionStatus] = [
    .compatUnspecified,
    .ok,
    .tooOld,
    .tooNew,
  ]

}

/// AuthSettings contains the form of authentication the auth server supports.
struct Teleport_Lib_Teleterm_V1_AuthSettings: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// local_auth_enabled is a flag that enables local authentication
  var localAuthEnabled: Bool = false

  /// auth_providers contains a list of auth providers
  var authProviders: [Teleport_Lib_Teleterm_V1_AuthProvider] = []

  /// has_message_of_the_day is a flag indicating that the cluster has MOTD
  /// banner text that must be retrieved, displayed and acknowledged by
  /// the user.
  var hasMessageOfTheDay_p: Bool = false

  /// auth_type is the authentication type e.g. "local", "github", "saml", "oidc"
  var authType: String = String()

  /// allow_passwordless is true if passwordless logins are allowed.
  var allowPasswordless: Bool = false

  /// local_connector_name is the name of the local connector.
  var localConnectorName: String = String()

  /// client_version_status describes the compatibility status of the client version when compared
  /// against the version of the server.
  var clientVersionStatus: Teleport_Lib_Teleterm_V1_ClientVersionStatus = .compatUnspecified

  var versions: Teleport_Lib_Teleterm_V1_Versions {
    get {return _versions ?? Teleport_Lib_Teleterm_V1_Versions()}
    set {_versions = newValue}
  }
  /// Returns true if `versions` has been explicitly set.
  var hasVersions: Bool {return self._versions != nil}
  /// Clears the value of `versions`. Subsequent reads from it will return its default value.
  mutating func clearVersions() {self._versions = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _versions: Teleport_Lib_Teleterm_V1_Versions? = nil
}

/// AuthProvider describes a way of authentication that is supported by the server. Auth provider is
/// referred to as "auth connector" on the backend.
struct Teleport_Lib_Teleterm_V1_AuthProvider: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type is the auth provider type (github|oidc|etc)
  var type: String = String()

  /// Name is the internal name of the connector.
  var name: String = String()

  /// Display is the display name for the connector.
  var displayName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Versions contains versions of different components that can be used to show the client
/// incompatibility warning. This way Connect can show the warning before the cluster is added to the
/// app.
struct Teleport_Lib_Teleterm_V1_Versions: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var minClient: String = String()

  /// client is the version of tsh. Included for convenience, in theory the Electron app knows this
  /// without asking tsh.
  var client: String = String()

  var server: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "teleport.lib.teleterm.v1"

extension Teleport_Lib_Teleterm_V1_ClientVersionStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CLIENT_VERSION_STATUS_COMPAT_UNSPECIFIED"),
    1: .same(proto: "CLIENT_VERSION_STATUS_OK"),
    2: .same(proto: "CLIENT_VERSION_STATUS_TOO_OLD"),
    3: .same(proto: "CLIENT_VERSION_STATUS_TOO_NEW"),
  ]
}

extension Teleport_Lib_Teleterm_V1_AuthSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "local_auth_enabled"),
    4: .standard(proto: "auth_providers"),
    5: .standard(proto: "has_message_of_the_day"),
    6: .standard(proto: "auth_type"),
    7: .standard(proto: "allow_passwordless"),
    8: .standard(proto: "local_connector_name"),
    9: .standard(proto: "client_version_status"),
    10: .same(proto: "versions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.localAuthEnabled) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.authProviders) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.hasMessageOfTheDay_p) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.authType) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.allowPasswordless) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.localConnectorName) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.clientVersionStatus) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._versions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.localAuthEnabled != false {
      try visitor.visitSingularBoolField(value: self.localAuthEnabled, fieldNumber: 1)
    }
    if !self.authProviders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.authProviders, fieldNumber: 4)
    }
    if self.hasMessageOfTheDay_p != false {
      try visitor.visitSingularBoolField(value: self.hasMessageOfTheDay_p, fieldNumber: 5)
    }
    if !self.authType.isEmpty {
      try visitor.visitSingularStringField(value: self.authType, fieldNumber: 6)
    }
    if self.allowPasswordless != false {
      try visitor.visitSingularBoolField(value: self.allowPasswordless, fieldNumber: 7)
    }
    if !self.localConnectorName.isEmpty {
      try visitor.visitSingularStringField(value: self.localConnectorName, fieldNumber: 8)
    }
    if self.clientVersionStatus != .compatUnspecified {
      try visitor.visitSingularEnumField(value: self.clientVersionStatus, fieldNumber: 9)
    }
    try { if let v = self._versions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Lib_Teleterm_V1_AuthSettings, rhs: Teleport_Lib_Teleterm_V1_AuthSettings) -> Bool {
    if lhs.localAuthEnabled != rhs.localAuthEnabled {return false}
    if lhs.authProviders != rhs.authProviders {return false}
    if lhs.hasMessageOfTheDay_p != rhs.hasMessageOfTheDay_p {return false}
    if lhs.authType != rhs.authType {return false}
    if lhs.allowPasswordless != rhs.allowPasswordless {return false}
    if lhs.localConnectorName != rhs.localConnectorName {return false}
    if lhs.clientVersionStatus != rhs.clientVersionStatus {return false}
    if lhs._versions != rhs._versions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_AuthProvider: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthProvider"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "name"),
    3: .standard(proto: "display_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Lib_Teleterm_V1_AuthProvider, rhs: Teleport_Lib_Teleterm_V1_AuthProvider) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.name != rhs.name {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_Versions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Versions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "min_client"),
    2: .same(proto: "client"),
    3: .same(proto: "server"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.minClient) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.client) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.server) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.minClient.isEmpty {
      try visitor.visitSingularStringField(value: self.minClient, fieldNumber: 1)
    }
    if !self.client.isEmpty {
      try visitor.visitSingularStringField(value: self.client, fieldNumber: 2)
    }
    if !self.server.isEmpty {
      try visitor.visitSingularStringField(value: self.server, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Lib_Teleterm_V1_Versions, rhs: Teleport_Lib_Teleterm_V1_Versions) -> Bool {
    if lhs.minClient != rhs.minClient {return false}
    if lhs.client != rhs.client {return false}
    if lhs.server != rhs.server {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
