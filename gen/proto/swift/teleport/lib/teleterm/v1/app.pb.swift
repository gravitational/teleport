// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: teleport/lib/teleterm/v1/app.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
// Teleport
// Copyright (C) 2024 Gravitational, Inc.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// App describes an app resource.
struct Teleport_Lib_Teleterm_V1_App: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// uri uniquely identifies an app within Teleport Connect.
  var uri: String = String()

  /// name is the name of the app.
  var name: String = String()

  /// endpoint_uri is the URI to which the app service is going to proxy requests. It corresponds to
  /// app_service.apps[].uri in the Teleport configuration.
  var endpointUri: String = String()

  /// desc is the app description.
  var desc: String = String()

  /// aws_console is true if this app is AWS management console.
  var awsConsole: Bool = false

  /// public_addr is the public address the application is accessible at.
  ///
  /// If the app resource has its public_addr field set, this field returns the value of public_addr
  /// from the app resource.
  ///
  /// If the app resource does not have public_addr field set, this field returns the name of the app
  /// under the proxy hostname of the cluster to which the app belongs, e.g.,
  /// dumper.root-cluster.com, example-app.leaf-cluster.org.
  ///
  /// In both cases public_addr does not include a port number. This is all cool and fine if the
  /// actual public address and the proxy service share the default port 443. In a scenario where the
  /// proxy uses a non-standard port like 3080 and the public address uses 443, it might cause
  /// problems. public_addr of an app resource cannot include a port number. The backend will reject
  /// such app resource with an error saying "public_addr "example.com:1337" can not contain a port,
  /// applications will be available on the same port as the web proxy". This is not always the case
  /// for custom public addresses. Ultimately, it means that public_addr alone might not be enough to
  /// access the app if either the cluster or the custom address use a port number other than 443.
  ///
  /// public_addr is always empty for SAML applications.
  var publicAddr: String = String()

  /// friendly_name is a user readable name of the app.
  /// Right now, it is set only for Okta applications.
  /// It is constructed from a label value.
  /// See more in api/types/resource.go.
  var friendlyName: String = String()

  /// saml_app is true if the application is a SAML Application (Service Provider).
  var samlApp: Bool = false

  /// labels is a list of labels for the app.
  var labels: [Teleport_Lib_Teleterm_V1_Label] = []

  /// fqdn is the hostname under which the app is accessible within the root cluster. It is used by
  /// the Web UI to route the requests from the /web/launch URL to the correct app. fqdn by itself
  /// does not include the port number, so fqdn alone cannot be used to launch an app, hence why it's
  /// incorporated into the /web/launch URL.
  ///
  /// If the app belongs to a root cluster, fqdn is equal to public_addr or [name].[root cluster
  /// proxy hostname] if public_addr is not present.
  /// If the app belongs to a leaf cluster, fqdn is equal to [name].[root cluster proxy hostname].
  ///
  /// fqdn is not present for SAML applications. Available only when the app was fetched through the
  /// ListUnifiedResources RPC.
  var fqdn: String = String()

  /// aws_roles is a list of AWS IAM roles for the application representing AWS console. Available
  /// only when the app wast fetched through the ListUnifiedResources RPC.
  var awsRoles: [Teleport_Lib_Teleterm_V1_AWSRole] = []

  /// TCPPorts is a list of ports and port ranges that an app agent can forward connections to.
  /// Only applicable to TCP App Access.
  /// If this field is not empty, URI is expected to contain no port number and start with the tcp
  /// protocol.
  var tcpPorts: [Teleport_Lib_Teleterm_V1_PortRange] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AwsRole describes AWS IAM role.
struct Teleport_Lib_Teleterm_V1_AWSRole: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name is the full role name with the entire path.
  var name: String = String()

  /// Display is the role display name.
  var display: String = String()

  /// ARN is the full role ARN.
  var arn: String = String()

  /// AccountID is the AWS Account ID this role refers to.
  var accountID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// PortRange describes a port range for TCP apps. The range starts with Port and ends with EndPort.
/// PortRange can be used to describe a single port in which case the Port field is the port and the
/// EndPort field is 0.
struct Teleport_Lib_Teleterm_V1_PortRange: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Port describes the start of the range. It must be between 1 and 65535.
  var port: UInt32 = 0

  /// EndPort describes the end of the range, inclusive. If set, it must be between 2 and 65535 and
  /// be greater than Port when describing a port range. When omitted or set to zero, it signifies
  /// that the port range defines a single port.
  var endPort: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// RouteToApp is used by the auth service and the app service during cert generation and routing.
/// It's purpose is to point to a specific app within a root cluster. Kind of like an app URI in
/// Connect, but with extra data attached.
struct Teleport_Lib_Teleterm_V1_RouteToApp: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// name is the name of the app within a cluster.
  var name: String = String()

  /// public_addr is the address under which the app can be reached. It's just the hostname, it does
  /// not include the schema or the port number. See the docs for public_addr of
  /// the App message for a more thorough description.
  var publicAddr: String = String()

  /// cluster_name is the name of the cluster that the app belongs to. In the case of the root
  /// cluster, it's not guaranteed to be equal to the proxy hostname â€“ the root cluster might have a
  /// distinct name set.
  var clusterName: String = String()

  /// uri is the URI which the app service is going to proxy requests to.
  var uri: String = String()

  /// target_port is the port of a multi-port TCP app that the connection is going to be proxied to.
  var targetPort: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "teleport.lib.teleterm.v1"

extension Teleport_Lib_Teleterm_V1_App: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".App"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uri"),
    2: .same(proto: "name"),
    3: .standard(proto: "endpoint_uri"),
    4: .same(proto: "desc"),
    5: .standard(proto: "aws_console"),
    6: .standard(proto: "public_addr"),
    7: .standard(proto: "friendly_name"),
    8: .standard(proto: "saml_app"),
    9: .same(proto: "labels"),
    10: .same(proto: "fqdn"),
    11: .standard(proto: "aws_roles"),
    12: .standard(proto: "tcp_ports"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.endpointUri) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.desc) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.awsConsole) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.publicAddr) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.friendlyName) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.samlApp) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.labels) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.fqdn) }()
      case 11: try { try decoder.decodeRepeatedMessageField(value: &self.awsRoles) }()
      case 12: try { try decoder.decodeRepeatedMessageField(value: &self.tcpPorts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.endpointUri.isEmpty {
      try visitor.visitSingularStringField(value: self.endpointUri, fieldNumber: 3)
    }
    if !self.desc.isEmpty {
      try visitor.visitSingularStringField(value: self.desc, fieldNumber: 4)
    }
    if self.awsConsole != false {
      try visitor.visitSingularBoolField(value: self.awsConsole, fieldNumber: 5)
    }
    if !self.publicAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.publicAddr, fieldNumber: 6)
    }
    if !self.friendlyName.isEmpty {
      try visitor.visitSingularStringField(value: self.friendlyName, fieldNumber: 7)
    }
    if self.samlApp != false {
      try visitor.visitSingularBoolField(value: self.samlApp, fieldNumber: 8)
    }
    if !self.labels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.labels, fieldNumber: 9)
    }
    if !self.fqdn.isEmpty {
      try visitor.visitSingularStringField(value: self.fqdn, fieldNumber: 10)
    }
    if !self.awsRoles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.awsRoles, fieldNumber: 11)
    }
    if !self.tcpPorts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tcpPorts, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Lib_Teleterm_V1_App, rhs: Teleport_Lib_Teleterm_V1_App) -> Bool {
    if lhs.uri != rhs.uri {return false}
    if lhs.name != rhs.name {return false}
    if lhs.endpointUri != rhs.endpointUri {return false}
    if lhs.desc != rhs.desc {return false}
    if lhs.awsConsole != rhs.awsConsole {return false}
    if lhs.publicAddr != rhs.publicAddr {return false}
    if lhs.friendlyName != rhs.friendlyName {return false}
    if lhs.samlApp != rhs.samlApp {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.fqdn != rhs.fqdn {return false}
    if lhs.awsRoles != rhs.awsRoles {return false}
    if lhs.tcpPorts != rhs.tcpPorts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_AWSRole: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AWSRole"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "display"),
    3: .same(proto: "arn"),
    4: .standard(proto: "account_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.display) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.arn) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.accountID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.display.isEmpty {
      try visitor.visitSingularStringField(value: self.display, fieldNumber: 2)
    }
    if !self.arn.isEmpty {
      try visitor.visitSingularStringField(value: self.arn, fieldNumber: 3)
    }
    if !self.accountID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Lib_Teleterm_V1_AWSRole, rhs: Teleport_Lib_Teleterm_V1_AWSRole) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.display != rhs.display {return false}
    if lhs.arn != rhs.arn {return false}
    if lhs.accountID != rhs.accountID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_PortRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PortRange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "port"),
    2: .standard(proto: "end_port"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.port) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.endPort) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.port != 0 {
      try visitor.visitSingularUInt32Field(value: self.port, fieldNumber: 1)
    }
    if self.endPort != 0 {
      try visitor.visitSingularUInt32Field(value: self.endPort, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Lib_Teleterm_V1_PortRange, rhs: Teleport_Lib_Teleterm_V1_PortRange) -> Bool {
    if lhs.port != rhs.port {return false}
    if lhs.endPort != rhs.endPort {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_RouteToApp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RouteToApp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "public_addr"),
    3: .standard(proto: "cluster_name"),
    4: .same(proto: "uri"),
    5: .standard(proto: "target_port"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.publicAddr) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.targetPort) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.publicAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.publicAddr, fieldNumber: 2)
    }
    if !self.clusterName.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterName, fieldNumber: 3)
    }
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 4)
    }
    if self.targetPort != 0 {
      try visitor.visitSingularUInt32Field(value: self.targetPort, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Lib_Teleterm_V1_RouteToApp, rhs: Teleport_Lib_Teleterm_V1_RouteToApp) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.publicAddr != rhs.publicAddr {return false}
    if lhs.clusterName != rhs.clusterName {return false}
    if lhs.uri != rhs.uri {return false}
    if lhs.targetPort != rhs.targetPort {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
