// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: teleport/accesslist/v1/accesslist.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2023 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// ReviewFrequency is the frequency of reviews.
enum Teleport_Accesslist_V1_ReviewFrequency: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unspecified // = 0
  case oneMonth // = 1
  case threeMonths // = 3
  case sixMonths // = 6
  case oneYear // = 12
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .oneMonth
    case 3: self = .threeMonths
    case 6: self = .sixMonths
    case 12: self = .oneYear
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .oneMonth: return 1
    case .threeMonths: return 3
    case .sixMonths: return 6
    case .oneYear: return 12
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Teleport_Accesslist_V1_ReviewFrequency] = [
    .unspecified,
    .oneMonth,
    .threeMonths,
    .sixMonths,
    .oneYear,
  ]

}

/// ReviewDayOfMonth is the day of month that reviews will repeat on.
enum Teleport_Accesslist_V1_ReviewDayOfMonth: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unspecified // = 0
  case first // = 1
  case fifteenth // = 15
  case last // = 31
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .first
    case 15: self = .fifteenth
    case 31: self = .last
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .first: return 1
    case .fifteenth: return 15
    case .last: return 31
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Teleport_Accesslist_V1_ReviewDayOfMonth] = [
    .unspecified,
    .first,
    .fifteenth,
    .last,
  ]

}

/// MembershipKind represents the different kinds of list membership
enum Teleport_Accesslist_V1_MembershipKind: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int

  /// MEMBERSHIP_KIND_UNSPECIFIED represents list members that are of
  /// unknown membership kind, defaulting to being treated as type USER
  case unspecified // = 0

  /// MEMBERSHIP_KIND_USER represents list members that are normal users
  case user // = 1

  /// MEMBERSHIP_KIND_LIST represents list members that are nested Access Lists
  case list // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .user
    case 2: self = .list
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .user: return 1
    case .list: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Teleport_Accesslist_V1_MembershipKind] = [
    .unspecified,
    .user,
    .list,
  ]

}

/// IneligibleStatus describes how the user is ineligible.
enum Teleport_Accesslist_V1_IneligibleStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int

  /// INELIGIBLE_STATUS_UNSPECIFIED means eligiblity is unknown.
  case unspecified // = 0

  /// INELIGIBLE_STATUS_ELIGIBLE means checks were done and user met all
  /// requirements.
  case eligible // = 1

  /// INELIGIBLE_STATUS_USER_NOT_EXIST means user was not found in backend.
  case userNotExist // = 2

  /// INELIGIBLE_STATUS_MISSING_REQUIREMENTS means user is missing some
  /// requirements defined by AccessListRequires (fields can be either
  /// ownership_requires or membership_requires)
  case missingRequirements // = 3

  /// INELIGIBLE_STATUS_EXPIRED means user is expired.
  /// Only applicable to members.
  case expired // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .eligible
    case 2: self = .userNotExist
    case 3: self = .missingRequirements
    case 4: self = .expired
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .eligible: return 1
    case .userNotExist: return 2
    case .missingRequirements: return 3
    case .expired: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Teleport_Accesslist_V1_IneligibleStatus] = [
    .unspecified,
    .eligible,
    .userNotExist,
    .missingRequirements,
    .expired,
  ]

}

/// AccessList describes the basic building block of access grants, which are
/// similar to access requests but for longer lived permissions that need to be
/// regularly audited.
struct Teleport_Accesslist_V1_AccessList: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// header is the header for the resource.
  var header: Teleport_Header_V1_ResourceHeader {
    get {return _header ?? Teleport_Header_V1_ResourceHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  mutating func clearHeader() {self._header = nil}

  /// spec is the specification for the Access List.
  var spec: Teleport_Accesslist_V1_AccessListSpec {
    get {return _spec ?? Teleport_Accesslist_V1_AccessListSpec()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {self._spec = nil}

  /// status contains dynamically calculated fields.
  var status: Teleport_Accesslist_V1_AccessListStatus {
    get {return _status ?? Teleport_Accesslist_V1_AccessListStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _header: Teleport_Header_V1_ResourceHeader? = nil
  fileprivate var _spec: Teleport_Accesslist_V1_AccessListSpec? = nil
  fileprivate var _status: Teleport_Accesslist_V1_AccessListStatus? = nil
}

/// AccessListSpec is the specification for an Access List.
struct Teleport_Accesslist_V1_AccessListSpec: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// description is an optional plaintext description of the Access List.
  var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// owners is a list of owners of the Access List.
  var owners: [Teleport_Accesslist_V1_AccessListOwner] {
    get {return _storage._owners}
    set {_uniqueStorage()._owners = newValue}
  }

  /// audit describes the frequency that this Access List must be audited.
  var audit: Teleport_Accesslist_V1_AccessListAudit {
    get {return _storage._audit ?? Teleport_Accesslist_V1_AccessListAudit()}
    set {_uniqueStorage()._audit = newValue}
  }
  /// Returns true if `audit` has been explicitly set.
  var hasAudit: Bool {return _storage._audit != nil}
  /// Clears the value of `audit`. Subsequent reads from it will return its default value.
  mutating func clearAudit() {_uniqueStorage()._audit = nil}

  /// membership_requires describes the requirements for a user to be a member of
  /// the Access List. For a membership to an Access List to be effective, the
  /// user must meet the requirements of Membership_requires and must be in the
  /// members list.
  var membershipRequires: Teleport_Accesslist_V1_AccessListRequires {
    get {return _storage._membershipRequires ?? Teleport_Accesslist_V1_AccessListRequires()}
    set {_uniqueStorage()._membershipRequires = newValue}
  }
  /// Returns true if `membershipRequires` has been explicitly set.
  var hasMembershipRequires: Bool {return _storage._membershipRequires != nil}
  /// Clears the value of `membershipRequires`. Subsequent reads from it will return its default value.
  mutating func clearMembershipRequires() {_uniqueStorage()._membershipRequires = nil}

  /// ownership_requires describes the requirements for a user to be an owner of
  /// the Access List. For ownership of an Access List to be effective, the user
  /// must meet the requirements of ownership_requires and must be in the owners
  /// list.
  var ownershipRequires: Teleport_Accesslist_V1_AccessListRequires {
    get {return _storage._ownershipRequires ?? Teleport_Accesslist_V1_AccessListRequires()}
    set {_uniqueStorage()._ownershipRequires = newValue}
  }
  /// Returns true if `ownershipRequires` has been explicitly set.
  var hasOwnershipRequires: Bool {return _storage._ownershipRequires != nil}
  /// Clears the value of `ownershipRequires`. Subsequent reads from it will return its default value.
  mutating func clearOwnershipRequires() {_uniqueStorage()._ownershipRequires = nil}

  /// grants describes the access granted by membership to this Access List.
  var grants: Teleport_Accesslist_V1_AccessListGrants {
    get {return _storage._grants ?? Teleport_Accesslist_V1_AccessListGrants()}
    set {_uniqueStorage()._grants = newValue}
  }
  /// Returns true if `grants` has been explicitly set.
  var hasGrants: Bool {return _storage._grants != nil}
  /// Clears the value of `grants`. Subsequent reads from it will return its default value.
  mutating func clearGrants() {_uniqueStorage()._grants = nil}

  /// title is a plaintext short description of the Access List.
  var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  /// owner_grants describes the access granted by owners to this Access List.
  var ownerGrants: Teleport_Accesslist_V1_AccessListGrants {
    get {return _storage._ownerGrants ?? Teleport_Accesslist_V1_AccessListGrants()}
    set {_uniqueStorage()._ownerGrants = newValue}
  }
  /// Returns true if `ownerGrants` has been explicitly set.
  var hasOwnerGrants: Bool {return _storage._ownerGrants != nil}
  /// Clears the value of `ownerGrants`. Subsequent reads from it will return its default value.
  mutating func clearOwnerGrants() {_uniqueStorage()._ownerGrants = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// AccessListOwner is an owner of an Access List.
struct Teleport_Accesslist_V1_AccessListOwner: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// name is the username of the owner.
  var name: String = String()

  /// description is the plaintext description of the owner and why they are an
  /// owner.
  var description_p: String = String()

  /// ineligible_status describes if this owner is eligible or not
  /// and if not, describes how they're lacking eligibility.
  var ineligibleStatus: Teleport_Accesslist_V1_IneligibleStatus = .unspecified

  /// membership_kind describes the type of membership, either
  /// `MEMBERSHIP_KIND_USER` or `MEMBERSHIP_KIND_LIST`.
  var membershipKind: Teleport_Accesslist_V1_MembershipKind = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AccessListAudit describes the audit configuration for an Access List.
struct Teleport_Accesslist_V1_AccessListAudit: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// next_audit_date is when the next audit date should be done by.
  var nextAuditDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _nextAuditDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_nextAuditDate = newValue}
  }
  /// Returns true if `nextAuditDate` has been explicitly set.
  var hasNextAuditDate: Bool {return self._nextAuditDate != nil}
  /// Clears the value of `nextAuditDate`. Subsequent reads from it will return its default value.
  mutating func clearNextAuditDate() {self._nextAuditDate = nil}

  /// recurrence is the recurrence definition
  var recurrence: Teleport_Accesslist_V1_Recurrence {
    get {return _recurrence ?? Teleport_Accesslist_V1_Recurrence()}
    set {_recurrence = newValue}
  }
  /// Returns true if `recurrence` has been explicitly set.
  var hasRecurrence: Bool {return self._recurrence != nil}
  /// Clears the value of `recurrence`. Subsequent reads from it will return its default value.
  mutating func clearRecurrence() {self._recurrence = nil}

  /// notifications is the configuration for notifying users.
  var notifications: Teleport_Accesslist_V1_Notifications {
    get {return _notifications ?? Teleport_Accesslist_V1_Notifications()}
    set {_notifications = newValue}
  }
  /// Returns true if `notifications` has been explicitly set.
  var hasNotifications: Bool {return self._notifications != nil}
  /// Clears the value of `notifications`. Subsequent reads from it will return its default value.
  mutating func clearNotifications() {self._notifications = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _nextAuditDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _recurrence: Teleport_Accesslist_V1_Recurrence? = nil
  fileprivate var _notifications: Teleport_Accesslist_V1_Notifications? = nil
}

/// Recurrence is the definition for when reviews will be scheduled.
struct Teleport_Accesslist_V1_Recurrence: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// frequency is the frequency of reviews. This represents the period in months
  /// between two reviews.
  /// Supported values are 0, 1, 3, 6, and 12.
  var frequency: Teleport_Accesslist_V1_ReviewFrequency = .unspecified

  /// day_of_month is the day of month that reviews will be scheduled on.
  /// Supported values are 0, 1, 15, and 31.
  var dayOfMonth: Teleport_Accesslist_V1_ReviewDayOfMonth = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Notifications contains the configuration for notifying users of a nearing
/// next audit date.
struct Teleport_Accesslist_V1_Notifications: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// start specifies when to start notifying users that the next audit date is
  /// coming up.
  var start: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _start ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_start = newValue}
  }
  /// Returns true if `start` has been explicitly set.
  var hasStart: Bool {return self._start != nil}
  /// Clears the value of `start`. Subsequent reads from it will return its default value.
  mutating func clearStart() {self._start = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _start: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// AccessListRequires describes a requirement section for an Access List. A user
/// must meet the following criteria to obtain the specific access to the list.
struct Teleport_Accesslist_V1_AccessListRequires: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// roles are the user roles that must be present for the user to obtain
  /// access.
  var roles: [String] = []

  /// traits are the traits that must be present for the user to obtain access.
  var traits: [Teleport_Trait_V1_Trait] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AccessListGrants describes what access is granted by membership to the Access
/// List.
struct Teleport_Accesslist_V1_AccessListGrants: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// roles are the roles that are granted to users who are members of the Access
  /// List.
  var roles: [String] = []

  /// traits are the traits that are granted to users who are members of the
  /// Access List.
  var traits: [Teleport_Trait_V1_Trait] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Member describes a member of an Access List.
struct Teleport_Accesslist_V1_Member: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// header is the header for the resource.
  var header: Teleport_Header_V1_ResourceHeader {
    get {return _storage._header ?? Teleport_Header_V1_ResourceHeader()}
    set {_uniqueStorage()._header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  var hasHeader: Bool {return _storage._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  mutating func clearHeader() {_uniqueStorage()._header = nil}

  /// spec is the specification for the Access List member.
  var spec: Teleport_Accesslist_V1_MemberSpec {
    get {return _storage._spec ?? Teleport_Accesslist_V1_MemberSpec()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// MemberSpec is the specification for an Access List member.
struct Teleport_Accesslist_V1_MemberSpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// associated Access List
  var accessList: String = String()

  /// name is the name of the member of the Access List.
  var name: String = String()

  /// joined is when the user joined the Access List.
  var joined: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _joined ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_joined = newValue}
  }
  /// Returns true if `joined` has been explicitly set.
  var hasJoined: Bool {return self._joined != nil}
  /// Clears the value of `joined`. Subsequent reads from it will return its default value.
  mutating func clearJoined() {self._joined = nil}

  /// expires is when the user's membership to the Access List expires.
  var expires: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expires ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expires = newValue}
  }
  /// Returns true if `expires` has been explicitly set.
  var hasExpires: Bool {return self._expires != nil}
  /// Clears the value of `expires`. Subsequent reads from it will return its default value.
  mutating func clearExpires() {self._expires = nil}

  /// reason is the reason this user was added to the Access List.
  var reason: String = String()

  /// added_by is the user that added this user to the Access List.
  var addedBy: String = String()

  /// ineligible_status describes if this member is eligible or not
  /// and if not, describes how they're lacking eligibility.
  var ineligibleStatus: Teleport_Accesslist_V1_IneligibleStatus = .unspecified

  /// membership_kind describes the type of membership, either
  /// `MEMBERSHIP_KIND_USER` or `MEMBERSHIP_KIND_LIST`.
  var membershipKind: Teleport_Accesslist_V1_MembershipKind = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _joined: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _expires: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Review is a review of an Access List.
struct Teleport_Accesslist_V1_Review: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// header is the header for the resource.
  var header: Teleport_Header_V1_ResourceHeader {
    get {return _storage._header ?? Teleport_Header_V1_ResourceHeader()}
    set {_uniqueStorage()._header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  var hasHeader: Bool {return _storage._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  mutating func clearHeader() {_uniqueStorage()._header = nil}

  /// spec is the specification for the Access List review.
  var spec: Teleport_Accesslist_V1_ReviewSpec {
    get {return _storage._spec ?? Teleport_Accesslist_V1_ReviewSpec()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ReviewSpec is the specification for an Access List review.
struct Teleport_Accesslist_V1_ReviewSpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// access_list is the name of the Access List that this review is for.
  var accessList: String = String()

  /// reviewers are the users who performed the review.
  var reviewers: [String] = []

  /// review_date is the date that this review was created.
  var reviewDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _reviewDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_reviewDate = newValue}
  }
  /// Returns true if `reviewDate` has been explicitly set.
  var hasReviewDate: Bool {return self._reviewDate != nil}
  /// Clears the value of `reviewDate`. Subsequent reads from it will return its default value.
  mutating func clearReviewDate() {self._reviewDate = nil}

  /// notes is an optional plaintext attached to the review that can be used by
  /// the review for arbitrary note taking on the review.
  var notes: String = String()

  /// changes are the changes made as part of the review.
  var changes: Teleport_Accesslist_V1_ReviewChanges {
    get {return _changes ?? Teleport_Accesslist_V1_ReviewChanges()}
    set {_changes = newValue}
  }
  /// Returns true if `changes` has been explicitly set.
  var hasChanges: Bool {return self._changes != nil}
  /// Clears the value of `changes`. Subsequent reads from it will return its default value.
  mutating func clearChanges() {self._changes = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _reviewDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _changes: Teleport_Accesslist_V1_ReviewChanges? = nil
}

/// ReviewChanges are the changes that were made as part of the review.
struct Teleport_Accesslist_V1_ReviewChanges: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// membership_requirements_changed is populated if the requirements were
  /// changed as part of this review.
  var membershipRequirementsChanged: Teleport_Accesslist_V1_AccessListRequires {
    get {return _membershipRequirementsChanged ?? Teleport_Accesslist_V1_AccessListRequires()}
    set {_membershipRequirementsChanged = newValue}
  }
  /// Returns true if `membershipRequirementsChanged` has been explicitly set.
  var hasMembershipRequirementsChanged: Bool {return self._membershipRequirementsChanged != nil}
  /// Clears the value of `membershipRequirementsChanged`. Subsequent reads from it will return its default value.
  mutating func clearMembershipRequirementsChanged() {self._membershipRequirementsChanged = nil}

  /// removed_members contains the members that were removed as part of this
  /// review.
  var removedMembers: [String] = []

  /// review_frequency_changed is populated if the review frequency has changed.
  var reviewFrequencyChanged: Teleport_Accesslist_V1_ReviewFrequency = .unspecified

  /// review_day_of_month_changed is populated if the review day of month has
  /// changed.
  var reviewDayOfMonthChanged: Teleport_Accesslist_V1_ReviewDayOfMonth = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _membershipRequirementsChanged: Teleport_Accesslist_V1_AccessListRequires? = nil
}

/// AccessListStatus contains dynamic fields calculated during retrieval.
struct Teleport_Accesslist_V1_AccessListStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// member_count is the number of members in the Access List.
  var memberCount: UInt32 {
    get {return _memberCount ?? 0}
    set {_memberCount = newValue}
  }
  /// Returns true if `memberCount` has been explicitly set.
  var hasMemberCount: Bool {return self._memberCount != nil}
  /// Clears the value of `memberCount`. Subsequent reads from it will return its default value.
  mutating func clearMemberCount() {self._memberCount = nil}

  /// member_list_count is the number of nested list members in the Access List.
  var memberListCount: UInt32 {
    get {return _memberListCount ?? 0}
    set {_memberListCount = newValue}
  }
  /// Returns true if `memberListCount` has been explicitly set.
  var hasMemberListCount: Bool {return self._memberListCount != nil}
  /// Clears the value of `memberListCount`. Subsequent reads from it will return its default value.
  mutating func clearMemberListCount() {self._memberListCount = nil}

  /// owner_of describes Access Lists where this Access List is an explicit owner.
  var ownerOf: [String] = []

  /// member_of describes Access Lists where this Access List is an explicit member.
  var memberOf: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _memberCount: UInt32? = nil
  fileprivate var _memberListCount: UInt32? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "teleport.accesslist.v1"

extension Teleport_Accesslist_V1_ReviewFrequency: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REVIEW_FREQUENCY_UNSPECIFIED"),
    1: .same(proto: "REVIEW_FREQUENCY_ONE_MONTH"),
    3: .same(proto: "REVIEW_FREQUENCY_THREE_MONTHS"),
    6: .same(proto: "REVIEW_FREQUENCY_SIX_MONTHS"),
    12: .same(proto: "REVIEW_FREQUENCY_ONE_YEAR"),
  ]
}

extension Teleport_Accesslist_V1_ReviewDayOfMonth: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REVIEW_DAY_OF_MONTH_UNSPECIFIED"),
    1: .same(proto: "REVIEW_DAY_OF_MONTH_FIRST"),
    15: .same(proto: "REVIEW_DAY_OF_MONTH_FIFTEENTH"),
    31: .same(proto: "REVIEW_DAY_OF_MONTH_LAST"),
  ]
}

extension Teleport_Accesslist_V1_MembershipKind: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MEMBERSHIP_KIND_UNSPECIFIED"),
    1: .same(proto: "MEMBERSHIP_KIND_USER"),
    2: .same(proto: "MEMBERSHIP_KIND_LIST"),
  ]
}

extension Teleport_Accesslist_V1_IneligibleStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INELIGIBLE_STATUS_UNSPECIFIED"),
    1: .same(proto: "INELIGIBLE_STATUS_ELIGIBLE"),
    2: .same(proto: "INELIGIBLE_STATUS_USER_NOT_EXIST"),
    3: .same(proto: "INELIGIBLE_STATUS_MISSING_REQUIREMENTS"),
    4: .same(proto: "INELIGIBLE_STATUS_EXPIRED"),
  ]
}

extension Teleport_Accesslist_V1_AccessList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "spec"),
    3: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_AccessList, rhs: Teleport_Accesslist_V1_AccessList) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_AccessListSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessListSpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "description"),
    2: .same(proto: "owners"),
    3: .same(proto: "audit"),
    4: .standard(proto: "membership_requires"),
    5: .standard(proto: "ownership_requires"),
    6: .same(proto: "grants"),
    8: .same(proto: "title"),
    11: .standard(proto: "owner_grants"),
  ]

  fileprivate class _StorageClass {
    var _description_p: String = String()
    var _owners: [Teleport_Accesslist_V1_AccessListOwner] = []
    var _audit: Teleport_Accesslist_V1_AccessListAudit? = nil
    var _membershipRequires: Teleport_Accesslist_V1_AccessListRequires? = nil
    var _ownershipRequires: Teleport_Accesslist_V1_AccessListRequires? = nil
    var _grants: Teleport_Accesslist_V1_AccessListGrants? = nil
    var _title: String = String()
    var _ownerGrants: Teleport_Accesslist_V1_AccessListGrants? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _description_p = source._description_p
      _owners = source._owners
      _audit = source._audit
      _membershipRequires = source._membershipRequires
      _ownershipRequires = source._ownershipRequires
      _grants = source._grants
      _title = source._title
      _ownerGrants = source._ownerGrants
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._owners) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._audit) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._membershipRequires) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._ownershipRequires) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._grants) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._title) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._ownerGrants) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 1)
      }
      if !_storage._owners.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._owners, fieldNumber: 2)
      }
      try { if let v = _storage._audit {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._membershipRequires {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._ownershipRequires {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._grants {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 8)
      }
      try { if let v = _storage._ownerGrants {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_AccessListSpec, rhs: Teleport_Accesslist_V1_AccessListSpec) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._owners != rhs_storage._owners {return false}
        if _storage._audit != rhs_storage._audit {return false}
        if _storage._membershipRequires != rhs_storage._membershipRequires {return false}
        if _storage._ownershipRequires != rhs_storage._ownershipRequires {return false}
        if _storage._grants != rhs_storage._grants {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._ownerGrants != rhs_storage._ownerGrants {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_AccessListOwner: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessListOwner"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "description"),
    3: .standard(proto: "ineligible_status"),
    4: .standard(proto: "membership_kind"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.ineligibleStatus) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.membershipKind) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if self.ineligibleStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.ineligibleStatus, fieldNumber: 3)
    }
    if self.membershipKind != .unspecified {
      try visitor.visitSingularEnumField(value: self.membershipKind, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_AccessListOwner, rhs: Teleport_Accesslist_V1_AccessListOwner) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.ineligibleStatus != rhs.ineligibleStatus {return false}
    if lhs.membershipKind != rhs.membershipKind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_AccessListAudit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessListAudit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "next_audit_date"),
    3: .same(proto: "recurrence"),
    4: .same(proto: "notifications"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._nextAuditDate) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._recurrence) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._notifications) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nextAuditDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._recurrence {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._notifications {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_AccessListAudit, rhs: Teleport_Accesslist_V1_AccessListAudit) -> Bool {
    if lhs._nextAuditDate != rhs._nextAuditDate {return false}
    if lhs._recurrence != rhs._recurrence {return false}
    if lhs._notifications != rhs._notifications {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_Recurrence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Recurrence"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "frequency"),
    2: .standard(proto: "day_of_month"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.frequency) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.dayOfMonth) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.frequency != .unspecified {
      try visitor.visitSingularEnumField(value: self.frequency, fieldNumber: 1)
    }
    if self.dayOfMonth != .unspecified {
      try visitor.visitSingularEnumField(value: self.dayOfMonth, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_Recurrence, rhs: Teleport_Accesslist_V1_Recurrence) -> Bool {
    if lhs.frequency != rhs.frequency {return false}
    if lhs.dayOfMonth != rhs.dayOfMonth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_Notifications: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Notifications"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._start) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._start {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_Notifications, rhs: Teleport_Accesslist_V1_Notifications) -> Bool {
    if lhs._start != rhs._start {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_AccessListRequires: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessListRequires"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "roles"),
    2: .same(proto: "traits"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.roles) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.traits) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.roles.isEmpty {
      try visitor.visitRepeatedStringField(value: self.roles, fieldNumber: 1)
    }
    if !self.traits.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.traits, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_AccessListRequires, rhs: Teleport_Accesslist_V1_AccessListRequires) -> Bool {
    if lhs.roles != rhs.roles {return false}
    if lhs.traits != rhs.traits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_AccessListGrants: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessListGrants"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "roles"),
    2: .same(proto: "traits"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.roles) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.traits) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.roles.isEmpty {
      try visitor.visitRepeatedStringField(value: self.roles, fieldNumber: 1)
    }
    if !self.traits.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.traits, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_AccessListGrants, rhs: Teleport_Accesslist_V1_AccessListGrants) -> Bool {
    if lhs.roles != rhs.roles {return false}
    if lhs.traits != rhs.traits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_Member: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Member"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "spec"),
  ]

  fileprivate class _StorageClass {
    var _header: Teleport_Header_V1_ResourceHeader? = nil
    var _spec: Teleport_Accesslist_V1_MemberSpec? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _header = source._header
      _spec = source._spec
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._header) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._spec) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._header {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_Member, rhs: Teleport_Accesslist_V1_Member) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._header != rhs_storage._header {return false}
        if _storage._spec != rhs_storage._spec {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_MemberSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MemberSpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_list"),
    2: .same(proto: "name"),
    3: .same(proto: "joined"),
    4: .same(proto: "expires"),
    5: .same(proto: "reason"),
    6: .standard(proto: "added_by"),
    7: .standard(proto: "ineligible_status"),
    9: .standard(proto: "membership_kind"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accessList) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._joined) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._expires) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.addedBy) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.ineligibleStatus) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.membershipKind) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.accessList.isEmpty {
      try visitor.visitSingularStringField(value: self.accessList, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try { if let v = self._joined {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._expires {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 5)
    }
    if !self.addedBy.isEmpty {
      try visitor.visitSingularStringField(value: self.addedBy, fieldNumber: 6)
    }
    if self.ineligibleStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.ineligibleStatus, fieldNumber: 7)
    }
    if self.membershipKind != .unspecified {
      try visitor.visitSingularEnumField(value: self.membershipKind, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_MemberSpec, rhs: Teleport_Accesslist_V1_MemberSpec) -> Bool {
    if lhs.accessList != rhs.accessList {return false}
    if lhs.name != rhs.name {return false}
    if lhs._joined != rhs._joined {return false}
    if lhs._expires != rhs._expires {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.addedBy != rhs.addedBy {return false}
    if lhs.ineligibleStatus != rhs.ineligibleStatus {return false}
    if lhs.membershipKind != rhs.membershipKind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_Review: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Review"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "spec"),
  ]

  fileprivate class _StorageClass {
    var _header: Teleport_Header_V1_ResourceHeader? = nil
    var _spec: Teleport_Accesslist_V1_ReviewSpec? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _header = source._header
      _spec = source._spec
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._header) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._spec) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._header {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_Review, rhs: Teleport_Accesslist_V1_Review) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._header != rhs_storage._header {return false}
        if _storage._spec != rhs_storage._spec {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_ReviewSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReviewSpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_list"),
    2: .same(proto: "reviewers"),
    3: .standard(proto: "review_date"),
    4: .same(proto: "notes"),
    5: .same(proto: "changes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accessList) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.reviewers) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._reviewDate) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.notes) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._changes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.accessList.isEmpty {
      try visitor.visitSingularStringField(value: self.accessList, fieldNumber: 1)
    }
    if !self.reviewers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.reviewers, fieldNumber: 2)
    }
    try { if let v = self._reviewDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.notes.isEmpty {
      try visitor.visitSingularStringField(value: self.notes, fieldNumber: 4)
    }
    try { if let v = self._changes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_ReviewSpec, rhs: Teleport_Accesslist_V1_ReviewSpec) -> Bool {
    if lhs.accessList != rhs.accessList {return false}
    if lhs.reviewers != rhs.reviewers {return false}
    if lhs._reviewDate != rhs._reviewDate {return false}
    if lhs.notes != rhs.notes {return false}
    if lhs._changes != rhs._changes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_ReviewChanges: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReviewChanges"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "membership_requirements_changed"),
    3: .standard(proto: "removed_members"),
    4: .standard(proto: "review_frequency_changed"),
    5: .standard(proto: "review_day_of_month_changed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._membershipRequirementsChanged) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.removedMembers) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.reviewFrequencyChanged) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.reviewDayOfMonthChanged) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._membershipRequirementsChanged {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.removedMembers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.removedMembers, fieldNumber: 3)
    }
    if self.reviewFrequencyChanged != .unspecified {
      try visitor.visitSingularEnumField(value: self.reviewFrequencyChanged, fieldNumber: 4)
    }
    if self.reviewDayOfMonthChanged != .unspecified {
      try visitor.visitSingularEnumField(value: self.reviewDayOfMonthChanged, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_ReviewChanges, rhs: Teleport_Accesslist_V1_ReviewChanges) -> Bool {
    if lhs._membershipRequirementsChanged != rhs._membershipRequirementsChanged {return false}
    if lhs.removedMembers != rhs.removedMembers {return false}
    if lhs.reviewFrequencyChanged != rhs.reviewFrequencyChanged {return false}
    if lhs.reviewDayOfMonthChanged != rhs.reviewDayOfMonthChanged {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_AccessListStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessListStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "member_count"),
    2: .standard(proto: "member_list_count"),
    3: .standard(proto: "owner_of"),
    4: .standard(proto: "member_of"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._memberCount) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._memberListCount) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.ownerOf) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.memberOf) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._memberCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._memberListCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    if !self.ownerOf.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ownerOf, fieldNumber: 3)
    }
    if !self.memberOf.isEmpty {
      try visitor.visitRepeatedStringField(value: self.memberOf, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_AccessListStatus, rhs: Teleport_Accesslist_V1_AccessListStatus) -> Bool {
    if lhs._memberCount != rhs._memberCount {return false}
    if lhs._memberListCount != rhs._memberListCount {return false}
    if lhs.ownerOf != rhs.ownerOf {return false}
    if lhs.memberOf != rhs.memberOf {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
