// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: teleport/accesslist/v1/accesslist_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2023 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// GetAccessListsRequest is the request for getting all access lists.
struct Teleport_Accesslist_V1_GetAccessListsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetAccessListsResponse is the response for getting all access lists.
struct Teleport_Accesslist_V1_GetAccessListsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// access_lists is the list of access lists.
  var accessLists: [Teleport_Accesslist_V1_AccessList] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ListAccessListsRequest is the request for getting paginated access lists.
struct Teleport_Accesslist_V1_ListAccessListsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// page_size is the size of the page to request.
  var pageSize: Int32 = 0

  /// next_token is the page token.
  var nextToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ListAccessListsResponse is the response for getting paginated access lists.
struct Teleport_Accesslist_V1_ListAccessListsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// access_lists is the list of access lists.
  var accessLists: [Teleport_Accesslist_V1_AccessList] = []

  /// next_token is the next page token.
  var nextToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetInheritedGrantsRequest is the request for getting inherited grants.
struct Teleport_Accesslist_V1_GetInheritedGrantsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// access_list_id is the ID of the access list to retrieve.
  var accessListID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetInheritedGrantsResponse is the response for getting inherited grants.
struct Teleport_Accesslist_V1_GetInheritedGrantsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// grants is the list of inherited member grants.
  var grants: Teleport_Accesslist_V1_AccessListGrants {
    get {return _grants ?? Teleport_Accesslist_V1_AccessListGrants()}
    set {_grants = newValue}
  }
  /// Returns true if `grants` has been explicitly set.
  var hasGrants: Bool {return self._grants != nil}
  /// Clears the value of `grants`. Subsequent reads from it will return its default value.
  mutating func clearGrants() {self._grants = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _grants: Teleport_Accesslist_V1_AccessListGrants? = nil
}

/// GetAccessListRequest is the request for retrieving an access list.
struct Teleport_Accesslist_V1_GetAccessListRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// name is the name of the access list to retrieve.
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// UpsertAccessListRequest is the request for upserting an access list.
struct Teleport_Accesslist_V1_UpsertAccessListRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// access_list is the access list to upsert.
  var accessList: Teleport_Accesslist_V1_AccessList {
    get {return _accessList ?? Teleport_Accesslist_V1_AccessList()}
    set {_accessList = newValue}
  }
  /// Returns true if `accessList` has been explicitly set.
  var hasAccessList: Bool {return self._accessList != nil}
  /// Clears the value of `accessList`. Subsequent reads from it will return its default value.
  mutating func clearAccessList() {self._accessList = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _accessList: Teleport_Accesslist_V1_AccessList? = nil
}

/// UpdateAccessListRequest is the request for updating an access list.
struct Teleport_Accesslist_V1_UpdateAccessListRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// access_list is the access list to upsert.
  var accessList: Teleport_Accesslist_V1_AccessList {
    get {return _accessList ?? Teleport_Accesslist_V1_AccessList()}
    set {_accessList = newValue}
  }
  /// Returns true if `accessList` has been explicitly set.
  var hasAccessList: Bool {return self._accessList != nil}
  /// Clears the value of `accessList`. Subsequent reads from it will return its default value.
  mutating func clearAccessList() {self._accessList = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _accessList: Teleport_Accesslist_V1_AccessList? = nil
}

/// DeleteAccessListRequest is the request for deleting an access list.
struct Teleport_Accesslist_V1_DeleteAccessListRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// name is the name of the access list to delete.
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DeleteAllAccessListsRequest is the request for deleting all access lists.
struct Teleport_Accesslist_V1_DeleteAllAccessListsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetAccessListsToReviewRequest is the request for getting access lists that
/// the current user needs to review.
struct Teleport_Accesslist_V1_GetAccessListsToReviewRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetAccessListsToReviewResponse is the response for getting access lists that
/// the current user needs to review.
struct Teleport_Accesslist_V1_GetAccessListsToReviewResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accessLists: [Teleport_Accesslist_V1_AccessList] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// CountAccessListMembersRequest is the request for counting access list
/// members.
struct Teleport_Accesslist_V1_CountAccessListMembersRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// access_list_name is the name of the access list to retrieve.
  var accessListName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// CountAccessListMembersResponse is the response for counting access list
/// members.
struct Teleport_Accesslist_V1_CountAccessListMembersResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// count is the number of access list members in the access list.
  var count: UInt32 = 0

  /// list_count is the number of access list members of type list in the access list.
  var listCount: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ListAccessListMembersRequest is the request for getting paginated access list
/// members.
struct Teleport_Accesslist_V1_ListAccessListMembersRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// page_size is the size of the page to request.
  var pageSize: Int32 = 0

  /// page_token is the page token.
  var pageToken: String = String()

  /// access_list is the name of the access list that the member belongs to.
  var accessList: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ListAccessListMembersResponse is the response for getting paginated access
/// list members.
struct Teleport_Accesslist_V1_ListAccessListMembersResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// members is the list of access list members.
  var members: [Teleport_Accesslist_V1_Member] = []

  /// next_page_token is the next page token.
  var nextPageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ListAllAccessListMembersRequest is the request for getting paginated access
/// list members for all access lists.
struct Teleport_Accesslist_V1_ListAllAccessListMembersRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// page_size is the size of the page to request.
  var pageSize: Int32 = 0

  /// page_token is the page token.
  var pageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ListAllAccessListMembersResponse is the response for getting paginated access
/// list members for all access lists.
struct Teleport_Accesslist_V1_ListAllAccessListMembersResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// members is the list of access list members.
  var members: [Teleport_Accesslist_V1_Member] = []

  /// next_page_token is the next page token.
  var nextPageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// UpsertAccessListWithMembers is the request for upserting an access list with
/// members.
struct Teleport_Accesslist_V1_UpsertAccessListWithMembersRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// access_list is the access list to upsert.
  var accessList: Teleport_Accesslist_V1_AccessList {
    get {return _accessList ?? Teleport_Accesslist_V1_AccessList()}
    set {_accessList = newValue}
  }
  /// Returns true if `accessList` has been explicitly set.
  var hasAccessList: Bool {return self._accessList != nil}
  /// Clears the value of `accessList`. Subsequent reads from it will return its default value.
  mutating func clearAccessList() {self._accessList = nil}

  /// members is the list of access list members.
  var members: [Teleport_Accesslist_V1_Member] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _accessList: Teleport_Accesslist_V1_AccessList? = nil
}

/// UpsertAccessListWithMembersResponse is the response for upserting an access
/// list with members.
struct Teleport_Accesslist_V1_UpsertAccessListWithMembersResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// access_list is the access list that was upserted.
  var accessList: Teleport_Accesslist_V1_AccessList {
    get {return _accessList ?? Teleport_Accesslist_V1_AccessList()}
    set {_accessList = newValue}
  }
  /// Returns true if `accessList` has been explicitly set.
  var hasAccessList: Bool {return self._accessList != nil}
  /// Clears the value of `accessList`. Subsequent reads from it will return its default value.
  mutating func clearAccessList() {self._accessList = nil}

  /// members is the list of access list members that were upserted.
  var members: [Teleport_Accesslist_V1_Member] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _accessList: Teleport_Accesslist_V1_AccessList? = nil
}

/// GetAccessListMemberRequest is the request for retrieving an access list
/// member.
struct Teleport_Accesslist_V1_GetAccessListMemberRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// access_list is the name of the access list that the member belongs to.
  var accessList: String = String()

  /// member_name is the name of the user that belongs to the access list.
  var memberName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetAccessListOwnersRequest is the request for getting a list of all owners
/// in an Access List, including those inherited from nested Access Lists.
struct Teleport_Accesslist_V1_GetAccessListOwnersRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// access_list is the name of the access list.
  var accessList: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetAccessListOwnersResponse is the response for getting a list of all
/// owners in an Access List, including those inherited from nested Access Lists.
struct Teleport_Accesslist_V1_GetAccessListOwnersResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// owners is the list of all owners in the Access List, including those
  /// inherited from nested Access Lists.
  var owners: [Teleport_Accesslist_V1_AccessListOwner] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// UpsertAccessListMemberRequest is the request for upserting an access list
/// member.
struct Teleport_Accesslist_V1_UpsertAccessListMemberRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// member is the access list member to upsert.
  var member: Teleport_Accesslist_V1_Member {
    get {return _member ?? Teleport_Accesslist_V1_Member()}
    set {_member = newValue}
  }
  /// Returns true if `member` has been explicitly set.
  var hasMember: Bool {return self._member != nil}
  /// Clears the value of `member`. Subsequent reads from it will return its default value.
  mutating func clearMember() {self._member = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _member: Teleport_Accesslist_V1_Member? = nil
}

/// UpdateAccessListMemberRequest is the request for updating an access list
/// member.
struct Teleport_Accesslist_V1_UpdateAccessListMemberRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// member is the access list member to upsert.
  var member: Teleport_Accesslist_V1_Member {
    get {return _member ?? Teleport_Accesslist_V1_Member()}
    set {_member = newValue}
  }
  /// Returns true if `member` has been explicitly set.
  var hasMember: Bool {return self._member != nil}
  /// Clears the value of `member`. Subsequent reads from it will return its default value.
  mutating func clearMember() {self._member = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _member: Teleport_Accesslist_V1_Member? = nil
}

/// DeleteAccessListMemberRequest is the request for deleting a member from an
/// access list.
struct Teleport_Accesslist_V1_DeleteAccessListMemberRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// access_list is the name of access list.
  var accessList: String = String()

  /// member_name is the name of the user to delete.
  var memberName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DeleteAllAccessListMembersForAccessListRequest is the request for deleting
/// all members from an access list.
struct Teleport_Accesslist_V1_DeleteAllAccessListMembersForAccessListRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// access_list is the name of access list.
  var accessList: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DeleteAllAccessListMembersRequest is the request for all access list members
/// in the backend.
struct Teleport_Accesslist_V1_DeleteAllAccessListMembersRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ListAccessListReviewsRequest is the request for getting paginated access list
/// reviews for a particular access list.
struct Teleport_Accesslist_V1_ListAccessListReviewsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// access_list is the name of the access list that we're listing reviews for.
  var accessList: String = String()

  /// page_size is the size of the page to request.
  var pageSize: Int32 = 0

  /// next_token is the page token.
  var nextToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ListAccessListReviewsResponse is the response for getting paginated access
/// list reviews for a particular access list.
struct Teleport_Accesslist_V1_ListAccessListReviewsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// reviews is the list of access list reviews.
  var reviews: [Teleport_Accesslist_V1_Review] = []

  /// next_token is the next page token.
  var nextToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ListAllAccessListReviewsRequest is the request for getting paginated access
/// list reviews for all access lists.
struct Teleport_Accesslist_V1_ListAllAccessListReviewsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// page_size is the size of the page to request.
  var pageSize: Int32 = 0

  /// next_token is the page token.
  var nextToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ListAllAccessListReviewsResponse is the response for getting paginated access
/// list reviews for all access lists.
struct Teleport_Accesslist_V1_ListAllAccessListReviewsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// reviews is the list of access list reviews.
  var reviews: [Teleport_Accesslist_V1_Review] = []

  /// next_token is the next page token.
  var nextToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// CreateAccessListReviewRequest is the request for creating an access list
/// review.
struct Teleport_Accesslist_V1_CreateAccessListReviewRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// review is the actual review to create.
  var review: Teleport_Accesslist_V1_Review {
    get {return _review ?? Teleport_Accesslist_V1_Review()}
    set {_review = newValue}
  }
  /// Returns true if `review` has been explicitly set.
  var hasReview: Bool {return self._review != nil}
  /// Clears the value of `review`. Subsequent reads from it will return its default value.
  mutating func clearReview() {self._review = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _review: Teleport_Accesslist_V1_Review? = nil
}

/// CreateAccessListReviewResponse is the response for creating an access list
/// review.
struct Teleport_Accesslist_V1_CreateAccessListReviewResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// review_name is the name of the review that was just created.
  var reviewName: String = String()

  /// next_audit_date is when the next audit should be done by.
  var nextAuditDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _nextAuditDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_nextAuditDate = newValue}
  }
  /// Returns true if `nextAuditDate` has been explicitly set.
  var hasNextAuditDate: Bool {return self._nextAuditDate != nil}
  /// Clears the value of `nextAuditDate`. Subsequent reads from it will return its default value.
  mutating func clearNextAuditDate() {self._nextAuditDate = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _nextAuditDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// DeleteAccessListReviewRequest is the request for deleting an access list
/// review.
struct Teleport_Accesslist_V1_DeleteAccessListReviewRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// review_name is the name of the review to delete.
  var reviewName: String = String()

  /// access_list_name is the name of the access list to delete the review from.
  var accessListName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AccessRequestPromoteRequest is the request for promoting an access request to
/// an access list.
struct Teleport_Accesslist_V1_AccessRequestPromoteRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// RequestID is the unique ID of the request to be promoted.
  var requestID: String = String()

  /// AccessListName is the name of the access list to promote the request to.
  var accessListName: String = String()

  /// Reason is the access request review reason.
  var reason: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AccessRequestPromoteResponse is the response for promoting an access request
/// to an access list.
struct Teleport_Accesslist_V1_AccessRequestPromoteResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetSuggestedAccessListsRequest is the request for suggested access lists for
/// an access request.
struct Teleport_Accesslist_V1_GetSuggestedAccessListsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// access_request_id is the unique ID of the request.
  var accessRequestID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetSuggestedAccessListsResponse is the response for suggested access lists
/// for an access request.
struct Teleport_Accesslist_V1_GetSuggestedAccessListsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// access_lists is the list of suggested lists.
  var accessLists: [Teleport_Accesslist_V1_AccessList] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "teleport.accesslist.v1"

extension Teleport_Accesslist_V1_GetAccessListsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAccessListsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_GetAccessListsRequest, rhs: Teleport_Accesslist_V1_GetAccessListsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_GetAccessListsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAccessListsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_lists"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.accessLists) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accessLists.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accessLists, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_GetAccessListsResponse, rhs: Teleport_Accesslist_V1_GetAccessListsResponse) -> Bool {
    if lhs.accessLists != rhs.accessLists {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_ListAccessListsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListAccessListsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "page_size"),
    2: .standard(proto: "next_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 1)
    }
    if !self.nextToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_ListAccessListsRequest, rhs: Teleport_Accesslist_V1_ListAccessListsRequest) -> Bool {
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.nextToken != rhs.nextToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_ListAccessListsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListAccessListsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_lists"),
    2: .standard(proto: "next_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.accessLists) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accessLists.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accessLists, fieldNumber: 1)
    }
    if !self.nextToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_ListAccessListsResponse, rhs: Teleport_Accesslist_V1_ListAccessListsResponse) -> Bool {
    if lhs.accessLists != rhs.accessLists {return false}
    if lhs.nextToken != rhs.nextToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_GetInheritedGrantsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetInheritedGrantsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_list_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accessListID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accessListID.isEmpty {
      try visitor.visitSingularStringField(value: self.accessListID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_GetInheritedGrantsRequest, rhs: Teleport_Accesslist_V1_GetInheritedGrantsRequest) -> Bool {
    if lhs.accessListID != rhs.accessListID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_GetInheritedGrantsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetInheritedGrantsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "grants"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._grants) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._grants {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_GetInheritedGrantsResponse, rhs: Teleport_Accesslist_V1_GetInheritedGrantsResponse) -> Bool {
    if lhs._grants != rhs._grants {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_GetAccessListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAccessListRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_GetAccessListRequest, rhs: Teleport_Accesslist_V1_GetAccessListRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_UpsertAccessListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpsertAccessListRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_list"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._accessList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._accessList {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_UpsertAccessListRequest, rhs: Teleport_Accesslist_V1_UpsertAccessListRequest) -> Bool {
    if lhs._accessList != rhs._accessList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_UpdateAccessListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateAccessListRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_list"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._accessList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._accessList {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_UpdateAccessListRequest, rhs: Teleport_Accesslist_V1_UpdateAccessListRequest) -> Bool {
    if lhs._accessList != rhs._accessList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_DeleteAccessListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteAccessListRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_DeleteAccessListRequest, rhs: Teleport_Accesslist_V1_DeleteAccessListRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_DeleteAllAccessListsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteAllAccessListsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_DeleteAllAccessListsRequest, rhs: Teleport_Accesslist_V1_DeleteAllAccessListsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_GetAccessListsToReviewRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAccessListsToReviewRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_GetAccessListsToReviewRequest, rhs: Teleport_Accesslist_V1_GetAccessListsToReviewRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_GetAccessListsToReviewResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAccessListsToReviewResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_lists"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.accessLists) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accessLists.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accessLists, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_GetAccessListsToReviewResponse, rhs: Teleport_Accesslist_V1_GetAccessListsToReviewResponse) -> Bool {
    if lhs.accessLists != rhs.accessLists {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_CountAccessListMembersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CountAccessListMembersRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_list_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accessListName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accessListName.isEmpty {
      try visitor.visitSingularStringField(value: self.accessListName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_CountAccessListMembersRequest, rhs: Teleport_Accesslist_V1_CountAccessListMembersRequest) -> Bool {
    if lhs.accessListName != rhs.accessListName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_CountAccessListMembersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CountAccessListMembersResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "count"),
    2: .standard(proto: "list_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.count) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.listCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.count != 0 {
      try visitor.visitSingularUInt32Field(value: self.count, fieldNumber: 1)
    }
    if self.listCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.listCount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_CountAccessListMembersResponse, rhs: Teleport_Accesslist_V1_CountAccessListMembersResponse) -> Bool {
    if lhs.count != rhs.count {return false}
    if lhs.listCount != rhs.listCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_ListAccessListMembersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListAccessListMembersRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "page_size"),
    2: .standard(proto: "page_token"),
    3: .standard(proto: "access_list"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.accessList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 1)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 2)
    }
    if !self.accessList.isEmpty {
      try visitor.visitSingularStringField(value: self.accessList, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_ListAccessListMembersRequest, rhs: Teleport_Accesslist_V1_ListAccessListMembersRequest) -> Bool {
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.accessList != rhs.accessList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_ListAccessListMembersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListAccessListMembersResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "members"),
    2: .standard(proto: "next_page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.members) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_ListAccessListMembersResponse, rhs: Teleport_Accesslist_V1_ListAccessListMembersResponse) -> Bool {
    if lhs.members != rhs.members {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_ListAllAccessListMembersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListAllAccessListMembersRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "page_size"),
    2: .standard(proto: "page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 1)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_ListAllAccessListMembersRequest, rhs: Teleport_Accesslist_V1_ListAllAccessListMembersRequest) -> Bool {
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_ListAllAccessListMembersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListAllAccessListMembersResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "members"),
    2: .standard(proto: "next_page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.members) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_ListAllAccessListMembersResponse, rhs: Teleport_Accesslist_V1_ListAllAccessListMembersResponse) -> Bool {
    if lhs.members != rhs.members {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_UpsertAccessListWithMembersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpsertAccessListWithMembersRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_list"),
    2: .same(proto: "members"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._accessList) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.members) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._accessList {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_UpsertAccessListWithMembersRequest, rhs: Teleport_Accesslist_V1_UpsertAccessListWithMembersRequest) -> Bool {
    if lhs._accessList != rhs._accessList {return false}
    if lhs.members != rhs.members {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_UpsertAccessListWithMembersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpsertAccessListWithMembersResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_list"),
    2: .same(proto: "members"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._accessList) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.members) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._accessList {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_UpsertAccessListWithMembersResponse, rhs: Teleport_Accesslist_V1_UpsertAccessListWithMembersResponse) -> Bool {
    if lhs._accessList != rhs._accessList {return false}
    if lhs.members != rhs.members {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_GetAccessListMemberRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAccessListMemberRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_list"),
    2: .standard(proto: "member_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accessList) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.memberName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accessList.isEmpty {
      try visitor.visitSingularStringField(value: self.accessList, fieldNumber: 1)
    }
    if !self.memberName.isEmpty {
      try visitor.visitSingularStringField(value: self.memberName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_GetAccessListMemberRequest, rhs: Teleport_Accesslist_V1_GetAccessListMemberRequest) -> Bool {
    if lhs.accessList != rhs.accessList {return false}
    if lhs.memberName != rhs.memberName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_GetAccessListOwnersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAccessListOwnersRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_list"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accessList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accessList.isEmpty {
      try visitor.visitSingularStringField(value: self.accessList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_GetAccessListOwnersRequest, rhs: Teleport_Accesslist_V1_GetAccessListOwnersRequest) -> Bool {
    if lhs.accessList != rhs.accessList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_GetAccessListOwnersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAccessListOwnersResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "owners"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.owners) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.owners.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.owners, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_GetAccessListOwnersResponse, rhs: Teleport_Accesslist_V1_GetAccessListOwnersResponse) -> Bool {
    if lhs.owners != rhs.owners {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_UpsertAccessListMemberRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpsertAccessListMemberRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .same(proto: "member"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 4: try { try decoder.decodeSingularMessageField(value: &self._member) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._member {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_UpsertAccessListMemberRequest, rhs: Teleport_Accesslist_V1_UpsertAccessListMemberRequest) -> Bool {
    if lhs._member != rhs._member {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_UpdateAccessListMemberRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateAccessListMemberRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "member"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._member) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._member {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_UpdateAccessListMemberRequest, rhs: Teleport_Accesslist_V1_UpdateAccessListMemberRequest) -> Bool {
    if lhs._member != rhs._member {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_DeleteAccessListMemberRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteAccessListMemberRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_list"),
    3: .standard(proto: "member_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accessList) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.memberName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accessList.isEmpty {
      try visitor.visitSingularStringField(value: self.accessList, fieldNumber: 1)
    }
    if !self.memberName.isEmpty {
      try visitor.visitSingularStringField(value: self.memberName, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_DeleteAccessListMemberRequest, rhs: Teleport_Accesslist_V1_DeleteAccessListMemberRequest) -> Bool {
    if lhs.accessList != rhs.accessList {return false}
    if lhs.memberName != rhs.memberName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_DeleteAllAccessListMembersForAccessListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteAllAccessListMembersForAccessListRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_list"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accessList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accessList.isEmpty {
      try visitor.visitSingularStringField(value: self.accessList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_DeleteAllAccessListMembersForAccessListRequest, rhs: Teleport_Accesslist_V1_DeleteAllAccessListMembersForAccessListRequest) -> Bool {
    if lhs.accessList != rhs.accessList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_DeleteAllAccessListMembersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteAllAccessListMembersRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_DeleteAllAccessListMembersRequest, rhs: Teleport_Accesslist_V1_DeleteAllAccessListMembersRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_ListAccessListReviewsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListAccessListReviewsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_list"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "next_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accessList) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.nextToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accessList.isEmpty {
      try visitor.visitSingularStringField(value: self.accessList, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.nextToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_ListAccessListReviewsRequest, rhs: Teleport_Accesslist_V1_ListAccessListReviewsRequest) -> Bool {
    if lhs.accessList != rhs.accessList {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.nextToken != rhs.nextToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_ListAccessListReviewsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListAccessListReviewsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reviews"),
    2: .standard(proto: "next_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.reviews) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.reviews.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.reviews, fieldNumber: 1)
    }
    if !self.nextToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_ListAccessListReviewsResponse, rhs: Teleport_Accesslist_V1_ListAccessListReviewsResponse) -> Bool {
    if lhs.reviews != rhs.reviews {return false}
    if lhs.nextToken != rhs.nextToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_ListAllAccessListReviewsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListAllAccessListReviewsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "page_size"),
    2: .standard(proto: "next_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 1)
    }
    if !self.nextToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_ListAllAccessListReviewsRequest, rhs: Teleport_Accesslist_V1_ListAllAccessListReviewsRequest) -> Bool {
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.nextToken != rhs.nextToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_ListAllAccessListReviewsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListAllAccessListReviewsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reviews"),
    2: .standard(proto: "next_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.reviews) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.reviews.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.reviews, fieldNumber: 1)
    }
    if !self.nextToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_ListAllAccessListReviewsResponse, rhs: Teleport_Accesslist_V1_ListAllAccessListReviewsResponse) -> Bool {
    if lhs.reviews != rhs.reviews {return false}
    if lhs.nextToken != rhs.nextToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_CreateAccessListReviewRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateAccessListReviewRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "review"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._review) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._review {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_CreateAccessListReviewRequest, rhs: Teleport_Accesslist_V1_CreateAccessListReviewRequest) -> Bool {
    if lhs._review != rhs._review {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_CreateAccessListReviewResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateAccessListReviewResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "review_name"),
    2: .standard(proto: "next_audit_date"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.reviewName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._nextAuditDate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.reviewName.isEmpty {
      try visitor.visitSingularStringField(value: self.reviewName, fieldNumber: 1)
    }
    try { if let v = self._nextAuditDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_CreateAccessListReviewResponse, rhs: Teleport_Accesslist_V1_CreateAccessListReviewResponse) -> Bool {
    if lhs.reviewName != rhs.reviewName {return false}
    if lhs._nextAuditDate != rhs._nextAuditDate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_DeleteAccessListReviewRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteAccessListReviewRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "review_name"),
    2: .standard(proto: "access_list_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.reviewName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.accessListName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.reviewName.isEmpty {
      try visitor.visitSingularStringField(value: self.reviewName, fieldNumber: 1)
    }
    if !self.accessListName.isEmpty {
      try visitor.visitSingularStringField(value: self.accessListName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_DeleteAccessListReviewRequest, rhs: Teleport_Accesslist_V1_DeleteAccessListReviewRequest) -> Bool {
    if lhs.reviewName != rhs.reviewName {return false}
    if lhs.accessListName != rhs.accessListName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_AccessRequestPromoteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessRequestPromoteRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "access_list_name"),
    3: .same(proto: "reason"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.accessListName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    if !self.accessListName.isEmpty {
      try visitor.visitSingularStringField(value: self.accessListName, fieldNumber: 2)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_AccessRequestPromoteRequest, rhs: Teleport_Accesslist_V1_AccessRequestPromoteRequest) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.accessListName != rhs.accessListName {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_AccessRequestPromoteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessRequestPromoteResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_AccessRequestPromoteResponse, rhs: Teleport_Accesslist_V1_AccessRequestPromoteResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_GetSuggestedAccessListsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSuggestedAccessListsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_request_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accessRequestID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accessRequestID.isEmpty {
      try visitor.visitSingularStringField(value: self.accessRequestID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_GetSuggestedAccessListsRequest, rhs: Teleport_Accesslist_V1_GetSuggestedAccessListsRequest) -> Bool {
    if lhs.accessRequestID != rhs.accessRequestID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_GetSuggestedAccessListsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSuggestedAccessListsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_lists"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.accessLists) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accessLists.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accessLists, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_GetSuggestedAccessListsResponse, rhs: Teleport_Accesslist_V1_GetSuggestedAccessListsResponse) -> Bool {
    if lhs.accessLists != rhs.accessLists {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
