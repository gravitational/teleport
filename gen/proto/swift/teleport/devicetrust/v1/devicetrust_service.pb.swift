// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: teleport/devicetrust/v1/devicetrust_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2022 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// DeviceView specifies which fields of returned devices should be present.
enum Teleport_Devicetrust_V1_DeviceView: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unspecified // = 0

  /// View for general device listings, like `tctl devices ls`.
  /// Contains only basic information, such as IDs and enrollment status.
  case list // = 1

  /// View for detailed device queries, like `tctl get devices`.
  /// Presents a complete view of the device.
  case resource // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .list
    case 2: self = .resource
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .list: return 1
    case .resource: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Teleport_Devicetrust_V1_DeviceView] = [
    .unspecified,
    .list,
    .resource,
  ]

}

/// Request for CreateDevice.
struct Teleport_Devicetrust_V1_CreateDeviceRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Device to create.
  var device: Teleport_Devicetrust_V1_Device {
    get {return _device ?? Teleport_Devicetrust_V1_Device()}
    set {_device = newValue}
  }
  /// Returns true if `device` has been explicitly set.
  var hasDevice: Bool {return self._device != nil}
  /// Clears the value of `device`. Subsequent reads from it will return its default value.
  mutating func clearDevice() {self._device = nil}

  /// If true, a DeviceEnrollToken is created along with the Device.
  var createEnrollToken: Bool = false

  /// If true, create the device as a Teleport resource, meaning that fields that
  /// are usually considered read-only or system managed are copied as provided
  /// to storage.
  /// Prefer using non-resource creation semantics if possible.
  var createAsResource: Bool = false

  /// Custom expiration time for enrollment tokens.
  /// A short (for humans) server default is used if unset.
  var enrollTokenExpireTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _enrollTokenExpireTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_enrollTokenExpireTime = newValue}
  }
  /// Returns true if `enrollTokenExpireTime` has been explicitly set.
  var hasEnrollTokenExpireTime: Bool {return self._enrollTokenExpireTime != nil}
  /// Clears the value of `enrollTokenExpireTime`. Subsequent reads from it will return its default value.
  mutating func clearEnrollTokenExpireTime() {self._enrollTokenExpireTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _device: Teleport_Devicetrust_V1_Device? = nil
  fileprivate var _enrollTokenExpireTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Request for UpdateDevice.
struct Teleport_Devicetrust_V1_UpdateDeviceRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Device to update.
  var device: Teleport_Devicetrust_V1_Device {
    get {return _device ?? Teleport_Devicetrust_V1_Device()}
    set {_device = newValue}
  }
  /// Returns true if `device` has been explicitly set.
  var hasDevice: Bool {return self._device != nil}
  /// Clears the value of `device`. Subsequent reads from it will return its default value.
  mutating func clearDevice() {self._device = nil}

  /// Update mask applied to the resource.
  /// Fields are masked according to their proto name.
  var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  mutating func clearUpdateMask() {self._updateMask = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _device: Teleport_Devicetrust_V1_Device? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Request for UpsertDevice.
struct Teleport_Devicetrust_V1_UpsertDeviceRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Device to create or update.
  var device: Teleport_Devicetrust_V1_Device {
    get {return _device ?? Teleport_Devicetrust_V1_Device()}
    set {_device = newValue}
  }
  /// Returns true if `device` has been explicitly set.
  var hasDevice: Bool {return self._device != nil}
  /// Clears the value of `device`. Subsequent reads from it will return its default value.
  mutating func clearDevice() {self._device = nil}

  /// If true, creates the device using resource semantics.
  /// Has no effect on device updates.
  /// See create_as_resource in CreateDeviceRequest.
  var createAsResource: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _device: Teleport_Devicetrust_V1_Device? = nil
}

/// Request for DeleteDevice.
struct Teleport_Devicetrust_V1_DeleteDeviceRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the Device to delete.
  var deviceID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for FindDevices.
///
/// Inspect the returned devices to determine whether the match was by ID or
/// asset tag.
struct Teleport_Devicetrust_V1_FindDevicesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Device ID or asset tag.
  var idOrTag: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Response for FindDevices.
struct Teleport_Devicetrust_V1_FindDevicesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Devices that matched the search.
  /// The number of resulting devices is expected to be low and may be
  /// artificially capped by the server otherwise.
  var devices: [Teleport_Devicetrust_V1_Device] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for GetDevice.
struct Teleport_Devicetrust_V1_GetDeviceRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the device.
  var deviceID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for ListDevices.
///
/// Follows the pagination semantics of
/// https://cloud.google.com/apis/design/standard_methods#list.
struct Teleport_Devicetrust_V1_ListDevicesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The maximum number of items to return.
  /// The server may impose a different page size at its discretion.
  var pageSize: Int32 = 0

  /// The next_page_token value returned from a previous List request, if any.
  var pageToken: String = String()

  /// Specifies which fields of the resource should be returned in the response.
  /// Defaults to DEVICE_VIEW_LIST.
  var view: Teleport_Devicetrust_V1_DeviceView = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Response for ListDevices.
struct Teleport_Devicetrust_V1_ListDevicesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Devices that matched the search.
  var devices: [Teleport_Devicetrust_V1_Device] = []

  /// Token to retrieve the next page of results, or empty if there are no
  /// more results in the list.
  var nextPageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for ListDevicesByUser.
///
/// Follows the pagination semantics of
/// https://cloud.google.com/apis/design/standard_methods#list.
struct Teleport_Devicetrust_V1_ListDevicesByUserRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The maximum number of items to return.
  /// The server may impose a different page size at its discretion.
  var pageSize: Int32 = 0

  /// The next_page_token value returned from a previous List request, if any.
  var pageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Response for ListDevicesByUser.
struct Teleport_Devicetrust_V1_ListDevicesByUserResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Devices owned by the user.
  var devices: [Teleport_Devicetrust_V1_Device] = []

  /// Token to retrieve the next page of results, or empty if there are no
  /// more results in the list.
  var nextPageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for BulkCreateDevices.
struct Teleport_Devicetrust_V1_BulkCreateDevicesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Devices to create.
  var devices: [Teleport_Devicetrust_V1_Device] = []

  /// If true, create the device as a Teleport resource, meaning that fields that
  /// are usually considered read-only or system managed are copied as provided
  /// to storage.
  /// Prefer using non-resource creation semantics if possible.
  var createAsResource: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Response for BulkCreateDevices.
struct Teleport_Devicetrust_V1_BulkCreateDevicesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Created devices or a failure reason.
  /// Responses are sorted according to the request.
  var devices: [Teleport_Devicetrust_V1_DeviceOrStatus] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DeviceOrStatus contains either a device ID, in case of success, or a status
/// in case of failures.
struct Teleport_Devicetrust_V1_DeviceOrStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the created device.
  /// Only present if the status is OK.
  var id: String = String()

  /// If true the action attempted against the device was a delete, instead of a
  /// create or update.
  var deleted: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for CreateDeviceEnrollToken.
struct Teleport_Devicetrust_V1_CreateDeviceEnrollTokenRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the device.
  var deviceID: String = String()

  /// Device collected data.
  /// Used to authorize issuance of device enrollment tokens for auto-enrollment.
  /// Not required otherwise.
  var deviceData: Teleport_Devicetrust_V1_DeviceCollectedData {
    get {return _deviceData ?? Teleport_Devicetrust_V1_DeviceCollectedData()}
    set {_deviceData = newValue}
  }
  /// Returns true if `deviceData` has been explicitly set.
  var hasDeviceData: Bool {return self._deviceData != nil}
  /// Clears the value of `deviceData`. Subsequent reads from it will return its default value.
  mutating func clearDeviceData() {self._deviceData = nil}

  /// Custom expiration time for enrollment tokens.
  /// A short (for humans) server default is used if unset.
  var expireTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expireTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expireTime = newValue}
  }
  /// Returns true if `expireTime` has been explicitly set.
  var hasExpireTime: Bool {return self._expireTime != nil}
  /// Clears the value of `expireTime`. Subsequent reads from it will return its default value.
  mutating func clearExpireTime() {self._expireTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _deviceData: Teleport_Devicetrust_V1_DeviceCollectedData? = nil
  fileprivate var _expireTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Request for EnrollDevice.
struct Teleport_Devicetrust_V1_EnrollDeviceRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var payload: Teleport_Devicetrust_V1_EnrollDeviceRequest.OneOf_Payload? = nil

  var init_p: Teleport_Devicetrust_V1_EnrollDeviceInit {
    get {
      if case .init_p(let v)? = payload {return v}
      return Teleport_Devicetrust_V1_EnrollDeviceInit()
    }
    set {payload = .init_p(newValue)}
  }

  var macosChallengeResponse: Teleport_Devicetrust_V1_MacOSEnrollChallengeResponse {
    get {
      if case .macosChallengeResponse(let v)? = payload {return v}
      return Teleport_Devicetrust_V1_MacOSEnrollChallengeResponse()
    }
    set {payload = .macosChallengeResponse(newValue)}
  }

  var tpmChallengeResponse: Teleport_Devicetrust_V1_TPMEnrollChallengeResponse {
    get {
      if case .tpmChallengeResponse(let v)? = payload {return v}
      return Teleport_Devicetrust_V1_TPMEnrollChallengeResponse()
    }
    set {payload = .tpmChallengeResponse(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Payload: Equatable, Sendable {
    case init_p(Teleport_Devicetrust_V1_EnrollDeviceInit)
    case macosChallengeResponse(Teleport_Devicetrust_V1_MacOSEnrollChallengeResponse)
    case tpmChallengeResponse(Teleport_Devicetrust_V1_TPMEnrollChallengeResponse)

  }

  init() {}
}

/// Response for EnrollDevice.
struct Teleport_Devicetrust_V1_EnrollDeviceResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var payload: Teleport_Devicetrust_V1_EnrollDeviceResponse.OneOf_Payload? = nil

  var success: Teleport_Devicetrust_V1_EnrollDeviceSuccess {
    get {
      if case .success(let v)? = payload {return v}
      return Teleport_Devicetrust_V1_EnrollDeviceSuccess()
    }
    set {payload = .success(newValue)}
  }

  var macosChallenge: Teleport_Devicetrust_V1_MacOSEnrollChallenge {
    get {
      if case .macosChallenge(let v)? = payload {return v}
      return Teleport_Devicetrust_V1_MacOSEnrollChallenge()
    }
    set {payload = .macosChallenge(newValue)}
  }

  var tpmChallenge: Teleport_Devicetrust_V1_TPMEnrollChallenge {
    get {
      if case .tpmChallenge(let v)? = payload {return v}
      return Teleport_Devicetrust_V1_TPMEnrollChallenge()
    }
    set {payload = .tpmChallenge(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Payload: Equatable, Sendable {
    case success(Teleport_Devicetrust_V1_EnrollDeviceSuccess)
    case macosChallenge(Teleport_Devicetrust_V1_MacOSEnrollChallenge)
    case tpmChallenge(Teleport_Devicetrust_V1_TPMEnrollChallenge)

  }

  init() {}
}

/// EnrollDeviceInit initiates the enrollment ceremony.
struct Teleport_Devicetrust_V1_EnrollDeviceInit: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Device enrollment token.
  /// See CreateDevice or CreateDeviceEnrollToken.
  var token: String = String()

  /// ID of the device credential.
  var credentialID: String = String()

  /// Device collected data.
  /// Matched against the device registration information and any previously
  /// collected data.
  var deviceData: Teleport_Devicetrust_V1_DeviceCollectedData {
    get {return _deviceData ?? Teleport_Devicetrust_V1_DeviceCollectedData()}
    set {_deviceData = newValue}
  }
  /// Returns true if `deviceData` has been explicitly set.
  var hasDeviceData: Bool {return self._deviceData != nil}
  /// Clears the value of `deviceData`. Subsequent reads from it will return its default value.
  mutating func clearDeviceData() {self._deviceData = nil}

  /// Payload for macOS-specific data.
  var macos: Teleport_Devicetrust_V1_MacOSEnrollPayload {
    get {return _macos ?? Teleport_Devicetrust_V1_MacOSEnrollPayload()}
    set {_macos = newValue}
  }
  /// Returns true if `macos` has been explicitly set.
  var hasMacos: Bool {return self._macos != nil}
  /// Clears the value of `macos`. Subsequent reads from it will return its default value.
  mutating func clearMacos() {self._macos = nil}

  /// Payload for TPM-specific data. Used for Windows/Linux.
  var tpm: Teleport_Devicetrust_V1_TPMEnrollPayload {
    get {return _tpm ?? Teleport_Devicetrust_V1_TPMEnrollPayload()}
    set {_tpm = newValue}
  }
  /// Returns true if `tpm` has been explicitly set.
  var hasTpm: Bool {return self._tpm != nil}
  /// Clears the value of `tpm`. Subsequent reads from it will return its default value.
  mutating func clearTpm() {self._tpm = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _deviceData: Teleport_Devicetrust_V1_DeviceCollectedData? = nil
  fileprivate var _macos: Teleport_Devicetrust_V1_MacOSEnrollPayload? = nil
  fileprivate var _tpm: Teleport_Devicetrust_V1_TPMEnrollPayload? = nil
}

/// EnrollDeviceSuccess marks a successful device enrollment ceremony.
struct Teleport_Devicetrust_V1_EnrollDeviceSuccess: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The enrolled device.
  var device: Teleport_Devicetrust_V1_Device {
    get {return _device ?? Teleport_Devicetrust_V1_Device()}
    set {_device = newValue}
  }
  /// Returns true if `device` has been explicitly set.
  var hasDevice: Bool {return self._device != nil}
  /// Clears the value of `device`. Subsequent reads from it will return its default value.
  mutating func clearDevice() {self._device = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _device: Teleport_Devicetrust_V1_Device? = nil
}

/// MacOSEnrollPayload is the macOS-specific enrollment payload.
struct Teleport_Devicetrust_V1_MacOSEnrollPayload: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Device public key marshaled as a PKIX, ASN.1 DER.
  var publicKeyDer: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MacOSEnrollChallenge is a macOS enrollment challenge.
struct Teleport_Devicetrust_V1_MacOSEnrollChallenge: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Randomly-generated, opaque challenge to be signed using the device key.
  var challenge: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MacOSEnrollChallengeResponse is a macOS enrollment challenge response.
struct Teleport_Devicetrust_V1_MacOSEnrollChallengeResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Signature over the challenge, using the device key.
  var signature: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The payload containing TPM specific information required on device
/// enrollment.
struct Teleport_Devicetrust_V1_TPMEnrollPayload: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ek: Teleport_Devicetrust_V1_TPMEnrollPayload.OneOf_Ek? = nil

  /// The device's endorsement certificate in X509, ASN.1 DER form. This
  /// certificate contains the public key of the endorsement key. This is
  /// preferred to ek_key.
  var ekCert: Data {
    get {
      if case .ekCert(let v)? = ek {return v}
      return Data()
    }
    set {ek = .ekCert(newValue)}
  }

  /// The device's public endorsement key in PKIX, ASN.1 DER form. This is
  /// used when a TPM does not contain any endorsement certificates.
  var ekKey: Data {
    get {
      if case .ekKey(let v)? = ek {return v}
      return Data()
    }
    set {ek = .ekKey(newValue)}
  }

  /// The attestation key and the parameters necessary to remotely verify it as
  /// related to the endorsement key.
  var attestationParameters: Teleport_Devicetrust_V1_TPMAttestationParameters {
    get {return _attestationParameters ?? Teleport_Devicetrust_V1_TPMAttestationParameters()}
    set {_attestationParameters = newValue}
  }
  /// Returns true if `attestationParameters` has been explicitly set.
  var hasAttestationParameters: Bool {return self._attestationParameters != nil}
  /// Clears the value of `attestationParameters`. Subsequent reads from it will return its default value.
  mutating func clearAttestationParameters() {self._attestationParameters = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Ek: Equatable, @unchecked Sendable {
    /// The device's endorsement certificate in X509, ASN.1 DER form. This
    /// certificate contains the public key of the endorsement key. This is
    /// preferred to ek_key.
    case ekCert(Data)
    /// The device's public endorsement key in PKIX, ASN.1 DER form. This is
    /// used when a TPM does not contain any endorsement certificates.
    case ekKey(Data)

  }

  init() {}

  fileprivate var _attestationParameters: Teleport_Devicetrust_V1_TPMAttestationParameters? = nil
}

/// The attestation key and the parameters necessary to remotely verify it as
/// related to the endorsement key.
/// See https://pkg.go.dev/github.com/google/go-attestation/attest#AttestationParameters.
/// This message excludes the `UseTCSDActivationFormat` field from the link above
/// as it is TMP 1.x specific and always false.
struct Teleport_Devicetrust_V1_TPMAttestationParameters: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The encoded TPMT_PUBLIC structure containing the attestation public key
  /// and signing parameters.
  var `public`: Data = Data()

  /// The properties of the attestation key, encoded as a TPMS_CREATION_DATA
  /// structure.
  var createData: Data = Data()

  /// An assertion as to the details of the key, encoded as a TPMS_ATTEST
  /// structure.
  var createAttestation: Data = Data()

  /// A signature of create_attestation, encoded as a TPMT_SIGNATURE structure.
  var createSignature: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The challenge sent to the client by the server during enrollment.
/// The challenge involves two parts:
/// - Solving an encrypted credential with `ActivateCredential`.
/// - Producing a platform attestation using the provided nonce.
struct Teleport_Devicetrust_V1_TPMEnrollChallenge: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The encrypted credential for the client to prove possession of the EK and
  /// AK.
  var encryptedCredential: Teleport_Devicetrust_V1_TPMEncryptedCredential {
    get {return _encryptedCredential ?? Teleport_Devicetrust_V1_TPMEncryptedCredential()}
    set {_encryptedCredential = newValue}
  }
  /// Returns true if `encryptedCredential` has been explicitly set.
  var hasEncryptedCredential: Bool {return self._encryptedCredential != nil}
  /// Clears the value of `encryptedCredential`. Subsequent reads from it will return its default value.
  mutating func clearEncryptedCredential() {self._encryptedCredential = nil}

  /// The nonce to use when producing the quotes over the PCRs with the TPM
  /// during the platform attestation.
  var attestationNonce: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _encryptedCredential: Teleport_Devicetrust_V1_TPMEncryptedCredential? = nil
}

/// These values are used by the TPM2.0 `ActivateCredential` command to produce
/// the solution which proves possession of the EK and AK.
///
/// For a more in-depth description see:
/// - https://pkg.go.dev/github.com/google/go-attestation/attest#EncryptedCredential
/// - https://trustedcomputinggroup.org/wp-content/uploads/TCG_TPM2_r1p59_Part3_Commands_code_pub.pdf (Heading 12.5.1 "TPM2_ActivateCredential" "General Description")
/// - https://github.com/google/go-attestation/blob/v0.4.3/attest/activation.go#L199
/// - https://github.com/google/go-tpm/blob/v0.3.3/tpm2/credactivation/credential_activation.go#L61
struct Teleport_Devicetrust_V1_TPMEncryptedCredential: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The `credential_blob` parameter to be used with the `ActivateCredential`
  /// command. This is used with the decrypted value of `secret` in a
  /// cryptographic process to decrypt the solution.
  var credentialBlob: Data = Data()

  /// The `secret` parameter to be used with `ActivateCredential`. This is a
  /// seed which can be decrypted with the EK. The decrypted seed is then used
  /// when decrypting `credential_blob`.
  var secret: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The enrollment challenge response containing the solution returned by
/// calling the TPM2.0 `ActivateCredential` command on the client with the
/// parameters provided in `TPMEnrollChallenge`.
struct Teleport_Devicetrust_V1_TPMEnrollChallengeResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The client's solution to `TPMEncryptedCredential` included in
  /// `TPMEnrollChallenge` using ActivateCredential.
  var solution: Data = Data()

  /// The result of the client's platform attestation with the nonce provided
  /// in `TPMEnrollChallenge`.
  var platformParameters: Teleport_Devicetrust_V1_TPMPlatformParameters {
    get {return _platformParameters ?? Teleport_Devicetrust_V1_TPMPlatformParameters()}
    set {_platformParameters = newValue}
  }
  /// Returns true if `platformParameters` has been explicitly set.
  var hasPlatformParameters: Bool {return self._platformParameters != nil}
  /// Clears the value of `platformParameters`. Subsequent reads from it will return its default value.
  mutating func clearPlatformParameters() {self._platformParameters = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _platformParameters: Teleport_Devicetrust_V1_TPMPlatformParameters? = nil
}

/// Request for AuthenticateDevice.
///
/// Authentication ceremony flow:
/// -> AuthenticateDeviceInit (client)
/// <- AuthenticateDeviceChallenge (server)
/// -> AuthenticateDeviceChallengeResponse
/// <- UserCertificates (regular authn) or ConfirmationToken (web authn)
struct Teleport_Devicetrust_V1_AuthenticateDeviceRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var payload: Teleport_Devicetrust_V1_AuthenticateDeviceRequest.OneOf_Payload? = nil

  var init_p: Teleport_Devicetrust_V1_AuthenticateDeviceInit {
    get {
      if case .init_p(let v)? = payload {return v}
      return Teleport_Devicetrust_V1_AuthenticateDeviceInit()
    }
    set {payload = .init_p(newValue)}
  }

  var challengeResponse: Teleport_Devicetrust_V1_AuthenticateDeviceChallengeResponse {
    get {
      if case .challengeResponse(let v)? = payload {return v}
      return Teleport_Devicetrust_V1_AuthenticateDeviceChallengeResponse()
    }
    set {payload = .challengeResponse(newValue)}
  }

  var tpmChallengeResponse: Teleport_Devicetrust_V1_TPMAuthenticateDeviceChallengeResponse {
    get {
      if case .tpmChallengeResponse(let v)? = payload {return v}
      return Teleport_Devicetrust_V1_TPMAuthenticateDeviceChallengeResponse()
    }
    set {payload = .tpmChallengeResponse(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Payload: Equatable, Sendable {
    case init_p(Teleport_Devicetrust_V1_AuthenticateDeviceInit)
    case challengeResponse(Teleport_Devicetrust_V1_AuthenticateDeviceChallengeResponse)
    case tpmChallengeResponse(Teleport_Devicetrust_V1_TPMAuthenticateDeviceChallengeResponse)

  }

  init() {}
}

/// Response for AuthenticateDevice.
struct Teleport_Devicetrust_V1_AuthenticateDeviceResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var payload: Teleport_Devicetrust_V1_AuthenticateDeviceResponse.OneOf_Payload? = nil

  var challenge: Teleport_Devicetrust_V1_AuthenticateDeviceChallenge {
    get {
      if case .challenge(let v)? = payload {return v}
      return Teleport_Devicetrust_V1_AuthenticateDeviceChallenge()
    }
    set {payload = .challenge(newValue)}
  }

  /// User certificates are returned as the result of a successful device
  /// authentication attempt ("regular" or non-web authentication).
  var userCertificates: Teleport_Devicetrust_V1_UserCertificates {
    get {
      if case .userCertificates(let v)? = payload {return v}
      return Teleport_Devicetrust_V1_UserCertificates()
    }
    set {payload = .userCertificates(newValue)}
  }

  var tpmChallenge: Teleport_Devicetrust_V1_TPMAuthenticateDeviceChallenge {
    get {
      if case .tpmChallenge(let v)? = payload {return v}
      return Teleport_Devicetrust_V1_TPMAuthenticateDeviceChallenge()
    }
    set {payload = .tpmChallenge(newValue)}
  }

  /// A confirmation token is returned as the result of a successful device web
  /// authentication.
  ///
  /// See AuthenticateDeviceInit.device_web_token.
  var confirmationToken: Teleport_Devicetrust_V1_DeviceConfirmationToken {
    get {
      if case .confirmationToken(let v)? = payload {return v}
      return Teleport_Devicetrust_V1_DeviceConfirmationToken()
    }
    set {payload = .confirmationToken(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Payload: Equatable, Sendable {
    case challenge(Teleport_Devicetrust_V1_AuthenticateDeviceChallenge)
    /// User certificates are returned as the result of a successful device
    /// authentication attempt ("regular" or non-web authentication).
    case userCertificates(Teleport_Devicetrust_V1_UserCertificates)
    case tpmChallenge(Teleport_Devicetrust_V1_TPMAuthenticateDeviceChallenge)
    /// A confirmation token is returned as the result of a successful device web
    /// authentication.
    ///
    /// See AuthenticateDeviceInit.device_web_token.
    case confirmationToken(Teleport_Devicetrust_V1_DeviceConfirmationToken)

  }

  init() {}
}

/// AuthenticateDeviceInit initiates the device authentication ceremony.
struct Teleport_Devicetrust_V1_AuthenticateDeviceInit: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// In-band user certificates to augment with device extensions.
  /// - The x509 certificate is acquired from the mTLS connection, thus the
  ///   in-band certificate is ignored.
  /// - All certificates must be valid and issued by the Teleport CA.
  /// - TLS and SSH certificates must match (same Teleport user, plus whatever
  ///   additional checks the backend sees fit).
  /// - TLS and SSH certificates must either have matching public keys, or
  ///   (TPM)AuthenticateDeviceChallengeResponse.SshSignature must be a valid
  ///   signature over the challenge by the SSH private key.
  /// - Augmented certificates have the same expiration as the original
  ///   certificates.
  var userCertificates: Teleport_Devicetrust_V1_UserCertificates {
    get {return _userCertificates ?? Teleport_Devicetrust_V1_UserCertificates()}
    set {_userCertificates = newValue}
  }
  /// Returns true if `userCertificates` has been explicitly set.
  var hasUserCertificates: Bool {return self._userCertificates != nil}
  /// Clears the value of `userCertificates`. Subsequent reads from it will return its default value.
  mutating func clearUserCertificates() {self._userCertificates = nil}

  /// ID of the enrolled device credential.
  var credentialID: String = String()

  /// Device collected data.
  /// Matched against the device registration information and any previously
  /// collected data.
  var deviceData: Teleport_Devicetrust_V1_DeviceCollectedData {
    get {return _deviceData ?? Teleport_Devicetrust_V1_DeviceCollectedData()}
    set {_deviceData = newValue}
  }
  /// Returns true if `deviceData` has been explicitly set.
  var hasDeviceData: Bool {return self._deviceData != nil}
  /// Clears the value of `deviceData`. Subsequent reads from it will return its default value.
  mutating func clearDeviceData() {self._deviceData = nil}

  /// If present, on-behalf-of device authentication is performed.
  /// The user_certificates input field is ignored and no certificate data is
  /// returned to the caller, instead a confirmation_token is returned in
  /// the last step.
  ///
  /// See ConfirmDeviceWebAuthentication.
  var deviceWebToken: Teleport_Devicetrust_V1_DeviceWebToken {
    get {return _deviceWebToken ?? Teleport_Devicetrust_V1_DeviceWebToken()}
    set {_deviceWebToken = newValue}
  }
  /// Returns true if `deviceWebToken` has been explicitly set.
  var hasDeviceWebToken: Bool {return self._deviceWebToken != nil}
  /// Clears the value of `deviceWebToken`. Subsequent reads from it will return its default value.
  mutating func clearDeviceWebToken() {self._deviceWebToken = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _userCertificates: Teleport_Devicetrust_V1_UserCertificates? = nil
  fileprivate var _deviceData: Teleport_Devicetrust_V1_DeviceCollectedData? = nil
  fileprivate var _deviceWebToken: Teleport_Devicetrust_V1_DeviceWebToken? = nil
}

/// Request for ConfirmDeviceWebAuthentication.
struct Teleport_Devicetrust_V1_ConfirmDeviceWebAuthenticationRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Confirmation token to be spent.
  var confirmationToken: Teleport_Devicetrust_V1_DeviceConfirmationToken {
    get {return _confirmationToken ?? Teleport_Devicetrust_V1_DeviceConfirmationToken()}
    set {_confirmationToken = newValue}
  }
  /// Returns true if `confirmationToken` has been explicitly set.
  var hasConfirmationToken: Bool {return self._confirmationToken != nil}
  /// Clears the value of `confirmationToken`. Subsequent reads from it will return its default value.
  mutating func clearConfirmationToken() {self._confirmationToken = nil}

  /// Web Session identifier of the session that started this request, via
  /// Teleport Proxy.
  ///
  /// For the request to be successful the Web Session must match the session
  /// that started the authentication attempt.
  var currentWebSessionID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _confirmationToken: Teleport_Devicetrust_V1_DeviceConfirmationToken? = nil
}

/// Response for ConfirmDeviceWebAuthentication.
struct Teleport_Devicetrust_V1_ConfirmDeviceWebAuthenticationResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for SyncInventory.
///
/// A typical message sequence is as follows:
/// (-> means client-to-server, <- means server-to-client)
/// -> SyncInventoryStart
/// <- SyncInventoryAck
/// (loop)
/// -> SyncInventoryDevices (add/remove devices)
/// <- SyncInventoryResult
/// (end loop)
/// -> SyncInventoryEnd
/// (loop until server closes the stream, zero or more times)
/// <- SyncInventoryMissingDevices
/// -> SyncInventoryDevices (removals only)
/// <- SyncInventoryResult
/// (end loop)
struct Teleport_Devicetrust_V1_SyncInventoryRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var payload: Teleport_Devicetrust_V1_SyncInventoryRequest.OneOf_Payload? = nil

  var start: Teleport_Devicetrust_V1_SyncInventoryStart {
    get {
      if case .start(let v)? = payload {return v}
      return Teleport_Devicetrust_V1_SyncInventoryStart()
    }
    set {payload = .start(newValue)}
  }

  var end: Teleport_Devicetrust_V1_SyncInventoryEnd {
    get {
      if case .end(let v)? = payload {return v}
      return Teleport_Devicetrust_V1_SyncInventoryEnd()
    }
    set {payload = .end(newValue)}
  }

  var devicesToUpsert: Teleport_Devicetrust_V1_SyncInventoryDevices {
    get {
      if case .devicesToUpsert(let v)? = payload {return v}
      return Teleport_Devicetrust_V1_SyncInventoryDevices()
    }
    set {payload = .devicesToUpsert(newValue)}
  }

  var devicesToRemove: Teleport_Devicetrust_V1_SyncInventoryDevices {
    get {
      if case .devicesToRemove(let v)? = payload {return v}
      return Teleport_Devicetrust_V1_SyncInventoryDevices()
    }
    set {payload = .devicesToRemove(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Payload: Equatable, Sendable {
    case start(Teleport_Devicetrust_V1_SyncInventoryStart)
    case end(Teleport_Devicetrust_V1_SyncInventoryEnd)
    case devicesToUpsert(Teleport_Devicetrust_V1_SyncInventoryDevices)
    case devicesToRemove(Teleport_Devicetrust_V1_SyncInventoryDevices)

  }

  init() {}
}

/// Response for SyncInventory.
struct Teleport_Devicetrust_V1_SyncInventoryResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var payload: Teleport_Devicetrust_V1_SyncInventoryResponse.OneOf_Payload? = nil

  var ack: Teleport_Devicetrust_V1_SyncInventoryAck {
    get {
      if case .ack(let v)? = payload {return v}
      return Teleport_Devicetrust_V1_SyncInventoryAck()
    }
    set {payload = .ack(newValue)}
  }

  var result: Teleport_Devicetrust_V1_SyncInventoryResult {
    get {
      if case .result(let v)? = payload {return v}
      return Teleport_Devicetrust_V1_SyncInventoryResult()
    }
    set {payload = .result(newValue)}
  }

  var missingDevices: Teleport_Devicetrust_V1_SyncInventoryMissingDevices {
    get {
      if case .missingDevices(let v)? = payload {return v}
      return Teleport_Devicetrust_V1_SyncInventoryMissingDevices()
    }
    set {payload = .missingDevices(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Payload: Equatable, Sendable {
    case ack(Teleport_Devicetrust_V1_SyncInventoryAck)
    case result(Teleport_Devicetrust_V1_SyncInventoryResult)
    case missingDevices(Teleport_Devicetrust_V1_SyncInventoryMissingDevices)

  }

  init() {}
}

/// SyncInventoryStart starts the inventory sync.
struct Teleport_Devicetrust_V1_SyncInventoryStart: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Source of the inventory sync.
  /// Used for all devices. The `source` field in individual devices is ignored
  /// by this RPC.
  var source: Teleport_Devicetrust_V1_DeviceSource {
    get {return _source ?? Teleport_Devicetrust_V1_DeviceSource()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  mutating func clearSource() {self._source = nil}

  /// If true, the server keeps track of the devices upserted during the sync.
  /// After receiving the [SyncInventoryEnd] message, the server informs the
  /// client of all devices that are present in storage but not observed in the
  /// upserts.
  /// See [SyncInventoryRequest] and [SyncInventoryMissingDevices] for details.
  var trackMissingDevices: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _source: Teleport_Devicetrust_V1_DeviceSource? = nil
}

/// SyncInventoryEnd ends the inventory sync, signaling that no more
/// SyncInventoryDevices messages will be sent by the client.
struct Teleport_Devicetrust_V1_SyncInventoryEnd: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// SyncInventoryDevices transports devices to add/update/remove.
/// Removals only need identifying fields to be set.
struct Teleport_Devicetrust_V1_SyncInventoryDevices: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Devices to sync.
  var devices: [Teleport_Devicetrust_V1_Device] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// SyncInventoryAck is used to confirm successful processing of messages that
/// lack a more specific response.
struct Teleport_Devicetrust_V1_SyncInventoryAck: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// SyncInventoryResult is the response for SyncInventoryDevices or
/// SyncInventoryEnd
/// It lists all synced/deleted devices.
struct Teleport_Devicetrust_V1_SyncInventoryResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Devices modified, in the same order as the input when applicable.
  var devices: [Teleport_Devicetrust_V1_DeviceOrStatus] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// SyncInventoryMissingDevices informs the sync client of all stored devices
/// that were not observed in upserts during the sync.
///
/// Requires `track_missing_devices` to be set in the [SyncInventoryStart]
/// message.
///
/// The client must follow up with a [SyncInventoryDevices] message, including
/// any devices to be deleted.
struct Teleport_Devicetrust_V1_SyncInventoryMissingDevices: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Devices missing from the client-side sync.
  /// Guaranteed to have the following fields: id, os_type, asset_tag and
  /// profile.external_id.
  var devices: [Teleport_Devicetrust_V1_Device] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Superseded by ResourceUsageService.GetUsage.
struct Teleport_Devicetrust_V1_GetDevicesUsageRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "teleport.devicetrust.v1"

extension Teleport_Devicetrust_V1_DeviceView: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEVICE_VIEW_UNSPECIFIED"),
    1: .same(proto: "DEVICE_VIEW_LIST"),
    2: .same(proto: "DEVICE_VIEW_RESOURCE"),
  ]
}

extension Teleport_Devicetrust_V1_CreateDeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateDeviceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "device"),
    2: .standard(proto: "create_enroll_token"),
    3: .standard(proto: "create_as_resource"),
    4: .standard(proto: "enroll_token_expire_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._device) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.createEnrollToken) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.createAsResource) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._enrollTokenExpireTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._device {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.createEnrollToken != false {
      try visitor.visitSingularBoolField(value: self.createEnrollToken, fieldNumber: 2)
    }
    if self.createAsResource != false {
      try visitor.visitSingularBoolField(value: self.createAsResource, fieldNumber: 3)
    }
    try { if let v = self._enrollTokenExpireTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Devicetrust_V1_CreateDeviceRequest, rhs: Teleport_Devicetrust_V1_CreateDeviceRequest) -> Bool {
    if lhs._device != rhs._device {return false}
    if lhs.createEnrollToken != rhs.createEnrollToken {return false}
    if lhs.createAsResource != rhs.createAsResource {return false}
    if lhs._enrollTokenExpireTime != rhs._enrollTokenExpireTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Devicetrust_V1_UpdateDeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateDeviceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "device"),
    2: .standard(proto: "update_mask"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._device) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._device {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Devicetrust_V1_UpdateDeviceRequest, rhs: Teleport_Devicetrust_V1_UpdateDeviceRequest) -> Bool {
    if lhs._device != rhs._device {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Devicetrust_V1_UpsertDeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpsertDeviceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "device"),
    2: .standard(proto: "create_as_resource"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._device) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.createAsResource) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._device {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.createAsResource != false {
      try visitor.visitSingularBoolField(value: self.createAsResource, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Devicetrust_V1_UpsertDeviceRequest, rhs: Teleport_Devicetrust_V1_UpsertDeviceRequest) -> Bool {
    if lhs._device != rhs._device {return false}
    if lhs.createAsResource != rhs.createAsResource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Devicetrust_V1_DeleteDeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteDeviceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Devicetrust_V1_DeleteDeviceRequest, rhs: Teleport_Devicetrust_V1_DeleteDeviceRequest) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Devicetrust_V1_FindDevicesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FindDevicesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "id_or_tag"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.idOrTag) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.idOrTag.isEmpty {
      try visitor.visitSingularStringField(value: self.idOrTag, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Devicetrust_V1_FindDevicesRequest, rhs: Teleport_Devicetrust_V1_FindDevicesRequest) -> Bool {
    if lhs.idOrTag != rhs.idOrTag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Devicetrust_V1_FindDevicesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FindDevicesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "devices"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.devices) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.devices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.devices, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Devicetrust_V1_FindDevicesResponse, rhs: Teleport_Devicetrust_V1_FindDevicesResponse) -> Bool {
    if lhs.devices != rhs.devices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Devicetrust_V1_GetDeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetDeviceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Devicetrust_V1_GetDeviceRequest, rhs: Teleport_Devicetrust_V1_GetDeviceRequest) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Devicetrust_V1_ListDevicesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListDevicesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "page_size"),
    2: .standard(proto: "page_token"),
    3: .same(proto: "view"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.view) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 1)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 2)
    }
    if self.view != .unspecified {
      try visitor.visitSingularEnumField(value: self.view, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Devicetrust_V1_ListDevicesRequest, rhs: Teleport_Devicetrust_V1_ListDevicesRequest) -> Bool {
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.view != rhs.view {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Devicetrust_V1_ListDevicesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListDevicesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "devices"),
    2: .standard(proto: "next_page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.devices) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.devices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.devices, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Devicetrust_V1_ListDevicesResponse, rhs: Teleport_Devicetrust_V1_ListDevicesResponse) -> Bool {
    if lhs.devices != rhs.devices {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Devicetrust_V1_ListDevicesByUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListDevicesByUserRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "page_size"),
    2: .standard(proto: "page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 1)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Devicetrust_V1_ListDevicesByUserRequest, rhs: Teleport_Devicetrust_V1_ListDevicesByUserRequest) -> Bool {
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Devicetrust_V1_ListDevicesByUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListDevicesByUserResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "devices"),
    2: .standard(proto: "next_page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.devices) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.devices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.devices, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Devicetrust_V1_ListDevicesByUserResponse, rhs: Teleport_Devicetrust_V1_ListDevicesByUserResponse) -> Bool {
    if lhs.devices != rhs.devices {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Devicetrust_V1_BulkCreateDevicesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BulkCreateDevicesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "devices"),
    2: .standard(proto: "create_as_resource"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.devices) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.createAsResource) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.devices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.devices, fieldNumber: 1)
    }
    if self.createAsResource != false {
      try visitor.visitSingularBoolField(value: self.createAsResource, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Devicetrust_V1_BulkCreateDevicesRequest, rhs: Teleport_Devicetrust_V1_BulkCreateDevicesRequest) -> Bool {
    if lhs.devices != rhs.devices {return false}
    if lhs.createAsResource != rhs.createAsResource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Devicetrust_V1_BulkCreateDevicesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BulkCreateDevicesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "devices"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.devices) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.devices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.devices, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Devicetrust_V1_BulkCreateDevicesResponse, rhs: Teleport_Devicetrust_V1_BulkCreateDevicesResponse) -> Bool {
    if lhs.devices != rhs.devices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Devicetrust_V1_DeviceOrStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeviceOrStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "id"),
    3: .same(proto: "deleted"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.deleted) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    if self.deleted != false {
      try visitor.visitSingularBoolField(value: self.deleted, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Devicetrust_V1_DeviceOrStatus, rhs: Teleport_Devicetrust_V1_DeviceOrStatus) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.deleted != rhs.deleted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Devicetrust_V1_CreateDeviceEnrollTokenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateDeviceEnrollTokenRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_id"),
    2: .standard(proto: "device_data"),
    3: .standard(proto: "expire_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._deviceData) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._expireTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    try { if let v = self._deviceData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._expireTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Devicetrust_V1_CreateDeviceEnrollTokenRequest, rhs: Teleport_Devicetrust_V1_CreateDeviceEnrollTokenRequest) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs._deviceData != rhs._deviceData {return false}
    if lhs._expireTime != rhs._expireTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Devicetrust_V1_EnrollDeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EnrollDeviceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "init"),
    2: .standard(proto: "macos_challenge_response"),
    3: .standard(proto: "tpm_challenge_response"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Teleport_Devicetrust_V1_EnrollDeviceInit?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .init_p(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .init_p(v)
        }
      }()
      case 2: try {
        var v: Teleport_Devicetrust_V1_MacOSEnrollChallengeResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .macosChallengeResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .macosChallengeResponse(v)
        }
      }()
      case 3: try {
        var v: Teleport_Devicetrust_V1_TPMEnrollChallengeResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .tpmChallengeResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .tpmChallengeResponse(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .init_p?: try {
      guard case .init_p(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .macosChallengeResponse?: try {
      guard case .macosChallengeResponse(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .tpmChallengeResponse?: try {
      guard case .tpmChallengeResponse(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Devicetrust_V1_EnrollDeviceRequest, rhs: Teleport_Devicetrust_V1_EnrollDeviceRequest) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Devicetrust_V1_EnrollDeviceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EnrollDeviceResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .standard(proto: "macos_challenge"),
    3: .standard(proto: "tpm_challenge"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Teleport_Devicetrust_V1_EnrollDeviceSuccess?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .success(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .success(v)
        }
      }()
      case 2: try {
        var v: Teleport_Devicetrust_V1_MacOSEnrollChallenge?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .macosChallenge(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .macosChallenge(v)
        }
      }()
      case 3: try {
        var v: Teleport_Devicetrust_V1_TPMEnrollChallenge?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .tpmChallenge(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .tpmChallenge(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .success?: try {
      guard case .success(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .macosChallenge?: try {
      guard case .macosChallenge(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .tpmChallenge?: try {
      guard case .tpmChallenge(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Devicetrust_V1_EnrollDeviceResponse, rhs: Teleport_Devicetrust_V1_EnrollDeviceResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Devicetrust_V1_EnrollDeviceInit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EnrollDeviceInit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .standard(proto: "credential_id"),
    3: .standard(proto: "device_data"),
    4: .same(proto: "macos"),
    5: .same(proto: "tpm"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.credentialID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._deviceData) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._macos) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._tpm) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    if !self.credentialID.isEmpty {
      try visitor.visitSingularStringField(value: self.credentialID, fieldNumber: 2)
    }
    try { if let v = self._deviceData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._macos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._tpm {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Devicetrust_V1_EnrollDeviceInit, rhs: Teleport_Devicetrust_V1_EnrollDeviceInit) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.credentialID != rhs.credentialID {return false}
    if lhs._deviceData != rhs._deviceData {return false}
    if lhs._macos != rhs._macos {return false}
    if lhs._tpm != rhs._tpm {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Devicetrust_V1_EnrollDeviceSuccess: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EnrollDeviceSuccess"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "device"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._device) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._device {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Devicetrust_V1_EnrollDeviceSuccess, rhs: Teleport_Devicetrust_V1_EnrollDeviceSuccess) -> Bool {
    if lhs._device != rhs._device {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Devicetrust_V1_MacOSEnrollPayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MacOSEnrollPayload"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "public_key_der"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularBytesField(value: &self.publicKeyDer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKeyDer.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKeyDer, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Devicetrust_V1_MacOSEnrollPayload, rhs: Teleport_Devicetrust_V1_MacOSEnrollPayload) -> Bool {
    if lhs.publicKeyDer != rhs.publicKeyDer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Devicetrust_V1_MacOSEnrollChallenge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MacOSEnrollChallenge"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "challenge"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.challenge) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.challenge.isEmpty {
      try visitor.visitSingularBytesField(value: self.challenge, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Devicetrust_V1_MacOSEnrollChallenge, rhs: Teleport_Devicetrust_V1_MacOSEnrollChallenge) -> Bool {
    if lhs.challenge != rhs.challenge {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Devicetrust_V1_MacOSEnrollChallengeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MacOSEnrollChallengeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularBytesField(value: &self.signature) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Devicetrust_V1_MacOSEnrollChallengeResponse, rhs: Teleport_Devicetrust_V1_MacOSEnrollChallengeResponse) -> Bool {
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Devicetrust_V1_TPMEnrollPayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TPMEnrollPayload"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ek_cert"),
    2: .standard(proto: "ek_key"),
    3: .standard(proto: "attestation_parameters"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.ek != nil {try decoder.handleConflictingOneOf()}
          self.ek = .ekCert(v)
        }
      }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.ek != nil {try decoder.handleConflictingOneOf()}
          self.ek = .ekKey(v)
        }
      }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._attestationParameters) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.ek {
    case .ekCert?: try {
      guard case .ekCert(let v)? = self.ek else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }()
    case .ekKey?: try {
      guard case .ekKey(let v)? = self.ek else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try { if let v = self._attestationParameters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Devicetrust_V1_TPMEnrollPayload, rhs: Teleport_Devicetrust_V1_TPMEnrollPayload) -> Bool {
    if lhs.ek != rhs.ek {return false}
    if lhs._attestationParameters != rhs._attestationParameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Devicetrust_V1_TPMAttestationParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TPMAttestationParameters"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "public"),
    2: .standard(proto: "create_data"),
    3: .standard(proto: "create_attestation"),
    4: .standard(proto: "create_signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.`public`) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.createData) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.createAttestation) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.createSignature) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.`public`.isEmpty {
      try visitor.visitSingularBytesField(value: self.`public`, fieldNumber: 1)
    }
    if !self.createData.isEmpty {
      try visitor.visitSingularBytesField(value: self.createData, fieldNumber: 2)
    }
    if !self.createAttestation.isEmpty {
      try visitor.visitSingularBytesField(value: self.createAttestation, fieldNumber: 3)
    }
    if !self.createSignature.isEmpty {
      try visitor.visitSingularBytesField(value: self.createSignature, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Devicetrust_V1_TPMAttestationParameters, rhs: Teleport_Devicetrust_V1_TPMAttestationParameters) -> Bool {
    if lhs.`public` != rhs.`public` {return false}
    if lhs.createData != rhs.createData {return false}
    if lhs.createAttestation != rhs.createAttestation {return false}
    if lhs.createSignature != rhs.createSignature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Devicetrust_V1_TPMEnrollChallenge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TPMEnrollChallenge"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "encrypted_credential"),
    2: .standard(proto: "attestation_nonce"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._encryptedCredential) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.attestationNonce) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._encryptedCredential {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.attestationNonce.isEmpty {
      try visitor.visitSingularBytesField(value: self.attestationNonce, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Devicetrust_V1_TPMEnrollChallenge, rhs: Teleport_Devicetrust_V1_TPMEnrollChallenge) -> Bool {
    if lhs._encryptedCredential != rhs._encryptedCredential {return false}
    if lhs.attestationNonce != rhs.attestationNonce {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Devicetrust_V1_TPMEncryptedCredential: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TPMEncryptedCredential"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "credential_blob"),
    2: .same(proto: "secret"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.credentialBlob) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.secret) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.credentialBlob.isEmpty {
      try visitor.visitSingularBytesField(value: self.credentialBlob, fieldNumber: 1)
    }
    if !self.secret.isEmpty {
      try visitor.visitSingularBytesField(value: self.secret, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Devicetrust_V1_TPMEncryptedCredential, rhs: Teleport_Devicetrust_V1_TPMEncryptedCredential) -> Bool {
    if lhs.credentialBlob != rhs.credentialBlob {return false}
    if lhs.secret != rhs.secret {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Devicetrust_V1_TPMEnrollChallengeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TPMEnrollChallengeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "solution"),
    2: .standard(proto: "platform_parameters"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.solution) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._platformParameters) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.solution.isEmpty {
      try visitor.visitSingularBytesField(value: self.solution, fieldNumber: 1)
    }
    try { if let v = self._platformParameters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Devicetrust_V1_TPMEnrollChallengeResponse, rhs: Teleport_Devicetrust_V1_TPMEnrollChallengeResponse) -> Bool {
    if lhs.solution != rhs.solution {return false}
    if lhs._platformParameters != rhs._platformParameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Devicetrust_V1_AuthenticateDeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthenticateDeviceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "init"),
    2: .standard(proto: "challenge_response"),
    3: .standard(proto: "tpm_challenge_response"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Teleport_Devicetrust_V1_AuthenticateDeviceInit?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .init_p(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .init_p(v)
        }
      }()
      case 2: try {
        var v: Teleport_Devicetrust_V1_AuthenticateDeviceChallengeResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .challengeResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .challengeResponse(v)
        }
      }()
      case 3: try {
        var v: Teleport_Devicetrust_V1_TPMAuthenticateDeviceChallengeResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .tpmChallengeResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .tpmChallengeResponse(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .init_p?: try {
      guard case .init_p(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .challengeResponse?: try {
      guard case .challengeResponse(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .tpmChallengeResponse?: try {
      guard case .tpmChallengeResponse(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Devicetrust_V1_AuthenticateDeviceRequest, rhs: Teleport_Devicetrust_V1_AuthenticateDeviceRequest) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Devicetrust_V1_AuthenticateDeviceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthenticateDeviceResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "challenge"),
    2: .standard(proto: "user_certificates"),
    3: .standard(proto: "tpm_challenge"),
    4: .standard(proto: "confirmation_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Teleport_Devicetrust_V1_AuthenticateDeviceChallenge?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .challenge(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .challenge(v)
        }
      }()
      case 2: try {
        var v: Teleport_Devicetrust_V1_UserCertificates?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .userCertificates(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .userCertificates(v)
        }
      }()
      case 3: try {
        var v: Teleport_Devicetrust_V1_TPMAuthenticateDeviceChallenge?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .tpmChallenge(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .tpmChallenge(v)
        }
      }()
      case 4: try {
        var v: Teleport_Devicetrust_V1_DeviceConfirmationToken?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .confirmationToken(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .confirmationToken(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .challenge?: try {
      guard case .challenge(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .userCertificates?: try {
      guard case .userCertificates(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .tpmChallenge?: try {
      guard case .tpmChallenge(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .confirmationToken?: try {
      guard case .confirmationToken(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Devicetrust_V1_AuthenticateDeviceResponse, rhs: Teleport_Devicetrust_V1_AuthenticateDeviceResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Devicetrust_V1_AuthenticateDeviceInit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthenticateDeviceInit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_certificates"),
    2: .standard(proto: "credential_id"),
    3: .standard(proto: "device_data"),
    4: .standard(proto: "device_web_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userCertificates) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.credentialID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._deviceData) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._deviceWebToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userCertificates {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.credentialID.isEmpty {
      try visitor.visitSingularStringField(value: self.credentialID, fieldNumber: 2)
    }
    try { if let v = self._deviceData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._deviceWebToken {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Devicetrust_V1_AuthenticateDeviceInit, rhs: Teleport_Devicetrust_V1_AuthenticateDeviceInit) -> Bool {
    if lhs._userCertificates != rhs._userCertificates {return false}
    if lhs.credentialID != rhs.credentialID {return false}
    if lhs._deviceData != rhs._deviceData {return false}
    if lhs._deviceWebToken != rhs._deviceWebToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Devicetrust_V1_ConfirmDeviceWebAuthenticationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConfirmDeviceWebAuthenticationRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "confirmation_token"),
    2: .standard(proto: "current_web_session_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._confirmationToken) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.currentWebSessionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._confirmationToken {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.currentWebSessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.currentWebSessionID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Devicetrust_V1_ConfirmDeviceWebAuthenticationRequest, rhs: Teleport_Devicetrust_V1_ConfirmDeviceWebAuthenticationRequest) -> Bool {
    if lhs._confirmationToken != rhs._confirmationToken {return false}
    if lhs.currentWebSessionID != rhs.currentWebSessionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Devicetrust_V1_ConfirmDeviceWebAuthenticationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConfirmDeviceWebAuthenticationResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Devicetrust_V1_ConfirmDeviceWebAuthenticationResponse, rhs: Teleport_Devicetrust_V1_ConfirmDeviceWebAuthenticationResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Devicetrust_V1_SyncInventoryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncInventoryRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "end"),
    3: .standard(proto: "devices_to_upsert"),
    4: .standard(proto: "devices_to_remove"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Teleport_Devicetrust_V1_SyncInventoryStart?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .start(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .start(v)
        }
      }()
      case 2: try {
        var v: Teleport_Devicetrust_V1_SyncInventoryEnd?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .end(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .end(v)
        }
      }()
      case 3: try {
        var v: Teleport_Devicetrust_V1_SyncInventoryDevices?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .devicesToUpsert(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .devicesToUpsert(v)
        }
      }()
      case 4: try {
        var v: Teleport_Devicetrust_V1_SyncInventoryDevices?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .devicesToRemove(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .devicesToRemove(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .start?: try {
      guard case .start(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .end?: try {
      guard case .end(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .devicesToUpsert?: try {
      guard case .devicesToUpsert(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .devicesToRemove?: try {
      guard case .devicesToRemove(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Devicetrust_V1_SyncInventoryRequest, rhs: Teleport_Devicetrust_V1_SyncInventoryRequest) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Devicetrust_V1_SyncInventoryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncInventoryResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ack"),
    2: .same(proto: "result"),
    3: .standard(proto: "missing_devices"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Teleport_Devicetrust_V1_SyncInventoryAck?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .ack(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .ack(v)
        }
      }()
      case 2: try {
        var v: Teleport_Devicetrust_V1_SyncInventoryResult?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .result(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .result(v)
        }
      }()
      case 3: try {
        var v: Teleport_Devicetrust_V1_SyncInventoryMissingDevices?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .missingDevices(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .missingDevices(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .ack?: try {
      guard case .ack(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .result?: try {
      guard case .result(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .missingDevices?: try {
      guard case .missingDevices(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Devicetrust_V1_SyncInventoryResponse, rhs: Teleport_Devicetrust_V1_SyncInventoryResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Devicetrust_V1_SyncInventoryStart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncInventoryStart"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
    4: .standard(proto: "track_missing_devices"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.trackMissingDevices) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.trackMissingDevices != false {
      try visitor.visitSingularBoolField(value: self.trackMissingDevices, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Devicetrust_V1_SyncInventoryStart, rhs: Teleport_Devicetrust_V1_SyncInventoryStart) -> Bool {
    if lhs._source != rhs._source {return false}
    if lhs.trackMissingDevices != rhs.trackMissingDevices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Devicetrust_V1_SyncInventoryEnd: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncInventoryEnd"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Devicetrust_V1_SyncInventoryEnd, rhs: Teleport_Devicetrust_V1_SyncInventoryEnd) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Devicetrust_V1_SyncInventoryDevices: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncInventoryDevices"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "devices"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.devices) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.devices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.devices, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Devicetrust_V1_SyncInventoryDevices, rhs: Teleport_Devicetrust_V1_SyncInventoryDevices) -> Bool {
    if lhs.devices != rhs.devices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Devicetrust_V1_SyncInventoryAck: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncInventoryAck"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Devicetrust_V1_SyncInventoryAck, rhs: Teleport_Devicetrust_V1_SyncInventoryAck) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Devicetrust_V1_SyncInventoryResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncInventoryResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "devices"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.devices) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.devices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.devices, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Devicetrust_V1_SyncInventoryResult, rhs: Teleport_Devicetrust_V1_SyncInventoryResult) -> Bool {
    if lhs.devices != rhs.devices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Devicetrust_V1_SyncInventoryMissingDevices: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncInventoryMissingDevices"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "devices"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.devices) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.devices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.devices, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Devicetrust_V1_SyncInventoryMissingDevices, rhs: Teleport_Devicetrust_V1_SyncInventoryMissingDevices) -> Bool {
    if lhs.devices != rhs.devices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Devicetrust_V1_GetDevicesUsageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetDevicesUsageRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Devicetrust_V1_GetDevicesUsageRequest, rhs: Teleport_Devicetrust_V1_GetDevicesUsageRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
