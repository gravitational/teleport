// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: teleport/devicetrust/v1/device.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2022 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// AttestationType indicates the degree to which the device credential has
/// been attested.
enum Teleport_Devicetrust_V1_DeviceAttestationType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int

  /// Bare public key which has only verified with proof of ownership.
  /// Used on macOS.
  case unspecified // = 0

  /// Credential was verified through a TPM EK->AK chain on enrollment.
  case tpmEkpub // = 1

  /// Credential was verified through a TPM EKCert->AK chain on enrollment,
  /// but no allow-listed CAs were configured to validate this EKCert against.
  case tpmEkcert // = 2

  /// Credential was verified through a TPM EKCert->AK chain on enrollment, and
  /// the EKCert was signed by a configured allow-listed CA.
  case tpmEkcertTrusted // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .tpmEkpub
    case 2: self = .tpmEkcert
    case 3: self = .tpmEkcertTrusted
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .tpmEkpub: return 1
    case .tpmEkcert: return 2
    case .tpmEkcertTrusted: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Teleport_Devicetrust_V1_DeviceAttestationType] = [
    .unspecified,
    .tpmEkpub,
    .tpmEkcert,
    .tpmEkcertTrusted,
  ]

}

/// DeviceEnrollStatus represents the enrollment status of a device.
enum Teleport_Devicetrust_V1_DeviceEnrollStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unspecified // = 0

  /// Device is registered but not enrolled.
  case notEnrolled // = 1

  /// Device is registered and enrolled.
  case enrolled // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .notEnrolled
    case 2: self = .enrolled
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .notEnrolled: return 1
    case .enrolled: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Teleport_Devicetrust_V1_DeviceEnrollStatus] = [
    .unspecified,
    .notEnrolled,
    .enrolled,
  ]

}

/// Device represents a registered device.
/// Registered devices may be enrolled. Enrolled devices are allowed to perform
/// device-aware actions.
struct Teleport_Devicetrust_V1_Device: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// API version of the Device definition, present for compatibility with
  /// types.DeviceV1.
  /// Always "v1".
  var apiVersion: String {
    get {return _storage._apiVersion}
    set {_uniqueStorage()._apiVersion = newValue}
  }

  /// Unique device identifier.
  /// System managed.
  var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// Device operating system.
  /// Required.
  var osType: Teleport_Devicetrust_V1_OSType {
    get {return _storage._osType}
    set {_uniqueStorage()._osType = newValue}
  }

  /// Device inventory identifier.
  /// Takes different meanings depending on the device and operating system.
  /// For macOS devices it is the device serial number.
  /// Required.
  var assetTag: String {
    get {return _storage._assetTag}
    set {_uniqueStorage()._assetTag = newValue}
  }

  /// Create time.
  /// System managed.
  var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  var hasCreateTime: Bool {return _storage._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  mutating func clearCreateTime() {_uniqueStorage()._createTime = nil}

  /// Last update time.
  /// System managed.
  var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  var hasUpdateTime: Bool {return _storage._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  mutating func clearUpdateTime() {_uniqueStorage()._updateTime = nil}

  /// Enrollment token for the device.
  /// Only present in situations where device creation and enrollment are rolled
  /// into a single operation.
  /// Transient.
  var enrollToken: Teleport_Devicetrust_V1_DeviceEnrollToken {
    get {return _storage._enrollToken ?? Teleport_Devicetrust_V1_DeviceEnrollToken()}
    set {_uniqueStorage()._enrollToken = newValue}
  }
  /// Returns true if `enrollToken` has been explicitly set.
  var hasEnrollToken: Bool {return _storage._enrollToken != nil}
  /// Clears the value of `enrollToken`. Subsequent reads from it will return its default value.
  mutating func clearEnrollToken() {_uniqueStorage()._enrollToken = nil}

  /// Enrollment status of the device.
  /// May be changed to DEVICE_ENROLL_STATUS_NOT_ENROLLED at any time to
  /// forcefully unenroll a device (server-side only).
  /// System managed.
  var enrollStatus: Teleport_Devicetrust_V1_DeviceEnrollStatus {
    get {return _storage._enrollStatus}
    set {_uniqueStorage()._enrollStatus = newValue}
  }

  /// Currently enrolled device credential.
  /// Manually unenrolling a device clears the credential.
  /// System managed.
  var credential: Teleport_Devicetrust_V1_DeviceCredential {
    get {return _storage._credential ?? Teleport_Devicetrust_V1_DeviceCredential()}
    set {_uniqueStorage()._credential = newValue}
  }
  /// Returns true if `credential` has been explicitly set.
  var hasCredential: Bool {return _storage._credential != nil}
  /// Clears the value of `credential`. Subsequent reads from it will return its default value.
  mutating func clearCredential() {_uniqueStorage()._credential = nil}

  /// Device data collected during enrollment and device authentication.
  /// Enrollment data is always present, while authentication data is capped at N
  /// most recent events.
  /// Only present in certain read modes.
  /// Transient.
  var collectedData: [Teleport_Devicetrust_V1_DeviceCollectedData] {
    get {return _storage._collectedData}
    set {_uniqueStorage()._collectedData = newValue}
  }

  /// Source of the device.
  /// Devices managed directly via Teleport (`tctl`, Web UI, etc) have no
  /// assigned source.
  var source: Teleport_Devicetrust_V1_DeviceSource {
    get {return _storage._source ?? Teleport_Devicetrust_V1_DeviceSource()}
    set {_uniqueStorage()._source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  var hasSource: Bool {return _storage._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  mutating func clearSource() {_uniqueStorage()._source = nil}

  /// Device information acquired from an external source.
  var profile: Teleport_Devicetrust_V1_DeviceProfile {
    get {return _storage._profile ?? Teleport_Devicetrust_V1_DeviceProfile()}
    set {_uniqueStorage()._profile = newValue}
  }
  /// Returns true if `profile` has been explicitly set.
  var hasProfile: Bool {return _storage._profile != nil}
  /// Clears the value of `profile`. Subsequent reads from it will return its default value.
  mutating func clearProfile() {_uniqueStorage()._profile = nil}

  /// Device owner.
  /// Usually the owner is the same user who performed the enrollment ceremony.
  /// May be empty for legacy devices (Teleport v13.2 and older).
  /// Manually unenrolling a device clears the owner.
  /// System-managed.
  var owner: String {
    get {return _storage._owner}
    set {_uniqueStorage()._owner = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DeviceCredential represents the current enrolled public key of a device.
struct Teleport_Devicetrust_V1_DeviceCredential: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique identifier of the credential, defined client-side.
  var id: String = String()

  /// Device public key marshaled as a PKIX, ASN.1 DER. Used only on MacOS.
  var publicKeyDer: Data = Data()

  /// The degree to which the device credential is attested.
  var deviceAttestationType: Teleport_Devicetrust_V1_DeviceAttestationType = .unspecified

  /// For TPM devices, the serial number of the TPM endorsement certificate.
  var tpmEkcertSerial: String = String()

  /// For TPM devices, the encoded TPMT_PUBLIC structure containing the
  /// attestation public key and signing parameters.
  var tpmAkPublic: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "teleport.devicetrust.v1"

extension Teleport_Devicetrust_V1_DeviceAttestationType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEVICE_ATTESTATION_TYPE_UNSPECIFIED"),
    1: .same(proto: "DEVICE_ATTESTATION_TYPE_TPM_EKPUB"),
    2: .same(proto: "DEVICE_ATTESTATION_TYPE_TPM_EKCERT"),
    3: .same(proto: "DEVICE_ATTESTATION_TYPE_TPM_EKCERT_TRUSTED"),
  ]
}

extension Teleport_Devicetrust_V1_DeviceEnrollStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEVICE_ENROLL_STATUS_UNSPECIFIED"),
    1: .same(proto: "DEVICE_ENROLL_STATUS_NOT_ENROLLED"),
    2: .same(proto: "DEVICE_ENROLL_STATUS_ENROLLED"),
  ]
}

extension Teleport_Devicetrust_V1_Device: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Device"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "api_version"),
    2: .same(proto: "id"),
    3: .standard(proto: "os_type"),
    4: .standard(proto: "asset_tag"),
    5: .standard(proto: "create_time"),
    6: .standard(proto: "update_time"),
    7: .standard(proto: "enroll_token"),
    8: .standard(proto: "enroll_status"),
    9: .same(proto: "credential"),
    10: .standard(proto: "collected_data"),
    11: .same(proto: "source"),
    12: .same(proto: "profile"),
    13: .same(proto: "owner"),
  ]

  fileprivate class _StorageClass {
    var _apiVersion: String = String()
    var _id: String = String()
    var _osType: Teleport_Devicetrust_V1_OSType = .unspecified
    var _assetTag: String = String()
    var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _enrollToken: Teleport_Devicetrust_V1_DeviceEnrollToken? = nil
    var _enrollStatus: Teleport_Devicetrust_V1_DeviceEnrollStatus = .unspecified
    var _credential: Teleport_Devicetrust_V1_DeviceCredential? = nil
    var _collectedData: [Teleport_Devicetrust_V1_DeviceCollectedData] = []
    var _source: Teleport_Devicetrust_V1_DeviceSource? = nil
    var _profile: Teleport_Devicetrust_V1_DeviceProfile? = nil
    var _owner: String = String()

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _apiVersion = source._apiVersion
      _id = source._id
      _osType = source._osType
      _assetTag = source._assetTag
      _createTime = source._createTime
      _updateTime = source._updateTime
      _enrollToken = source._enrollToken
      _enrollStatus = source._enrollStatus
      _credential = source._credential
      _collectedData = source._collectedData
      _source = source._source
      _profile = source._profile
      _owner = source._owner
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._apiVersion) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._osType) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._assetTag) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._createTime) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._updateTime) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._enrollToken) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._enrollStatus) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._credential) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._collectedData) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._source) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._profile) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._owner) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._apiVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._apiVersion, fieldNumber: 1)
      }
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 2)
      }
      if _storage._osType != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._osType, fieldNumber: 3)
      }
      if !_storage._assetTag.isEmpty {
        try visitor.visitSingularStringField(value: _storage._assetTag, fieldNumber: 4)
      }
      try { if let v = _storage._createTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._updateTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._enrollToken {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if _storage._enrollStatus != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._enrollStatus, fieldNumber: 8)
      }
      try { if let v = _storage._credential {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if !_storage._collectedData.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._collectedData, fieldNumber: 10)
      }
      try { if let v = _storage._source {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._profile {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if !_storage._owner.isEmpty {
        try visitor.visitSingularStringField(value: _storage._owner, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Devicetrust_V1_Device, rhs: Teleport_Devicetrust_V1_Device) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._apiVersion != rhs_storage._apiVersion {return false}
        if _storage._id != rhs_storage._id {return false}
        if _storage._osType != rhs_storage._osType {return false}
        if _storage._assetTag != rhs_storage._assetTag {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._updateTime != rhs_storage._updateTime {return false}
        if _storage._enrollToken != rhs_storage._enrollToken {return false}
        if _storage._enrollStatus != rhs_storage._enrollStatus {return false}
        if _storage._credential != rhs_storage._credential {return false}
        if _storage._collectedData != rhs_storage._collectedData {return false}
        if _storage._source != rhs_storage._source {return false}
        if _storage._profile != rhs_storage._profile {return false}
        if _storage._owner != rhs_storage._owner {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Devicetrust_V1_DeviceCredential: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeviceCredential"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "public_key_der"),
    3: .standard(proto: "device_attestation_type"),
    4: .standard(proto: "tpm_ekcert_serial"),
    5: .standard(proto: "tpm_ak_public"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.publicKeyDer) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.deviceAttestationType) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.tpmEkcertSerial) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.tpmAkPublic) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.publicKeyDer.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKeyDer, fieldNumber: 2)
    }
    if self.deviceAttestationType != .unspecified {
      try visitor.visitSingularEnumField(value: self.deviceAttestationType, fieldNumber: 3)
    }
    if !self.tpmEkcertSerial.isEmpty {
      try visitor.visitSingularStringField(value: self.tpmEkcertSerial, fieldNumber: 4)
    }
    if !self.tpmAkPublic.isEmpty {
      try visitor.visitSingularBytesField(value: self.tpmAkPublic, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Devicetrust_V1_DeviceCredential, rhs: Teleport_Devicetrust_V1_DeviceCredential) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.publicKeyDer != rhs.publicKeyDer {return false}
    if lhs.deviceAttestationType != rhs.deviceAttestationType {return false}
    if lhs.tpmEkcertSerial != rhs.tpmEkcertSerial {return false}
    if lhs.tpmAkPublic != rhs.tpmAkPublic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
