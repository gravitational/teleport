/* eslint-disable */
// @generated by protobuf-ts 2.9.3 with parameter eslint_disable,add_pb_suffix,server_grpc1,ts_nocheck
// @generated from protobuf file "prehog/v1/teleport.proto" (package "prehog.v1", syntax proto3)
// tslint:disable
// @ts-nocheck
//
//
// Teleport
// Copyright (C) 2023  Gravitational, Inc.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "../../google/protobuf/timestamp_pb";
/**
 * counters for user activity coming from a specific auth server from a specific
 * cluster, for a time window of up to 15 minutes
 *
 * PostHog event: tp.user.activity
 *
 * @generated from protobuf message prehog.v1.UserActivityReport
 */
export interface UserActivityReport {
    /**
     * randomly generated UUID for this specific report, 16 bytes (in string order)
     *
     * PostHog property: tp.report_uuid (in 8-4-4-4-12 string form)
     *
     * @generated from protobuf field: bytes report_uuid = 1;
     */
    reportUuid: Uint8Array;
    /**
     * cluster name, anonymized, 32 bytes (HMAC-SHA-256)
     *
     * PostHog property: tp.cluster_name (in base64)
     *
     * @generated from protobuf field: bytes cluster_name = 2;
     */
    clusterName: Uint8Array;
    /**
     * hostid of the auth that collected this report, anonymized, 32 bytes (HMAC-SHA-256)
     *
     * PostHog property: tp.reporter_hostid (in base64)
     *
     * @generated from protobuf field: bytes reporter_hostid = 3;
     */
    reporterHostid: Uint8Array;
    /**
     * beginning of the time window for this data; ending is not specified but is
     * intended to be at most 15 minutes
     *
     * PostHog timestamp (not a property, the ingest time is tp.report_time instead)
     *
     * @generated from protobuf field: google.protobuf.Timestamp start_time = 4;
     */
    startTime?: Timestamp;
    /**
     * one set of counters for each user
     *
     * PostHog property: tp.records (encoded as a map keyed by username, not as a list)
     *
     * @generated from protobuf field: repeated prehog.v1.UserActivityRecord records = 5;
     */
    records: UserActivityRecord[];
}
/**
 * a set of activity counters for a single user; some old versions report
 * "ssh_port_sessions", counting both SSH port forwards and kubectl port-forward
 * connections in a single counter
 *
 * fields other than user_name are encoded as the same field name in PostHog
 *
 * @generated from protobuf message prehog.v1.UserActivityRecord
 */
export interface UserActivityRecord {
    /**
     * anonymized, 32 bytes (HMAC-SHA-256)
     *
     * key of the tp.records map in tp.user.activity (in base64)
     *
     * @generated from protobuf field: bytes user_name = 1;
     */
    userName: Uint8Array;
    /**
     * Indicates the type of user, e.g. bot or human, if known.
     *
     * @generated from protobuf field: prehog.v1.UserKind user_kind = 14;
     */
    userKind: UserKind;
    /**
     * counter of user.login events
     *
     * @generated from protobuf field: uint64 logins = 2;
     */
    logins: bigint;
    /**
     * counter of session.start events (non-Kube)
     *
     * @generated from protobuf field: uint64 ssh_sessions = 3;
     */
    sshSessions: bigint;
    /**
     * counter of app.session.start events (non-TCP)
     *
     * @generated from protobuf field: uint64 app_sessions = 4;
     */
    appSessions: bigint;
    /**
     * counter of session.start events (only Kube)
     *
     * @generated from protobuf field: uint64 kube_sessions = 5;
     */
    kubeSessions: bigint;
    /**
     * counter of db.session.start events
     *
     * @generated from protobuf field: uint64 db_sessions = 6;
     */
    dbSessions: bigint;
    /**
     * counter of windows.desktop.session.start events
     *
     * @generated from protobuf field: uint64 desktop_sessions = 7;
     */
    desktopSessions: bigint;
    /**
     * counter of app.session.start events (only TCP)
     *
     * @generated from protobuf field: uint64 app_tcp_sessions = 8;
     */
    appTcpSessions: bigint;
    /**
     * counter of port events (both SSH and Kube)
     *
     * @deprecated
     * @generated from protobuf field: uint64 ssh_port_sessions = 9 [deprecated = true];
     */
    sshPortSessions: bigint;
    /**
     * counter of kube.request events
     *
     * @generated from protobuf field: uint64 kube_requests = 10;
     */
    kubeRequests: bigint;
    /**
     * counter of sftp events
     *
     * @generated from protobuf field: uint64 sftp_events = 11;
     */
    sftpEvents: bigint;
    /**
     * counter of port events (only SSH)
     *
     * @generated from protobuf field: uint64 ssh_port_v2_sessions = 12;
     */
    sshPortV2Sessions: bigint;
    /**
     * counter of port events (only Kube)
     *
     * @generated from protobuf field: uint64 kube_port_sessions = 13;
     */
    kubePortSessions: bigint;
    /**
     * counter of SPIFFE SVIDs issued
     *
     * @generated from protobuf field: uint64 spiffe_svids_issued = 15;
     */
    spiffeSvidsIssued: bigint;
    /**
     * counter of bot joins
     *
     * @generated from protobuf field: uint64 bot_joins = 16;
     */
    botJoins: bigint;
    /**
     * counter of certificates issued for this user
     *
     * @generated from protobuf field: uint64 certificates_issued = 17;
     */
    certificatesIssued: bigint;
}
/**
 * @generated from protobuf message prehog.v1.ResourcePresenceReport
 */
export interface ResourcePresenceReport {
    /**
     * randomly generated UUID for this specific report, 16 bytes (in string order)
     *
     * @generated from protobuf field: bytes report_uuid = 1;
     */
    reportUuid: Uint8Array;
    /**
     * anonymized, 32 bytes (HMAC-SHA-256)
     *
     * @generated from protobuf field: bytes cluster_name = 2;
     */
    clusterName: Uint8Array;
    /**
     * anonymized, 32 bytes (HMAC-SHA-256)
     *
     * @generated from protobuf field: bytes reporter_hostid = 3;
     */
    reporterHostid: Uint8Array;
    /**
     * beginning of the time window for this data; ending is not specified but is
     * intended to be at most one hour
     *
     * @generated from protobuf field: google.protobuf.Timestamp start_time = 4;
     */
    startTime?: Timestamp;
    /**
     * @generated from protobuf field: repeated prehog.v1.ResourceKindPresenceReport resource_kind_reports = 5;
     */
    resourceKindReports: ResourceKindPresenceReport[];
}
/**
 * Counts all resources of one kind that were active during the time window
 * to track the number of active resources in a cluster over time.
 *
 * @generated from protobuf message prehog.v1.ResourceKindPresenceReport
 */
export interface ResourceKindPresenceReport {
    /**
     * the kind of resource
     *
     * @generated from protobuf field: prehog.v1.ResourceKind resource_kind = 1;
     */
    resourceKind: ResourceKind;
    /**
     * first 8 bytes of anonymized resource name
     *
     * @generated from protobuf field: repeated fixed64 resource_ids = 2;
     */
    resourceIds: bigint[];
}
/**
 * @generated from protobuf message prehog.v1.SubmitUsageReportsRequest
 */
export interface SubmitUsageReportsRequest {
    /**
     * at most 10 reports of all kinds in a single RPC, each shouldn't exceed 128KiB or so
     *
     * each report is encoded as a separate tp.user.activity PostHog event
     *
     * @generated from protobuf field: repeated prehog.v1.UserActivityReport user_activity = 1;
     */
    userActivity: UserActivityReport[];
    /**
     * encoded as a separate tp.resource.counts PostHog event
     *
     * @generated from protobuf field: repeated prehog.v1.ResourcePresenceReport resource_presence = 2;
     */
    resourcePresence: ResourcePresenceReport[];
}
/**
 * @generated from protobuf message prehog.v1.SubmitUsageReportsResponse
 */
export interface SubmitUsageReportsResponse {
    /**
     * randomly generated UUID for this specific batch, 16 bytes (in string order)
     *
     * PostHog property: tp.batch_uuid (in each report of the batch)
     *
     * @generated from protobuf field: bytes batch_uuid = 1;
     */
    batchUuid: Uint8Array;
}
/**
 * The kind of user a given username refers to. Usernames should always refer to
 * a valid cluster user (even if temporary, e.g. SSO), but may be Machine ID
 * bot users.
 *
 * @generated from protobuf enum prehog.v1.UserKind
 */
export enum UserKind {
    /**
     * Indicates a legacy cluster emitting events without a defined user kind.
     * Note that users (from PostHog's perspective) can be identified via future
     * events if the cluster is upgraded to specify this field.
     *
     * PostHog property value: ""
     *
     * @generated from protobuf enum value: USER_KIND_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Indicates the user associated with this event is human, either created
     * locally or via SSO.
     *
     * PostHog property value: "human"
     *
     * @generated from protobuf enum value: USER_KIND_HUMAN = 1;
     */
    HUMAN = 1,
    /**
     * Indicates the user associated with this event is a Machine ID bot user.
     *
     * PostHog property value: "bot"
     *
     * @generated from protobuf enum value: USER_KIND_BOT = 2;
     */
    BOT = 2
}
/**
 * the kind of a "resource" (e.g. a node, a database, a desktop, etc.)
 * Keep in sync with prehog/v1alpha/teleport.proto
 *
 * @generated from protobuf enum prehog.v1.ResourceKind
 */
export enum ResourceKind {
    /**
     * @generated from protobuf enum value: RESOURCE_KIND_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * PostHog property value: "node"
     *
     * @generated from protobuf enum value: RESOURCE_KIND_NODE = 1;
     */
    NODE = 1,
    /**
     * PostHog property value: "app_server"
     *
     * @generated from protobuf enum value: RESOURCE_KIND_APP_SERVER = 2;
     */
    APP_SERVER = 2,
    /**
     * PostHog property value: "kube_server"
     *
     * @generated from protobuf enum value: RESOURCE_KIND_KUBE_SERVER = 3;
     */
    KUBE_SERVER = 3,
    /**
     * PostHog property value: "db_server"
     *
     * @generated from protobuf enum value: RESOURCE_KIND_DB_SERVER = 4;
     */
    DB_SERVER = 4,
    /**
     * PostHog property value: "windows_desktop"
     *
     * @generated from protobuf enum value: RESOURCE_KIND_WINDOWS_DESKTOP = 5;
     */
    WINDOWS_DESKTOP = 5,
    /**
     * ServerV3 ("node") heartbeat with a subkind of "openssh" (as opposed to
     * empty or "teleport"); not used in keepalives
     *
     * PostHog property value: "node.openssh"
     *
     * @generated from protobuf enum value: RESOURCE_KIND_NODE_OPENSSH = 6;
     */
    NODE_OPENSSH = 6,
    /**
     * ServerV3 ("node") heartbeat with a subkind of "openssh-ec2-ice".
     * Nodes that map EC2 instances and are accessed using EC2 Instance Connect Endpoint.
     * Not used in keepalives.
     * This is the SubKind SubKindOpenSSHEICENode in teleport repo.
     *
     * PostHog property value: "node.openssh_ec2_ice"
     *
     * @generated from protobuf enum value: RESOURCE_KIND_NODE_OPENSSH_EICE = 7;
     */
    NODE_OPENSSH_EICE = 7
}
// @generated message type with reflection information, may provide speed optimized methods
class UserActivityReport$Type extends MessageType<UserActivityReport> {
    constructor() {
        super("prehog.v1.UserActivityReport", [
            { no: 1, name: "report_uuid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "cluster_name", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "reporter_hostid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "start_time", kind: "message", T: () => Timestamp },
            { no: 5, name: "records", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => UserActivityRecord }
        ]);
    }
    create(value?: PartialMessage<UserActivityReport>): UserActivityReport {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.reportUuid = new Uint8Array(0);
        message.clusterName = new Uint8Array(0);
        message.reporterHostid = new Uint8Array(0);
        message.records = [];
        if (value !== undefined)
            reflectionMergePartial<UserActivityReport>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserActivityReport): UserActivityReport {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes report_uuid */ 1:
                    message.reportUuid = reader.bytes();
                    break;
                case /* bytes cluster_name */ 2:
                    message.clusterName = reader.bytes();
                    break;
                case /* bytes reporter_hostid */ 3:
                    message.reporterHostid = reader.bytes();
                    break;
                case /* google.protobuf.Timestamp start_time */ 4:
                    message.startTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.startTime);
                    break;
                case /* repeated prehog.v1.UserActivityRecord records */ 5:
                    message.records.push(UserActivityRecord.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserActivityReport, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes report_uuid = 1; */
        if (message.reportUuid.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.reportUuid);
        /* bytes cluster_name = 2; */
        if (message.clusterName.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.clusterName);
        /* bytes reporter_hostid = 3; */
        if (message.reporterHostid.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.reporterHostid);
        /* google.protobuf.Timestamp start_time = 4; */
        if (message.startTime)
            Timestamp.internalBinaryWrite(message.startTime, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated prehog.v1.UserActivityRecord records = 5; */
        for (let i = 0; i < message.records.length; i++)
            UserActivityRecord.internalBinaryWrite(message.records[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message prehog.v1.UserActivityReport
 */
export const UserActivityReport = new UserActivityReport$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserActivityRecord$Type extends MessageType<UserActivityRecord> {
    constructor() {
        super("prehog.v1.UserActivityRecord", [
            { no: 1, name: "user_name", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 14, name: "user_kind", kind: "enum", T: () => ["prehog.v1.UserKind", UserKind, "USER_KIND_"] },
            { no: 2, name: "logins", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "ssh_sessions", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "app_sessions", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "kube_sessions", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "db_sessions", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "desktop_sessions", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "app_tcp_sessions", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "ssh_port_sessions", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "kube_requests", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "sftp_events", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "ssh_port_v2_sessions", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "kube_port_sessions", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 15, name: "spiffe_svids_issued", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 16, name: "bot_joins", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 17, name: "certificates_issued", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<UserActivityRecord>): UserActivityRecord {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userName = new Uint8Array(0);
        message.userKind = 0;
        message.logins = 0n;
        message.sshSessions = 0n;
        message.appSessions = 0n;
        message.kubeSessions = 0n;
        message.dbSessions = 0n;
        message.desktopSessions = 0n;
        message.appTcpSessions = 0n;
        message.sshPortSessions = 0n;
        message.kubeRequests = 0n;
        message.sftpEvents = 0n;
        message.sshPortV2Sessions = 0n;
        message.kubePortSessions = 0n;
        message.spiffeSvidsIssued = 0n;
        message.botJoins = 0n;
        message.certificatesIssued = 0n;
        if (value !== undefined)
            reflectionMergePartial<UserActivityRecord>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserActivityRecord): UserActivityRecord {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes user_name */ 1:
                    message.userName = reader.bytes();
                    break;
                case /* prehog.v1.UserKind user_kind */ 14:
                    message.userKind = reader.int32();
                    break;
                case /* uint64 logins */ 2:
                    message.logins = reader.uint64().toBigInt();
                    break;
                case /* uint64 ssh_sessions */ 3:
                    message.sshSessions = reader.uint64().toBigInt();
                    break;
                case /* uint64 app_sessions */ 4:
                    message.appSessions = reader.uint64().toBigInt();
                    break;
                case /* uint64 kube_sessions */ 5:
                    message.kubeSessions = reader.uint64().toBigInt();
                    break;
                case /* uint64 db_sessions */ 6:
                    message.dbSessions = reader.uint64().toBigInt();
                    break;
                case /* uint64 desktop_sessions */ 7:
                    message.desktopSessions = reader.uint64().toBigInt();
                    break;
                case /* uint64 app_tcp_sessions */ 8:
                    message.appTcpSessions = reader.uint64().toBigInt();
                    break;
                case /* uint64 ssh_port_sessions = 9 [deprecated = true];*/ 9:
                    message.sshPortSessions = reader.uint64().toBigInt();
                    break;
                case /* uint64 kube_requests */ 10:
                    message.kubeRequests = reader.uint64().toBigInt();
                    break;
                case /* uint64 sftp_events */ 11:
                    message.sftpEvents = reader.uint64().toBigInt();
                    break;
                case /* uint64 ssh_port_v2_sessions */ 12:
                    message.sshPortV2Sessions = reader.uint64().toBigInt();
                    break;
                case /* uint64 kube_port_sessions */ 13:
                    message.kubePortSessions = reader.uint64().toBigInt();
                    break;
                case /* uint64 spiffe_svids_issued */ 15:
                    message.spiffeSvidsIssued = reader.uint64().toBigInt();
                    break;
                case /* uint64 bot_joins */ 16:
                    message.botJoins = reader.uint64().toBigInt();
                    break;
                case /* uint64 certificates_issued */ 17:
                    message.certificatesIssued = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserActivityRecord, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes user_name = 1; */
        if (message.userName.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.userName);
        /* prehog.v1.UserKind user_kind = 14; */
        if (message.userKind !== 0)
            writer.tag(14, WireType.Varint).int32(message.userKind);
        /* uint64 logins = 2; */
        if (message.logins !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.logins);
        /* uint64 ssh_sessions = 3; */
        if (message.sshSessions !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.sshSessions);
        /* uint64 app_sessions = 4; */
        if (message.appSessions !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.appSessions);
        /* uint64 kube_sessions = 5; */
        if (message.kubeSessions !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.kubeSessions);
        /* uint64 db_sessions = 6; */
        if (message.dbSessions !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.dbSessions);
        /* uint64 desktop_sessions = 7; */
        if (message.desktopSessions !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.desktopSessions);
        /* uint64 app_tcp_sessions = 8; */
        if (message.appTcpSessions !== 0n)
            writer.tag(8, WireType.Varint).uint64(message.appTcpSessions);
        /* uint64 ssh_port_sessions = 9 [deprecated = true]; */
        if (message.sshPortSessions !== 0n)
            writer.tag(9, WireType.Varint).uint64(message.sshPortSessions);
        /* uint64 kube_requests = 10; */
        if (message.kubeRequests !== 0n)
            writer.tag(10, WireType.Varint).uint64(message.kubeRequests);
        /* uint64 sftp_events = 11; */
        if (message.sftpEvents !== 0n)
            writer.tag(11, WireType.Varint).uint64(message.sftpEvents);
        /* uint64 ssh_port_v2_sessions = 12; */
        if (message.sshPortV2Sessions !== 0n)
            writer.tag(12, WireType.Varint).uint64(message.sshPortV2Sessions);
        /* uint64 kube_port_sessions = 13; */
        if (message.kubePortSessions !== 0n)
            writer.tag(13, WireType.Varint).uint64(message.kubePortSessions);
        /* uint64 spiffe_svids_issued = 15; */
        if (message.spiffeSvidsIssued !== 0n)
            writer.tag(15, WireType.Varint).uint64(message.spiffeSvidsIssued);
        /* uint64 bot_joins = 16; */
        if (message.botJoins !== 0n)
            writer.tag(16, WireType.Varint).uint64(message.botJoins);
        /* uint64 certificates_issued = 17; */
        if (message.certificatesIssued !== 0n)
            writer.tag(17, WireType.Varint).uint64(message.certificatesIssued);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message prehog.v1.UserActivityRecord
 */
export const UserActivityRecord = new UserActivityRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResourcePresenceReport$Type extends MessageType<ResourcePresenceReport> {
    constructor() {
        super("prehog.v1.ResourcePresenceReport", [
            { no: 1, name: "report_uuid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "cluster_name", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "reporter_hostid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "start_time", kind: "message", T: () => Timestamp },
            { no: 5, name: "resource_kind_reports", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ResourceKindPresenceReport }
        ]);
    }
    create(value?: PartialMessage<ResourcePresenceReport>): ResourcePresenceReport {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.reportUuid = new Uint8Array(0);
        message.clusterName = new Uint8Array(0);
        message.reporterHostid = new Uint8Array(0);
        message.resourceKindReports = [];
        if (value !== undefined)
            reflectionMergePartial<ResourcePresenceReport>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResourcePresenceReport): ResourcePresenceReport {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes report_uuid */ 1:
                    message.reportUuid = reader.bytes();
                    break;
                case /* bytes cluster_name */ 2:
                    message.clusterName = reader.bytes();
                    break;
                case /* bytes reporter_hostid */ 3:
                    message.reporterHostid = reader.bytes();
                    break;
                case /* google.protobuf.Timestamp start_time */ 4:
                    message.startTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.startTime);
                    break;
                case /* repeated prehog.v1.ResourceKindPresenceReport resource_kind_reports */ 5:
                    message.resourceKindReports.push(ResourceKindPresenceReport.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResourcePresenceReport, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes report_uuid = 1; */
        if (message.reportUuid.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.reportUuid);
        /* bytes cluster_name = 2; */
        if (message.clusterName.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.clusterName);
        /* bytes reporter_hostid = 3; */
        if (message.reporterHostid.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.reporterHostid);
        /* google.protobuf.Timestamp start_time = 4; */
        if (message.startTime)
            Timestamp.internalBinaryWrite(message.startTime, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated prehog.v1.ResourceKindPresenceReport resource_kind_reports = 5; */
        for (let i = 0; i < message.resourceKindReports.length; i++)
            ResourceKindPresenceReport.internalBinaryWrite(message.resourceKindReports[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message prehog.v1.ResourcePresenceReport
 */
export const ResourcePresenceReport = new ResourcePresenceReport$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResourceKindPresenceReport$Type extends MessageType<ResourceKindPresenceReport> {
    constructor() {
        super("prehog.v1.ResourceKindPresenceReport", [
            { no: 1, name: "resource_kind", kind: "enum", T: () => ["prehog.v1.ResourceKind", ResourceKind, "RESOURCE_KIND_"] },
            { no: 2, name: "resource_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ResourceKindPresenceReport>): ResourceKindPresenceReport {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.resourceKind = 0;
        message.resourceIds = [];
        if (value !== undefined)
            reflectionMergePartial<ResourceKindPresenceReport>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResourceKindPresenceReport): ResourceKindPresenceReport {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* prehog.v1.ResourceKind resource_kind */ 1:
                    message.resourceKind = reader.int32();
                    break;
                case /* repeated fixed64 resource_ids */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.resourceIds.push(reader.fixed64().toBigInt());
                    else
                        message.resourceIds.push(reader.fixed64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResourceKindPresenceReport, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* prehog.v1.ResourceKind resource_kind = 1; */
        if (message.resourceKind !== 0)
            writer.tag(1, WireType.Varint).int32(message.resourceKind);
        /* repeated fixed64 resource_ids = 2; */
        if (message.resourceIds.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.resourceIds.length; i++)
                writer.fixed64(message.resourceIds[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message prehog.v1.ResourceKindPresenceReport
 */
export const ResourceKindPresenceReport = new ResourceKindPresenceReport$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubmitUsageReportsRequest$Type extends MessageType<SubmitUsageReportsRequest> {
    constructor() {
        super("prehog.v1.SubmitUsageReportsRequest", [
            { no: 1, name: "user_activity", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => UserActivityReport },
            { no: 2, name: "resource_presence", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ResourcePresenceReport }
        ]);
    }
    create(value?: PartialMessage<SubmitUsageReportsRequest>): SubmitUsageReportsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userActivity = [];
        message.resourcePresence = [];
        if (value !== undefined)
            reflectionMergePartial<SubmitUsageReportsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubmitUsageReportsRequest): SubmitUsageReportsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated prehog.v1.UserActivityReport user_activity */ 1:
                    message.userActivity.push(UserActivityReport.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated prehog.v1.ResourcePresenceReport resource_presence */ 2:
                    message.resourcePresence.push(ResourcePresenceReport.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubmitUsageReportsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated prehog.v1.UserActivityReport user_activity = 1; */
        for (let i = 0; i < message.userActivity.length; i++)
            UserActivityReport.internalBinaryWrite(message.userActivity[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated prehog.v1.ResourcePresenceReport resource_presence = 2; */
        for (let i = 0; i < message.resourcePresence.length; i++)
            ResourcePresenceReport.internalBinaryWrite(message.resourcePresence[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message prehog.v1.SubmitUsageReportsRequest
 */
export const SubmitUsageReportsRequest = new SubmitUsageReportsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubmitUsageReportsResponse$Type extends MessageType<SubmitUsageReportsResponse> {
    constructor() {
        super("prehog.v1.SubmitUsageReportsResponse", [
            { no: 1, name: "batch_uuid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SubmitUsageReportsResponse>): SubmitUsageReportsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.batchUuid = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<SubmitUsageReportsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubmitUsageReportsResponse): SubmitUsageReportsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes batch_uuid */ 1:
                    message.batchUuid = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubmitUsageReportsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes batch_uuid = 1; */
        if (message.batchUuid.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.batchUuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message prehog.v1.SubmitUsageReportsResponse
 */
export const SubmitUsageReportsResponse = new SubmitUsageReportsResponse$Type();
/**
 * @generated ServiceType for protobuf service prehog.v1.TeleportReportingService
 */
export const TeleportReportingService = new ServiceType("prehog.v1.TeleportReportingService", [
    { name: "SubmitUsageReports", options: {}, I: SubmitUsageReportsRequest, O: SubmitUsageReportsResponse }
]);
