/* eslint-disable */
// @generated by protobuf-ts 2.9.3 with parameter add_pb_suffix,eslint_disable,generate_dependencies,server_grpc1,ts_nocheck
// @generated from protobuf file "teleport/desktop/v1/tdpb.proto" (package "teleport.desktop.v1", syntax proto3)
// tslint:disable
// @ts-nocheck
//
//
// Teleport
// Copyright (C) 2025  Gravitational, Inc.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { AuthenticateResponse } from "../../mfa/v1/challenge_pb";
import { AuthenticateChallenge } from "../../mfa/v1/challenge_pb";
/**
 * Sent by client to begin a TDPB connection and advertise capabilities.
 *
 * @generated from protobuf message teleport.desktop.v1.ClientHello
 */
export interface ClientHello {
    /**
     * @generated from protobuf field: string username = 1;
     */
    username: string;
    /**
     * @generated from protobuf field: teleport.desktop.v1.ClientScreenSpec screen_spec = 2;
     */
    screenSpec?: ClientScreenSpec;
    /**
     * @generated from protobuf field: uint32 keyboard_layout = 3;
     */
    keyboardLayout: number;
}
/**
 * Sent by server in response to a 'Client Hello'. Advertises server capabilities.
 *
 * @generated from protobuf message teleport.desktop.v1.ServerHello
 */
export interface ServerHello {
    /**
     * @generated from protobuf field: teleport.desktop.v1.ConnectionActivated activation_spec = 1;
     */
    activationSpec?: ConnectionActivated;
    /**
     * @generated from protobuf field: bool clipboard_enabled = 2;
     */
    clipboardEnabled: boolean;
}
/**
 * Defines the boundaries that PNG frame will update.
 * Used for composition on PNG frame messages only.
 *
 * @generated from protobuf message teleport.desktop.v1.Rectangle
 */
export interface Rectangle {
    /**
     * @generated from protobuf field: uint32 left = 1;
     */
    left: number;
    /**
     * @generated from protobuf field: uint32 top = 2;
     */
    top: number;
    /**
     * @generated from protobuf field: uint32 right = 3;
     */
    right: number;
    /**
     * @generated from protobuf field: uint32 bottom = 4;
     */
    bottom: number;
}
/**
 * Contains updated image data to be displayed.
 *
 * @generated from protobuf message teleport.desktop.v1.PNGFrame
 */
export interface PNGFrame {
    /**
     * @generated from protobuf field: teleport.desktop.v1.Rectangle coordinates = 1;
     */
    coordinates?: Rectangle;
    /**
     * @generated from protobuf field: bytes data = 2;
     */
    data: Uint8Array;
}
/**
 * Contains a raw RDP FastPath message to by interpreted by the client.
 *
 * @generated from protobuf message teleport.desktop.v1.FastPathPDU
 */
export interface FastPathPDU {
    /**
     * @generated from protobuf field: bytes pdu = 1;
     */
    pdu: Uint8Array;
}
/**
 * Contains a raw RDP response PDU to send to the server.
 *
 * @generated from protobuf message teleport.desktop.v1.RDPResponsePDU
 */
export interface RDPResponsePDU {
    /**
     * @generated from protobuf field: bytes response = 1;
     */
    response: Uint8Array;
}
/**
 * Internal message sent by the server after establishing a connection
 * to the RDP host.
 *
 * @generated from protobuf message teleport.desktop.v1.ConnectionActivated
 */
export interface ConnectionActivated {
    /**
     * @generated from protobuf field: uint32 io_channel_id = 1;
     */
    ioChannelId: number;
    /**
     * @generated from protobuf field: uint32 user_channel_id = 2;
     */
    userChannelId: number;
    /**
     * @generated from protobuf field: uint32 screen_width = 3;
     */
    screenWidth: number;
    /**
     * @generated from protobuf field: uint32 screen_height = 4;
     */
    screenHeight: number;
}
/**
 * Conveys the current state of keyboard buttons with persistent state.
 *
 * @generated from protobuf message teleport.desktop.v1.SyncKeys
 */
export interface SyncKeys {
    /**
     * @generated from protobuf field: bool scroll_lock_pressed = 1;
     */
    scrollLockPressed: boolean;
    /**
     * @generated from protobuf field: bool num_lock_state = 2;
     */
    numLockState: boolean;
    /**
     * @generated from protobuf field: bool caps_lock_state = 3;
     */
    capsLockState: boolean;
    /**
     * @generated from protobuf field: bool kana_lock_state = 4;
     */
    kanaLockState: boolean;
}
/**
 * Represents the current position of the cursor on the client.
 *
 * @generated from protobuf message teleport.desktop.v1.MouseMove
 */
export interface MouseMove {
    /**
     * @generated from protobuf field: uint32 x = 1;
     */
    x: number;
    /**
     * @generated from protobuf field: uint32 y = 2;
     */
    y: number;
}
/**
 * Informs the server of a mouse button press.
 *
 * @generated from protobuf message teleport.desktop.v1.MouseButton
 */
export interface MouseButton {
    /**
     * @generated from protobuf field: teleport.desktop.v1.MouseButtonType button = 1;
     */
    button: MouseButtonType;
    /**
     * @generated from protobuf field: bool pressed = 2;
     */
    pressed: boolean;
}
/**
 * Informs the server of a keyboard button press.
 *
 * @generated from protobuf message teleport.desktop.v1.KeyboardButton
 */
export interface KeyboardButton {
    /**
     * @generated from protobuf field: uint32 key_code = 1;
     */
    keyCode: number;
    /**
     * @generated from protobuf field: bool pressed = 2;
     */
    pressed: boolean;
}
/**
 * Composed in Client Hello to inform the server of the client's screen size.
 * May also be sent during a desktop session as the client resizes its display.
 * These mesasages are captured for session recordings in order to replay
 * resizing events.
 *
 * @generated from protobuf message teleport.desktop.v1.ClientScreenSpec
 */
export interface ClientScreenSpec {
    /**
     * @generated from protobuf field: uint32 width = 1;
     */
    width: number;
    /**
     * @generated from protobuf field: uint32 height = 2;
     */
    height: number;
}
/**
 * Represents an Alert to be displayed by the client.
 *
 * @generated from protobuf message teleport.desktop.v1.Alert
 */
export interface Alert {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
    /**
     * @generated from protobuf field: teleport.desktop.v1.AlertSeverity severity = 2;
     */
    severity: AlertSeverity;
}
/**
 * Mouse wheel event.
 *
 * @generated from protobuf message teleport.desktop.v1.MouseWheel
 */
export interface MouseWheel {
    /**
     * @generated from protobuf field: teleport.desktop.v1.MouseWheelAxis axis = 1;
     */
    axis: MouseWheelAxis;
    /**
     * @generated from protobuf field: int32 delta = 2;
     */
    delta: number;
}
/**
 * Represents shared clipboard data.
 *
 * @generated from protobuf message teleport.desktop.v1.ClipboardData
 */
export interface ClipboardData {
    /**
     * @generated from protobuf field: bytes data = 1;
     */
    data: Uint8Array;
}
/**
 * Contains an MFA challenge or response
 * The client implicitly expects a non-empty challenge while the server
 * expects a non-empty response.
 *
 * @generated from protobuf message teleport.desktop.v1.MFA
 */
export interface MFA {
    /**
     * @generated from protobuf field: teleport.desktop.v1.MFAType type = 1;
     */
    type: MFAType;
    /**
     * @generated from protobuf field: string channel_id = 2;
     */
    channelId: string;
    /**
     * @generated from protobuf field: teleport.mfa.v1.AuthenticateChallenge challenge = 3;
     */
    challenge?: AuthenticateChallenge;
    /**
     * @generated from protobuf field: teleport.mfa.v1.AuthenticateResponse authentication_response = 4;
     */
    authenticationResponse?: AuthenticateResponse;
}
/**
 * Sent by client to announce a new shared directory.
 *
 * @generated from protobuf message teleport.desktop.v1.SharedDirectoryAnnounce
 */
export interface SharedDirectoryAnnounce {
    /**
     * @generated from protobuf field: uint32 directory_id = 1;
     */
    directoryId: number;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
}
/**
 * Sent by server to acknowledge a new shared directory.
 *
 * @generated from protobuf message teleport.desktop.v1.SharedDirectoryAcknowledge
 */
export interface SharedDirectoryAcknowledge {
    /**
     * @generated from protobuf field: uint32 directory_id = 1;
     */
    directoryId: number;
    /**
     * @generated from protobuf field: uint32 error_code = 2;
     */
    errorCode: number;
}
/**
 * Shared directory operation requests.
 *
 * @generated from protobuf message teleport.desktop.v1.SharedDirectoryRequest
 */
export interface SharedDirectoryRequest {
    /**
     * Common fields used for all request types.
     *
     * @generated from protobuf field: uint32 directory_id = 1;
     */
    directoryId: number;
    /**
     * @generated from protobuf field: uint32 completion_id = 2;
     */
    completionId: number;
    /**
     * @generated from protobuf oneof: operation
     */
    operation: {
        oneofKind: "info";
        /**
         * @generated from protobuf field: teleport.desktop.v1.SharedDirectoryRequest.Info info = 3;
         */
        info: SharedDirectoryRequest_Info;
    } | {
        oneofKind: "create";
        /**
         * @generated from protobuf field: teleport.desktop.v1.SharedDirectoryRequest.Create create = 4;
         */
        create: SharedDirectoryRequest_Create;
    } | {
        oneofKind: "delete";
        /**
         * @generated from protobuf field: teleport.desktop.v1.SharedDirectoryRequest.Delete delete = 5;
         */
        delete: SharedDirectoryRequest_Delete;
    } | {
        oneofKind: "list";
        /**
         * @generated from protobuf field: teleport.desktop.v1.SharedDirectoryRequest.List list = 6;
         */
        list: SharedDirectoryRequest_List;
    } | {
        oneofKind: "read";
        /**
         * @generated from protobuf field: teleport.desktop.v1.SharedDirectoryRequest.Read read = 7;
         */
        read: SharedDirectoryRequest_Read;
    } | {
        oneofKind: "write";
        /**
         * @generated from protobuf field: teleport.desktop.v1.SharedDirectoryRequest.Write write = 8;
         */
        write: SharedDirectoryRequest_Write;
    } | {
        oneofKind: "move";
        /**
         * @generated from protobuf field: teleport.desktop.v1.SharedDirectoryRequest.Move move = 9;
         */
        move: SharedDirectoryRequest_Move;
    } | {
        oneofKind: "truncate";
        /**
         * @generated from protobuf field: teleport.desktop.v1.SharedDirectoryRequest.Truncate truncate = 10;
         */
        truncate: SharedDirectoryRequest_Truncate;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Info request.
 *
 * @generated from protobuf message teleport.desktop.v1.SharedDirectoryRequest.Info
 */
export interface SharedDirectoryRequest_Info {
    /**
     * @generated from protobuf field: string path = 1;
     */
    path: string;
}
/**
 * Create request.
 *
 * @generated from protobuf message teleport.desktop.v1.SharedDirectoryRequest.Create
 */
export interface SharedDirectoryRequest_Create {
    /**
     * @generated from protobuf field: string path = 1;
     */
    path: string;
    /**
     * @generated from protobuf field: uint32 file_type = 2;
     */
    fileType: number;
}
/**
 * Delete request.
 *
 * @generated from protobuf message teleport.desktop.v1.SharedDirectoryRequest.Delete
 */
export interface SharedDirectoryRequest_Delete {
    /**
     * @generated from protobuf field: string path = 1;
     */
    path: string;
}
/**
 * List request.
 *
 * @generated from protobuf message teleport.desktop.v1.SharedDirectoryRequest.List
 */
export interface SharedDirectoryRequest_List {
    /**
     * @generated from protobuf field: string path = 1;
     */
    path: string;
}
/**
 * Read Request.
 *
 * @generated from protobuf message teleport.desktop.v1.SharedDirectoryRequest.Read
 */
export interface SharedDirectoryRequest_Read {
    /**
     * @generated from protobuf field: string path = 1;
     */
    path: string;
    /**
     * @generated from protobuf field: uint64 offset = 2;
     */
    offset: bigint;
    /**
     * @generated from protobuf field: uint32 length = 3;
     */
    length: number;
}
/**
 * Write Request.
 *
 * @generated from protobuf message teleport.desktop.v1.SharedDirectoryRequest.Write
 */
export interface SharedDirectoryRequest_Write {
    /**
     * @generated from protobuf field: string path = 1;
     */
    path: string;
    /**
     * @generated from protobuf field: uint64 offset = 2;
     */
    offset: bigint;
    /**
     * @generated from protobuf field: bytes data = 3;
     */
    data: Uint8Array;
}
/**
 * Move Request.
 *
 * @generated from protobuf message teleport.desktop.v1.SharedDirectoryRequest.Move
 */
export interface SharedDirectoryRequest_Move {
    /**
     * @generated from protobuf field: string original_path = 1;
     */
    originalPath: string;
    /**
     * @generated from protobuf field: string new_path = 2;
     */
    newPath: string;
}
/**
 * Truncate Request.
 *
 * @generated from protobuf message teleport.desktop.v1.SharedDirectoryRequest.Truncate
 */
export interface SharedDirectoryRequest_Truncate {
    /**
     * @generated from protobuf field: string path = 1;
     */
    path: string;
    /**
     * @generated from protobuf field: uint32 end_of_file = 2;
     */
    endOfFile: number;
}
/**
 * Shared directory operation responses.
 *
 * @generated from protobuf message teleport.desktop.v1.SharedDirectoryResponse
 */
export interface SharedDirectoryResponse {
    /**
     * Common fields used for all response types.
     *
     * @generated from protobuf field: uint32 completion_id = 1;
     */
    completionId: number;
    /**
     * @generated from protobuf field: uint32 error_code = 2;
     */
    errorCode: number;
    /**
     * @generated from protobuf oneof: operation
     */
    operation: {
        oneofKind: "info";
        /**
         * @generated from protobuf field: teleport.desktop.v1.SharedDirectoryResponse.Info info = 3;
         */
        info: SharedDirectoryResponse_Info;
    } | {
        oneofKind: "create";
        /**
         * @generated from protobuf field: teleport.desktop.v1.SharedDirectoryResponse.Create create = 4;
         */
        create: SharedDirectoryResponse_Create;
    } | {
        oneofKind: "delete";
        /**
         * @generated from protobuf field: teleport.desktop.v1.SharedDirectoryResponse.Delete delete = 5;
         */
        delete: SharedDirectoryResponse_Delete;
    } | {
        oneofKind: "list";
        /**
         * @generated from protobuf field: teleport.desktop.v1.SharedDirectoryResponse.List list = 6;
         */
        list: SharedDirectoryResponse_List;
    } | {
        oneofKind: "read";
        /**
         * @generated from protobuf field: teleport.desktop.v1.SharedDirectoryResponse.Read read = 7;
         */
        read: SharedDirectoryResponse_Read;
    } | {
        oneofKind: "write";
        /**
         * @generated from protobuf field: teleport.desktop.v1.SharedDirectoryResponse.Write write = 8;
         */
        write: SharedDirectoryResponse_Write;
    } | {
        oneofKind: "move";
        /**
         * @generated from protobuf field: teleport.desktop.v1.SharedDirectoryResponse.Move move = 9;
         */
        move: SharedDirectoryResponse_Move;
    } | {
        oneofKind: "truncate";
        /**
         * @generated from protobuf field: teleport.desktop.v1.SharedDirectoryResponse.Truncate truncate = 10;
         */
        truncate: SharedDirectoryResponse_Truncate;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Info response.
 *
 * @generated from protobuf message teleport.desktop.v1.SharedDirectoryResponse.Info
 */
export interface SharedDirectoryResponse_Info {
    /**
     * @generated from protobuf field: teleport.desktop.v1.FileSystemObject fso = 1;
     */
    fso?: FileSystemObject;
}
/**
 * Create response.
 *
 * @generated from protobuf message teleport.desktop.v1.SharedDirectoryResponse.Create
 */
export interface SharedDirectoryResponse_Create {
    /**
     * @generated from protobuf field: teleport.desktop.v1.FileSystemObject fso = 1;
     */
    fso?: FileSystemObject;
}
/**
 * Delete response.
 *
 * @generated from protobuf message teleport.desktop.v1.SharedDirectoryResponse.Delete
 */
export interface SharedDirectoryResponse_Delete {
}
/**
 * List response.
 *
 * @generated from protobuf message teleport.desktop.v1.SharedDirectoryResponse.List
 */
export interface SharedDirectoryResponse_List {
    /**
     * @generated from protobuf field: repeated teleport.desktop.v1.FileSystemObject fso_list = 1;
     */
    fsoList: FileSystemObject[];
}
/**
 * Read response.
 *
 * @generated from protobuf message teleport.desktop.v1.SharedDirectoryResponse.Read
 */
export interface SharedDirectoryResponse_Read {
    /**
     * @generated from protobuf field: bytes data = 1;
     */
    data: Uint8Array;
}
/**
 * Write response.
 *
 * @generated from protobuf message teleport.desktop.v1.SharedDirectoryResponse.Write
 */
export interface SharedDirectoryResponse_Write {
    /**
     * @generated from protobuf field: uint32 bytes_written = 1;
     */
    bytesWritten: number;
}
/**
 * Move response.
 *
 * @generated from protobuf message teleport.desktop.v1.SharedDirectoryResponse.Move
 */
export interface SharedDirectoryResponse_Move {
}
/**
 * Truncate response.
 *
 * @generated from protobuf message teleport.desktop.v1.SharedDirectoryResponse.Truncate
 */
export interface SharedDirectoryResponse_Truncate {
}
/**
 * Represents a file object in a shared directory.
 *
 * @generated from protobuf message teleport.desktop.v1.FileSystemObject
 */
export interface FileSystemObject {
    /**
     * @generated from protobuf field: uint64 last_modified = 1;
     */
    lastModified: bigint;
    /**
     * @generated from protobuf field: uint64 size = 2;
     */
    size: bigint;
    /**
     * @generated from protobuf field: uint32 file_type = 3;
     */
    fileType: number;
    /**
     * @generated from protobuf field: bool is_empty = 4;
     */
    isEmpty: boolean;
    /**
     * @generated from protobuf field: string path = 5;
     */
    path: string;
}
/**
 * Contains latency metrics between the proxy and RDP host
 * as well as between the proxy and client.
 *
 * @generated from protobuf message teleport.desktop.v1.LatencyStats
 */
export interface LatencyStats {
    /**
     * @generated from protobuf field: uint32 client_latency_ms = 1;
     */
    clientLatencyMs: number;
    /**
     * @generated from protobuf field: uint32 server_latency_ms = 2;
     */
    serverLatencyMs: number;
}
/**
 * A ping message used to time latency between the web client and proxy.
 *
 * @generated from protobuf message teleport.desktop.v1.Ping
 */
export interface Ping {
    /**
     * UUID is used to correlate message sent by proxy and received from the Windows Desktop Service.
     *
     * @generated from protobuf field: bytes uuid = 1;
     */
    uuid: Uint8Array;
}
/**
 * Envelope wraps all messages that are allowed to be sent on the wire.
 *
 * @generated from protobuf message teleport.desktop.v1.Envelope
 */
export interface Envelope {
    /**
     * @generated from protobuf oneof: payload
     */
    payload: {
        oneofKind: "clientHello";
        /**
         * @generated from protobuf field: teleport.desktop.v1.ClientHello client_hello = 1;
         */
        clientHello: ClientHello;
    } | {
        oneofKind: "serverHello";
        /**
         * @generated from protobuf field: teleport.desktop.v1.ServerHello server_hello = 2;
         */
        serverHello: ServerHello;
    } | {
        oneofKind: "pngFrame";
        /**
         * @generated from protobuf field: teleport.desktop.v1.PNGFrame png_frame = 3;
         */
        pngFrame: PNGFrame;
    } | {
        oneofKind: "fastPathPdu";
        /**
         * @generated from protobuf field: teleport.desktop.v1.FastPathPDU fast_path_pdu = 4;
         */
        fastPathPdu: FastPathPDU;
    } | {
        oneofKind: "rdpResponsePdu";
        /**
         * @generated from protobuf field: teleport.desktop.v1.RDPResponsePDU rdp_response_pdu = 5;
         */
        rdpResponsePdu: RDPResponsePDU;
    } | {
        oneofKind: "syncKeys";
        /**
         * @generated from protobuf field: teleport.desktop.v1.SyncKeys sync_keys = 6;
         */
        syncKeys: SyncKeys;
    } | {
        oneofKind: "mouseMove";
        /**
         * @generated from protobuf field: teleport.desktop.v1.MouseMove mouse_move = 7;
         */
        mouseMove: MouseMove;
    } | {
        oneofKind: "mouseButton";
        /**
         * @generated from protobuf field: teleport.desktop.v1.MouseButton mouse_button = 8;
         */
        mouseButton: MouseButton;
    } | {
        oneofKind: "keyboardButton";
        /**
         * @generated from protobuf field: teleport.desktop.v1.KeyboardButton keyboard_button = 9;
         */
        keyboardButton: KeyboardButton;
    } | {
        oneofKind: "clientScreenSpec";
        /**
         * @generated from protobuf field: teleport.desktop.v1.ClientScreenSpec client_screen_spec = 10;
         */
        clientScreenSpec: ClientScreenSpec;
    } | {
        oneofKind: "alert";
        /**
         * @generated from protobuf field: teleport.desktop.v1.Alert alert = 11;
         */
        alert: Alert;
    } | {
        oneofKind: "mouseWheel";
        /**
         * @generated from protobuf field: teleport.desktop.v1.MouseWheel mouse_wheel = 12;
         */
        mouseWheel: MouseWheel;
    } | {
        oneofKind: "clipboardData";
        /**
         * @generated from protobuf field: teleport.desktop.v1.ClipboardData clipboard_data = 13;
         */
        clipboardData: ClipboardData;
    } | {
        oneofKind: "mfa";
        /**
         * @generated from protobuf field: teleport.desktop.v1.MFA mfa = 14;
         */
        mfa: MFA;
    } | {
        oneofKind: "sharedDirectoryAnnounce";
        /**
         * @generated from protobuf field: teleport.desktop.v1.SharedDirectoryAnnounce shared_directory_announce = 15;
         */
        sharedDirectoryAnnounce: SharedDirectoryAnnounce;
    } | {
        oneofKind: "sharedDirectoryAcknowledge";
        /**
         * @generated from protobuf field: teleport.desktop.v1.SharedDirectoryAcknowledge shared_directory_acknowledge = 16;
         */
        sharedDirectoryAcknowledge: SharedDirectoryAcknowledge;
    } | {
        oneofKind: "sharedDirectoryRequest";
        /**
         * @generated from protobuf field: teleport.desktop.v1.SharedDirectoryRequest shared_directory_request = 17;
         */
        sharedDirectoryRequest: SharedDirectoryRequest;
    } | {
        oneofKind: "sharedDirectoryResponse";
        /**
         * @generated from protobuf field: teleport.desktop.v1.SharedDirectoryResponse shared_directory_response = 18;
         */
        sharedDirectoryResponse: SharedDirectoryResponse;
    } | {
        oneofKind: "latencyStats";
        /**
         * @generated from protobuf field: teleport.desktop.v1.LatencyStats latency_stats = 19;
         */
        latencyStats: LatencyStats;
    } | {
        oneofKind: "ping";
        /**
         * @generated from protobuf field: teleport.desktop.v1.Ping ping = 20;
         */
        ping: Ping;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Specifies which mouse button was pressed.
 *
 * @generated from protobuf enum teleport.desktop.v1.MouseButtonType
 */
export enum MouseButtonType {
    /**
     * @generated from protobuf enum value: MOUSE_BUTTON_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: MOUSE_BUTTON_TYPE_LEFT = 1;
     */
    LEFT = 1,
    /**
     * @generated from protobuf enum value: MOUSE_BUTTON_TYPE_MIDDLE = 2;
     */
    MIDDLE = 2,
    /**
     * @generated from protobuf enum value: MOUSE_BUTTON_TYPE_RIGHT = 3;
     */
    RIGHT = 3
}
/**
 * Severity of an alert contained in an Alert message.
 *
 * @generated from protobuf enum teleport.desktop.v1.AlertSeverity
 */
export enum AlertSeverity {
    /**
     * @generated from protobuf enum value: ALERT_SEVERITY_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: ALERT_SEVERITY_INFO = 1;
     */
    INFO = 1,
    /**
     * @generated from protobuf enum value: ALERT_SEVERITY_WARNING = 2;
     */
    WARNING = 2,
    /**
     * @generated from protobuf enum value: ALERT_SEVERITY_ERROR = 3;
     */
    ERROR = 3
}
/**
 * Represents the axis on which a scroll wheel acts.
 *
 * @generated from protobuf enum teleport.desktop.v1.MouseWheelAxis
 */
export enum MouseWheelAxis {
    /**
     * @generated from protobuf enum value: MOUSE_WHEEL_AXIS_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: MOUSE_WHEEL_AXIS_VERTICAL = 1;
     */
    VERTICAL = 1,
    /**
     * @generated from protobuf enum value: MOUSE_WHEEL_AXIS_HORIZONTAL = 2;
     */
    HORIZONTAL = 2
}
/**
 * MFA challenge type.
 *
 * @generated from protobuf enum teleport.desktop.v1.MFAType
 */
export enum MFAType {
    /**
     * @generated from protobuf enum value: MFA_TYPE_UNSPECIFIED = 0;
     */
    MFA_TYPE_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: MFA_TYPE_WEBAUTHN = 1;
     */
    MFA_TYPE_WEBAUTHN = 1,
    /**
     * @generated from protobuf enum value: MFA_TYPE_U2F = 2;
     */
    MFA_TYPE_U2F = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class ClientHello$Type extends MessageType<ClientHello> {
    constructor() {
        super("teleport.desktop.v1.ClientHello", [
            { no: 1, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "screen_spec", kind: "message", T: () => ClientScreenSpec },
            { no: 3, name: "keyboard_layout", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ClientHello>): ClientHello {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.username = "";
        message.keyboardLayout = 0;
        if (value !== undefined)
            reflectionMergePartial<ClientHello>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClientHello): ClientHello {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string username */ 1:
                    message.username = reader.string();
                    break;
                case /* teleport.desktop.v1.ClientScreenSpec screen_spec */ 2:
                    message.screenSpec = ClientScreenSpec.internalBinaryRead(reader, reader.uint32(), options, message.screenSpec);
                    break;
                case /* uint32 keyboard_layout */ 3:
                    message.keyboardLayout = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClientHello, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string username = 1; */
        if (message.username !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.username);
        /* teleport.desktop.v1.ClientScreenSpec screen_spec = 2; */
        if (message.screenSpec)
            ClientScreenSpec.internalBinaryWrite(message.screenSpec, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* uint32 keyboard_layout = 3; */
        if (message.keyboardLayout !== 0)
            writer.tag(3, WireType.Varint).uint32(message.keyboardLayout);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.ClientHello
 */
export const ClientHello = new ClientHello$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServerHello$Type extends MessageType<ServerHello> {
    constructor() {
        super("teleport.desktop.v1.ServerHello", [
            { no: 1, name: "activation_spec", kind: "message", T: () => ConnectionActivated },
            { no: 2, name: "clipboard_enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ServerHello>): ServerHello {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clipboardEnabled = false;
        if (value !== undefined)
            reflectionMergePartial<ServerHello>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServerHello): ServerHello {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.desktop.v1.ConnectionActivated activation_spec */ 1:
                    message.activationSpec = ConnectionActivated.internalBinaryRead(reader, reader.uint32(), options, message.activationSpec);
                    break;
                case /* bool clipboard_enabled */ 2:
                    message.clipboardEnabled = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServerHello, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.desktop.v1.ConnectionActivated activation_spec = 1; */
        if (message.activationSpec)
            ConnectionActivated.internalBinaryWrite(message.activationSpec, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool clipboard_enabled = 2; */
        if (message.clipboardEnabled !== false)
            writer.tag(2, WireType.Varint).bool(message.clipboardEnabled);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.ServerHello
 */
export const ServerHello = new ServerHello$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Rectangle$Type extends MessageType<Rectangle> {
    constructor() {
        super("teleport.desktop.v1.Rectangle", [
            { no: 1, name: "left", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "top", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "right", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "bottom", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Rectangle>): Rectangle {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.left = 0;
        message.top = 0;
        message.right = 0;
        message.bottom = 0;
        if (value !== undefined)
            reflectionMergePartial<Rectangle>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Rectangle): Rectangle {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 left */ 1:
                    message.left = reader.uint32();
                    break;
                case /* uint32 top */ 2:
                    message.top = reader.uint32();
                    break;
                case /* uint32 right */ 3:
                    message.right = reader.uint32();
                    break;
                case /* uint32 bottom */ 4:
                    message.bottom = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Rectangle, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 left = 1; */
        if (message.left !== 0)
            writer.tag(1, WireType.Varint).uint32(message.left);
        /* uint32 top = 2; */
        if (message.top !== 0)
            writer.tag(2, WireType.Varint).uint32(message.top);
        /* uint32 right = 3; */
        if (message.right !== 0)
            writer.tag(3, WireType.Varint).uint32(message.right);
        /* uint32 bottom = 4; */
        if (message.bottom !== 0)
            writer.tag(4, WireType.Varint).uint32(message.bottom);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.Rectangle
 */
export const Rectangle = new Rectangle$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PNGFrame$Type extends MessageType<PNGFrame> {
    constructor() {
        super("teleport.desktop.v1.PNGFrame", [
            { no: 1, name: "coordinates", kind: "message", T: () => Rectangle },
            { no: 2, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<PNGFrame>): PNGFrame {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<PNGFrame>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PNGFrame): PNGFrame {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.desktop.v1.Rectangle coordinates */ 1:
                    message.coordinates = Rectangle.internalBinaryRead(reader, reader.uint32(), options, message.coordinates);
                    break;
                case /* bytes data */ 2:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PNGFrame, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.desktop.v1.Rectangle coordinates = 1; */
        if (message.coordinates)
            Rectangle.internalBinaryWrite(message.coordinates, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bytes data = 2; */
        if (message.data.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.PNGFrame
 */
export const PNGFrame = new PNGFrame$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FastPathPDU$Type extends MessageType<FastPathPDU> {
    constructor() {
        super("teleport.desktop.v1.FastPathPDU", [
            { no: 1, name: "pdu", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<FastPathPDU>): FastPathPDU {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pdu = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<FastPathPDU>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FastPathPDU): FastPathPDU {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes pdu */ 1:
                    message.pdu = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FastPathPDU, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes pdu = 1; */
        if (message.pdu.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.pdu);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.FastPathPDU
 */
export const FastPathPDU = new FastPathPDU$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RDPResponsePDU$Type extends MessageType<RDPResponsePDU> {
    constructor() {
        super("teleport.desktop.v1.RDPResponsePDU", [
            { no: 1, name: "response", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<RDPResponsePDU>): RDPResponsePDU {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.response = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<RDPResponsePDU>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RDPResponsePDU): RDPResponsePDU {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes response */ 1:
                    message.response = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RDPResponsePDU, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes response = 1; */
        if (message.response.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.response);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.RDPResponsePDU
 */
export const RDPResponsePDU = new RDPResponsePDU$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConnectionActivated$Type extends MessageType<ConnectionActivated> {
    constructor() {
        super("teleport.desktop.v1.ConnectionActivated", [
            { no: 1, name: "io_channel_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "user_channel_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "screen_width", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "screen_height", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ConnectionActivated>): ConnectionActivated {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ioChannelId = 0;
        message.userChannelId = 0;
        message.screenWidth = 0;
        message.screenHeight = 0;
        if (value !== undefined)
            reflectionMergePartial<ConnectionActivated>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConnectionActivated): ConnectionActivated {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 io_channel_id */ 1:
                    message.ioChannelId = reader.uint32();
                    break;
                case /* uint32 user_channel_id */ 2:
                    message.userChannelId = reader.uint32();
                    break;
                case /* uint32 screen_width */ 3:
                    message.screenWidth = reader.uint32();
                    break;
                case /* uint32 screen_height */ 4:
                    message.screenHeight = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConnectionActivated, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 io_channel_id = 1; */
        if (message.ioChannelId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.ioChannelId);
        /* uint32 user_channel_id = 2; */
        if (message.userChannelId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.userChannelId);
        /* uint32 screen_width = 3; */
        if (message.screenWidth !== 0)
            writer.tag(3, WireType.Varint).uint32(message.screenWidth);
        /* uint32 screen_height = 4; */
        if (message.screenHeight !== 0)
            writer.tag(4, WireType.Varint).uint32(message.screenHeight);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.ConnectionActivated
 */
export const ConnectionActivated = new ConnectionActivated$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SyncKeys$Type extends MessageType<SyncKeys> {
    constructor() {
        super("teleport.desktop.v1.SyncKeys", [
            { no: 1, name: "scroll_lock_pressed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "num_lock_state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "caps_lock_state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "kana_lock_state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SyncKeys>): SyncKeys {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.scrollLockPressed = false;
        message.numLockState = false;
        message.capsLockState = false;
        message.kanaLockState = false;
        if (value !== undefined)
            reflectionMergePartial<SyncKeys>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SyncKeys): SyncKeys {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool scroll_lock_pressed */ 1:
                    message.scrollLockPressed = reader.bool();
                    break;
                case /* bool num_lock_state */ 2:
                    message.numLockState = reader.bool();
                    break;
                case /* bool caps_lock_state */ 3:
                    message.capsLockState = reader.bool();
                    break;
                case /* bool kana_lock_state */ 4:
                    message.kanaLockState = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SyncKeys, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool scroll_lock_pressed = 1; */
        if (message.scrollLockPressed !== false)
            writer.tag(1, WireType.Varint).bool(message.scrollLockPressed);
        /* bool num_lock_state = 2; */
        if (message.numLockState !== false)
            writer.tag(2, WireType.Varint).bool(message.numLockState);
        /* bool caps_lock_state = 3; */
        if (message.capsLockState !== false)
            writer.tag(3, WireType.Varint).bool(message.capsLockState);
        /* bool kana_lock_state = 4; */
        if (message.kanaLockState !== false)
            writer.tag(4, WireType.Varint).bool(message.kanaLockState);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.SyncKeys
 */
export const SyncKeys = new SyncKeys$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MouseMove$Type extends MessageType<MouseMove> {
    constructor() {
        super("teleport.desktop.v1.MouseMove", [
            { no: 1, name: "x", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "y", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<MouseMove>): MouseMove {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.x = 0;
        message.y = 0;
        if (value !== undefined)
            reflectionMergePartial<MouseMove>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MouseMove): MouseMove {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 x */ 1:
                    message.x = reader.uint32();
                    break;
                case /* uint32 y */ 2:
                    message.y = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MouseMove, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 x = 1; */
        if (message.x !== 0)
            writer.tag(1, WireType.Varint).uint32(message.x);
        /* uint32 y = 2; */
        if (message.y !== 0)
            writer.tag(2, WireType.Varint).uint32(message.y);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.MouseMove
 */
export const MouseMove = new MouseMove$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MouseButton$Type extends MessageType<MouseButton> {
    constructor() {
        super("teleport.desktop.v1.MouseButton", [
            { no: 1, name: "button", kind: "enum", T: () => ["teleport.desktop.v1.MouseButtonType", MouseButtonType, "MOUSE_BUTTON_TYPE_"] },
            { no: 2, name: "pressed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<MouseButton>): MouseButton {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.button = 0;
        message.pressed = false;
        if (value !== undefined)
            reflectionMergePartial<MouseButton>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MouseButton): MouseButton {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.desktop.v1.MouseButtonType button */ 1:
                    message.button = reader.int32();
                    break;
                case /* bool pressed */ 2:
                    message.pressed = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MouseButton, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.desktop.v1.MouseButtonType button = 1; */
        if (message.button !== 0)
            writer.tag(1, WireType.Varint).int32(message.button);
        /* bool pressed = 2; */
        if (message.pressed !== false)
            writer.tag(2, WireType.Varint).bool(message.pressed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.MouseButton
 */
export const MouseButton = new MouseButton$Type();
// @generated message type with reflection information, may provide speed optimized methods
class KeyboardButton$Type extends MessageType<KeyboardButton> {
    constructor() {
        super("teleport.desktop.v1.KeyboardButton", [
            { no: 1, name: "key_code", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "pressed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<KeyboardButton>): KeyboardButton {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyCode = 0;
        message.pressed = false;
        if (value !== undefined)
            reflectionMergePartial<KeyboardButton>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KeyboardButton): KeyboardButton {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 key_code */ 1:
                    message.keyCode = reader.uint32();
                    break;
                case /* bool pressed */ 2:
                    message.pressed = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: KeyboardButton, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 key_code = 1; */
        if (message.keyCode !== 0)
            writer.tag(1, WireType.Varint).uint32(message.keyCode);
        /* bool pressed = 2; */
        if (message.pressed !== false)
            writer.tag(2, WireType.Varint).bool(message.pressed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.KeyboardButton
 */
export const KeyboardButton = new KeyboardButton$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClientScreenSpec$Type extends MessageType<ClientScreenSpec> {
    constructor() {
        super("teleport.desktop.v1.ClientScreenSpec", [
            { no: 1, name: "width", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "height", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ClientScreenSpec>): ClientScreenSpec {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.width = 0;
        message.height = 0;
        if (value !== undefined)
            reflectionMergePartial<ClientScreenSpec>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClientScreenSpec): ClientScreenSpec {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 width */ 1:
                    message.width = reader.uint32();
                    break;
                case /* uint32 height */ 2:
                    message.height = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClientScreenSpec, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 width = 1; */
        if (message.width !== 0)
            writer.tag(1, WireType.Varint).uint32(message.width);
        /* uint32 height = 2; */
        if (message.height !== 0)
            writer.tag(2, WireType.Varint).uint32(message.height);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.ClientScreenSpec
 */
export const ClientScreenSpec = new ClientScreenSpec$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Alert$Type extends MessageType<Alert> {
    constructor() {
        super("teleport.desktop.v1.Alert", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "severity", kind: "enum", T: () => ["teleport.desktop.v1.AlertSeverity", AlertSeverity, "ALERT_SEVERITY_"] }
        ]);
    }
    create(value?: PartialMessage<Alert>): Alert {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.message = "";
        message.severity = 0;
        if (value !== undefined)
            reflectionMergePartial<Alert>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Alert): Alert {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                case /* teleport.desktop.v1.AlertSeverity severity */ 2:
                    message.severity = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Alert, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        /* teleport.desktop.v1.AlertSeverity severity = 2; */
        if (message.severity !== 0)
            writer.tag(2, WireType.Varint).int32(message.severity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.Alert
 */
export const Alert = new Alert$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MouseWheel$Type extends MessageType<MouseWheel> {
    constructor() {
        super("teleport.desktop.v1.MouseWheel", [
            { no: 1, name: "axis", kind: "enum", T: () => ["teleport.desktop.v1.MouseWheelAxis", MouseWheelAxis, "MOUSE_WHEEL_AXIS_"] },
            { no: 2, name: "delta", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<MouseWheel>): MouseWheel {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.axis = 0;
        message.delta = 0;
        if (value !== undefined)
            reflectionMergePartial<MouseWheel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MouseWheel): MouseWheel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.desktop.v1.MouseWheelAxis axis */ 1:
                    message.axis = reader.int32();
                    break;
                case /* int32 delta */ 2:
                    message.delta = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MouseWheel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.desktop.v1.MouseWheelAxis axis = 1; */
        if (message.axis !== 0)
            writer.tag(1, WireType.Varint).int32(message.axis);
        /* int32 delta = 2; */
        if (message.delta !== 0)
            writer.tag(2, WireType.Varint).int32(message.delta);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.MouseWheel
 */
export const MouseWheel = new MouseWheel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClipboardData$Type extends MessageType<ClipboardData> {
    constructor() {
        super("teleport.desktop.v1.ClipboardData", [
            { no: 1, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<ClipboardData>): ClipboardData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<ClipboardData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClipboardData): ClipboardData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes data */ 1:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClipboardData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes data = 1; */
        if (message.data.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.ClipboardData
 */
export const ClipboardData = new ClipboardData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MFA$Type extends MessageType<MFA> {
    constructor() {
        super("teleport.desktop.v1.MFA", [
            { no: 1, name: "type", kind: "enum", T: () => ["teleport.desktop.v1.MFAType", MFAType] },
            { no: 2, name: "channel_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "challenge", kind: "message", T: () => AuthenticateChallenge },
            { no: 4, name: "authentication_response", kind: "message", T: () => AuthenticateResponse }
        ]);
    }
    create(value?: PartialMessage<MFA>): MFA {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.channelId = "";
        if (value !== undefined)
            reflectionMergePartial<MFA>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MFA): MFA {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.desktop.v1.MFAType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* string channel_id */ 2:
                    message.channelId = reader.string();
                    break;
                case /* teleport.mfa.v1.AuthenticateChallenge challenge */ 3:
                    message.challenge = AuthenticateChallenge.internalBinaryRead(reader, reader.uint32(), options, message.challenge);
                    break;
                case /* teleport.mfa.v1.AuthenticateResponse authentication_response */ 4:
                    message.authenticationResponse = AuthenticateResponse.internalBinaryRead(reader, reader.uint32(), options, message.authenticationResponse);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MFA, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.desktop.v1.MFAType type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* string channel_id = 2; */
        if (message.channelId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.channelId);
        /* teleport.mfa.v1.AuthenticateChallenge challenge = 3; */
        if (message.challenge)
            AuthenticateChallenge.internalBinaryWrite(message.challenge, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* teleport.mfa.v1.AuthenticateResponse authentication_response = 4; */
        if (message.authenticationResponse)
            AuthenticateResponse.internalBinaryWrite(message.authenticationResponse, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.MFA
 */
export const MFA = new MFA$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SharedDirectoryAnnounce$Type extends MessageType<SharedDirectoryAnnounce> {
    constructor() {
        super("teleport.desktop.v1.SharedDirectoryAnnounce", [
            { no: 1, name: "directory_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SharedDirectoryAnnounce>): SharedDirectoryAnnounce {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.directoryId = 0;
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<SharedDirectoryAnnounce>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SharedDirectoryAnnounce): SharedDirectoryAnnounce {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 directory_id */ 1:
                    message.directoryId = reader.uint32();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SharedDirectoryAnnounce, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 directory_id = 1; */
        if (message.directoryId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.directoryId);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.SharedDirectoryAnnounce
 */
export const SharedDirectoryAnnounce = new SharedDirectoryAnnounce$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SharedDirectoryAcknowledge$Type extends MessageType<SharedDirectoryAcknowledge> {
    constructor() {
        super("teleport.desktop.v1.SharedDirectoryAcknowledge", [
            { no: 1, name: "directory_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "error_code", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SharedDirectoryAcknowledge>): SharedDirectoryAcknowledge {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.directoryId = 0;
        message.errorCode = 0;
        if (value !== undefined)
            reflectionMergePartial<SharedDirectoryAcknowledge>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SharedDirectoryAcknowledge): SharedDirectoryAcknowledge {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 directory_id */ 1:
                    message.directoryId = reader.uint32();
                    break;
                case /* uint32 error_code */ 2:
                    message.errorCode = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SharedDirectoryAcknowledge, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 directory_id = 1; */
        if (message.directoryId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.directoryId);
        /* uint32 error_code = 2; */
        if (message.errorCode !== 0)
            writer.tag(2, WireType.Varint).uint32(message.errorCode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.SharedDirectoryAcknowledge
 */
export const SharedDirectoryAcknowledge = new SharedDirectoryAcknowledge$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SharedDirectoryRequest$Type extends MessageType<SharedDirectoryRequest> {
    constructor() {
        super("teleport.desktop.v1.SharedDirectoryRequest", [
            { no: 1, name: "directory_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "completion_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "info", kind: "message", oneof: "operation", T: () => SharedDirectoryRequest_Info },
            { no: 4, name: "create", kind: "message", oneof: "operation", T: () => SharedDirectoryRequest_Create },
            { no: 5, name: "delete", kind: "message", oneof: "operation", T: () => SharedDirectoryRequest_Delete },
            { no: 6, name: "list", kind: "message", oneof: "operation", T: () => SharedDirectoryRequest_List },
            { no: 7, name: "read", kind: "message", oneof: "operation", T: () => SharedDirectoryRequest_Read },
            { no: 8, name: "write", kind: "message", oneof: "operation", T: () => SharedDirectoryRequest_Write },
            { no: 9, name: "move", kind: "message", oneof: "operation", T: () => SharedDirectoryRequest_Move },
            { no: 10, name: "truncate", kind: "message", oneof: "operation", T: () => SharedDirectoryRequest_Truncate }
        ]);
    }
    create(value?: PartialMessage<SharedDirectoryRequest>): SharedDirectoryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.directoryId = 0;
        message.completionId = 0;
        message.operation = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<SharedDirectoryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SharedDirectoryRequest): SharedDirectoryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 directory_id */ 1:
                    message.directoryId = reader.uint32();
                    break;
                case /* uint32 completion_id */ 2:
                    message.completionId = reader.uint32();
                    break;
                case /* teleport.desktop.v1.SharedDirectoryRequest.Info info */ 3:
                    message.operation = {
                        oneofKind: "info",
                        info: SharedDirectoryRequest_Info.internalBinaryRead(reader, reader.uint32(), options, (message.operation as any).info)
                    };
                    break;
                case /* teleport.desktop.v1.SharedDirectoryRequest.Create create */ 4:
                    message.operation = {
                        oneofKind: "create",
                        create: SharedDirectoryRequest_Create.internalBinaryRead(reader, reader.uint32(), options, (message.operation as any).create)
                    };
                    break;
                case /* teleport.desktop.v1.SharedDirectoryRequest.Delete delete */ 5:
                    message.operation = {
                        oneofKind: "delete",
                        delete: SharedDirectoryRequest_Delete.internalBinaryRead(reader, reader.uint32(), options, (message.operation as any).delete)
                    };
                    break;
                case /* teleport.desktop.v1.SharedDirectoryRequest.List list */ 6:
                    message.operation = {
                        oneofKind: "list",
                        list: SharedDirectoryRequest_List.internalBinaryRead(reader, reader.uint32(), options, (message.operation as any).list)
                    };
                    break;
                case /* teleport.desktop.v1.SharedDirectoryRequest.Read read */ 7:
                    message.operation = {
                        oneofKind: "read",
                        read: SharedDirectoryRequest_Read.internalBinaryRead(reader, reader.uint32(), options, (message.operation as any).read)
                    };
                    break;
                case /* teleport.desktop.v1.SharedDirectoryRequest.Write write */ 8:
                    message.operation = {
                        oneofKind: "write",
                        write: SharedDirectoryRequest_Write.internalBinaryRead(reader, reader.uint32(), options, (message.operation as any).write)
                    };
                    break;
                case /* teleport.desktop.v1.SharedDirectoryRequest.Move move */ 9:
                    message.operation = {
                        oneofKind: "move",
                        move: SharedDirectoryRequest_Move.internalBinaryRead(reader, reader.uint32(), options, (message.operation as any).move)
                    };
                    break;
                case /* teleport.desktop.v1.SharedDirectoryRequest.Truncate truncate */ 10:
                    message.operation = {
                        oneofKind: "truncate",
                        truncate: SharedDirectoryRequest_Truncate.internalBinaryRead(reader, reader.uint32(), options, (message.operation as any).truncate)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SharedDirectoryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 directory_id = 1; */
        if (message.directoryId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.directoryId);
        /* uint32 completion_id = 2; */
        if (message.completionId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.completionId);
        /* teleport.desktop.v1.SharedDirectoryRequest.Info info = 3; */
        if (message.operation.oneofKind === "info")
            SharedDirectoryRequest_Info.internalBinaryWrite(message.operation.info, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* teleport.desktop.v1.SharedDirectoryRequest.Create create = 4; */
        if (message.operation.oneofKind === "create")
            SharedDirectoryRequest_Create.internalBinaryWrite(message.operation.create, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* teleport.desktop.v1.SharedDirectoryRequest.Delete delete = 5; */
        if (message.operation.oneofKind === "delete")
            SharedDirectoryRequest_Delete.internalBinaryWrite(message.operation.delete, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* teleport.desktop.v1.SharedDirectoryRequest.List list = 6; */
        if (message.operation.oneofKind === "list")
            SharedDirectoryRequest_List.internalBinaryWrite(message.operation.list, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* teleport.desktop.v1.SharedDirectoryRequest.Read read = 7; */
        if (message.operation.oneofKind === "read")
            SharedDirectoryRequest_Read.internalBinaryWrite(message.operation.read, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* teleport.desktop.v1.SharedDirectoryRequest.Write write = 8; */
        if (message.operation.oneofKind === "write")
            SharedDirectoryRequest_Write.internalBinaryWrite(message.operation.write, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* teleport.desktop.v1.SharedDirectoryRequest.Move move = 9; */
        if (message.operation.oneofKind === "move")
            SharedDirectoryRequest_Move.internalBinaryWrite(message.operation.move, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* teleport.desktop.v1.SharedDirectoryRequest.Truncate truncate = 10; */
        if (message.operation.oneofKind === "truncate")
            SharedDirectoryRequest_Truncate.internalBinaryWrite(message.operation.truncate, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.SharedDirectoryRequest
 */
export const SharedDirectoryRequest = new SharedDirectoryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SharedDirectoryRequest_Info$Type extends MessageType<SharedDirectoryRequest_Info> {
    constructor() {
        super("teleport.desktop.v1.SharedDirectoryRequest.Info", [
            { no: 1, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SharedDirectoryRequest_Info>): SharedDirectoryRequest_Info {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.path = "";
        if (value !== undefined)
            reflectionMergePartial<SharedDirectoryRequest_Info>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SharedDirectoryRequest_Info): SharedDirectoryRequest_Info {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string path */ 1:
                    message.path = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SharedDirectoryRequest_Info, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string path = 1; */
        if (message.path !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.path);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.SharedDirectoryRequest.Info
 */
export const SharedDirectoryRequest_Info = new SharedDirectoryRequest_Info$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SharedDirectoryRequest_Create$Type extends MessageType<SharedDirectoryRequest_Create> {
    constructor() {
        super("teleport.desktop.v1.SharedDirectoryRequest.Create", [
            { no: 1, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "file_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SharedDirectoryRequest_Create>): SharedDirectoryRequest_Create {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.path = "";
        message.fileType = 0;
        if (value !== undefined)
            reflectionMergePartial<SharedDirectoryRequest_Create>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SharedDirectoryRequest_Create): SharedDirectoryRequest_Create {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string path */ 1:
                    message.path = reader.string();
                    break;
                case /* uint32 file_type */ 2:
                    message.fileType = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SharedDirectoryRequest_Create, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string path = 1; */
        if (message.path !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.path);
        /* uint32 file_type = 2; */
        if (message.fileType !== 0)
            writer.tag(2, WireType.Varint).uint32(message.fileType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.SharedDirectoryRequest.Create
 */
export const SharedDirectoryRequest_Create = new SharedDirectoryRequest_Create$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SharedDirectoryRequest_Delete$Type extends MessageType<SharedDirectoryRequest_Delete> {
    constructor() {
        super("teleport.desktop.v1.SharedDirectoryRequest.Delete", [
            { no: 1, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SharedDirectoryRequest_Delete>): SharedDirectoryRequest_Delete {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.path = "";
        if (value !== undefined)
            reflectionMergePartial<SharedDirectoryRequest_Delete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SharedDirectoryRequest_Delete): SharedDirectoryRequest_Delete {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string path */ 1:
                    message.path = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SharedDirectoryRequest_Delete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string path = 1; */
        if (message.path !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.path);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.SharedDirectoryRequest.Delete
 */
export const SharedDirectoryRequest_Delete = new SharedDirectoryRequest_Delete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SharedDirectoryRequest_List$Type extends MessageType<SharedDirectoryRequest_List> {
    constructor() {
        super("teleport.desktop.v1.SharedDirectoryRequest.List", [
            { no: 1, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SharedDirectoryRequest_List>): SharedDirectoryRequest_List {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.path = "";
        if (value !== undefined)
            reflectionMergePartial<SharedDirectoryRequest_List>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SharedDirectoryRequest_List): SharedDirectoryRequest_List {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string path */ 1:
                    message.path = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SharedDirectoryRequest_List, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string path = 1; */
        if (message.path !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.path);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.SharedDirectoryRequest.List
 */
export const SharedDirectoryRequest_List = new SharedDirectoryRequest_List$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SharedDirectoryRequest_Read$Type extends MessageType<SharedDirectoryRequest_Read> {
    constructor() {
        super("teleport.desktop.v1.SharedDirectoryRequest.Read", [
            { no: 1, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "offset", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "length", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SharedDirectoryRequest_Read>): SharedDirectoryRequest_Read {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.path = "";
        message.offset = 0n;
        message.length = 0;
        if (value !== undefined)
            reflectionMergePartial<SharedDirectoryRequest_Read>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SharedDirectoryRequest_Read): SharedDirectoryRequest_Read {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string path */ 1:
                    message.path = reader.string();
                    break;
                case /* uint64 offset */ 2:
                    message.offset = reader.uint64().toBigInt();
                    break;
                case /* uint32 length */ 3:
                    message.length = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SharedDirectoryRequest_Read, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string path = 1; */
        if (message.path !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.path);
        /* uint64 offset = 2; */
        if (message.offset !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.offset);
        /* uint32 length = 3; */
        if (message.length !== 0)
            writer.tag(3, WireType.Varint).uint32(message.length);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.SharedDirectoryRequest.Read
 */
export const SharedDirectoryRequest_Read = new SharedDirectoryRequest_Read$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SharedDirectoryRequest_Write$Type extends MessageType<SharedDirectoryRequest_Write> {
    constructor() {
        super("teleport.desktop.v1.SharedDirectoryRequest.Write", [
            { no: 1, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "offset", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SharedDirectoryRequest_Write>): SharedDirectoryRequest_Write {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.path = "";
        message.offset = 0n;
        message.data = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<SharedDirectoryRequest_Write>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SharedDirectoryRequest_Write): SharedDirectoryRequest_Write {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string path */ 1:
                    message.path = reader.string();
                    break;
                case /* uint64 offset */ 2:
                    message.offset = reader.uint64().toBigInt();
                    break;
                case /* bytes data */ 3:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SharedDirectoryRequest_Write, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string path = 1; */
        if (message.path !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.path);
        /* uint64 offset = 2; */
        if (message.offset !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.offset);
        /* bytes data = 3; */
        if (message.data.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.SharedDirectoryRequest.Write
 */
export const SharedDirectoryRequest_Write = new SharedDirectoryRequest_Write$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SharedDirectoryRequest_Move$Type extends MessageType<SharedDirectoryRequest_Move> {
    constructor() {
        super("teleport.desktop.v1.SharedDirectoryRequest.Move", [
            { no: 1, name: "original_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "new_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SharedDirectoryRequest_Move>): SharedDirectoryRequest_Move {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.originalPath = "";
        message.newPath = "";
        if (value !== undefined)
            reflectionMergePartial<SharedDirectoryRequest_Move>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SharedDirectoryRequest_Move): SharedDirectoryRequest_Move {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string original_path */ 1:
                    message.originalPath = reader.string();
                    break;
                case /* string new_path */ 2:
                    message.newPath = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SharedDirectoryRequest_Move, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string original_path = 1; */
        if (message.originalPath !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.originalPath);
        /* string new_path = 2; */
        if (message.newPath !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.newPath);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.SharedDirectoryRequest.Move
 */
export const SharedDirectoryRequest_Move = new SharedDirectoryRequest_Move$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SharedDirectoryRequest_Truncate$Type extends MessageType<SharedDirectoryRequest_Truncate> {
    constructor() {
        super("teleport.desktop.v1.SharedDirectoryRequest.Truncate", [
            { no: 1, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "end_of_file", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SharedDirectoryRequest_Truncate>): SharedDirectoryRequest_Truncate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.path = "";
        message.endOfFile = 0;
        if (value !== undefined)
            reflectionMergePartial<SharedDirectoryRequest_Truncate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SharedDirectoryRequest_Truncate): SharedDirectoryRequest_Truncate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string path */ 1:
                    message.path = reader.string();
                    break;
                case /* uint32 end_of_file */ 2:
                    message.endOfFile = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SharedDirectoryRequest_Truncate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string path = 1; */
        if (message.path !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.path);
        /* uint32 end_of_file = 2; */
        if (message.endOfFile !== 0)
            writer.tag(2, WireType.Varint).uint32(message.endOfFile);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.SharedDirectoryRequest.Truncate
 */
export const SharedDirectoryRequest_Truncate = new SharedDirectoryRequest_Truncate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SharedDirectoryResponse$Type extends MessageType<SharedDirectoryResponse> {
    constructor() {
        super("teleport.desktop.v1.SharedDirectoryResponse", [
            { no: 1, name: "completion_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "error_code", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "info", kind: "message", oneof: "operation", T: () => SharedDirectoryResponse_Info },
            { no: 4, name: "create", kind: "message", oneof: "operation", T: () => SharedDirectoryResponse_Create },
            { no: 5, name: "delete", kind: "message", oneof: "operation", T: () => SharedDirectoryResponse_Delete },
            { no: 6, name: "list", kind: "message", oneof: "operation", T: () => SharedDirectoryResponse_List },
            { no: 7, name: "read", kind: "message", oneof: "operation", T: () => SharedDirectoryResponse_Read },
            { no: 8, name: "write", kind: "message", oneof: "operation", T: () => SharedDirectoryResponse_Write },
            { no: 9, name: "move", kind: "message", oneof: "operation", T: () => SharedDirectoryResponse_Move },
            { no: 10, name: "truncate", kind: "message", oneof: "operation", T: () => SharedDirectoryResponse_Truncate }
        ]);
    }
    create(value?: PartialMessage<SharedDirectoryResponse>): SharedDirectoryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.completionId = 0;
        message.errorCode = 0;
        message.operation = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<SharedDirectoryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SharedDirectoryResponse): SharedDirectoryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 completion_id */ 1:
                    message.completionId = reader.uint32();
                    break;
                case /* uint32 error_code */ 2:
                    message.errorCode = reader.uint32();
                    break;
                case /* teleport.desktop.v1.SharedDirectoryResponse.Info info */ 3:
                    message.operation = {
                        oneofKind: "info",
                        info: SharedDirectoryResponse_Info.internalBinaryRead(reader, reader.uint32(), options, (message.operation as any).info)
                    };
                    break;
                case /* teleport.desktop.v1.SharedDirectoryResponse.Create create */ 4:
                    message.operation = {
                        oneofKind: "create",
                        create: SharedDirectoryResponse_Create.internalBinaryRead(reader, reader.uint32(), options, (message.operation as any).create)
                    };
                    break;
                case /* teleport.desktop.v1.SharedDirectoryResponse.Delete delete */ 5:
                    message.operation = {
                        oneofKind: "delete",
                        delete: SharedDirectoryResponse_Delete.internalBinaryRead(reader, reader.uint32(), options, (message.operation as any).delete)
                    };
                    break;
                case /* teleport.desktop.v1.SharedDirectoryResponse.List list */ 6:
                    message.operation = {
                        oneofKind: "list",
                        list: SharedDirectoryResponse_List.internalBinaryRead(reader, reader.uint32(), options, (message.operation as any).list)
                    };
                    break;
                case /* teleport.desktop.v1.SharedDirectoryResponse.Read read */ 7:
                    message.operation = {
                        oneofKind: "read",
                        read: SharedDirectoryResponse_Read.internalBinaryRead(reader, reader.uint32(), options, (message.operation as any).read)
                    };
                    break;
                case /* teleport.desktop.v1.SharedDirectoryResponse.Write write */ 8:
                    message.operation = {
                        oneofKind: "write",
                        write: SharedDirectoryResponse_Write.internalBinaryRead(reader, reader.uint32(), options, (message.operation as any).write)
                    };
                    break;
                case /* teleport.desktop.v1.SharedDirectoryResponse.Move move */ 9:
                    message.operation = {
                        oneofKind: "move",
                        move: SharedDirectoryResponse_Move.internalBinaryRead(reader, reader.uint32(), options, (message.operation as any).move)
                    };
                    break;
                case /* teleport.desktop.v1.SharedDirectoryResponse.Truncate truncate */ 10:
                    message.operation = {
                        oneofKind: "truncate",
                        truncate: SharedDirectoryResponse_Truncate.internalBinaryRead(reader, reader.uint32(), options, (message.operation as any).truncate)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SharedDirectoryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 completion_id = 1; */
        if (message.completionId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.completionId);
        /* uint32 error_code = 2; */
        if (message.errorCode !== 0)
            writer.tag(2, WireType.Varint).uint32(message.errorCode);
        /* teleport.desktop.v1.SharedDirectoryResponse.Info info = 3; */
        if (message.operation.oneofKind === "info")
            SharedDirectoryResponse_Info.internalBinaryWrite(message.operation.info, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* teleport.desktop.v1.SharedDirectoryResponse.Create create = 4; */
        if (message.operation.oneofKind === "create")
            SharedDirectoryResponse_Create.internalBinaryWrite(message.operation.create, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* teleport.desktop.v1.SharedDirectoryResponse.Delete delete = 5; */
        if (message.operation.oneofKind === "delete")
            SharedDirectoryResponse_Delete.internalBinaryWrite(message.operation.delete, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* teleport.desktop.v1.SharedDirectoryResponse.List list = 6; */
        if (message.operation.oneofKind === "list")
            SharedDirectoryResponse_List.internalBinaryWrite(message.operation.list, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* teleport.desktop.v1.SharedDirectoryResponse.Read read = 7; */
        if (message.operation.oneofKind === "read")
            SharedDirectoryResponse_Read.internalBinaryWrite(message.operation.read, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* teleport.desktop.v1.SharedDirectoryResponse.Write write = 8; */
        if (message.operation.oneofKind === "write")
            SharedDirectoryResponse_Write.internalBinaryWrite(message.operation.write, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* teleport.desktop.v1.SharedDirectoryResponse.Move move = 9; */
        if (message.operation.oneofKind === "move")
            SharedDirectoryResponse_Move.internalBinaryWrite(message.operation.move, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* teleport.desktop.v1.SharedDirectoryResponse.Truncate truncate = 10; */
        if (message.operation.oneofKind === "truncate")
            SharedDirectoryResponse_Truncate.internalBinaryWrite(message.operation.truncate, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.SharedDirectoryResponse
 */
export const SharedDirectoryResponse = new SharedDirectoryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SharedDirectoryResponse_Info$Type extends MessageType<SharedDirectoryResponse_Info> {
    constructor() {
        super("teleport.desktop.v1.SharedDirectoryResponse.Info", [
            { no: 1, name: "fso", kind: "message", T: () => FileSystemObject }
        ]);
    }
    create(value?: PartialMessage<SharedDirectoryResponse_Info>): SharedDirectoryResponse_Info {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SharedDirectoryResponse_Info>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SharedDirectoryResponse_Info): SharedDirectoryResponse_Info {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.desktop.v1.FileSystemObject fso */ 1:
                    message.fso = FileSystemObject.internalBinaryRead(reader, reader.uint32(), options, message.fso);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SharedDirectoryResponse_Info, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.desktop.v1.FileSystemObject fso = 1; */
        if (message.fso)
            FileSystemObject.internalBinaryWrite(message.fso, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.SharedDirectoryResponse.Info
 */
export const SharedDirectoryResponse_Info = new SharedDirectoryResponse_Info$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SharedDirectoryResponse_Create$Type extends MessageType<SharedDirectoryResponse_Create> {
    constructor() {
        super("teleport.desktop.v1.SharedDirectoryResponse.Create", [
            { no: 1, name: "fso", kind: "message", T: () => FileSystemObject }
        ]);
    }
    create(value?: PartialMessage<SharedDirectoryResponse_Create>): SharedDirectoryResponse_Create {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SharedDirectoryResponse_Create>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SharedDirectoryResponse_Create): SharedDirectoryResponse_Create {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.desktop.v1.FileSystemObject fso */ 1:
                    message.fso = FileSystemObject.internalBinaryRead(reader, reader.uint32(), options, message.fso);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SharedDirectoryResponse_Create, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.desktop.v1.FileSystemObject fso = 1; */
        if (message.fso)
            FileSystemObject.internalBinaryWrite(message.fso, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.SharedDirectoryResponse.Create
 */
export const SharedDirectoryResponse_Create = new SharedDirectoryResponse_Create$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SharedDirectoryResponse_Delete$Type extends MessageType<SharedDirectoryResponse_Delete> {
    constructor() {
        super("teleport.desktop.v1.SharedDirectoryResponse.Delete", []);
    }
    create(value?: PartialMessage<SharedDirectoryResponse_Delete>): SharedDirectoryResponse_Delete {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SharedDirectoryResponse_Delete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SharedDirectoryResponse_Delete): SharedDirectoryResponse_Delete {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SharedDirectoryResponse_Delete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.SharedDirectoryResponse.Delete
 */
export const SharedDirectoryResponse_Delete = new SharedDirectoryResponse_Delete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SharedDirectoryResponse_List$Type extends MessageType<SharedDirectoryResponse_List> {
    constructor() {
        super("teleport.desktop.v1.SharedDirectoryResponse.List", [
            { no: 1, name: "fso_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => FileSystemObject }
        ]);
    }
    create(value?: PartialMessage<SharedDirectoryResponse_List>): SharedDirectoryResponse_List {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fsoList = [];
        if (value !== undefined)
            reflectionMergePartial<SharedDirectoryResponse_List>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SharedDirectoryResponse_List): SharedDirectoryResponse_List {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated teleport.desktop.v1.FileSystemObject fso_list */ 1:
                    message.fsoList.push(FileSystemObject.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SharedDirectoryResponse_List, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated teleport.desktop.v1.FileSystemObject fso_list = 1; */
        for (let i = 0; i < message.fsoList.length; i++)
            FileSystemObject.internalBinaryWrite(message.fsoList[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.SharedDirectoryResponse.List
 */
export const SharedDirectoryResponse_List = new SharedDirectoryResponse_List$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SharedDirectoryResponse_Read$Type extends MessageType<SharedDirectoryResponse_Read> {
    constructor() {
        super("teleport.desktop.v1.SharedDirectoryResponse.Read", [
            { no: 1, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SharedDirectoryResponse_Read>): SharedDirectoryResponse_Read {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<SharedDirectoryResponse_Read>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SharedDirectoryResponse_Read): SharedDirectoryResponse_Read {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes data */ 1:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SharedDirectoryResponse_Read, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes data = 1; */
        if (message.data.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.SharedDirectoryResponse.Read
 */
export const SharedDirectoryResponse_Read = new SharedDirectoryResponse_Read$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SharedDirectoryResponse_Write$Type extends MessageType<SharedDirectoryResponse_Write> {
    constructor() {
        super("teleport.desktop.v1.SharedDirectoryResponse.Write", [
            { no: 1, name: "bytes_written", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SharedDirectoryResponse_Write>): SharedDirectoryResponse_Write {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.bytesWritten = 0;
        if (value !== undefined)
            reflectionMergePartial<SharedDirectoryResponse_Write>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SharedDirectoryResponse_Write): SharedDirectoryResponse_Write {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 bytes_written */ 1:
                    message.bytesWritten = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SharedDirectoryResponse_Write, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 bytes_written = 1; */
        if (message.bytesWritten !== 0)
            writer.tag(1, WireType.Varint).uint32(message.bytesWritten);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.SharedDirectoryResponse.Write
 */
export const SharedDirectoryResponse_Write = new SharedDirectoryResponse_Write$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SharedDirectoryResponse_Move$Type extends MessageType<SharedDirectoryResponse_Move> {
    constructor() {
        super("teleport.desktop.v1.SharedDirectoryResponse.Move", []);
    }
    create(value?: PartialMessage<SharedDirectoryResponse_Move>): SharedDirectoryResponse_Move {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SharedDirectoryResponse_Move>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SharedDirectoryResponse_Move): SharedDirectoryResponse_Move {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SharedDirectoryResponse_Move, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.SharedDirectoryResponse.Move
 */
export const SharedDirectoryResponse_Move = new SharedDirectoryResponse_Move$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SharedDirectoryResponse_Truncate$Type extends MessageType<SharedDirectoryResponse_Truncate> {
    constructor() {
        super("teleport.desktop.v1.SharedDirectoryResponse.Truncate", []);
    }
    create(value?: PartialMessage<SharedDirectoryResponse_Truncate>): SharedDirectoryResponse_Truncate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SharedDirectoryResponse_Truncate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SharedDirectoryResponse_Truncate): SharedDirectoryResponse_Truncate {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SharedDirectoryResponse_Truncate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.SharedDirectoryResponse.Truncate
 */
export const SharedDirectoryResponse_Truncate = new SharedDirectoryResponse_Truncate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FileSystemObject$Type extends MessageType<FileSystemObject> {
    constructor() {
        super("teleport.desktop.v1.FileSystemObject", [
            { no: 1, name: "last_modified", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "size", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "file_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "is_empty", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FileSystemObject>): FileSystemObject {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.lastModified = 0n;
        message.size = 0n;
        message.fileType = 0;
        message.isEmpty = false;
        message.path = "";
        if (value !== undefined)
            reflectionMergePartial<FileSystemObject>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FileSystemObject): FileSystemObject {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 last_modified */ 1:
                    message.lastModified = reader.uint64().toBigInt();
                    break;
                case /* uint64 size */ 2:
                    message.size = reader.uint64().toBigInt();
                    break;
                case /* uint32 file_type */ 3:
                    message.fileType = reader.uint32();
                    break;
                case /* bool is_empty */ 4:
                    message.isEmpty = reader.bool();
                    break;
                case /* string path */ 5:
                    message.path = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FileSystemObject, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 last_modified = 1; */
        if (message.lastModified !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.lastModified);
        /* uint64 size = 2; */
        if (message.size !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.size);
        /* uint32 file_type = 3; */
        if (message.fileType !== 0)
            writer.tag(3, WireType.Varint).uint32(message.fileType);
        /* bool is_empty = 4; */
        if (message.isEmpty !== false)
            writer.tag(4, WireType.Varint).bool(message.isEmpty);
        /* string path = 5; */
        if (message.path !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.path);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.FileSystemObject
 */
export const FileSystemObject = new FileSystemObject$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LatencyStats$Type extends MessageType<LatencyStats> {
    constructor() {
        super("teleport.desktop.v1.LatencyStats", [
            { no: 1, name: "client_latency_ms", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "server_latency_ms", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<LatencyStats>): LatencyStats {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clientLatencyMs = 0;
        message.serverLatencyMs = 0;
        if (value !== undefined)
            reflectionMergePartial<LatencyStats>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LatencyStats): LatencyStats {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 client_latency_ms */ 1:
                    message.clientLatencyMs = reader.uint32();
                    break;
                case /* uint32 server_latency_ms */ 2:
                    message.serverLatencyMs = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LatencyStats, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 client_latency_ms = 1; */
        if (message.clientLatencyMs !== 0)
            writer.tag(1, WireType.Varint).uint32(message.clientLatencyMs);
        /* uint32 server_latency_ms = 2; */
        if (message.serverLatencyMs !== 0)
            writer.tag(2, WireType.Varint).uint32(message.serverLatencyMs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.LatencyStats
 */
export const LatencyStats = new LatencyStats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Ping$Type extends MessageType<Ping> {
    constructor() {
        super("teleport.desktop.v1.Ping", [
            { no: 1, name: "uuid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Ping>): Ping {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<Ping>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Ping): Ping {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes uuid */ 1:
                    message.uuid = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Ping, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes uuid = 1; */
        if (message.uuid.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.uuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.Ping
 */
export const Ping = new Ping$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Envelope$Type extends MessageType<Envelope> {
    constructor() {
        super("teleport.desktop.v1.Envelope", [
            { no: 1, name: "client_hello", kind: "message", oneof: "payload", T: () => ClientHello },
            { no: 2, name: "server_hello", kind: "message", oneof: "payload", T: () => ServerHello },
            { no: 3, name: "png_frame", kind: "message", oneof: "payload", T: () => PNGFrame },
            { no: 4, name: "fast_path_pdu", kind: "message", oneof: "payload", T: () => FastPathPDU },
            { no: 5, name: "rdp_response_pdu", kind: "message", oneof: "payload", T: () => RDPResponsePDU },
            { no: 6, name: "sync_keys", kind: "message", oneof: "payload", T: () => SyncKeys },
            { no: 7, name: "mouse_move", kind: "message", oneof: "payload", T: () => MouseMove },
            { no: 8, name: "mouse_button", kind: "message", oneof: "payload", T: () => MouseButton },
            { no: 9, name: "keyboard_button", kind: "message", oneof: "payload", T: () => KeyboardButton },
            { no: 10, name: "client_screen_spec", kind: "message", oneof: "payload", T: () => ClientScreenSpec },
            { no: 11, name: "alert", kind: "message", oneof: "payload", T: () => Alert },
            { no: 12, name: "mouse_wheel", kind: "message", oneof: "payload", T: () => MouseWheel },
            { no: 13, name: "clipboard_data", kind: "message", oneof: "payload", T: () => ClipboardData },
            { no: 14, name: "mfa", kind: "message", oneof: "payload", T: () => MFA },
            { no: 15, name: "shared_directory_announce", kind: "message", oneof: "payload", T: () => SharedDirectoryAnnounce },
            { no: 16, name: "shared_directory_acknowledge", kind: "message", oneof: "payload", T: () => SharedDirectoryAcknowledge },
            { no: 17, name: "shared_directory_request", kind: "message", oneof: "payload", T: () => SharedDirectoryRequest },
            { no: 18, name: "shared_directory_response", kind: "message", oneof: "payload", T: () => SharedDirectoryResponse },
            { no: 19, name: "latency_stats", kind: "message", oneof: "payload", T: () => LatencyStats },
            { no: 20, name: "ping", kind: "message", oneof: "payload", T: () => Ping }
        ]);
    }
    create(value?: PartialMessage<Envelope>): Envelope {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.payload = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Envelope>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Envelope): Envelope {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.desktop.v1.ClientHello client_hello */ 1:
                    message.payload = {
                        oneofKind: "clientHello",
                        clientHello: ClientHello.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).clientHello)
                    };
                    break;
                case /* teleport.desktop.v1.ServerHello server_hello */ 2:
                    message.payload = {
                        oneofKind: "serverHello",
                        serverHello: ServerHello.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).serverHello)
                    };
                    break;
                case /* teleport.desktop.v1.PNGFrame png_frame */ 3:
                    message.payload = {
                        oneofKind: "pngFrame",
                        pngFrame: PNGFrame.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).pngFrame)
                    };
                    break;
                case /* teleport.desktop.v1.FastPathPDU fast_path_pdu */ 4:
                    message.payload = {
                        oneofKind: "fastPathPdu",
                        fastPathPdu: FastPathPDU.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).fastPathPdu)
                    };
                    break;
                case /* teleport.desktop.v1.RDPResponsePDU rdp_response_pdu */ 5:
                    message.payload = {
                        oneofKind: "rdpResponsePdu",
                        rdpResponsePdu: RDPResponsePDU.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).rdpResponsePdu)
                    };
                    break;
                case /* teleport.desktop.v1.SyncKeys sync_keys */ 6:
                    message.payload = {
                        oneofKind: "syncKeys",
                        syncKeys: SyncKeys.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).syncKeys)
                    };
                    break;
                case /* teleport.desktop.v1.MouseMove mouse_move */ 7:
                    message.payload = {
                        oneofKind: "mouseMove",
                        mouseMove: MouseMove.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).mouseMove)
                    };
                    break;
                case /* teleport.desktop.v1.MouseButton mouse_button */ 8:
                    message.payload = {
                        oneofKind: "mouseButton",
                        mouseButton: MouseButton.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).mouseButton)
                    };
                    break;
                case /* teleport.desktop.v1.KeyboardButton keyboard_button */ 9:
                    message.payload = {
                        oneofKind: "keyboardButton",
                        keyboardButton: KeyboardButton.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).keyboardButton)
                    };
                    break;
                case /* teleport.desktop.v1.ClientScreenSpec client_screen_spec */ 10:
                    message.payload = {
                        oneofKind: "clientScreenSpec",
                        clientScreenSpec: ClientScreenSpec.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).clientScreenSpec)
                    };
                    break;
                case /* teleport.desktop.v1.Alert alert */ 11:
                    message.payload = {
                        oneofKind: "alert",
                        alert: Alert.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).alert)
                    };
                    break;
                case /* teleport.desktop.v1.MouseWheel mouse_wheel */ 12:
                    message.payload = {
                        oneofKind: "mouseWheel",
                        mouseWheel: MouseWheel.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).mouseWheel)
                    };
                    break;
                case /* teleport.desktop.v1.ClipboardData clipboard_data */ 13:
                    message.payload = {
                        oneofKind: "clipboardData",
                        clipboardData: ClipboardData.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).clipboardData)
                    };
                    break;
                case /* teleport.desktop.v1.MFA mfa */ 14:
                    message.payload = {
                        oneofKind: "mfa",
                        mfa: MFA.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).mfa)
                    };
                    break;
                case /* teleport.desktop.v1.SharedDirectoryAnnounce shared_directory_announce */ 15:
                    message.payload = {
                        oneofKind: "sharedDirectoryAnnounce",
                        sharedDirectoryAnnounce: SharedDirectoryAnnounce.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).sharedDirectoryAnnounce)
                    };
                    break;
                case /* teleport.desktop.v1.SharedDirectoryAcknowledge shared_directory_acknowledge */ 16:
                    message.payload = {
                        oneofKind: "sharedDirectoryAcknowledge",
                        sharedDirectoryAcknowledge: SharedDirectoryAcknowledge.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).sharedDirectoryAcknowledge)
                    };
                    break;
                case /* teleport.desktop.v1.SharedDirectoryRequest shared_directory_request */ 17:
                    message.payload = {
                        oneofKind: "sharedDirectoryRequest",
                        sharedDirectoryRequest: SharedDirectoryRequest.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).sharedDirectoryRequest)
                    };
                    break;
                case /* teleport.desktop.v1.SharedDirectoryResponse shared_directory_response */ 18:
                    message.payload = {
                        oneofKind: "sharedDirectoryResponse",
                        sharedDirectoryResponse: SharedDirectoryResponse.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).sharedDirectoryResponse)
                    };
                    break;
                case /* teleport.desktop.v1.LatencyStats latency_stats */ 19:
                    message.payload = {
                        oneofKind: "latencyStats",
                        latencyStats: LatencyStats.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).latencyStats)
                    };
                    break;
                case /* teleport.desktop.v1.Ping ping */ 20:
                    message.payload = {
                        oneofKind: "ping",
                        ping: Ping.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).ping)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Envelope, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.desktop.v1.ClientHello client_hello = 1; */
        if (message.payload.oneofKind === "clientHello")
            ClientHello.internalBinaryWrite(message.payload.clientHello, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* teleport.desktop.v1.ServerHello server_hello = 2; */
        if (message.payload.oneofKind === "serverHello")
            ServerHello.internalBinaryWrite(message.payload.serverHello, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* teleport.desktop.v1.PNGFrame png_frame = 3; */
        if (message.payload.oneofKind === "pngFrame")
            PNGFrame.internalBinaryWrite(message.payload.pngFrame, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* teleport.desktop.v1.FastPathPDU fast_path_pdu = 4; */
        if (message.payload.oneofKind === "fastPathPdu")
            FastPathPDU.internalBinaryWrite(message.payload.fastPathPdu, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* teleport.desktop.v1.RDPResponsePDU rdp_response_pdu = 5; */
        if (message.payload.oneofKind === "rdpResponsePdu")
            RDPResponsePDU.internalBinaryWrite(message.payload.rdpResponsePdu, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* teleport.desktop.v1.SyncKeys sync_keys = 6; */
        if (message.payload.oneofKind === "syncKeys")
            SyncKeys.internalBinaryWrite(message.payload.syncKeys, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* teleport.desktop.v1.MouseMove mouse_move = 7; */
        if (message.payload.oneofKind === "mouseMove")
            MouseMove.internalBinaryWrite(message.payload.mouseMove, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* teleport.desktop.v1.MouseButton mouse_button = 8; */
        if (message.payload.oneofKind === "mouseButton")
            MouseButton.internalBinaryWrite(message.payload.mouseButton, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* teleport.desktop.v1.KeyboardButton keyboard_button = 9; */
        if (message.payload.oneofKind === "keyboardButton")
            KeyboardButton.internalBinaryWrite(message.payload.keyboardButton, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* teleport.desktop.v1.ClientScreenSpec client_screen_spec = 10; */
        if (message.payload.oneofKind === "clientScreenSpec")
            ClientScreenSpec.internalBinaryWrite(message.payload.clientScreenSpec, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* teleport.desktop.v1.Alert alert = 11; */
        if (message.payload.oneofKind === "alert")
            Alert.internalBinaryWrite(message.payload.alert, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* teleport.desktop.v1.MouseWheel mouse_wheel = 12; */
        if (message.payload.oneofKind === "mouseWheel")
            MouseWheel.internalBinaryWrite(message.payload.mouseWheel, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* teleport.desktop.v1.ClipboardData clipboard_data = 13; */
        if (message.payload.oneofKind === "clipboardData")
            ClipboardData.internalBinaryWrite(message.payload.clipboardData, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* teleport.desktop.v1.MFA mfa = 14; */
        if (message.payload.oneofKind === "mfa")
            MFA.internalBinaryWrite(message.payload.mfa, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* teleport.desktop.v1.SharedDirectoryAnnounce shared_directory_announce = 15; */
        if (message.payload.oneofKind === "sharedDirectoryAnnounce")
            SharedDirectoryAnnounce.internalBinaryWrite(message.payload.sharedDirectoryAnnounce, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* teleport.desktop.v1.SharedDirectoryAcknowledge shared_directory_acknowledge = 16; */
        if (message.payload.oneofKind === "sharedDirectoryAcknowledge")
            SharedDirectoryAcknowledge.internalBinaryWrite(message.payload.sharedDirectoryAcknowledge, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* teleport.desktop.v1.SharedDirectoryRequest shared_directory_request = 17; */
        if (message.payload.oneofKind === "sharedDirectoryRequest")
            SharedDirectoryRequest.internalBinaryWrite(message.payload.sharedDirectoryRequest, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* teleport.desktop.v1.SharedDirectoryResponse shared_directory_response = 18; */
        if (message.payload.oneofKind === "sharedDirectoryResponse")
            SharedDirectoryResponse.internalBinaryWrite(message.payload.sharedDirectoryResponse, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* teleport.desktop.v1.LatencyStats latency_stats = 19; */
        if (message.payload.oneofKind === "latencyStats")
            LatencyStats.internalBinaryWrite(message.payload.latencyStats, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* teleport.desktop.v1.Ping ping = 20; */
        if (message.payload.oneofKind === "ping")
            Ping.internalBinaryWrite(message.payload.ping, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.Envelope
 */
export const Envelope = new Envelope$Type();
