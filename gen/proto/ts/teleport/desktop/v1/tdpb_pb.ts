/* eslint-disable */
// @generated by protobuf-ts 2.9.3 with parameter add_pb_suffix,eslint_disable,generate_dependencies,server_grpc1,ts_nocheck
// @generated from protobuf file "teleport/desktop/v1/tdpb.proto" (package "teleport.desktop.v1", syntax proto3)
// tslint:disable
// @ts-nocheck
//
//
// Teleport
// Copyright (C) 2025  Gravitational, Inc.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType as MessageType$ } from "@protobuf-ts/runtime";
import { AuthenticateResponse } from "../../mfa/v1/challenge_pb";
import { AuthenticateChallenge } from "../../mfa/v1/challenge_pb";
/**
 * Sent by client to begin a TDPB connection and advertise capabilities.
 *
 * @generated from protobuf message teleport.desktop.v1.ClientHello
 */
export interface ClientHello {
    /**
     * @generated from protobuf field: string username = 1;
     */
    username: string;
    /**
     * @generated from protobuf field: teleport.desktop.v1.ClientScreenSpec screen_spec = 2;
     */
    screenSpec?: ClientScreenSpec;
    /**
     * @generated from protobuf field: uint32 keyboard_layout = 3;
     */
    keyboardLayout: number;
}
/**
 * Sent by server in response to a 'Client Hello'. Advertises server capabilities.
 *
 * @generated from protobuf message teleport.desktop.v1.ServerHello
 */
export interface ServerHello {
    /**
     * @generated from protobuf field: teleport.desktop.v1.ConnectionActivated activation_spec = 1;
     */
    activationSpec?: ConnectionActivated;
    /**
     * @generated from protobuf field: bool clipboard_enabled = 2;
     */
    clipboardEnabled: boolean;
}
/**
 * Defines the boundaries that PNG frame will update.
 * Used for composition on PNG frame messages only.
 *
 * @generated from protobuf message teleport.desktop.v1.Rectangle
 */
export interface Rectangle {
    /**
     * @generated from protobuf field: uint32 left = 1;
     */
    left: number;
    /**
     * @generated from protobuf field: uint32 top = 2;
     */
    top: number;
    /**
     * @generated from protobuf field: uint32 right = 3;
     */
    right: number;
    /**
     * @generated from protobuf field: uint32 bottom = 4;
     */
    bottom: number;
}
/**
 * Contains updated image data to be displayed.
 *
 * @generated from protobuf message teleport.desktop.v1.PNGFrame
 */
export interface PNGFrame {
    /**
     * @generated from protobuf field: teleport.desktop.v1.Rectangle coordinates = 1;
     */
    coordinates?: Rectangle;
    /**
     * @generated from protobuf field: bytes data = 2;
     */
    data: Uint8Array;
}
/**
 * Contains a raw RDP FastPath message to by interpreted by the client.
 *
 * @generated from protobuf message teleport.desktop.v1.FastPathPDU
 */
export interface FastPathPDU {
    /**
     * @generated from protobuf field: bytes pdu = 1;
     */
    pdu: Uint8Array;
}
/**
 * Contains a raw RDP response PDU to send be interpreted by the server.
 *
 * @generated from protobuf message teleport.desktop.v1.RDPResponsePDU
 */
export interface RDPResponsePDU {
    /**
     * @generated from protobuf field: bytes response = 1;
     */
    response: Uint8Array;
}
/**
 * Internal message sent by the server after establishing a connection
 * to the RDP host.
 *
 * @generated from protobuf message teleport.desktop.v1.ConnectionActivated
 */
export interface ConnectionActivated {
    /**
     * @generated from protobuf field: uint32 io_channel_id = 1;
     */
    ioChannelId: number;
    /**
     * @generated from protobuf field: uint32 user_channel_id = 2;
     */
    userChannelId: number;
    /**
     * @generated from protobuf field: uint32 screen_width = 3;
     */
    screenWidth: number;
    /**
     * @generated from protobuf field: uint32 screen_height = 4;
     */
    screenHeight: number;
}
/**
 * Conveys the current state of keyboard buttons with persistent state.
 *
 * @generated from protobuf message teleport.desktop.v1.SyncKeys
 */
export interface SyncKeys {
    /**
     * @generated from protobuf field: bool scroll_lock_pressed = 1;
     */
    scrollLockPressed: boolean;
    /**
     * @generated from protobuf field: bool num_lock_state = 2;
     */
    numLockState: boolean;
    /**
     * @generated from protobuf field: bool caps_lock_state = 3;
     */
    capsLockState: boolean;
    /**
     * @generated from protobuf field: bool kana_lock_state = 4;
     */
    kanaLockState: boolean;
}
/**
 * Represents the current position of the cursor on the client.
 *
 * @generated from protobuf message teleport.desktop.v1.MouseMove
 */
export interface MouseMove {
    /**
     * @generated from protobuf field: uint32 x = 1;
     */
    x: number;
    /**
     * @generated from protobuf field: uint32 y = 2;
     */
    y: number;
}
/**
 * Informs the server of a mouse button press.
 *
 * @generated from protobuf message teleport.desktop.v1.MouseButton
 */
export interface MouseButton {
    /**
     * @generated from protobuf field: teleport.desktop.v1.MouseButtonType button = 1;
     */
    button: MouseButtonType;
    /**
     * @generated from protobuf field: bool pressed = 2;
     */
    pressed: boolean;
}
/**
 * Informs the server of a keyboard button press.
 *
 * @generated from protobuf message teleport.desktop.v1.KeyboardButton
 */
export interface KeyboardButton {
    /**
     * @generated from protobuf field: uint32 key_code = 1;
     */
    keyCode: number;
    /**
     * @generated from protobuf field: bool pressed = 2;
     */
    pressed: boolean;
}
/**
 * Composed in Client Hello to inform the server of the client's screen size.
 * May also be sent during a desktop session as the client resizes its display.
 * These mesasages are captured for session recordings in order to replay
 * resizing events.
 *
 * @generated from protobuf message teleport.desktop.v1.ClientScreenSpec
 */
export interface ClientScreenSpec {
    /**
     * @generated from protobuf field: uint32 width = 1;
     */
    width: number;
    /**
     * @generated from protobuf field: uint32 height = 2;
     */
    height: number;
}
/**
 * Represents an Alert to be displayed by the client.
 *
 * @generated from protobuf message teleport.desktop.v1.Alert
 */
export interface Alert {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
    /**
     * @generated from protobuf field: teleport.desktop.v1.AlertSeverity severity = 2;
     */
    severity: AlertSeverity;
}
/**
 * Mouse wheel event
 *
 * @generated from protobuf message teleport.desktop.v1.MouseWheel
 */
export interface MouseWheel {
    /**
     * @generated from protobuf field: teleport.desktop.v1.MouseWheelAxis axis = 1;
     */
    axis: MouseWheelAxis;
    /**
     * @generated from protobuf field: uint32 delta = 2;
     */
    delta: number;
}
/**
 * Represents shared clipboard data.
 *
 * @generated from protobuf message teleport.desktop.v1.ClipboardData
 */
export interface ClipboardData {
    /**
     * @generated from protobuf field: bytes data = 1;
     */
    data: Uint8Array;
}
/**
 * Contains an MFA challenge or response
 * The client implicitly expects a non-empty challenge while the server
 * expects a non-empty response.
 *
 * @generated from protobuf message teleport.desktop.v1.MFA
 */
export interface MFA {
    /**
     * @generated from protobuf field: teleport.desktop.v1.MFAType type = 1;
     */
    type: MFAType;
    /**
     * @generated from protobuf field: string channel_id = 2;
     */
    channelId: string;
    /**
     * @generated from protobuf field: teleport.mfa.v1.AuthenticateChallenge challenge = 3;
     */
    challenge?: AuthenticateChallenge;
    /**
     * @generated from protobuf field: teleport.mfa.v1.AuthenticateResponse authentication_response = 4;
     */
    authenticationResponse?: AuthenticateResponse;
}
/**
 * Sent by client to announce a new shared directory.
 *
 * @generated from protobuf message teleport.desktop.v1.SharedDirectoryAnnounce
 */
export interface SharedDirectoryAnnounce {
    /**
     * @generated from protobuf field: uint32 directory_id = 1;
     */
    directoryId: number;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
}
/**
 * Sent by server to acknowledge a new shared directory.
 *
 * @generated from protobuf message teleport.desktop.v1.SharedDirectoryAcknowledge
 */
export interface SharedDirectoryAcknowledge {
    /**
     * @generated from protobuf field: uint32 directory_id = 1;
     */
    directoryId: number;
    /**
     * @generated from protobuf field: uint32 error_code = 2;
     */
    errorCode: number;
}
/**
 * Contains data necessary for shared directory operations.
 * Not all operation types make use of all fields.
 *
 * @generated from protobuf message teleport.desktop.v1.SharedDirectoryRequest
 */
export interface SharedDirectoryRequest {
    /**
     * Operation type
     *
     * @generated from protobuf field: teleport.desktop.v1.DirectoryOperation operation_code = 1;
     */
    operationCode: DirectoryOperation;
    /**
     * Common fields
     *
     * @generated from protobuf field: uint32 directory_id = 2;
     */
    directoryId: number;
    /**
     * @generated from protobuf field: uint32 completion_id = 3;
     */
    completionId: number;
    /**
     * Subject path for Info and Move requests.
     *
     * @generated from protobuf field: string path = 4;
     */
    path: string;
    /**
     * Destination path for Move requests.
     *
     * @generated from protobuf field: string new_path = 9;
     */
    newPath: string;
    /**
     * Specifies file type in CREATE requests.
     *
     * @generated from protobuf field: uint32 file_type = 5;
     */
    fileType: number;
    /**
     * Specifies offset where the read/write should start
     * in READ and WRITE requests.
     *
     * @generated from protobuf field: uint64 offset = 6;
     */
    offset: bigint;
    /**
     * Requested length to read for READ requests.
     *
     * @generated from protobuf field: uint32 length = 7;
     */
    length: number;
    /**
     * For TRUNCATE requests.
     *
     * @generated from protobuf field: uint32 end_of_file = 8;
     */
    endOfFile: number;
    /**
     * Data to be written in WRITE requests.
     *
     * @generated from protobuf field: bytes data = 10;
     */
    data: Uint8Array;
    /**
     * Defines the shared directory name in
     * ANNOUNCE operations.
     *
     * @generated from protobuf field: string name = 11;
     */
    name: string;
}
/**
 * Contains data necessary for responses to shared directory operations.
 * Not all operation types make use of all fields.
 *
 * @generated from protobuf message teleport.desktop.v1.SharedDirectoryResponse
 */
export interface SharedDirectoryResponse {
    /**
     * Operation type
     *
     * @generated from protobuf field: teleport.desktop.v1.DirectoryOperation operation_code = 1;
     */
    operationCode: DirectoryOperation;
    /**
     * Common response fields
     *
     * @generated from protobuf field: uint32 completion_id = 2;
     */
    completionId: number;
    /**
     * @generated from protobuf field: uint32 error_code = 3;
     */
    errorCode: number;
    /**
     * Returned FileSystemObject(s) for INFO and LIST responses.
     *
     * @generated from protobuf field: repeated teleport.desktop.v1.FileSystemObject fso_list = 4;
     */
    fsoList: FileSystemObject[];
    /**
     * Data returned in READ responses.
     *
     * @generated from protobuf field: bytes data = 5;
     */
    data: Uint8Array;
    /**
     * Returned in WRITE responses.
     *
     * @generated from protobuf field: uint32 bytes_written = 6;
     */
    bytesWritten: number;
}
/**
 * Represents a file object in a shared directory.
 *
 * @generated from protobuf message teleport.desktop.v1.FileSystemObject
 */
export interface FileSystemObject {
    /**
     * @generated from protobuf field: uint64 last_modified = 1;
     */
    lastModified: bigint;
    /**
     * @generated from protobuf field: uint64 size = 2;
     */
    size: bigint;
    /**
     * @generated from protobuf field: uint32 file_type = 3;
     */
    fileType: number;
    /**
     * @generated from protobuf field: bool is_empty = 4;
     */
    isEmpty: boolean;
    /**
     * @generated from protobuf field: string path = 5;
     */
    path: string;
}
/**
 * Contains latency metrics between the proxy and RDP host
 * as well as between the proxy and client.
 *
 * @generated from protobuf message teleport.desktop.v1.LatencyStats
 */
export interface LatencyStats {
    /**
     * @generated from protobuf field: uint32 client_latency = 1;
     */
    clientLatency: number;
    /**
     * @generated from protobuf field: uint32 server_latency = 2;
     */
    serverLatency: number;
}
/**
 * A ping message used to time latency between the web client and proxy.
 *
 * @generated from protobuf message teleport.desktop.v1.Ping
 */
export interface Ping {
    /**
     * UUID is used to correlate message send by proxy and received from the Windows Desktop Service
     *
     * @generated from protobuf field: bytes uuid = 1;
     */
    uuid: Uint8Array;
}
/**
 * Types of messages that TDPB implementations will exchange
 *
 * @generated from protobuf enum teleport.desktop.v1.MessageType
 */
export enum MessageType {
    /**
     * @generated from protobuf enum value: MESSAGE_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: MESSAGE_TYPE_PNG_FRAME = 1;
     */
    PNG_FRAME = 1,
    /**
     * @generated from protobuf enum value: MESSAGE_TYPE_FASTPATH_PDU = 2;
     */
    FASTPATH_PDU = 2,
    /**
     * @generated from protobuf enum value: MESSAGE_TYPE_RDP_RESPONSE_PDU = 3;
     */
    RDP_RESPONSE_PDU = 3,
    /**
     * @generated from protobuf enum value: MESSAGE_TYPE_SYNC_KEYS = 4;
     */
    SYNC_KEYS = 4,
    /**
     * @generated from protobuf enum value: MESSAGE_TYPE_MOUSE_MOVE = 5;
     */
    MOUSE_MOVE = 5,
    /**
     * @generated from protobuf enum value: MESSAGE_TYPE_MOUSE_BUTTON = 6;
     */
    MOUSE_BUTTON = 6,
    /**
     * @generated from protobuf enum value: MESSAGE_TYPE_KEYBOARD_BUTTON = 7;
     */
    KEYBOARD_BUTTON = 7,
    /**
     * @generated from protobuf enum value: MESSAGE_TYPE_ALERT = 8;
     */
    ALERT = 8,
    /**
     * @generated from protobuf enum value: MESSAGE_TYPE_MOUSE_WHEEL = 9;
     */
    MOUSE_WHEEL = 9,
    /**
     * @generated from protobuf enum value: MESSAGE_TYPE_CLIPBOARD_DATA = 10;
     */
    CLIPBOARD_DATA = 10,
    /**
     * @generated from protobuf enum value: MESSAGE_TYPE_MFA = 11;
     */
    MFA = 11,
    /**
     * @generated from protobuf enum value: MESSAGE_TYPE_SHARED_DIRECTORY_REQUEST = 12;
     */
    SHARED_DIRECTORY_REQUEST = 12,
    /**
     * @generated from protobuf enum value: MESSAGE_TYPE_SHARED_DIRECTORY_RESPONSE = 13;
     */
    SHARED_DIRECTORY_RESPONSE = 13,
    /**
     * @generated from protobuf enum value: MESSAGE_TYPE_SHARED_DIRECTORY_ANNOUNCE = 14;
     */
    SHARED_DIRECTORY_ANNOUNCE = 14,
    /**
     * @generated from protobuf enum value: MESSAGE_TYPE_SHARED_DIRECTORY_ACKNOWLEDGE = 15;
     */
    SHARED_DIRECTORY_ACKNOWLEDGE = 15,
    /**
     * @generated from protobuf enum value: MESSAGE_TYPE_LATENCY_STATS = 16;
     */
    LATENCY_STATS = 16,
    /**
     * @generated from protobuf enum value: MESSAGE_TYPE_PING = 17;
     */
    PING = 17,
    /**
     * @generated from protobuf enum value: MESSAGE_TYPE_CLIENT_HELLO = 18;
     */
    CLIENT_HELLO = 18,
    /**
     * @generated from protobuf enum value: MESSAGE_TYPE_SERVER_HELLO = 19;
     */
    SERVER_HELLO = 19,
    /**
     * @generated from protobuf enum value: MESSAGE_TYPE_CLIENT_SCREEN_SPEC = 20;
     */
    CLIENT_SCREEN_SPEC = 20
}
/**
 * Specifies which mount button was pressed.
 *
 * @generated from protobuf enum teleport.desktop.v1.MouseButtonType
 */
export enum MouseButtonType {
    /**
     * @generated from protobuf enum value: MOUSE_BUTTON_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: MOUSE_BUTTON_TYPE_LEFT = 1;
     */
    LEFT = 1,
    /**
     * @generated from protobuf enum value: MOUSE_BUTTON_TYPE_MIDDLE = 2;
     */
    MIDDLE = 2,
    /**
     * @generated from protobuf enum value: MOUSE_BUTTON_TYPE_RIGHT = 3;
     */
    RIGHT = 3
}
/**
 * Severity of an alert contained in an Alert message.
 *
 * @generated from protobuf enum teleport.desktop.v1.AlertSeverity
 */
export enum AlertSeverity {
    /**
     * @generated from protobuf enum value: ALERT_SEVERITY_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: ALERT_SEVERITY_INFO = 1;
     */
    INFO = 1,
    /**
     * @generated from protobuf enum value: ALERT_SEVERITY_WARNING = 2;
     */
    WARNING = 2,
    /**
     * @generated from protobuf enum value: ALERT_SEVERITY_ERROR = 3;
     */
    ERROR = 3
}
/**
 * Represents the axis on which a scroll wheel acts.
 *
 * @generated from protobuf enum teleport.desktop.v1.MouseWheelAxis
 */
export enum MouseWheelAxis {
    /**
     * @generated from protobuf enum value: MOUSE_WHEEL_AXIS_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: MOUSE_WHEEL_AXIS_VERTICAL = 1;
     */
    VERTICAL = 1,
    /**
     * @generated from protobuf enum value: MOUSE_WHEEL_AXIS_HORIZONTAL = 2;
     */
    HORIZONTAL = 2
}
/**
 * MFA challenge type
 *
 * @generated from protobuf enum teleport.desktop.v1.MFAType
 */
export enum MFAType {
    /**
     * @generated from protobuf enum value: MFA_TYPE_UNSPECIFIED = 0;
     */
    MFA_TYPE_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: MFA_TYPE_WEBAUTHN = 1;
     */
    MFA_TYPE_WEBAUTHN = 1,
    /**
     * @generated from protobuf enum value: MFA_TYPE_U2F = 2;
     */
    MFA_TYPE_U2F = 2
}
/**
 * Represents an operation on a shared directory.
 *
 * @generated from protobuf enum teleport.desktop.v1.DirectoryOperation
 */
export enum DirectoryOperation {
    /**
     * @generated from protobuf enum value: DIRECTORY_OPERATION_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: DIRECTORY_OPERATION_INFO = 1;
     */
    INFO = 1,
    /**
     * @generated from protobuf enum value: DIRECTORY_OPERATION_CREATE = 2;
     */
    CREATE = 2,
    /**
     * @generated from protobuf enum value: DIRECTORY_OPERATION_DELETE = 3;
     */
    DELETE = 3,
    /**
     * @generated from protobuf enum value: DIRECTORY_OPERATION_LIST = 4;
     */
    LIST = 4,
    /**
     * @generated from protobuf enum value: DIRECTORY_OPERATION_READ = 5;
     */
    READ = 5,
    /**
     * @generated from protobuf enum value: DIRECTORY_OPERATION_WRITE = 6;
     */
    WRITE = 6,
    /**
     * @generated from protobuf enum value: DIRECTORY_OPERATION_MOVE = 7;
     */
    MOVE = 7,
    /**
     * @generated from protobuf enum value: DIRECTORY_OPERATION_TRUNCATE = 8;
     */
    TRUNCATE = 8
}
// @generated message type with reflection information, may provide speed optimized methods
class ClientHello$Type extends MessageType$<ClientHello> {
    constructor() {
        super("teleport.desktop.v1.ClientHello", [
            { no: 1, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "screen_spec", kind: "message", T: () => ClientScreenSpec },
            { no: 3, name: "keyboard_layout", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ], { "teleport.desktop.v1.tdp_type_option": "MESSAGE_TYPE_CLIENT_HELLO" });
    }
    create(value?: PartialMessage<ClientHello>): ClientHello {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.username = "";
        message.keyboardLayout = 0;
        if (value !== undefined)
            reflectionMergePartial<ClientHello>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClientHello): ClientHello {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string username */ 1:
                    message.username = reader.string();
                    break;
                case /* teleport.desktop.v1.ClientScreenSpec screen_spec */ 2:
                    message.screenSpec = ClientScreenSpec.internalBinaryRead(reader, reader.uint32(), options, message.screenSpec);
                    break;
                case /* uint32 keyboard_layout */ 3:
                    message.keyboardLayout = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClientHello, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string username = 1; */
        if (message.username !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.username);
        /* teleport.desktop.v1.ClientScreenSpec screen_spec = 2; */
        if (message.screenSpec)
            ClientScreenSpec.internalBinaryWrite(message.screenSpec, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* uint32 keyboard_layout = 3; */
        if (message.keyboardLayout !== 0)
            writer.tag(3, WireType.Varint).uint32(message.keyboardLayout);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.ClientHello
 */
export const ClientHello = new ClientHello$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServerHello$Type extends MessageType$<ServerHello> {
    constructor() {
        super("teleport.desktop.v1.ServerHello", [
            { no: 1, name: "activation_spec", kind: "message", T: () => ConnectionActivated },
            { no: 2, name: "clipboard_enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { "teleport.desktop.v1.tdp_type_option": "MESSAGE_TYPE_SERVER_HELLO" });
    }
    create(value?: PartialMessage<ServerHello>): ServerHello {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clipboardEnabled = false;
        if (value !== undefined)
            reflectionMergePartial<ServerHello>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServerHello): ServerHello {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.desktop.v1.ConnectionActivated activation_spec */ 1:
                    message.activationSpec = ConnectionActivated.internalBinaryRead(reader, reader.uint32(), options, message.activationSpec);
                    break;
                case /* bool clipboard_enabled */ 2:
                    message.clipboardEnabled = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServerHello, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.desktop.v1.ConnectionActivated activation_spec = 1; */
        if (message.activationSpec)
            ConnectionActivated.internalBinaryWrite(message.activationSpec, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool clipboard_enabled = 2; */
        if (message.clipboardEnabled !== false)
            writer.tag(2, WireType.Varint).bool(message.clipboardEnabled);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.ServerHello
 */
export const ServerHello = new ServerHello$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Rectangle$Type extends MessageType$<Rectangle> {
    constructor() {
        super("teleport.desktop.v1.Rectangle", [
            { no: 1, name: "left", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "top", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "right", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "bottom", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Rectangle>): Rectangle {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.left = 0;
        message.top = 0;
        message.right = 0;
        message.bottom = 0;
        if (value !== undefined)
            reflectionMergePartial<Rectangle>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Rectangle): Rectangle {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 left */ 1:
                    message.left = reader.uint32();
                    break;
                case /* uint32 top */ 2:
                    message.top = reader.uint32();
                    break;
                case /* uint32 right */ 3:
                    message.right = reader.uint32();
                    break;
                case /* uint32 bottom */ 4:
                    message.bottom = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Rectangle, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 left = 1; */
        if (message.left !== 0)
            writer.tag(1, WireType.Varint).uint32(message.left);
        /* uint32 top = 2; */
        if (message.top !== 0)
            writer.tag(2, WireType.Varint).uint32(message.top);
        /* uint32 right = 3; */
        if (message.right !== 0)
            writer.tag(3, WireType.Varint).uint32(message.right);
        /* uint32 bottom = 4; */
        if (message.bottom !== 0)
            writer.tag(4, WireType.Varint).uint32(message.bottom);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.Rectangle
 */
export const Rectangle = new Rectangle$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PNGFrame$Type extends MessageType$<PNGFrame> {
    constructor() {
        super("teleport.desktop.v1.PNGFrame", [
            { no: 1, name: "coordinates", kind: "message", T: () => Rectangle },
            { no: 2, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ], { "teleport.desktop.v1.tdp_type_option": "MESSAGE_TYPE_PNG_FRAME" });
    }
    create(value?: PartialMessage<PNGFrame>): PNGFrame {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<PNGFrame>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PNGFrame): PNGFrame {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.desktop.v1.Rectangle coordinates */ 1:
                    message.coordinates = Rectangle.internalBinaryRead(reader, reader.uint32(), options, message.coordinates);
                    break;
                case /* bytes data */ 2:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PNGFrame, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.desktop.v1.Rectangle coordinates = 1; */
        if (message.coordinates)
            Rectangle.internalBinaryWrite(message.coordinates, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bytes data = 2; */
        if (message.data.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.PNGFrame
 */
export const PNGFrame = new PNGFrame$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FastPathPDU$Type extends MessageType$<FastPathPDU> {
    constructor() {
        super("teleport.desktop.v1.FastPathPDU", [
            { no: 1, name: "pdu", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ], { "teleport.desktop.v1.tdp_type_option": "MESSAGE_TYPE_FASTPATH_PDU" });
    }
    create(value?: PartialMessage<FastPathPDU>): FastPathPDU {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pdu = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<FastPathPDU>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FastPathPDU): FastPathPDU {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes pdu */ 1:
                    message.pdu = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FastPathPDU, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes pdu = 1; */
        if (message.pdu.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.pdu);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.FastPathPDU
 */
export const FastPathPDU = new FastPathPDU$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RDPResponsePDU$Type extends MessageType$<RDPResponsePDU> {
    constructor() {
        super("teleport.desktop.v1.RDPResponsePDU", [
            { no: 1, name: "response", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ], { "teleport.desktop.v1.tdp_type_option": "MESSAGE_TYPE_RDP_RESPONSE_PDU" });
    }
    create(value?: PartialMessage<RDPResponsePDU>): RDPResponsePDU {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.response = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<RDPResponsePDU>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RDPResponsePDU): RDPResponsePDU {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes response */ 1:
                    message.response = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RDPResponsePDU, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes response = 1; */
        if (message.response.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.response);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.RDPResponsePDU
 */
export const RDPResponsePDU = new RDPResponsePDU$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConnectionActivated$Type extends MessageType$<ConnectionActivated> {
    constructor() {
        super("teleport.desktop.v1.ConnectionActivated", [
            { no: 1, name: "io_channel_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "user_channel_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "screen_width", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "screen_height", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ConnectionActivated>): ConnectionActivated {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ioChannelId = 0;
        message.userChannelId = 0;
        message.screenWidth = 0;
        message.screenHeight = 0;
        if (value !== undefined)
            reflectionMergePartial<ConnectionActivated>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConnectionActivated): ConnectionActivated {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 io_channel_id */ 1:
                    message.ioChannelId = reader.uint32();
                    break;
                case /* uint32 user_channel_id */ 2:
                    message.userChannelId = reader.uint32();
                    break;
                case /* uint32 screen_width */ 3:
                    message.screenWidth = reader.uint32();
                    break;
                case /* uint32 screen_height */ 4:
                    message.screenHeight = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConnectionActivated, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 io_channel_id = 1; */
        if (message.ioChannelId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.ioChannelId);
        /* uint32 user_channel_id = 2; */
        if (message.userChannelId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.userChannelId);
        /* uint32 screen_width = 3; */
        if (message.screenWidth !== 0)
            writer.tag(3, WireType.Varint).uint32(message.screenWidth);
        /* uint32 screen_height = 4; */
        if (message.screenHeight !== 0)
            writer.tag(4, WireType.Varint).uint32(message.screenHeight);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.ConnectionActivated
 */
export const ConnectionActivated = new ConnectionActivated$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SyncKeys$Type extends MessageType$<SyncKeys> {
    constructor() {
        super("teleport.desktop.v1.SyncKeys", [
            { no: 1, name: "scroll_lock_pressed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "num_lock_state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "caps_lock_state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "kana_lock_state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { "teleport.desktop.v1.tdp_type_option": "MESSAGE_TYPE_SYNC_KEYS" });
    }
    create(value?: PartialMessage<SyncKeys>): SyncKeys {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.scrollLockPressed = false;
        message.numLockState = false;
        message.capsLockState = false;
        message.kanaLockState = false;
        if (value !== undefined)
            reflectionMergePartial<SyncKeys>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SyncKeys): SyncKeys {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool scroll_lock_pressed */ 1:
                    message.scrollLockPressed = reader.bool();
                    break;
                case /* bool num_lock_state */ 2:
                    message.numLockState = reader.bool();
                    break;
                case /* bool caps_lock_state */ 3:
                    message.capsLockState = reader.bool();
                    break;
                case /* bool kana_lock_state */ 4:
                    message.kanaLockState = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SyncKeys, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool scroll_lock_pressed = 1; */
        if (message.scrollLockPressed !== false)
            writer.tag(1, WireType.Varint).bool(message.scrollLockPressed);
        /* bool num_lock_state = 2; */
        if (message.numLockState !== false)
            writer.tag(2, WireType.Varint).bool(message.numLockState);
        /* bool caps_lock_state = 3; */
        if (message.capsLockState !== false)
            writer.tag(3, WireType.Varint).bool(message.capsLockState);
        /* bool kana_lock_state = 4; */
        if (message.kanaLockState !== false)
            writer.tag(4, WireType.Varint).bool(message.kanaLockState);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.SyncKeys
 */
export const SyncKeys = new SyncKeys$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MouseMove$Type extends MessageType$<MouseMove> {
    constructor() {
        super("teleport.desktop.v1.MouseMove", [
            { no: 1, name: "x", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "y", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ], { "teleport.desktop.v1.tdp_type_option": "MESSAGE_TYPE_MOUSE_MOVE" });
    }
    create(value?: PartialMessage<MouseMove>): MouseMove {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.x = 0;
        message.y = 0;
        if (value !== undefined)
            reflectionMergePartial<MouseMove>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MouseMove): MouseMove {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 x */ 1:
                    message.x = reader.uint32();
                    break;
                case /* uint32 y */ 2:
                    message.y = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MouseMove, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 x = 1; */
        if (message.x !== 0)
            writer.tag(1, WireType.Varint).uint32(message.x);
        /* uint32 y = 2; */
        if (message.y !== 0)
            writer.tag(2, WireType.Varint).uint32(message.y);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.MouseMove
 */
export const MouseMove = new MouseMove$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MouseButton$Type extends MessageType$<MouseButton> {
    constructor() {
        super("teleport.desktop.v1.MouseButton", [
            { no: 1, name: "button", kind: "enum", T: () => ["teleport.desktop.v1.MouseButtonType", MouseButtonType, "MOUSE_BUTTON_TYPE_"] },
            { no: 2, name: "pressed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { "teleport.desktop.v1.tdp_type_option": "MESSAGE_TYPE_MOUSE_BUTTON" });
    }
    create(value?: PartialMessage<MouseButton>): MouseButton {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.button = 0;
        message.pressed = false;
        if (value !== undefined)
            reflectionMergePartial<MouseButton>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MouseButton): MouseButton {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.desktop.v1.MouseButtonType button */ 1:
                    message.button = reader.int32();
                    break;
                case /* bool pressed */ 2:
                    message.pressed = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MouseButton, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.desktop.v1.MouseButtonType button = 1; */
        if (message.button !== 0)
            writer.tag(1, WireType.Varint).int32(message.button);
        /* bool pressed = 2; */
        if (message.pressed !== false)
            writer.tag(2, WireType.Varint).bool(message.pressed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.MouseButton
 */
export const MouseButton = new MouseButton$Type();
// @generated message type with reflection information, may provide speed optimized methods
class KeyboardButton$Type extends MessageType$<KeyboardButton> {
    constructor() {
        super("teleport.desktop.v1.KeyboardButton", [
            { no: 1, name: "key_code", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "pressed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { "teleport.desktop.v1.tdp_type_option": "MESSAGE_TYPE_KEYBOARD_BUTTON" });
    }
    create(value?: PartialMessage<KeyboardButton>): KeyboardButton {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyCode = 0;
        message.pressed = false;
        if (value !== undefined)
            reflectionMergePartial<KeyboardButton>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KeyboardButton): KeyboardButton {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 key_code */ 1:
                    message.keyCode = reader.uint32();
                    break;
                case /* bool pressed */ 2:
                    message.pressed = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: KeyboardButton, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 key_code = 1; */
        if (message.keyCode !== 0)
            writer.tag(1, WireType.Varint).uint32(message.keyCode);
        /* bool pressed = 2; */
        if (message.pressed !== false)
            writer.tag(2, WireType.Varint).bool(message.pressed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.KeyboardButton
 */
export const KeyboardButton = new KeyboardButton$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClientScreenSpec$Type extends MessageType$<ClientScreenSpec> {
    constructor() {
        super("teleport.desktop.v1.ClientScreenSpec", [
            { no: 1, name: "width", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "height", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ], { "teleport.desktop.v1.tdp_type_option": "MESSAGE_TYPE_CLIENT_SCREEN_SPEC" });
    }
    create(value?: PartialMessage<ClientScreenSpec>): ClientScreenSpec {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.width = 0;
        message.height = 0;
        if (value !== undefined)
            reflectionMergePartial<ClientScreenSpec>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClientScreenSpec): ClientScreenSpec {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 width */ 1:
                    message.width = reader.uint32();
                    break;
                case /* uint32 height */ 2:
                    message.height = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClientScreenSpec, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 width = 1; */
        if (message.width !== 0)
            writer.tag(1, WireType.Varint).uint32(message.width);
        /* uint32 height = 2; */
        if (message.height !== 0)
            writer.tag(2, WireType.Varint).uint32(message.height);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.ClientScreenSpec
 */
export const ClientScreenSpec = new ClientScreenSpec$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Alert$Type extends MessageType$<Alert> {
    constructor() {
        super("teleport.desktop.v1.Alert", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "severity", kind: "enum", T: () => ["teleport.desktop.v1.AlertSeverity", AlertSeverity, "ALERT_SEVERITY_"] }
        ], { "teleport.desktop.v1.tdp_type_option": "MESSAGE_TYPE_ALERT" });
    }
    create(value?: PartialMessage<Alert>): Alert {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.message = "";
        message.severity = 0;
        if (value !== undefined)
            reflectionMergePartial<Alert>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Alert): Alert {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                case /* teleport.desktop.v1.AlertSeverity severity */ 2:
                    message.severity = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Alert, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        /* teleport.desktop.v1.AlertSeverity severity = 2; */
        if (message.severity !== 0)
            writer.tag(2, WireType.Varint).int32(message.severity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.Alert
 */
export const Alert = new Alert$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MouseWheel$Type extends MessageType$<MouseWheel> {
    constructor() {
        super("teleport.desktop.v1.MouseWheel", [
            { no: 1, name: "axis", kind: "enum", T: () => ["teleport.desktop.v1.MouseWheelAxis", MouseWheelAxis, "MOUSE_WHEEL_AXIS_"] },
            { no: 2, name: "delta", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ], { "teleport.desktop.v1.tdp_type_option": "MESSAGE_TYPE_MOUSE_WHEEL" });
    }
    create(value?: PartialMessage<MouseWheel>): MouseWheel {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.axis = 0;
        message.delta = 0;
        if (value !== undefined)
            reflectionMergePartial<MouseWheel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MouseWheel): MouseWheel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.desktop.v1.MouseWheelAxis axis */ 1:
                    message.axis = reader.int32();
                    break;
                case /* uint32 delta */ 2:
                    message.delta = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MouseWheel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.desktop.v1.MouseWheelAxis axis = 1; */
        if (message.axis !== 0)
            writer.tag(1, WireType.Varint).int32(message.axis);
        /* uint32 delta = 2; */
        if (message.delta !== 0)
            writer.tag(2, WireType.Varint).uint32(message.delta);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.MouseWheel
 */
export const MouseWheel = new MouseWheel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClipboardData$Type extends MessageType$<ClipboardData> {
    constructor() {
        super("teleport.desktop.v1.ClipboardData", [
            { no: 1, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ], { "teleport.desktop.v1.tdp_type_option": "MESSAGE_TYPE_CLIPBOARD_DATA" });
    }
    create(value?: PartialMessage<ClipboardData>): ClipboardData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<ClipboardData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClipboardData): ClipboardData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes data */ 1:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClipboardData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes data = 1; */
        if (message.data.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.ClipboardData
 */
export const ClipboardData = new ClipboardData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MFA$Type extends MessageType$<MFA> {
    constructor() {
        super("teleport.desktop.v1.MFA", [
            { no: 1, name: "type", kind: "enum", T: () => ["teleport.desktop.v1.MFAType", MFAType] },
            { no: 2, name: "channel_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "challenge", kind: "message", T: () => AuthenticateChallenge },
            { no: 4, name: "authentication_response", kind: "message", T: () => AuthenticateResponse }
        ], { "teleport.desktop.v1.tdp_type_option": "MESSAGE_TYPE_MFA" });
    }
    create(value?: PartialMessage<MFA>): MFA {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.channelId = "";
        if (value !== undefined)
            reflectionMergePartial<MFA>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MFA): MFA {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.desktop.v1.MFAType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* string channel_id */ 2:
                    message.channelId = reader.string();
                    break;
                case /* teleport.mfa.v1.AuthenticateChallenge challenge */ 3:
                    message.challenge = AuthenticateChallenge.internalBinaryRead(reader, reader.uint32(), options, message.challenge);
                    break;
                case /* teleport.mfa.v1.AuthenticateResponse authentication_response */ 4:
                    message.authenticationResponse = AuthenticateResponse.internalBinaryRead(reader, reader.uint32(), options, message.authenticationResponse);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MFA, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.desktop.v1.MFAType type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* string channel_id = 2; */
        if (message.channelId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.channelId);
        /* teleport.mfa.v1.AuthenticateChallenge challenge = 3; */
        if (message.challenge)
            AuthenticateChallenge.internalBinaryWrite(message.challenge, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* teleport.mfa.v1.AuthenticateResponse authentication_response = 4; */
        if (message.authenticationResponse)
            AuthenticateResponse.internalBinaryWrite(message.authenticationResponse, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.MFA
 */
export const MFA = new MFA$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SharedDirectoryAnnounce$Type extends MessageType$<SharedDirectoryAnnounce> {
    constructor() {
        super("teleport.desktop.v1.SharedDirectoryAnnounce", [
            { no: 1, name: "directory_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "teleport.desktop.v1.tdp_type_option": "MESSAGE_TYPE_SHARED_DIRECTORY_ANNOUNCE" });
    }
    create(value?: PartialMessage<SharedDirectoryAnnounce>): SharedDirectoryAnnounce {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.directoryId = 0;
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<SharedDirectoryAnnounce>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SharedDirectoryAnnounce): SharedDirectoryAnnounce {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 directory_id */ 1:
                    message.directoryId = reader.uint32();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SharedDirectoryAnnounce, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 directory_id = 1; */
        if (message.directoryId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.directoryId);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.SharedDirectoryAnnounce
 */
export const SharedDirectoryAnnounce = new SharedDirectoryAnnounce$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SharedDirectoryAcknowledge$Type extends MessageType$<SharedDirectoryAcknowledge> {
    constructor() {
        super("teleport.desktop.v1.SharedDirectoryAcknowledge", [
            { no: 1, name: "directory_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "error_code", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ], { "teleport.desktop.v1.tdp_type_option": "MESSAGE_TYPE_SHARED_DIRECTORY_ACKNOWLEDGE" });
    }
    create(value?: PartialMessage<SharedDirectoryAcknowledge>): SharedDirectoryAcknowledge {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.directoryId = 0;
        message.errorCode = 0;
        if (value !== undefined)
            reflectionMergePartial<SharedDirectoryAcknowledge>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SharedDirectoryAcknowledge): SharedDirectoryAcknowledge {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 directory_id */ 1:
                    message.directoryId = reader.uint32();
                    break;
                case /* uint32 error_code */ 2:
                    message.errorCode = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SharedDirectoryAcknowledge, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 directory_id = 1; */
        if (message.directoryId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.directoryId);
        /* uint32 error_code = 2; */
        if (message.errorCode !== 0)
            writer.tag(2, WireType.Varint).uint32(message.errorCode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.SharedDirectoryAcknowledge
 */
export const SharedDirectoryAcknowledge = new SharedDirectoryAcknowledge$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SharedDirectoryRequest$Type extends MessageType$<SharedDirectoryRequest> {
    constructor() {
        super("teleport.desktop.v1.SharedDirectoryRequest", [
            { no: 1, name: "operation_code", kind: "enum", T: () => ["teleport.desktop.v1.DirectoryOperation", DirectoryOperation, "DIRECTORY_OPERATION_"] },
            { no: 2, name: "directory_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "completion_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "new_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "file_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "offset", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "length", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "end_of_file", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 11, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "teleport.desktop.v1.tdp_type_option": "MESSAGE_TYPE_SHARED_DIRECTORY_REQUEST" });
    }
    create(value?: PartialMessage<SharedDirectoryRequest>): SharedDirectoryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.operationCode = 0;
        message.directoryId = 0;
        message.completionId = 0;
        message.path = "";
        message.newPath = "";
        message.fileType = 0;
        message.offset = 0n;
        message.length = 0;
        message.endOfFile = 0;
        message.data = new Uint8Array(0);
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<SharedDirectoryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SharedDirectoryRequest): SharedDirectoryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.desktop.v1.DirectoryOperation operation_code */ 1:
                    message.operationCode = reader.int32();
                    break;
                case /* uint32 directory_id */ 2:
                    message.directoryId = reader.uint32();
                    break;
                case /* uint32 completion_id */ 3:
                    message.completionId = reader.uint32();
                    break;
                case /* string path */ 4:
                    message.path = reader.string();
                    break;
                case /* string new_path */ 9:
                    message.newPath = reader.string();
                    break;
                case /* uint32 file_type */ 5:
                    message.fileType = reader.uint32();
                    break;
                case /* uint64 offset */ 6:
                    message.offset = reader.uint64().toBigInt();
                    break;
                case /* uint32 length */ 7:
                    message.length = reader.uint32();
                    break;
                case /* uint32 end_of_file */ 8:
                    message.endOfFile = reader.uint32();
                    break;
                case /* bytes data */ 10:
                    message.data = reader.bytes();
                    break;
                case /* string name */ 11:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SharedDirectoryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.desktop.v1.DirectoryOperation operation_code = 1; */
        if (message.operationCode !== 0)
            writer.tag(1, WireType.Varint).int32(message.operationCode);
        /* uint32 directory_id = 2; */
        if (message.directoryId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.directoryId);
        /* uint32 completion_id = 3; */
        if (message.completionId !== 0)
            writer.tag(3, WireType.Varint).uint32(message.completionId);
        /* string path = 4; */
        if (message.path !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.path);
        /* string new_path = 9; */
        if (message.newPath !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.newPath);
        /* uint32 file_type = 5; */
        if (message.fileType !== 0)
            writer.tag(5, WireType.Varint).uint32(message.fileType);
        /* uint64 offset = 6; */
        if (message.offset !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.offset);
        /* uint32 length = 7; */
        if (message.length !== 0)
            writer.tag(7, WireType.Varint).uint32(message.length);
        /* uint32 end_of_file = 8; */
        if (message.endOfFile !== 0)
            writer.tag(8, WireType.Varint).uint32(message.endOfFile);
        /* bytes data = 10; */
        if (message.data.length)
            writer.tag(10, WireType.LengthDelimited).bytes(message.data);
        /* string name = 11; */
        if (message.name !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.SharedDirectoryRequest
 */
export const SharedDirectoryRequest = new SharedDirectoryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SharedDirectoryResponse$Type extends MessageType$<SharedDirectoryResponse> {
    constructor() {
        super("teleport.desktop.v1.SharedDirectoryResponse", [
            { no: 1, name: "operation_code", kind: "enum", T: () => ["teleport.desktop.v1.DirectoryOperation", DirectoryOperation, "DIRECTORY_OPERATION_"] },
            { no: 2, name: "completion_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "error_code", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "fso_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => FileSystemObject },
            { no: 5, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 6, name: "bytes_written", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ], { "teleport.desktop.v1.tdp_type_option": "MESSAGE_TYPE_SHARED_DIRECTORY_RESPONSE" });
    }
    create(value?: PartialMessage<SharedDirectoryResponse>): SharedDirectoryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.operationCode = 0;
        message.completionId = 0;
        message.errorCode = 0;
        message.fsoList = [];
        message.data = new Uint8Array(0);
        message.bytesWritten = 0;
        if (value !== undefined)
            reflectionMergePartial<SharedDirectoryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SharedDirectoryResponse): SharedDirectoryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.desktop.v1.DirectoryOperation operation_code */ 1:
                    message.operationCode = reader.int32();
                    break;
                case /* uint32 completion_id */ 2:
                    message.completionId = reader.uint32();
                    break;
                case /* uint32 error_code */ 3:
                    message.errorCode = reader.uint32();
                    break;
                case /* repeated teleport.desktop.v1.FileSystemObject fso_list */ 4:
                    message.fsoList.push(FileSystemObject.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bytes data */ 5:
                    message.data = reader.bytes();
                    break;
                case /* uint32 bytes_written */ 6:
                    message.bytesWritten = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SharedDirectoryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.desktop.v1.DirectoryOperation operation_code = 1; */
        if (message.operationCode !== 0)
            writer.tag(1, WireType.Varint).int32(message.operationCode);
        /* uint32 completion_id = 2; */
        if (message.completionId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.completionId);
        /* uint32 error_code = 3; */
        if (message.errorCode !== 0)
            writer.tag(3, WireType.Varint).uint32(message.errorCode);
        /* repeated teleport.desktop.v1.FileSystemObject fso_list = 4; */
        for (let i = 0; i < message.fsoList.length; i++)
            FileSystemObject.internalBinaryWrite(message.fsoList[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bytes data = 5; */
        if (message.data.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.data);
        /* uint32 bytes_written = 6; */
        if (message.bytesWritten !== 0)
            writer.tag(6, WireType.Varint).uint32(message.bytesWritten);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.SharedDirectoryResponse
 */
export const SharedDirectoryResponse = new SharedDirectoryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FileSystemObject$Type extends MessageType$<FileSystemObject> {
    constructor() {
        super("teleport.desktop.v1.FileSystemObject", [
            { no: 1, name: "last_modified", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "size", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "file_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "is_empty", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FileSystemObject>): FileSystemObject {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.lastModified = 0n;
        message.size = 0n;
        message.fileType = 0;
        message.isEmpty = false;
        message.path = "";
        if (value !== undefined)
            reflectionMergePartial<FileSystemObject>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FileSystemObject): FileSystemObject {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 last_modified */ 1:
                    message.lastModified = reader.uint64().toBigInt();
                    break;
                case /* uint64 size */ 2:
                    message.size = reader.uint64().toBigInt();
                    break;
                case /* uint32 file_type */ 3:
                    message.fileType = reader.uint32();
                    break;
                case /* bool is_empty */ 4:
                    message.isEmpty = reader.bool();
                    break;
                case /* string path */ 5:
                    message.path = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FileSystemObject, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 last_modified = 1; */
        if (message.lastModified !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.lastModified);
        /* uint64 size = 2; */
        if (message.size !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.size);
        /* uint32 file_type = 3; */
        if (message.fileType !== 0)
            writer.tag(3, WireType.Varint).uint32(message.fileType);
        /* bool is_empty = 4; */
        if (message.isEmpty !== false)
            writer.tag(4, WireType.Varint).bool(message.isEmpty);
        /* string path = 5; */
        if (message.path !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.path);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.FileSystemObject
 */
export const FileSystemObject = new FileSystemObject$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LatencyStats$Type extends MessageType$<LatencyStats> {
    constructor() {
        super("teleport.desktop.v1.LatencyStats", [
            { no: 1, name: "client_latency", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "server_latency", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ], { "teleport.desktop.v1.tdp_type_option": "MESSAGE_TYPE_LATENCY_STATS" });
    }
    create(value?: PartialMessage<LatencyStats>): LatencyStats {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clientLatency = 0;
        message.serverLatency = 0;
        if (value !== undefined)
            reflectionMergePartial<LatencyStats>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LatencyStats): LatencyStats {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 client_latency */ 1:
                    message.clientLatency = reader.uint32();
                    break;
                case /* uint32 server_latency */ 2:
                    message.serverLatency = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LatencyStats, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 client_latency = 1; */
        if (message.clientLatency !== 0)
            writer.tag(1, WireType.Varint).uint32(message.clientLatency);
        /* uint32 server_latency = 2; */
        if (message.serverLatency !== 0)
            writer.tag(2, WireType.Varint).uint32(message.serverLatency);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.LatencyStats
 */
export const LatencyStats = new LatencyStats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Ping$Type extends MessageType$<Ping> {
    constructor() {
        super("teleport.desktop.v1.Ping", [
            { no: 1, name: "uuid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ], { "teleport.desktop.v1.tdp_type_option": "MESSAGE_TYPE_PING" });
    }
    create(value?: PartialMessage<Ping>): Ping {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<Ping>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Ping): Ping {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes uuid */ 1:
                    message.uuid = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Ping, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes uuid = 1; */
        if (message.uuid.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.uuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.desktop.v1.Ping
 */
export const Ping = new Ping$Type();
