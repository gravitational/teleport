/* eslint-disable */
// @generated by protobuf-ts 2.9.3 with parameter eslint_disable,add_pb_suffix,server_grpc1,ts_nocheck
// @generated from protobuf file "teleport/devicetrust/v1/devicetrust_service.proto" (package "teleport.devicetrust.v1", syntax proto3)
// tslint:disable
// @ts-nocheck
//
// Copyright 2022 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import { DevicesUsage } from "./usage_pb";
import { DeviceEnrollToken } from "./device_enroll_token_pb";
import { Empty } from "../../../google/protobuf/empty_pb";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { DeviceSource } from "./device_source_pb";
import { DeviceWebToken } from "./device_web_token_pb";
import { DeviceConfirmationToken } from "./device_confirmation_token_pb";
import { UserCertificates } from "./user_certificates_pb";
import { TPMPlatformParameters } from "./tpm_pb";
import { DeviceCollectedData } from "./device_collected_data_pb";
import { Status } from "../../../google/rpc/status_pb";
import { FieldMask } from "../../../google/protobuf/field_mask_pb";
import { Timestamp } from "../../../google/protobuf/timestamp_pb";
import { Device } from "./device_pb";
/**
 * Request for CreateDevice.
 *
 * @generated from protobuf message teleport.devicetrust.v1.CreateDeviceRequest
 */
export interface CreateDeviceRequest {
    /**
     * Device to create.
     *
     * @generated from protobuf field: teleport.devicetrust.v1.Device device = 1;
     */
    device?: Device;
    /**
     * If true, a DeviceEnrollToken is created along with the Device.
     *
     * @generated from protobuf field: bool create_enroll_token = 2;
     */
    createEnrollToken: boolean;
    /**
     * If true, create the device as a Teleport resource, meaning that fields that
     * are usually considered read-only or system managed are copied as provided
     * to storage.
     * Prefer using non-resource creation semantics if possible.
     *
     * @generated from protobuf field: bool create_as_resource = 3;
     */
    createAsResource: boolean;
    /**
     * Custom expiration time for enrollment tokens.
     * A short (for humans) server default is used if unset.
     *
     * @generated from protobuf field: google.protobuf.Timestamp enroll_token_expire_time = 4;
     */
    enrollTokenExpireTime?: Timestamp;
}
/**
 * Request for UpdateDevice.
 *
 * @generated from protobuf message teleport.devicetrust.v1.UpdateDeviceRequest
 */
export interface UpdateDeviceRequest {
    /**
     * Device to update.
     *
     * @generated from protobuf field: teleport.devicetrust.v1.Device device = 1;
     */
    device?: Device;
    /**
     * Update mask applied to the resource.
     * Fields are masked according to their proto name.
     *
     * @generated from protobuf field: google.protobuf.FieldMask update_mask = 2;
     */
    updateMask?: FieldMask;
}
/**
 * Request for UpsertDevice.
 *
 * @generated from protobuf message teleport.devicetrust.v1.UpsertDeviceRequest
 */
export interface UpsertDeviceRequest {
    /**
     * Device to create or update.
     *
     * @generated from protobuf field: teleport.devicetrust.v1.Device device = 1;
     */
    device?: Device;
    /**
     * If true, creates the device using resource semantics.
     * Has no effect on device updates.
     * See create_as_resource in CreateDeviceRequest.
     *
     * @generated from protobuf field: bool create_as_resource = 2;
     */
    createAsResource: boolean;
}
/**
 * Request for DeleteDevice.
 *
 * @generated from protobuf message teleport.devicetrust.v1.DeleteDeviceRequest
 */
export interface DeleteDeviceRequest {
    /**
     * ID of the Device to delete.
     *
     * @generated from protobuf field: string device_id = 1;
     */
    deviceId: string;
}
/**
 * Request for FindDevices.
 *
 * Inspect the returned devices to determine whether the match was by ID or
 * asset tag.
 *
 * @generated from protobuf message teleport.devicetrust.v1.FindDevicesRequest
 */
export interface FindDevicesRequest {
    /**
     * Device ID or asset tag.
     *
     * @generated from protobuf field: string id_or_tag = 1;
     */
    idOrTag: string;
}
/**
 * Response for FindDevices.
 *
 * @generated from protobuf message teleport.devicetrust.v1.FindDevicesResponse
 */
export interface FindDevicesResponse {
    /**
     * Devices that matched the search.
     * The number of resulting devices is expected to be low and may be
     * artificially capped by the server otherwise.
     *
     * @generated from protobuf field: repeated teleport.devicetrust.v1.Device devices = 1;
     */
    devices: Device[];
}
/**
 * Request for GetDevice.
 *
 * @generated from protobuf message teleport.devicetrust.v1.GetDeviceRequest
 */
export interface GetDeviceRequest {
    /**
     * ID of the device.
     *
     * @generated from protobuf field: string device_id = 1;
     */
    deviceId: string;
}
/**
 * Request for ListDevices.
 *
 * Follows the pagination semantics of
 * https://cloud.google.com/apis/design/standard_methods#list.
 *
 * @generated from protobuf message teleport.devicetrust.v1.ListDevicesRequest
 */
export interface ListDevicesRequest {
    /**
     * The maximum number of items to return.
     * The server may impose a different page size at its discretion.
     *
     * @generated from protobuf field: int32 page_size = 1;
     */
    pageSize: number;
    /**
     * The next_page_token value returned from a previous List request, if any.
     *
     * @generated from protobuf field: string page_token = 2;
     */
    pageToken: string;
    /**
     * Specifies which fields of the resource should be returned in the response.
     * Defaults to DEVICE_VIEW_LIST.
     *
     * @generated from protobuf field: teleport.devicetrust.v1.DeviceView view = 3;
     */
    view: DeviceView;
}
/**
 * Response for ListDevices.
 *
 * @generated from protobuf message teleport.devicetrust.v1.ListDevicesResponse
 */
export interface ListDevicesResponse {
    /**
     * Devices that matched the search.
     *
     * @generated from protobuf field: repeated teleport.devicetrust.v1.Device devices = 1;
     */
    devices: Device[];
    /**
     * Token to retrieve the next page of results, or empty if there are no
     * more results in the list.
     *
     * @generated from protobuf field: string next_page_token = 2;
     */
    nextPageToken: string;
}
/**
 * Request for BulkCreateDevices.
 *
 * @generated from protobuf message teleport.devicetrust.v1.BulkCreateDevicesRequest
 */
export interface BulkCreateDevicesRequest {
    /**
     * Devices to create.
     *
     * @generated from protobuf field: repeated teleport.devicetrust.v1.Device devices = 1;
     */
    devices: Device[];
    /**
     * If true, create the device as a Teleport resource, meaning that fields that
     * are usually considered read-only or system managed are copied as provided
     * to storage.
     * Prefer using non-resource creation semantics if possible.
     *
     * @generated from protobuf field: bool create_as_resource = 2;
     */
    createAsResource: boolean;
}
/**
 * Response for BulkCreateDevices.
 *
 * @generated from protobuf message teleport.devicetrust.v1.BulkCreateDevicesResponse
 */
export interface BulkCreateDevicesResponse {
    /**
     * Created devices or a failure reason.
     * Responses are sorted according to the request.
     *
     * @generated from protobuf field: repeated teleport.devicetrust.v1.DeviceOrStatus devices = 1;
     */
    devices: DeviceOrStatus[];
}
/**
 * DeviceOrStatus contains either a device ID, in case of success, or a status
 * in case of failures.
 *
 * @generated from protobuf message teleport.devicetrust.v1.DeviceOrStatus
 */
export interface DeviceOrStatus {
    /**
     * Status of the operation.
     * May either be absent or contain the OK code for successes, at the
     * implementation's discretion.
     *
     * @generated from protobuf field: google.rpc.Status status = 1;
     */
    status?: Status;
    /**
     * ID of the created device.
     * Only present if the status is OK.
     *
     * @generated from protobuf field: string id = 2;
     */
    id: string;
    /**
     * If true the action attempted against the device was a delete, instead of a
     * create or update.
     *
     * @generated from protobuf field: bool deleted = 3;
     */
    deleted: boolean;
}
/**
 * Request for CreateDeviceEnrollToken.
 *
 * @generated from protobuf message teleport.devicetrust.v1.CreateDeviceEnrollTokenRequest
 */
export interface CreateDeviceEnrollTokenRequest {
    /**
     * ID of the device.
     *
     * @generated from protobuf field: string device_id = 1;
     */
    deviceId: string;
    /**
     * Device collected data.
     * Used to authorize issuance of device enrollment tokens for auto-enrollment.
     * Not required otherwise.
     *
     * @generated from protobuf field: teleport.devicetrust.v1.DeviceCollectedData device_data = 2;
     */
    deviceData?: DeviceCollectedData;
    /**
     * Custom expiration time for enrollment tokens.
     * A short (for humans) server default is used if unset.
     *
     * @generated from protobuf field: google.protobuf.Timestamp expire_time = 3;
     */
    expireTime?: Timestamp;
}
/**
 * Request for EnrollDevice.
 *
 * @generated from protobuf message teleport.devicetrust.v1.EnrollDeviceRequest
 */
export interface EnrollDeviceRequest {
    /**
     * @generated from protobuf oneof: payload
     */
    payload: {
        oneofKind: "init";
        /**
         * @generated from protobuf field: teleport.devicetrust.v1.EnrollDeviceInit init = 1;
         */
        init: EnrollDeviceInit;
    } | {
        oneofKind: "macosChallengeResponse";
        /**
         * @generated from protobuf field: teleport.devicetrust.v1.MacOSEnrollChallengeResponse macos_challenge_response = 2;
         */
        macosChallengeResponse: MacOSEnrollChallengeResponse;
    } | {
        oneofKind: "tpmChallengeResponse";
        /**
         * @generated from protobuf field: teleport.devicetrust.v1.TPMEnrollChallengeResponse tpm_challenge_response = 3;
         */
        tpmChallengeResponse: TPMEnrollChallengeResponse;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Response for EnrollDevice.
 *
 * @generated from protobuf message teleport.devicetrust.v1.EnrollDeviceResponse
 */
export interface EnrollDeviceResponse {
    /**
     * @generated from protobuf oneof: payload
     */
    payload: {
        oneofKind: "success";
        /**
         * @generated from protobuf field: teleport.devicetrust.v1.EnrollDeviceSuccess success = 1;
         */
        success: EnrollDeviceSuccess;
    } | {
        oneofKind: "macosChallenge";
        /**
         * @generated from protobuf field: teleport.devicetrust.v1.MacOSEnrollChallenge macos_challenge = 2;
         */
        macosChallenge: MacOSEnrollChallenge;
    } | {
        oneofKind: "tpmChallenge";
        /**
         * @generated from protobuf field: teleport.devicetrust.v1.TPMEnrollChallenge tpm_challenge = 3;
         */
        tpmChallenge: TPMEnrollChallenge;
    } | {
        oneofKind: undefined;
    };
}
/**
 * EnrollDeviceInit initiates the enrollment ceremony.
 *
 * @generated from protobuf message teleport.devicetrust.v1.EnrollDeviceInit
 */
export interface EnrollDeviceInit {
    /**
     * Device enrollment token.
     * See CreateDevice or CreateDeviceEnrollToken.
     *
     * @generated from protobuf field: string token = 1;
     */
    token: string;
    /**
     * ID of the device credential.
     *
     * @generated from protobuf field: string credential_id = 2;
     */
    credentialId: string;
    /**
     * Device collected data.
     * Matched against the device registration information and any previously
     * collected data.
     *
     * @generated from protobuf field: teleport.devicetrust.v1.DeviceCollectedData device_data = 3;
     */
    deviceData?: DeviceCollectedData;
    /**
     * Payload for macOS-specific data.
     *
     * @generated from protobuf field: teleport.devicetrust.v1.MacOSEnrollPayload macos = 4;
     */
    macos?: MacOSEnrollPayload;
    /**
     * Payload for TPM-specific data. Used for Windows/Linux.
     *
     * @generated from protobuf field: teleport.devicetrust.v1.TPMEnrollPayload tpm = 5;
     */
    tpm?: TPMEnrollPayload;
}
/**
 * EnrollDeviceSuccess marks a successful device enrollment ceremony.
 *
 * @generated from protobuf message teleport.devicetrust.v1.EnrollDeviceSuccess
 */
export interface EnrollDeviceSuccess {
    /**
     * The enrolled device.
     *
     * @generated from protobuf field: teleport.devicetrust.v1.Device device = 1;
     */
    device?: Device;
}
/**
 * MacOSEnrollPayload is the macOS-specific enrollment payload.
 *
 * @generated from protobuf message teleport.devicetrust.v1.MacOSEnrollPayload
 */
export interface MacOSEnrollPayload {
    /**
     * Device public key marshaled as a PKIX, ASN.1 DER.
     *
     * @generated from protobuf field: bytes public_key_der = 2;
     */
    publicKeyDer: Uint8Array;
}
/**
 * MacOSEnrollChallenge is a macOS enrollment challenge.
 *
 * @generated from protobuf message teleport.devicetrust.v1.MacOSEnrollChallenge
 */
export interface MacOSEnrollChallenge {
    /**
     * Randomly-generated, opaque challenge to be signed using the device key.
     *
     * @generated from protobuf field: bytes challenge = 1;
     */
    challenge: Uint8Array;
}
/**
 * MacOSEnrollChallengeResponse is a macOS enrollment challenge response.
 *
 * @generated from protobuf message teleport.devicetrust.v1.MacOSEnrollChallengeResponse
 */
export interface MacOSEnrollChallengeResponse {
    /**
     * Signature over the challenge, using the device key.
     *
     * @generated from protobuf field: bytes signature = 2;
     */
    signature: Uint8Array;
}
/**
 * The payload containing TPM specific information required on device
 * enrollment.
 *
 * @generated from protobuf message teleport.devicetrust.v1.TPMEnrollPayload
 */
export interface TPMEnrollPayload {
    /**
     * @generated from protobuf oneof: ek
     */
    ek: {
        oneofKind: "ekCert";
        /**
         * The device's endorsement certificate in X509, ASN.1 DER form. This
         * certificate contains the public key of the endorsement key. This is
         * preferred to ek_key.
         *
         * @generated from protobuf field: bytes ek_cert = 1;
         */
        ekCert: Uint8Array;
    } | {
        oneofKind: "ekKey";
        /**
         * The device's public endorsement key in PKIX, ASN.1 DER form. This is
         * used when a TPM does not contain any endorsement certificates.
         *
         * @generated from protobuf field: bytes ek_key = 2;
         */
        ekKey: Uint8Array;
    } | {
        oneofKind: undefined;
    };
    /**
     * The attestation key and the parameters necessary to remotely verify it as
     * related to the endorsement key.
     *
     * @generated from protobuf field: teleport.devicetrust.v1.TPMAttestationParameters attestation_parameters = 3;
     */
    attestationParameters?: TPMAttestationParameters;
}
/**
 * The attestation key and the parameters necessary to remotely verify it as
 * related to the endorsement key.
 * See https://pkg.go.dev/github.com/google/go-attestation/attest#AttestationParameters.
 * This message excludes the `UseTCSDActivationFormat` field from the link above
 * as it is TMP 1.x specific and always false.
 *
 * @generated from protobuf message teleport.devicetrust.v1.TPMAttestationParameters
 */
export interface TPMAttestationParameters {
    /**
     * The encoded TPMT_PUBLIC structure containing the attestation public key
     * and signing parameters.
     *
     * @generated from protobuf field: bytes public = 1;
     */
    public: Uint8Array;
    /**
     * The properties of the attestation key, encoded as a TPMS_CREATION_DATA
     * structure.
     *
     * @generated from protobuf field: bytes create_data = 2;
     */
    createData: Uint8Array;
    /**
     * An assertion as to the details of the key, encoded as a TPMS_ATTEST
     * structure.
     *
     * @generated from protobuf field: bytes create_attestation = 3;
     */
    createAttestation: Uint8Array;
    /**
     * A signature of create_attestation, encoded as a TPMT_SIGNATURE structure.
     *
     * @generated from protobuf field: bytes create_signature = 4;
     */
    createSignature: Uint8Array;
}
/**
 * The challenge sent to the client by the server during enrollment.
 * The challenge involves two parts:
 * - Solving an encrypted credential with `ActivateCredential`.
 * - Producing a platform attestation using the provided nonce.
 *
 * @generated from protobuf message teleport.devicetrust.v1.TPMEnrollChallenge
 */
export interface TPMEnrollChallenge {
    /**
     * The encrypted credential for the client to prove possession of the EK and
     * AK.
     *
     * @generated from protobuf field: teleport.devicetrust.v1.TPMEncryptedCredential encrypted_credential = 1;
     */
    encryptedCredential?: TPMEncryptedCredential;
    /**
     * The nonce to use when producing the quotes over the PCRs with the TPM
     * during the platform attestation.
     *
     * @generated from protobuf field: bytes attestation_nonce = 2;
     */
    attestationNonce: Uint8Array;
}
/**
 * These values are used by the TPM2.0 `ActivateCredential` command to produce
 * the solution which proves possession of the EK and AK.
 *
 * For a more in-depth description see:
 * - https://pkg.go.dev/github.com/google/go-attestation/attest#EncryptedCredential
 * - https://trustedcomputinggroup.org/wp-content/uploads/TCG_TPM2_r1p59_Part3_Commands_code_pub.pdf (Heading 12.5.1 "TPM2_ActivateCredential" "General Description")
 * - https://github.com/google/go-attestation/blob/v0.4.3/attest/activation.go#L199
 * - https://github.com/google/go-tpm/blob/v0.3.3/tpm2/credactivation/credential_activation.go#L61
 *
 * @generated from protobuf message teleport.devicetrust.v1.TPMEncryptedCredential
 */
export interface TPMEncryptedCredential {
    /**
     * The `credential_blob` parameter to be used with the `ActivateCredential`
     * command. This is used with the decrypted value of `secret` in a
     * cryptographic process to decrypt the solution.
     *
     * @generated from protobuf field: bytes credential_blob = 1;
     */
    credentialBlob: Uint8Array;
    /**
     * The `secret` parameter to be used with `ActivateCredential`. This is a
     * seed which can be decrypted with the EK. The decrypted seed is then used
     * when decrypting `credential_blob`.
     *
     * @generated from protobuf field: bytes secret = 2;
     */
    secret: Uint8Array;
}
/**
 * The enrollment challenge response containing the solution returned by
 * calling the TPM2.0 `ActivateCredential` command on the client with the
 * parameters provided in `TPMEnrollChallenge`.
 *
 * @generated from protobuf message teleport.devicetrust.v1.TPMEnrollChallengeResponse
 */
export interface TPMEnrollChallengeResponse {
    /**
     * The client's solution to `TPMEncryptedCredential` included in
     * `TPMEnrollChallenge` using ActivateCredential.
     *
     * @generated from protobuf field: bytes solution = 1;
     */
    solution: Uint8Array;
    /**
     * The result of the client's platform attestation with the nonce provided
     * in `TPMEnrollChallenge`.
     *
     * @generated from protobuf field: teleport.devicetrust.v1.TPMPlatformParameters platform_parameters = 2;
     */
    platformParameters?: TPMPlatformParameters;
}
/**
 * Request for AuthenticateDevice.
 *
 * Authentication ceremony flow:
 * -> AuthenticateDeviceInit (client)
 * <- AuthenticateDeviceChallenge (server)
 * -> AuthenticateDeviceChallengeResponse
 * <- UserCertificates (regular authn) or ConfirmationToken (web authn)
 *
 * @generated from protobuf message teleport.devicetrust.v1.AuthenticateDeviceRequest
 */
export interface AuthenticateDeviceRequest {
    /**
     * @generated from protobuf oneof: payload
     */
    payload: {
        oneofKind: "init";
        /**
         * @generated from protobuf field: teleport.devicetrust.v1.AuthenticateDeviceInit init = 1;
         */
        init: AuthenticateDeviceInit;
    } | {
        oneofKind: "challengeResponse";
        /**
         * @generated from protobuf field: teleport.devicetrust.v1.AuthenticateDeviceChallengeResponse challenge_response = 2;
         */
        challengeResponse: AuthenticateDeviceChallengeResponse;
    } | {
        oneofKind: "tpmChallengeResponse";
        /**
         * @generated from protobuf field: teleport.devicetrust.v1.TPMAuthenticateDeviceChallengeResponse tpm_challenge_response = 3;
         */
        tpmChallengeResponse: TPMAuthenticateDeviceChallengeResponse;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Response for AuthenticateDevice.
 *
 * @generated from protobuf message teleport.devicetrust.v1.AuthenticateDeviceResponse
 */
export interface AuthenticateDeviceResponse {
    /**
     * @generated from protobuf oneof: payload
     */
    payload: {
        oneofKind: "challenge";
        /**
         * @generated from protobuf field: teleport.devicetrust.v1.AuthenticateDeviceChallenge challenge = 1;
         */
        challenge: AuthenticateDeviceChallenge;
    } | {
        oneofKind: "userCertificates";
        /**
         * User certificates are returned as the result of a successful device
         * authentication attempt ("regular" or non-web authentication).
         *
         * @generated from protobuf field: teleport.devicetrust.v1.UserCertificates user_certificates = 2;
         */
        userCertificates: UserCertificates;
    } | {
        oneofKind: "tpmChallenge";
        /**
         * @generated from protobuf field: teleport.devicetrust.v1.TPMAuthenticateDeviceChallenge tpm_challenge = 3;
         */
        tpmChallenge: TPMAuthenticateDeviceChallenge;
    } | {
        oneofKind: "confirmationToken";
        /**
         * A confirmation token is returned as the result of a successful device web
         * authentication.
         *
         * See AuthenticateDeviceInit.device_web_token.
         *
         * @generated from protobuf field: teleport.devicetrust.v1.DeviceConfirmationToken confirmation_token = 4;
         */
        confirmationToken: DeviceConfirmationToken;
    } | {
        oneofKind: undefined;
    };
}
/**
 * AuthenticateDeviceInit initiates the device authentication ceremony.
 *
 * @generated from protobuf message teleport.devicetrust.v1.AuthenticateDeviceInit
 */
export interface AuthenticateDeviceInit {
    /**
     * In-band user certificates to augment with device extensions.
     * - The x509 certificate is acquired from the mTLS connection, thus the
     *   in-band certificate is ignored.
     * - All certificates must be valid and issued by the Teleport CA.
     * - All certificates must match (same public key, same Teleport user, plus
     *   whatever additional checks the backend sees fit).
     * - Augmented certificates have the same expiration as the original
     *   certificates.
     *
     * @generated from protobuf field: teleport.devicetrust.v1.UserCertificates user_certificates = 1;
     */
    userCertificates?: UserCertificates;
    /**
     * ID of the enrolled device credential.
     *
     * @generated from protobuf field: string credential_id = 2;
     */
    credentialId: string;
    /**
     * Device collected data.
     * Matched against the device registration information and any previously
     * collected data.
     *
     * @generated from protobuf field: teleport.devicetrust.v1.DeviceCollectedData device_data = 3;
     */
    deviceData?: DeviceCollectedData;
    /**
     * If present, on-behalf-of device authentication is performed.
     * The user_certificates input field is ignored and no certificate data is
     * returned to the caller, instead a confirmation_token is returned in
     * the last step.
     *
     * See ConfirmDeviceWebAuthentication.
     *
     * @generated from protobuf field: teleport.devicetrust.v1.DeviceWebToken device_web_token = 4;
     */
    deviceWebToken?: DeviceWebToken;
}
/**
 * TPMAuthenticateDeviceChallenge carries the authentication challenge
 * specific to TPMs.
 *
 * @generated from protobuf message teleport.devicetrust.v1.TPMAuthenticateDeviceChallenge
 */
export interface TPMAuthenticateDeviceChallenge {
    /**
     * Randomly-generated nonce to be used during platform attestation by the
     * TPM.
     *
     * @generated from protobuf field: bytes attestation_nonce = 1;
     */
    attestationNonce: Uint8Array;
}
/**
 * TPMAuthenticateDeviceChallengeResponse carries the authentication challenge
 * response specific to TPMs.
 *
 * @generated from protobuf message teleport.devicetrust.v1.TPMAuthenticateDeviceChallengeResponse
 */
export interface TPMAuthenticateDeviceChallengeResponse {
    /**
     * The result of the client's platform attestation with the nonce provided
     * in `TPMAuthenticateDeviceChallenge`.
     *
     * @generated from protobuf field: teleport.devicetrust.v1.TPMPlatformParameters platform_parameters = 1;
     */
    platformParameters?: TPMPlatformParameters;
}
/**
 * AuthenticateDeviceChallenge carries the authentication challenge.
 *
 * @generated from protobuf message teleport.devicetrust.v1.AuthenticateDeviceChallenge
 */
export interface AuthenticateDeviceChallenge {
    /**
     * Randomly-generated, opaque challenge to be signed using the device key.
     *
     * @generated from protobuf field: bytes challenge = 1;
     */
    challenge: Uint8Array;
}
/**
 * AuthenticateDeviceChallengeResponse carries the authentication challenge
 * response.
 *
 * @generated from protobuf message teleport.devicetrust.v1.AuthenticateDeviceChallengeResponse
 */
export interface AuthenticateDeviceChallengeResponse {
    /**
     * Signature over the challenge, using the device key.
     *
     * @generated from protobuf field: bytes signature = 1;
     */
    signature: Uint8Array;
}
/**
 * Request for ConfirmDeviceWebAuthentication.
 *
 * @generated from protobuf message teleport.devicetrust.v1.ConfirmDeviceWebAuthenticationRequest
 */
export interface ConfirmDeviceWebAuthenticationRequest {
    /**
     * Confirmation token to be spent.
     *
     * @generated from protobuf field: teleport.devicetrust.v1.DeviceConfirmationToken confirmation_token = 1;
     */
    confirmationToken?: DeviceConfirmationToken;
    /**
     * Web Session identifier of the session that started this request, via
     * Teleport Proxy.
     *
     * For the request to be successful the Web Session must match the session
     * that started the authentication attempt.
     *
     * @generated from protobuf field: string current_web_session_id = 2;
     */
    currentWebSessionId: string;
}
/**
 * Response for ConfirmDeviceWebAuthentication.
 *
 * @generated from protobuf message teleport.devicetrust.v1.ConfirmDeviceWebAuthenticationResponse
 */
export interface ConfirmDeviceWebAuthenticationResponse {
}
/**
 * Request for SyncInventory.
 *
 * A typical message sequence is as follows:
 * (-> means client-to-server, <- means server-to-client)
 * -> SyncInventoryStart
 * <- SyncInventoryAck
 * (loop)
 * -> SyncInventoryDevices (add/remove devices)
 * <- SyncInventoryResult
 * (end loop)
 * -> SyncInventoryEnd
 * (loop until server closes the stream, zero or more times)
 * <- SyncInventoryMissingDevices
 * -> SyncInventoryDevices (removals only)
 * <- SyncInventoryResult
 * (end loop)
 *
 * @generated from protobuf message teleport.devicetrust.v1.SyncInventoryRequest
 */
export interface SyncInventoryRequest {
    /**
     * @generated from protobuf oneof: payload
     */
    payload: {
        oneofKind: "start";
        /**
         * @generated from protobuf field: teleport.devicetrust.v1.SyncInventoryStart start = 1;
         */
        start: SyncInventoryStart;
    } | {
        oneofKind: "end";
        /**
         * @generated from protobuf field: teleport.devicetrust.v1.SyncInventoryEnd end = 2;
         */
        end: SyncInventoryEnd;
    } | {
        oneofKind: "devicesToUpsert";
        /**
         * @generated from protobuf field: teleport.devicetrust.v1.SyncInventoryDevices devices_to_upsert = 3;
         */
        devicesToUpsert: SyncInventoryDevices;
    } | {
        oneofKind: "devicesToRemove";
        /**
         * @generated from protobuf field: teleport.devicetrust.v1.SyncInventoryDevices devices_to_remove = 4;
         */
        devicesToRemove: SyncInventoryDevices;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Response for SyncInventory.
 *
 * @generated from protobuf message teleport.devicetrust.v1.SyncInventoryResponse
 */
export interface SyncInventoryResponse {
    /**
     * @generated from protobuf oneof: payload
     */
    payload: {
        oneofKind: "ack";
        /**
         * @generated from protobuf field: teleport.devicetrust.v1.SyncInventoryAck ack = 1;
         */
        ack: SyncInventoryAck;
    } | {
        oneofKind: "result";
        /**
         * @generated from protobuf field: teleport.devicetrust.v1.SyncInventoryResult result = 2;
         */
        result: SyncInventoryResult;
    } | {
        oneofKind: "missingDevices";
        /**
         * @generated from protobuf field: teleport.devicetrust.v1.SyncInventoryMissingDevices missing_devices = 3;
         */
        missingDevices: SyncInventoryMissingDevices;
    } | {
        oneofKind: undefined;
    };
}
/**
 * SyncInventoryStart starts the inventory sync.
 *
 * @generated from protobuf message teleport.devicetrust.v1.SyncInventoryStart
 */
export interface SyncInventoryStart {
    /**
     * Source of the inventory sync.
     * Used for all devices. The `source` field in individual devices is ignored
     * by this RPC.
     *
     * @generated from protobuf field: teleport.devicetrust.v1.DeviceSource source = 1;
     */
    source?: DeviceSource;
    /**
     * If true, the server keeps track of the devices upserted during the sync.
     * After receiving the [SyncInventoryEnd] message, the server informs the
     * client of all devices that are present in storage but not observed in the
     * upserts.
     * See [SyncInventoryRequest] and [SyncInventoryMissingDevices] for details.
     *
     * @generated from protobuf field: bool track_missing_devices = 4;
     */
    trackMissingDevices: boolean;
}
/**
 * SyncInventoryEnd ends the inventory sync, signaling that no more
 * SyncInventoryDevices messages will be sent by the client.
 *
 * @generated from protobuf message teleport.devicetrust.v1.SyncInventoryEnd
 */
export interface SyncInventoryEnd {
}
/**
 * SyncInventoryDevices transports devices to add/update/remove.
 * Removals only need identifying fields to be set.
 *
 * @generated from protobuf message teleport.devicetrust.v1.SyncInventoryDevices
 */
export interface SyncInventoryDevices {
    /**
     * Devices to sync.
     *
     * @generated from protobuf field: repeated teleport.devicetrust.v1.Device devices = 1;
     */
    devices: Device[];
}
/**
 * SyncInventoryAck is used to confirm successful processing of messages that
 * lack a more specific response.
 *
 * @generated from protobuf message teleport.devicetrust.v1.SyncInventoryAck
 */
export interface SyncInventoryAck {
}
/**
 * SyncInventoryResult is the response for SyncInventoryDevices or
 * SyncInventoryEnd
 * It lists all synced/deleted devices.
 *
 * @generated from protobuf message teleport.devicetrust.v1.SyncInventoryResult
 */
export interface SyncInventoryResult {
    /**
     * Devices modified, in the same order as the input when applicable.
     *
     * @generated from protobuf field: repeated teleport.devicetrust.v1.DeviceOrStatus devices = 1;
     */
    devices: DeviceOrStatus[];
}
/**
 * SyncInventoryMissingDevices informs the sync client of all stored devices
 * that were not observed in upserts during the sync.
 *
 * Requires `track_missing_devices` to be set in the [SyncInventoryStart]
 * message.
 *
 * The client must follow up with a [SyncInventoryDevices] message, including
 * any devices to be deleted.
 *
 * @generated from protobuf message teleport.devicetrust.v1.SyncInventoryMissingDevices
 */
export interface SyncInventoryMissingDevices {
    /**
     * Devices missing from the client-side sync.
     * Guaranteed to have the following fields: id, os_type, asset_tag and
     * profile.external_id.
     *
     * @generated from protobuf field: repeated teleport.devicetrust.v1.Device devices = 1;
     */
    devices: Device[];
}
/**
 * Superseded by ResourceUsageService.GetUsage.
 *
 * @generated from protobuf message teleport.devicetrust.v1.GetDevicesUsageRequest
 */
export interface GetDevicesUsageRequest {
}
/**
 * DeviceView specifies which fields of returned devices should be present.
 *
 * @generated from protobuf enum teleport.devicetrust.v1.DeviceView
 */
export enum DeviceView {
    /**
     * @generated from protobuf enum value: DEVICE_VIEW_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * View for general device listings, like `tctl devices ls`.
     * Contains only basic information, such as IDs and enrollment status.
     *
     * @generated from protobuf enum value: DEVICE_VIEW_LIST = 1;
     */
    LIST = 1,
    /**
     * View for detailed device queries, like `tctl get devices`.
     * Presents a complete view of the device.
     *
     * @generated from protobuf enum value: DEVICE_VIEW_RESOURCE = 2;
     */
    RESOURCE = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class CreateDeviceRequest$Type extends MessageType<CreateDeviceRequest> {
    constructor() {
        super("teleport.devicetrust.v1.CreateDeviceRequest", [
            { no: 1, name: "device", kind: "message", T: () => Device },
            { no: 2, name: "create_enroll_token", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "create_as_resource", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "enroll_token_expire_time", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<CreateDeviceRequest>): CreateDeviceRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.createEnrollToken = false;
        message.createAsResource = false;
        if (value !== undefined)
            reflectionMergePartial<CreateDeviceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateDeviceRequest): CreateDeviceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.devicetrust.v1.Device device */ 1:
                    message.device = Device.internalBinaryRead(reader, reader.uint32(), options, message.device);
                    break;
                case /* bool create_enroll_token */ 2:
                    message.createEnrollToken = reader.bool();
                    break;
                case /* bool create_as_resource */ 3:
                    message.createAsResource = reader.bool();
                    break;
                case /* google.protobuf.Timestamp enroll_token_expire_time */ 4:
                    message.enrollTokenExpireTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.enrollTokenExpireTime);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateDeviceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.devicetrust.v1.Device device = 1; */
        if (message.device)
            Device.internalBinaryWrite(message.device, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool create_enroll_token = 2; */
        if (message.createEnrollToken !== false)
            writer.tag(2, WireType.Varint).bool(message.createEnrollToken);
        /* bool create_as_resource = 3; */
        if (message.createAsResource !== false)
            writer.tag(3, WireType.Varint).bool(message.createAsResource);
        /* google.protobuf.Timestamp enroll_token_expire_time = 4; */
        if (message.enrollTokenExpireTime)
            Timestamp.internalBinaryWrite(message.enrollTokenExpireTime, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.CreateDeviceRequest
 */
export const CreateDeviceRequest = new CreateDeviceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateDeviceRequest$Type extends MessageType<UpdateDeviceRequest> {
    constructor() {
        super("teleport.devicetrust.v1.UpdateDeviceRequest", [
            { no: 1, name: "device", kind: "message", T: () => Device },
            { no: 2, name: "update_mask", kind: "message", T: () => FieldMask }
        ]);
    }
    create(value?: PartialMessage<UpdateDeviceRequest>): UpdateDeviceRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdateDeviceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateDeviceRequest): UpdateDeviceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.devicetrust.v1.Device device */ 1:
                    message.device = Device.internalBinaryRead(reader, reader.uint32(), options, message.device);
                    break;
                case /* google.protobuf.FieldMask update_mask */ 2:
                    message.updateMask = FieldMask.internalBinaryRead(reader, reader.uint32(), options, message.updateMask);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateDeviceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.devicetrust.v1.Device device = 1; */
        if (message.device)
            Device.internalBinaryWrite(message.device, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.FieldMask update_mask = 2; */
        if (message.updateMask)
            FieldMask.internalBinaryWrite(message.updateMask, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.UpdateDeviceRequest
 */
export const UpdateDeviceRequest = new UpdateDeviceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpsertDeviceRequest$Type extends MessageType<UpsertDeviceRequest> {
    constructor() {
        super("teleport.devicetrust.v1.UpsertDeviceRequest", [
            { no: 1, name: "device", kind: "message", T: () => Device },
            { no: 2, name: "create_as_resource", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<UpsertDeviceRequest>): UpsertDeviceRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.createAsResource = false;
        if (value !== undefined)
            reflectionMergePartial<UpsertDeviceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpsertDeviceRequest): UpsertDeviceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.devicetrust.v1.Device device */ 1:
                    message.device = Device.internalBinaryRead(reader, reader.uint32(), options, message.device);
                    break;
                case /* bool create_as_resource */ 2:
                    message.createAsResource = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpsertDeviceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.devicetrust.v1.Device device = 1; */
        if (message.device)
            Device.internalBinaryWrite(message.device, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool create_as_resource = 2; */
        if (message.createAsResource !== false)
            writer.tag(2, WireType.Varint).bool(message.createAsResource);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.UpsertDeviceRequest
 */
export const UpsertDeviceRequest = new UpsertDeviceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteDeviceRequest$Type extends MessageType<DeleteDeviceRequest> {
    constructor() {
        super("teleport.devicetrust.v1.DeleteDeviceRequest", [
            { no: 1, name: "device_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteDeviceRequest>): DeleteDeviceRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.deviceId = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteDeviceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteDeviceRequest): DeleteDeviceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string device_id */ 1:
                    message.deviceId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteDeviceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string device_id = 1; */
        if (message.deviceId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.deviceId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.DeleteDeviceRequest
 */
export const DeleteDeviceRequest = new DeleteDeviceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FindDevicesRequest$Type extends MessageType<FindDevicesRequest> {
    constructor() {
        super("teleport.devicetrust.v1.FindDevicesRequest", [
            { no: 1, name: "id_or_tag", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FindDevicesRequest>): FindDevicesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.idOrTag = "";
        if (value !== undefined)
            reflectionMergePartial<FindDevicesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FindDevicesRequest): FindDevicesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id_or_tag */ 1:
                    message.idOrTag = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FindDevicesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id_or_tag = 1; */
        if (message.idOrTag !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.idOrTag);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.FindDevicesRequest
 */
export const FindDevicesRequest = new FindDevicesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FindDevicesResponse$Type extends MessageType<FindDevicesResponse> {
    constructor() {
        super("teleport.devicetrust.v1.FindDevicesResponse", [
            { no: 1, name: "devices", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Device }
        ]);
    }
    create(value?: PartialMessage<FindDevicesResponse>): FindDevicesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.devices = [];
        if (value !== undefined)
            reflectionMergePartial<FindDevicesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FindDevicesResponse): FindDevicesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated teleport.devicetrust.v1.Device devices */ 1:
                    message.devices.push(Device.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FindDevicesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated teleport.devicetrust.v1.Device devices = 1; */
        for (let i = 0; i < message.devices.length; i++)
            Device.internalBinaryWrite(message.devices[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.FindDevicesResponse
 */
export const FindDevicesResponse = new FindDevicesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDeviceRequest$Type extends MessageType<GetDeviceRequest> {
    constructor() {
        super("teleport.devicetrust.v1.GetDeviceRequest", [
            { no: 1, name: "device_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetDeviceRequest>): GetDeviceRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.deviceId = "";
        if (value !== undefined)
            reflectionMergePartial<GetDeviceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDeviceRequest): GetDeviceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string device_id */ 1:
                    message.deviceId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDeviceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string device_id = 1; */
        if (message.deviceId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.deviceId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.GetDeviceRequest
 */
export const GetDeviceRequest = new GetDeviceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListDevicesRequest$Type extends MessageType<ListDevicesRequest> {
    constructor() {
        super("teleport.devicetrust.v1.ListDevicesRequest", [
            { no: 1, name: "page_size", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "view", kind: "enum", T: () => ["teleport.devicetrust.v1.DeviceView", DeviceView, "DEVICE_VIEW_"] }
        ]);
    }
    create(value?: PartialMessage<ListDevicesRequest>): ListDevicesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pageSize = 0;
        message.pageToken = "";
        message.view = 0;
        if (value !== undefined)
            reflectionMergePartial<ListDevicesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListDevicesRequest): ListDevicesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 page_size */ 1:
                    message.pageSize = reader.int32();
                    break;
                case /* string page_token */ 2:
                    message.pageToken = reader.string();
                    break;
                case /* teleport.devicetrust.v1.DeviceView view */ 3:
                    message.view = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListDevicesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 page_size = 1; */
        if (message.pageSize !== 0)
            writer.tag(1, WireType.Varint).int32(message.pageSize);
        /* string page_token = 2; */
        if (message.pageToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.pageToken);
        /* teleport.devicetrust.v1.DeviceView view = 3; */
        if (message.view !== 0)
            writer.tag(3, WireType.Varint).int32(message.view);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.ListDevicesRequest
 */
export const ListDevicesRequest = new ListDevicesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListDevicesResponse$Type extends MessageType<ListDevicesResponse> {
    constructor() {
        super("teleport.devicetrust.v1.ListDevicesResponse", [
            { no: 1, name: "devices", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Device },
            { no: 2, name: "next_page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListDevicesResponse>): ListDevicesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.devices = [];
        message.nextPageToken = "";
        if (value !== undefined)
            reflectionMergePartial<ListDevicesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListDevicesResponse): ListDevicesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated teleport.devicetrust.v1.Device devices */ 1:
                    message.devices.push(Device.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string next_page_token */ 2:
                    message.nextPageToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListDevicesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated teleport.devicetrust.v1.Device devices = 1; */
        for (let i = 0; i < message.devices.length; i++)
            Device.internalBinaryWrite(message.devices[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string next_page_token = 2; */
        if (message.nextPageToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.nextPageToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.ListDevicesResponse
 */
export const ListDevicesResponse = new ListDevicesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BulkCreateDevicesRequest$Type extends MessageType<BulkCreateDevicesRequest> {
    constructor() {
        super("teleport.devicetrust.v1.BulkCreateDevicesRequest", [
            { no: 1, name: "devices", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Device },
            { no: 2, name: "create_as_resource", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<BulkCreateDevicesRequest>): BulkCreateDevicesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.devices = [];
        message.createAsResource = false;
        if (value !== undefined)
            reflectionMergePartial<BulkCreateDevicesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BulkCreateDevicesRequest): BulkCreateDevicesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated teleport.devicetrust.v1.Device devices */ 1:
                    message.devices.push(Device.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool create_as_resource */ 2:
                    message.createAsResource = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BulkCreateDevicesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated teleport.devicetrust.v1.Device devices = 1; */
        for (let i = 0; i < message.devices.length; i++)
            Device.internalBinaryWrite(message.devices[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool create_as_resource = 2; */
        if (message.createAsResource !== false)
            writer.tag(2, WireType.Varint).bool(message.createAsResource);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.BulkCreateDevicesRequest
 */
export const BulkCreateDevicesRequest = new BulkCreateDevicesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BulkCreateDevicesResponse$Type extends MessageType<BulkCreateDevicesResponse> {
    constructor() {
        super("teleport.devicetrust.v1.BulkCreateDevicesResponse", [
            { no: 1, name: "devices", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DeviceOrStatus }
        ]);
    }
    create(value?: PartialMessage<BulkCreateDevicesResponse>): BulkCreateDevicesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.devices = [];
        if (value !== undefined)
            reflectionMergePartial<BulkCreateDevicesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BulkCreateDevicesResponse): BulkCreateDevicesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated teleport.devicetrust.v1.DeviceOrStatus devices */ 1:
                    message.devices.push(DeviceOrStatus.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BulkCreateDevicesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated teleport.devicetrust.v1.DeviceOrStatus devices = 1; */
        for (let i = 0; i < message.devices.length; i++)
            DeviceOrStatus.internalBinaryWrite(message.devices[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.BulkCreateDevicesResponse
 */
export const BulkCreateDevicesResponse = new BulkCreateDevicesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeviceOrStatus$Type extends MessageType<DeviceOrStatus> {
    constructor() {
        super("teleport.devicetrust.v1.DeviceOrStatus", [
            { no: 1, name: "status", kind: "message", T: () => Status },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "deleted", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<DeviceOrStatus>): DeviceOrStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.deleted = false;
        if (value !== undefined)
            reflectionMergePartial<DeviceOrStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeviceOrStatus): DeviceOrStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.rpc.Status status */ 1:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                case /* bool deleted */ 3:
                    message.deleted = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeviceOrStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.rpc.Status status = 1; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.id);
        /* bool deleted = 3; */
        if (message.deleted !== false)
            writer.tag(3, WireType.Varint).bool(message.deleted);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.DeviceOrStatus
 */
export const DeviceOrStatus = new DeviceOrStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateDeviceEnrollTokenRequest$Type extends MessageType<CreateDeviceEnrollTokenRequest> {
    constructor() {
        super("teleport.devicetrust.v1.CreateDeviceEnrollTokenRequest", [
            { no: 1, name: "device_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "device_data", kind: "message", T: () => DeviceCollectedData },
            { no: 3, name: "expire_time", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<CreateDeviceEnrollTokenRequest>): CreateDeviceEnrollTokenRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.deviceId = "";
        if (value !== undefined)
            reflectionMergePartial<CreateDeviceEnrollTokenRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateDeviceEnrollTokenRequest): CreateDeviceEnrollTokenRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string device_id */ 1:
                    message.deviceId = reader.string();
                    break;
                case /* teleport.devicetrust.v1.DeviceCollectedData device_data */ 2:
                    message.deviceData = DeviceCollectedData.internalBinaryRead(reader, reader.uint32(), options, message.deviceData);
                    break;
                case /* google.protobuf.Timestamp expire_time */ 3:
                    message.expireTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expireTime);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateDeviceEnrollTokenRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string device_id = 1; */
        if (message.deviceId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.deviceId);
        /* teleport.devicetrust.v1.DeviceCollectedData device_data = 2; */
        if (message.deviceData)
            DeviceCollectedData.internalBinaryWrite(message.deviceData, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp expire_time = 3; */
        if (message.expireTime)
            Timestamp.internalBinaryWrite(message.expireTime, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.CreateDeviceEnrollTokenRequest
 */
export const CreateDeviceEnrollTokenRequest = new CreateDeviceEnrollTokenRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EnrollDeviceRequest$Type extends MessageType<EnrollDeviceRequest> {
    constructor() {
        super("teleport.devicetrust.v1.EnrollDeviceRequest", [
            { no: 1, name: "init", kind: "message", oneof: "payload", T: () => EnrollDeviceInit },
            { no: 2, name: "macos_challenge_response", kind: "message", oneof: "payload", T: () => MacOSEnrollChallengeResponse },
            { no: 3, name: "tpm_challenge_response", kind: "message", oneof: "payload", T: () => TPMEnrollChallengeResponse }
        ]);
    }
    create(value?: PartialMessage<EnrollDeviceRequest>): EnrollDeviceRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.payload = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<EnrollDeviceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EnrollDeviceRequest): EnrollDeviceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.devicetrust.v1.EnrollDeviceInit init */ 1:
                    message.payload = {
                        oneofKind: "init",
                        init: EnrollDeviceInit.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).init)
                    };
                    break;
                case /* teleport.devicetrust.v1.MacOSEnrollChallengeResponse macos_challenge_response */ 2:
                    message.payload = {
                        oneofKind: "macosChallengeResponse",
                        macosChallengeResponse: MacOSEnrollChallengeResponse.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).macosChallengeResponse)
                    };
                    break;
                case /* teleport.devicetrust.v1.TPMEnrollChallengeResponse tpm_challenge_response */ 3:
                    message.payload = {
                        oneofKind: "tpmChallengeResponse",
                        tpmChallengeResponse: TPMEnrollChallengeResponse.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).tpmChallengeResponse)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EnrollDeviceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.devicetrust.v1.EnrollDeviceInit init = 1; */
        if (message.payload.oneofKind === "init")
            EnrollDeviceInit.internalBinaryWrite(message.payload.init, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* teleport.devicetrust.v1.MacOSEnrollChallengeResponse macos_challenge_response = 2; */
        if (message.payload.oneofKind === "macosChallengeResponse")
            MacOSEnrollChallengeResponse.internalBinaryWrite(message.payload.macosChallengeResponse, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* teleport.devicetrust.v1.TPMEnrollChallengeResponse tpm_challenge_response = 3; */
        if (message.payload.oneofKind === "tpmChallengeResponse")
            TPMEnrollChallengeResponse.internalBinaryWrite(message.payload.tpmChallengeResponse, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.EnrollDeviceRequest
 */
export const EnrollDeviceRequest = new EnrollDeviceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EnrollDeviceResponse$Type extends MessageType<EnrollDeviceResponse> {
    constructor() {
        super("teleport.devicetrust.v1.EnrollDeviceResponse", [
            { no: 1, name: "success", kind: "message", oneof: "payload", T: () => EnrollDeviceSuccess },
            { no: 2, name: "macos_challenge", kind: "message", oneof: "payload", T: () => MacOSEnrollChallenge },
            { no: 3, name: "tpm_challenge", kind: "message", oneof: "payload", T: () => TPMEnrollChallenge }
        ]);
    }
    create(value?: PartialMessage<EnrollDeviceResponse>): EnrollDeviceResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.payload = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<EnrollDeviceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EnrollDeviceResponse): EnrollDeviceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.devicetrust.v1.EnrollDeviceSuccess success */ 1:
                    message.payload = {
                        oneofKind: "success",
                        success: EnrollDeviceSuccess.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).success)
                    };
                    break;
                case /* teleport.devicetrust.v1.MacOSEnrollChallenge macos_challenge */ 2:
                    message.payload = {
                        oneofKind: "macosChallenge",
                        macosChallenge: MacOSEnrollChallenge.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).macosChallenge)
                    };
                    break;
                case /* teleport.devicetrust.v1.TPMEnrollChallenge tpm_challenge */ 3:
                    message.payload = {
                        oneofKind: "tpmChallenge",
                        tpmChallenge: TPMEnrollChallenge.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).tpmChallenge)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EnrollDeviceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.devicetrust.v1.EnrollDeviceSuccess success = 1; */
        if (message.payload.oneofKind === "success")
            EnrollDeviceSuccess.internalBinaryWrite(message.payload.success, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* teleport.devicetrust.v1.MacOSEnrollChallenge macos_challenge = 2; */
        if (message.payload.oneofKind === "macosChallenge")
            MacOSEnrollChallenge.internalBinaryWrite(message.payload.macosChallenge, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* teleport.devicetrust.v1.TPMEnrollChallenge tpm_challenge = 3; */
        if (message.payload.oneofKind === "tpmChallenge")
            TPMEnrollChallenge.internalBinaryWrite(message.payload.tpmChallenge, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.EnrollDeviceResponse
 */
export const EnrollDeviceResponse = new EnrollDeviceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EnrollDeviceInit$Type extends MessageType<EnrollDeviceInit> {
    constructor() {
        super("teleport.devicetrust.v1.EnrollDeviceInit", [
            { no: 1, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "credential_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "device_data", kind: "message", T: () => DeviceCollectedData },
            { no: 4, name: "macos", kind: "message", T: () => MacOSEnrollPayload },
            { no: 5, name: "tpm", kind: "message", T: () => TPMEnrollPayload }
        ]);
    }
    create(value?: PartialMessage<EnrollDeviceInit>): EnrollDeviceInit {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.token = "";
        message.credentialId = "";
        if (value !== undefined)
            reflectionMergePartial<EnrollDeviceInit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EnrollDeviceInit): EnrollDeviceInit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string token */ 1:
                    message.token = reader.string();
                    break;
                case /* string credential_id */ 2:
                    message.credentialId = reader.string();
                    break;
                case /* teleport.devicetrust.v1.DeviceCollectedData device_data */ 3:
                    message.deviceData = DeviceCollectedData.internalBinaryRead(reader, reader.uint32(), options, message.deviceData);
                    break;
                case /* teleport.devicetrust.v1.MacOSEnrollPayload macos */ 4:
                    message.macos = MacOSEnrollPayload.internalBinaryRead(reader, reader.uint32(), options, message.macos);
                    break;
                case /* teleport.devicetrust.v1.TPMEnrollPayload tpm */ 5:
                    message.tpm = TPMEnrollPayload.internalBinaryRead(reader, reader.uint32(), options, message.tpm);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EnrollDeviceInit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string token = 1; */
        if (message.token !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.token);
        /* string credential_id = 2; */
        if (message.credentialId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.credentialId);
        /* teleport.devicetrust.v1.DeviceCollectedData device_data = 3; */
        if (message.deviceData)
            DeviceCollectedData.internalBinaryWrite(message.deviceData, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* teleport.devicetrust.v1.MacOSEnrollPayload macos = 4; */
        if (message.macos)
            MacOSEnrollPayload.internalBinaryWrite(message.macos, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* teleport.devicetrust.v1.TPMEnrollPayload tpm = 5; */
        if (message.tpm)
            TPMEnrollPayload.internalBinaryWrite(message.tpm, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.EnrollDeviceInit
 */
export const EnrollDeviceInit = new EnrollDeviceInit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EnrollDeviceSuccess$Type extends MessageType<EnrollDeviceSuccess> {
    constructor() {
        super("teleport.devicetrust.v1.EnrollDeviceSuccess", [
            { no: 1, name: "device", kind: "message", T: () => Device }
        ]);
    }
    create(value?: PartialMessage<EnrollDeviceSuccess>): EnrollDeviceSuccess {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<EnrollDeviceSuccess>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EnrollDeviceSuccess): EnrollDeviceSuccess {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.devicetrust.v1.Device device */ 1:
                    message.device = Device.internalBinaryRead(reader, reader.uint32(), options, message.device);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EnrollDeviceSuccess, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.devicetrust.v1.Device device = 1; */
        if (message.device)
            Device.internalBinaryWrite(message.device, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.EnrollDeviceSuccess
 */
export const EnrollDeviceSuccess = new EnrollDeviceSuccess$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MacOSEnrollPayload$Type extends MessageType<MacOSEnrollPayload> {
    constructor() {
        super("teleport.devicetrust.v1.MacOSEnrollPayload", [
            { no: 2, name: "public_key_der", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<MacOSEnrollPayload>): MacOSEnrollPayload {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.publicKeyDer = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<MacOSEnrollPayload>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MacOSEnrollPayload): MacOSEnrollPayload {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes public_key_der */ 2:
                    message.publicKeyDer = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MacOSEnrollPayload, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes public_key_der = 2; */
        if (message.publicKeyDer.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.publicKeyDer);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.MacOSEnrollPayload
 */
export const MacOSEnrollPayload = new MacOSEnrollPayload$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MacOSEnrollChallenge$Type extends MessageType<MacOSEnrollChallenge> {
    constructor() {
        super("teleport.devicetrust.v1.MacOSEnrollChallenge", [
            { no: 1, name: "challenge", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<MacOSEnrollChallenge>): MacOSEnrollChallenge {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.challenge = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<MacOSEnrollChallenge>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MacOSEnrollChallenge): MacOSEnrollChallenge {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes challenge */ 1:
                    message.challenge = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MacOSEnrollChallenge, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes challenge = 1; */
        if (message.challenge.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.challenge);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.MacOSEnrollChallenge
 */
export const MacOSEnrollChallenge = new MacOSEnrollChallenge$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MacOSEnrollChallengeResponse$Type extends MessageType<MacOSEnrollChallengeResponse> {
    constructor() {
        super("teleport.devicetrust.v1.MacOSEnrollChallengeResponse", [
            { no: 2, name: "signature", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<MacOSEnrollChallengeResponse>): MacOSEnrollChallengeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.signature = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<MacOSEnrollChallengeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MacOSEnrollChallengeResponse): MacOSEnrollChallengeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes signature */ 2:
                    message.signature = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MacOSEnrollChallengeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes signature = 2; */
        if (message.signature.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.signature);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.MacOSEnrollChallengeResponse
 */
export const MacOSEnrollChallengeResponse = new MacOSEnrollChallengeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TPMEnrollPayload$Type extends MessageType<TPMEnrollPayload> {
    constructor() {
        super("teleport.devicetrust.v1.TPMEnrollPayload", [
            { no: 1, name: "ek_cert", kind: "scalar", oneof: "ek", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "ek_key", kind: "scalar", oneof: "ek", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "attestation_parameters", kind: "message", T: () => TPMAttestationParameters }
        ]);
    }
    create(value?: PartialMessage<TPMEnrollPayload>): TPMEnrollPayload {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ek = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<TPMEnrollPayload>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TPMEnrollPayload): TPMEnrollPayload {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes ek_cert */ 1:
                    message.ek = {
                        oneofKind: "ekCert",
                        ekCert: reader.bytes()
                    };
                    break;
                case /* bytes ek_key */ 2:
                    message.ek = {
                        oneofKind: "ekKey",
                        ekKey: reader.bytes()
                    };
                    break;
                case /* teleport.devicetrust.v1.TPMAttestationParameters attestation_parameters */ 3:
                    message.attestationParameters = TPMAttestationParameters.internalBinaryRead(reader, reader.uint32(), options, message.attestationParameters);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TPMEnrollPayload, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes ek_cert = 1; */
        if (message.ek.oneofKind === "ekCert")
            writer.tag(1, WireType.LengthDelimited).bytes(message.ek.ekCert);
        /* bytes ek_key = 2; */
        if (message.ek.oneofKind === "ekKey")
            writer.tag(2, WireType.LengthDelimited).bytes(message.ek.ekKey);
        /* teleport.devicetrust.v1.TPMAttestationParameters attestation_parameters = 3; */
        if (message.attestationParameters)
            TPMAttestationParameters.internalBinaryWrite(message.attestationParameters, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.TPMEnrollPayload
 */
export const TPMEnrollPayload = new TPMEnrollPayload$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TPMAttestationParameters$Type extends MessageType<TPMAttestationParameters> {
    constructor() {
        super("teleport.devicetrust.v1.TPMAttestationParameters", [
            { no: 1, name: "public", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "create_data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "create_attestation", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "create_signature", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<TPMAttestationParameters>): TPMAttestationParameters {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.public = new Uint8Array(0);
        message.createData = new Uint8Array(0);
        message.createAttestation = new Uint8Array(0);
        message.createSignature = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<TPMAttestationParameters>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TPMAttestationParameters): TPMAttestationParameters {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes public */ 1:
                    message.public = reader.bytes();
                    break;
                case /* bytes create_data */ 2:
                    message.createData = reader.bytes();
                    break;
                case /* bytes create_attestation */ 3:
                    message.createAttestation = reader.bytes();
                    break;
                case /* bytes create_signature */ 4:
                    message.createSignature = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TPMAttestationParameters, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes public = 1; */
        if (message.public.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.public);
        /* bytes create_data = 2; */
        if (message.createData.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.createData);
        /* bytes create_attestation = 3; */
        if (message.createAttestation.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.createAttestation);
        /* bytes create_signature = 4; */
        if (message.createSignature.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.createSignature);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.TPMAttestationParameters
 */
export const TPMAttestationParameters = new TPMAttestationParameters$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TPMEnrollChallenge$Type extends MessageType<TPMEnrollChallenge> {
    constructor() {
        super("teleport.devicetrust.v1.TPMEnrollChallenge", [
            { no: 1, name: "encrypted_credential", kind: "message", T: () => TPMEncryptedCredential },
            { no: 2, name: "attestation_nonce", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<TPMEnrollChallenge>): TPMEnrollChallenge {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.attestationNonce = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<TPMEnrollChallenge>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TPMEnrollChallenge): TPMEnrollChallenge {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.devicetrust.v1.TPMEncryptedCredential encrypted_credential */ 1:
                    message.encryptedCredential = TPMEncryptedCredential.internalBinaryRead(reader, reader.uint32(), options, message.encryptedCredential);
                    break;
                case /* bytes attestation_nonce */ 2:
                    message.attestationNonce = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TPMEnrollChallenge, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.devicetrust.v1.TPMEncryptedCredential encrypted_credential = 1; */
        if (message.encryptedCredential)
            TPMEncryptedCredential.internalBinaryWrite(message.encryptedCredential, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bytes attestation_nonce = 2; */
        if (message.attestationNonce.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.attestationNonce);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.TPMEnrollChallenge
 */
export const TPMEnrollChallenge = new TPMEnrollChallenge$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TPMEncryptedCredential$Type extends MessageType<TPMEncryptedCredential> {
    constructor() {
        super("teleport.devicetrust.v1.TPMEncryptedCredential", [
            { no: 1, name: "credential_blob", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "secret", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<TPMEncryptedCredential>): TPMEncryptedCredential {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.credentialBlob = new Uint8Array(0);
        message.secret = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<TPMEncryptedCredential>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TPMEncryptedCredential): TPMEncryptedCredential {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes credential_blob */ 1:
                    message.credentialBlob = reader.bytes();
                    break;
                case /* bytes secret */ 2:
                    message.secret = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TPMEncryptedCredential, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes credential_blob = 1; */
        if (message.credentialBlob.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.credentialBlob);
        /* bytes secret = 2; */
        if (message.secret.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.secret);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.TPMEncryptedCredential
 */
export const TPMEncryptedCredential = new TPMEncryptedCredential$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TPMEnrollChallengeResponse$Type extends MessageType<TPMEnrollChallengeResponse> {
    constructor() {
        super("teleport.devicetrust.v1.TPMEnrollChallengeResponse", [
            { no: 1, name: "solution", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "platform_parameters", kind: "message", T: () => TPMPlatformParameters }
        ]);
    }
    create(value?: PartialMessage<TPMEnrollChallengeResponse>): TPMEnrollChallengeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.solution = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<TPMEnrollChallengeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TPMEnrollChallengeResponse): TPMEnrollChallengeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes solution */ 1:
                    message.solution = reader.bytes();
                    break;
                case /* teleport.devicetrust.v1.TPMPlatformParameters platform_parameters */ 2:
                    message.platformParameters = TPMPlatformParameters.internalBinaryRead(reader, reader.uint32(), options, message.platformParameters);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TPMEnrollChallengeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes solution = 1; */
        if (message.solution.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.solution);
        /* teleport.devicetrust.v1.TPMPlatformParameters platform_parameters = 2; */
        if (message.platformParameters)
            TPMPlatformParameters.internalBinaryWrite(message.platformParameters, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.TPMEnrollChallengeResponse
 */
export const TPMEnrollChallengeResponse = new TPMEnrollChallengeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthenticateDeviceRequest$Type extends MessageType<AuthenticateDeviceRequest> {
    constructor() {
        super("teleport.devicetrust.v1.AuthenticateDeviceRequest", [
            { no: 1, name: "init", kind: "message", oneof: "payload", T: () => AuthenticateDeviceInit },
            { no: 2, name: "challenge_response", kind: "message", oneof: "payload", T: () => AuthenticateDeviceChallengeResponse },
            { no: 3, name: "tpm_challenge_response", kind: "message", oneof: "payload", T: () => TPMAuthenticateDeviceChallengeResponse }
        ]);
    }
    create(value?: PartialMessage<AuthenticateDeviceRequest>): AuthenticateDeviceRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.payload = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<AuthenticateDeviceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthenticateDeviceRequest): AuthenticateDeviceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.devicetrust.v1.AuthenticateDeviceInit init */ 1:
                    message.payload = {
                        oneofKind: "init",
                        init: AuthenticateDeviceInit.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).init)
                    };
                    break;
                case /* teleport.devicetrust.v1.AuthenticateDeviceChallengeResponse challenge_response */ 2:
                    message.payload = {
                        oneofKind: "challengeResponse",
                        challengeResponse: AuthenticateDeviceChallengeResponse.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).challengeResponse)
                    };
                    break;
                case /* teleport.devicetrust.v1.TPMAuthenticateDeviceChallengeResponse tpm_challenge_response */ 3:
                    message.payload = {
                        oneofKind: "tpmChallengeResponse",
                        tpmChallengeResponse: TPMAuthenticateDeviceChallengeResponse.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).tpmChallengeResponse)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthenticateDeviceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.devicetrust.v1.AuthenticateDeviceInit init = 1; */
        if (message.payload.oneofKind === "init")
            AuthenticateDeviceInit.internalBinaryWrite(message.payload.init, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* teleport.devicetrust.v1.AuthenticateDeviceChallengeResponse challenge_response = 2; */
        if (message.payload.oneofKind === "challengeResponse")
            AuthenticateDeviceChallengeResponse.internalBinaryWrite(message.payload.challengeResponse, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* teleport.devicetrust.v1.TPMAuthenticateDeviceChallengeResponse tpm_challenge_response = 3; */
        if (message.payload.oneofKind === "tpmChallengeResponse")
            TPMAuthenticateDeviceChallengeResponse.internalBinaryWrite(message.payload.tpmChallengeResponse, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.AuthenticateDeviceRequest
 */
export const AuthenticateDeviceRequest = new AuthenticateDeviceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthenticateDeviceResponse$Type extends MessageType<AuthenticateDeviceResponse> {
    constructor() {
        super("teleport.devicetrust.v1.AuthenticateDeviceResponse", [
            { no: 1, name: "challenge", kind: "message", oneof: "payload", T: () => AuthenticateDeviceChallenge },
            { no: 2, name: "user_certificates", kind: "message", oneof: "payload", T: () => UserCertificates },
            { no: 3, name: "tpm_challenge", kind: "message", oneof: "payload", T: () => TPMAuthenticateDeviceChallenge },
            { no: 4, name: "confirmation_token", kind: "message", oneof: "payload", T: () => DeviceConfirmationToken }
        ]);
    }
    create(value?: PartialMessage<AuthenticateDeviceResponse>): AuthenticateDeviceResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.payload = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<AuthenticateDeviceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthenticateDeviceResponse): AuthenticateDeviceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.devicetrust.v1.AuthenticateDeviceChallenge challenge */ 1:
                    message.payload = {
                        oneofKind: "challenge",
                        challenge: AuthenticateDeviceChallenge.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).challenge)
                    };
                    break;
                case /* teleport.devicetrust.v1.UserCertificates user_certificates */ 2:
                    message.payload = {
                        oneofKind: "userCertificates",
                        userCertificates: UserCertificates.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).userCertificates)
                    };
                    break;
                case /* teleport.devicetrust.v1.TPMAuthenticateDeviceChallenge tpm_challenge */ 3:
                    message.payload = {
                        oneofKind: "tpmChallenge",
                        tpmChallenge: TPMAuthenticateDeviceChallenge.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).tpmChallenge)
                    };
                    break;
                case /* teleport.devicetrust.v1.DeviceConfirmationToken confirmation_token */ 4:
                    message.payload = {
                        oneofKind: "confirmationToken",
                        confirmationToken: DeviceConfirmationToken.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).confirmationToken)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthenticateDeviceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.devicetrust.v1.AuthenticateDeviceChallenge challenge = 1; */
        if (message.payload.oneofKind === "challenge")
            AuthenticateDeviceChallenge.internalBinaryWrite(message.payload.challenge, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* teleport.devicetrust.v1.UserCertificates user_certificates = 2; */
        if (message.payload.oneofKind === "userCertificates")
            UserCertificates.internalBinaryWrite(message.payload.userCertificates, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* teleport.devicetrust.v1.TPMAuthenticateDeviceChallenge tpm_challenge = 3; */
        if (message.payload.oneofKind === "tpmChallenge")
            TPMAuthenticateDeviceChallenge.internalBinaryWrite(message.payload.tpmChallenge, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* teleport.devicetrust.v1.DeviceConfirmationToken confirmation_token = 4; */
        if (message.payload.oneofKind === "confirmationToken")
            DeviceConfirmationToken.internalBinaryWrite(message.payload.confirmationToken, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.AuthenticateDeviceResponse
 */
export const AuthenticateDeviceResponse = new AuthenticateDeviceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthenticateDeviceInit$Type extends MessageType<AuthenticateDeviceInit> {
    constructor() {
        super("teleport.devicetrust.v1.AuthenticateDeviceInit", [
            { no: 1, name: "user_certificates", kind: "message", T: () => UserCertificates },
            { no: 2, name: "credential_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "device_data", kind: "message", T: () => DeviceCollectedData },
            { no: 4, name: "device_web_token", kind: "message", T: () => DeviceWebToken }
        ]);
    }
    create(value?: PartialMessage<AuthenticateDeviceInit>): AuthenticateDeviceInit {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.credentialId = "";
        if (value !== undefined)
            reflectionMergePartial<AuthenticateDeviceInit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthenticateDeviceInit): AuthenticateDeviceInit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.devicetrust.v1.UserCertificates user_certificates */ 1:
                    message.userCertificates = UserCertificates.internalBinaryRead(reader, reader.uint32(), options, message.userCertificates);
                    break;
                case /* string credential_id */ 2:
                    message.credentialId = reader.string();
                    break;
                case /* teleport.devicetrust.v1.DeviceCollectedData device_data */ 3:
                    message.deviceData = DeviceCollectedData.internalBinaryRead(reader, reader.uint32(), options, message.deviceData);
                    break;
                case /* teleport.devicetrust.v1.DeviceWebToken device_web_token */ 4:
                    message.deviceWebToken = DeviceWebToken.internalBinaryRead(reader, reader.uint32(), options, message.deviceWebToken);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthenticateDeviceInit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.devicetrust.v1.UserCertificates user_certificates = 1; */
        if (message.userCertificates)
            UserCertificates.internalBinaryWrite(message.userCertificates, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string credential_id = 2; */
        if (message.credentialId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.credentialId);
        /* teleport.devicetrust.v1.DeviceCollectedData device_data = 3; */
        if (message.deviceData)
            DeviceCollectedData.internalBinaryWrite(message.deviceData, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* teleport.devicetrust.v1.DeviceWebToken device_web_token = 4; */
        if (message.deviceWebToken)
            DeviceWebToken.internalBinaryWrite(message.deviceWebToken, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.AuthenticateDeviceInit
 */
export const AuthenticateDeviceInit = new AuthenticateDeviceInit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TPMAuthenticateDeviceChallenge$Type extends MessageType<TPMAuthenticateDeviceChallenge> {
    constructor() {
        super("teleport.devicetrust.v1.TPMAuthenticateDeviceChallenge", [
            { no: 1, name: "attestation_nonce", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<TPMAuthenticateDeviceChallenge>): TPMAuthenticateDeviceChallenge {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.attestationNonce = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<TPMAuthenticateDeviceChallenge>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TPMAuthenticateDeviceChallenge): TPMAuthenticateDeviceChallenge {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes attestation_nonce */ 1:
                    message.attestationNonce = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TPMAuthenticateDeviceChallenge, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes attestation_nonce = 1; */
        if (message.attestationNonce.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.attestationNonce);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.TPMAuthenticateDeviceChallenge
 */
export const TPMAuthenticateDeviceChallenge = new TPMAuthenticateDeviceChallenge$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TPMAuthenticateDeviceChallengeResponse$Type extends MessageType<TPMAuthenticateDeviceChallengeResponse> {
    constructor() {
        super("teleport.devicetrust.v1.TPMAuthenticateDeviceChallengeResponse", [
            { no: 1, name: "platform_parameters", kind: "message", T: () => TPMPlatformParameters }
        ]);
    }
    create(value?: PartialMessage<TPMAuthenticateDeviceChallengeResponse>): TPMAuthenticateDeviceChallengeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TPMAuthenticateDeviceChallengeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TPMAuthenticateDeviceChallengeResponse): TPMAuthenticateDeviceChallengeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.devicetrust.v1.TPMPlatformParameters platform_parameters */ 1:
                    message.platformParameters = TPMPlatformParameters.internalBinaryRead(reader, reader.uint32(), options, message.platformParameters);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TPMAuthenticateDeviceChallengeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.devicetrust.v1.TPMPlatformParameters platform_parameters = 1; */
        if (message.platformParameters)
            TPMPlatformParameters.internalBinaryWrite(message.platformParameters, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.TPMAuthenticateDeviceChallengeResponse
 */
export const TPMAuthenticateDeviceChallengeResponse = new TPMAuthenticateDeviceChallengeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthenticateDeviceChallenge$Type extends MessageType<AuthenticateDeviceChallenge> {
    constructor() {
        super("teleport.devicetrust.v1.AuthenticateDeviceChallenge", [
            { no: 1, name: "challenge", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<AuthenticateDeviceChallenge>): AuthenticateDeviceChallenge {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.challenge = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<AuthenticateDeviceChallenge>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthenticateDeviceChallenge): AuthenticateDeviceChallenge {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes challenge */ 1:
                    message.challenge = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthenticateDeviceChallenge, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes challenge = 1; */
        if (message.challenge.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.challenge);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.AuthenticateDeviceChallenge
 */
export const AuthenticateDeviceChallenge = new AuthenticateDeviceChallenge$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthenticateDeviceChallengeResponse$Type extends MessageType<AuthenticateDeviceChallengeResponse> {
    constructor() {
        super("teleport.devicetrust.v1.AuthenticateDeviceChallengeResponse", [
            { no: 1, name: "signature", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<AuthenticateDeviceChallengeResponse>): AuthenticateDeviceChallengeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.signature = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<AuthenticateDeviceChallengeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthenticateDeviceChallengeResponse): AuthenticateDeviceChallengeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes signature */ 1:
                    message.signature = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthenticateDeviceChallengeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes signature = 1; */
        if (message.signature.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.signature);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.AuthenticateDeviceChallengeResponse
 */
export const AuthenticateDeviceChallengeResponse = new AuthenticateDeviceChallengeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConfirmDeviceWebAuthenticationRequest$Type extends MessageType<ConfirmDeviceWebAuthenticationRequest> {
    constructor() {
        super("teleport.devicetrust.v1.ConfirmDeviceWebAuthenticationRequest", [
            { no: 1, name: "confirmation_token", kind: "message", T: () => DeviceConfirmationToken },
            { no: 2, name: "current_web_session_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ConfirmDeviceWebAuthenticationRequest>): ConfirmDeviceWebAuthenticationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.currentWebSessionId = "";
        if (value !== undefined)
            reflectionMergePartial<ConfirmDeviceWebAuthenticationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConfirmDeviceWebAuthenticationRequest): ConfirmDeviceWebAuthenticationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.devicetrust.v1.DeviceConfirmationToken confirmation_token */ 1:
                    message.confirmationToken = DeviceConfirmationToken.internalBinaryRead(reader, reader.uint32(), options, message.confirmationToken);
                    break;
                case /* string current_web_session_id */ 2:
                    message.currentWebSessionId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConfirmDeviceWebAuthenticationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.devicetrust.v1.DeviceConfirmationToken confirmation_token = 1; */
        if (message.confirmationToken)
            DeviceConfirmationToken.internalBinaryWrite(message.confirmationToken, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string current_web_session_id = 2; */
        if (message.currentWebSessionId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.currentWebSessionId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.ConfirmDeviceWebAuthenticationRequest
 */
export const ConfirmDeviceWebAuthenticationRequest = new ConfirmDeviceWebAuthenticationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConfirmDeviceWebAuthenticationResponse$Type extends MessageType<ConfirmDeviceWebAuthenticationResponse> {
    constructor() {
        super("teleport.devicetrust.v1.ConfirmDeviceWebAuthenticationResponse", []);
    }
    create(value?: PartialMessage<ConfirmDeviceWebAuthenticationResponse>): ConfirmDeviceWebAuthenticationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ConfirmDeviceWebAuthenticationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConfirmDeviceWebAuthenticationResponse): ConfirmDeviceWebAuthenticationResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ConfirmDeviceWebAuthenticationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.ConfirmDeviceWebAuthenticationResponse
 */
export const ConfirmDeviceWebAuthenticationResponse = new ConfirmDeviceWebAuthenticationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SyncInventoryRequest$Type extends MessageType<SyncInventoryRequest> {
    constructor() {
        super("teleport.devicetrust.v1.SyncInventoryRequest", [
            { no: 1, name: "start", kind: "message", oneof: "payload", T: () => SyncInventoryStart },
            { no: 2, name: "end", kind: "message", oneof: "payload", T: () => SyncInventoryEnd },
            { no: 3, name: "devices_to_upsert", kind: "message", oneof: "payload", T: () => SyncInventoryDevices },
            { no: 4, name: "devices_to_remove", kind: "message", oneof: "payload", T: () => SyncInventoryDevices }
        ]);
    }
    create(value?: PartialMessage<SyncInventoryRequest>): SyncInventoryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.payload = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<SyncInventoryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SyncInventoryRequest): SyncInventoryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.devicetrust.v1.SyncInventoryStart start */ 1:
                    message.payload = {
                        oneofKind: "start",
                        start: SyncInventoryStart.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).start)
                    };
                    break;
                case /* teleport.devicetrust.v1.SyncInventoryEnd end */ 2:
                    message.payload = {
                        oneofKind: "end",
                        end: SyncInventoryEnd.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).end)
                    };
                    break;
                case /* teleport.devicetrust.v1.SyncInventoryDevices devices_to_upsert */ 3:
                    message.payload = {
                        oneofKind: "devicesToUpsert",
                        devicesToUpsert: SyncInventoryDevices.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).devicesToUpsert)
                    };
                    break;
                case /* teleport.devicetrust.v1.SyncInventoryDevices devices_to_remove */ 4:
                    message.payload = {
                        oneofKind: "devicesToRemove",
                        devicesToRemove: SyncInventoryDevices.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).devicesToRemove)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SyncInventoryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.devicetrust.v1.SyncInventoryStart start = 1; */
        if (message.payload.oneofKind === "start")
            SyncInventoryStart.internalBinaryWrite(message.payload.start, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* teleport.devicetrust.v1.SyncInventoryEnd end = 2; */
        if (message.payload.oneofKind === "end")
            SyncInventoryEnd.internalBinaryWrite(message.payload.end, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* teleport.devicetrust.v1.SyncInventoryDevices devices_to_upsert = 3; */
        if (message.payload.oneofKind === "devicesToUpsert")
            SyncInventoryDevices.internalBinaryWrite(message.payload.devicesToUpsert, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* teleport.devicetrust.v1.SyncInventoryDevices devices_to_remove = 4; */
        if (message.payload.oneofKind === "devicesToRemove")
            SyncInventoryDevices.internalBinaryWrite(message.payload.devicesToRemove, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.SyncInventoryRequest
 */
export const SyncInventoryRequest = new SyncInventoryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SyncInventoryResponse$Type extends MessageType<SyncInventoryResponse> {
    constructor() {
        super("teleport.devicetrust.v1.SyncInventoryResponse", [
            { no: 1, name: "ack", kind: "message", oneof: "payload", T: () => SyncInventoryAck },
            { no: 2, name: "result", kind: "message", oneof: "payload", T: () => SyncInventoryResult },
            { no: 3, name: "missing_devices", kind: "message", oneof: "payload", T: () => SyncInventoryMissingDevices }
        ]);
    }
    create(value?: PartialMessage<SyncInventoryResponse>): SyncInventoryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.payload = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<SyncInventoryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SyncInventoryResponse): SyncInventoryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.devicetrust.v1.SyncInventoryAck ack */ 1:
                    message.payload = {
                        oneofKind: "ack",
                        ack: SyncInventoryAck.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).ack)
                    };
                    break;
                case /* teleport.devicetrust.v1.SyncInventoryResult result */ 2:
                    message.payload = {
                        oneofKind: "result",
                        result: SyncInventoryResult.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).result)
                    };
                    break;
                case /* teleport.devicetrust.v1.SyncInventoryMissingDevices missing_devices */ 3:
                    message.payload = {
                        oneofKind: "missingDevices",
                        missingDevices: SyncInventoryMissingDevices.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).missingDevices)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SyncInventoryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.devicetrust.v1.SyncInventoryAck ack = 1; */
        if (message.payload.oneofKind === "ack")
            SyncInventoryAck.internalBinaryWrite(message.payload.ack, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* teleport.devicetrust.v1.SyncInventoryResult result = 2; */
        if (message.payload.oneofKind === "result")
            SyncInventoryResult.internalBinaryWrite(message.payload.result, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* teleport.devicetrust.v1.SyncInventoryMissingDevices missing_devices = 3; */
        if (message.payload.oneofKind === "missingDevices")
            SyncInventoryMissingDevices.internalBinaryWrite(message.payload.missingDevices, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.SyncInventoryResponse
 */
export const SyncInventoryResponse = new SyncInventoryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SyncInventoryStart$Type extends MessageType<SyncInventoryStart> {
    constructor() {
        super("teleport.devicetrust.v1.SyncInventoryStart", [
            { no: 1, name: "source", kind: "message", T: () => DeviceSource },
            { no: 4, name: "track_missing_devices", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SyncInventoryStart>): SyncInventoryStart {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.trackMissingDevices = false;
        if (value !== undefined)
            reflectionMergePartial<SyncInventoryStart>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SyncInventoryStart): SyncInventoryStart {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.devicetrust.v1.DeviceSource source */ 1:
                    message.source = DeviceSource.internalBinaryRead(reader, reader.uint32(), options, message.source);
                    break;
                case /* bool track_missing_devices */ 4:
                    message.trackMissingDevices = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SyncInventoryStart, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.devicetrust.v1.DeviceSource source = 1; */
        if (message.source)
            DeviceSource.internalBinaryWrite(message.source, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool track_missing_devices = 4; */
        if (message.trackMissingDevices !== false)
            writer.tag(4, WireType.Varint).bool(message.trackMissingDevices);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.SyncInventoryStart
 */
export const SyncInventoryStart = new SyncInventoryStart$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SyncInventoryEnd$Type extends MessageType<SyncInventoryEnd> {
    constructor() {
        super("teleport.devicetrust.v1.SyncInventoryEnd", []);
    }
    create(value?: PartialMessage<SyncInventoryEnd>): SyncInventoryEnd {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SyncInventoryEnd>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SyncInventoryEnd): SyncInventoryEnd {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SyncInventoryEnd, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.SyncInventoryEnd
 */
export const SyncInventoryEnd = new SyncInventoryEnd$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SyncInventoryDevices$Type extends MessageType<SyncInventoryDevices> {
    constructor() {
        super("teleport.devicetrust.v1.SyncInventoryDevices", [
            { no: 1, name: "devices", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Device }
        ]);
    }
    create(value?: PartialMessage<SyncInventoryDevices>): SyncInventoryDevices {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.devices = [];
        if (value !== undefined)
            reflectionMergePartial<SyncInventoryDevices>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SyncInventoryDevices): SyncInventoryDevices {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated teleport.devicetrust.v1.Device devices */ 1:
                    message.devices.push(Device.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SyncInventoryDevices, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated teleport.devicetrust.v1.Device devices = 1; */
        for (let i = 0; i < message.devices.length; i++)
            Device.internalBinaryWrite(message.devices[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.SyncInventoryDevices
 */
export const SyncInventoryDevices = new SyncInventoryDevices$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SyncInventoryAck$Type extends MessageType<SyncInventoryAck> {
    constructor() {
        super("teleport.devicetrust.v1.SyncInventoryAck", []);
    }
    create(value?: PartialMessage<SyncInventoryAck>): SyncInventoryAck {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SyncInventoryAck>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SyncInventoryAck): SyncInventoryAck {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SyncInventoryAck, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.SyncInventoryAck
 */
export const SyncInventoryAck = new SyncInventoryAck$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SyncInventoryResult$Type extends MessageType<SyncInventoryResult> {
    constructor() {
        super("teleport.devicetrust.v1.SyncInventoryResult", [
            { no: 1, name: "devices", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DeviceOrStatus }
        ]);
    }
    create(value?: PartialMessage<SyncInventoryResult>): SyncInventoryResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.devices = [];
        if (value !== undefined)
            reflectionMergePartial<SyncInventoryResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SyncInventoryResult): SyncInventoryResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated teleport.devicetrust.v1.DeviceOrStatus devices */ 1:
                    message.devices.push(DeviceOrStatus.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SyncInventoryResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated teleport.devicetrust.v1.DeviceOrStatus devices = 1; */
        for (let i = 0; i < message.devices.length; i++)
            DeviceOrStatus.internalBinaryWrite(message.devices[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.SyncInventoryResult
 */
export const SyncInventoryResult = new SyncInventoryResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SyncInventoryMissingDevices$Type extends MessageType<SyncInventoryMissingDevices> {
    constructor() {
        super("teleport.devicetrust.v1.SyncInventoryMissingDevices", [
            { no: 1, name: "devices", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Device }
        ]);
    }
    create(value?: PartialMessage<SyncInventoryMissingDevices>): SyncInventoryMissingDevices {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.devices = [];
        if (value !== undefined)
            reflectionMergePartial<SyncInventoryMissingDevices>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SyncInventoryMissingDevices): SyncInventoryMissingDevices {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated teleport.devicetrust.v1.Device devices */ 1:
                    message.devices.push(Device.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SyncInventoryMissingDevices, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated teleport.devicetrust.v1.Device devices = 1; */
        for (let i = 0; i < message.devices.length; i++)
            Device.internalBinaryWrite(message.devices[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.SyncInventoryMissingDevices
 */
export const SyncInventoryMissingDevices = new SyncInventoryMissingDevices$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDevicesUsageRequest$Type extends MessageType<GetDevicesUsageRequest> {
    constructor() {
        super("teleport.devicetrust.v1.GetDevicesUsageRequest", []);
    }
    create(value?: PartialMessage<GetDevicesUsageRequest>): GetDevicesUsageRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetDevicesUsageRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDevicesUsageRequest): GetDevicesUsageRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetDevicesUsageRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.GetDevicesUsageRequest
 */
export const GetDevicesUsageRequest = new GetDevicesUsageRequest$Type();
/**
 * @generated ServiceType for protobuf service teleport.devicetrust.v1.DeviceTrustService
 */
export const DeviceTrustService = new ServiceType("teleport.devicetrust.v1.DeviceTrustService", [
    { name: "CreateDevice", options: {}, I: CreateDeviceRequest, O: Device },
    { name: "UpdateDevice", options: {}, I: UpdateDeviceRequest, O: Device },
    { name: "UpsertDevice", options: {}, I: UpsertDeviceRequest, O: Device },
    { name: "DeleteDevice", options: {}, I: DeleteDeviceRequest, O: Empty },
    { name: "FindDevices", options: {}, I: FindDevicesRequest, O: FindDevicesResponse },
    { name: "GetDevice", options: {}, I: GetDeviceRequest, O: Device },
    { name: "ListDevices", options: {}, I: ListDevicesRequest, O: ListDevicesResponse },
    { name: "BulkCreateDevices", options: {}, I: BulkCreateDevicesRequest, O: BulkCreateDevicesResponse },
    { name: "CreateDeviceEnrollToken", options: {}, I: CreateDeviceEnrollTokenRequest, O: DeviceEnrollToken },
    { name: "EnrollDevice", serverStreaming: true, clientStreaming: true, options: {}, I: EnrollDeviceRequest, O: EnrollDeviceResponse },
    { name: "AuthenticateDevice", serverStreaming: true, clientStreaming: true, options: {}, I: AuthenticateDeviceRequest, O: AuthenticateDeviceResponse },
    { name: "ConfirmDeviceWebAuthentication", options: {}, I: ConfirmDeviceWebAuthenticationRequest, O: ConfirmDeviceWebAuthenticationResponse },
    { name: "SyncInventory", serverStreaming: true, clientStreaming: true, options: {}, I: SyncInventoryRequest, O: SyncInventoryResponse },
    { name: "GetDevicesUsage", options: {}, I: GetDevicesUsageRequest, O: DevicesUsage }
]);
