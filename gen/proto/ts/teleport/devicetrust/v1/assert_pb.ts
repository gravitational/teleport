/* eslint-disable */
// @generated by protobuf-ts 2.9.3 with parameter eslint_disable,add_pb_suffix,server_grpc1,ts_nocheck
// @generated from protobuf file "teleport/devicetrust/v1/assert.proto" (package "teleport.devicetrust.v1", syntax proto3)
// tslint:disable
// @ts-nocheck
//
// Copyright 2024 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { DeviceCollectedData } from "./device_collected_data_pb";
import { TPMAuthenticateDeviceChallenge } from "./authenticate_challenge_pb";
import { AuthenticateDeviceChallenge } from "./authenticate_challenge_pb";
import { TPMAuthenticateDeviceChallengeResponse } from "./authenticate_challenge_pb";
import { AuthenticateDeviceChallengeResponse } from "./authenticate_challenge_pb";
/**
 * Request to assert an enrolled device. Assertion authenticates the device,
 * regardless of the user driving the assertion.
 *
 * Assertion messages are meant to be included by other requests and responses,
 * either streams or multi-stage RPCs. The ceremony is resolved by a co-located
 * DeviceTrustService.
 *
 * See the lib/devicetrust/assert (client) and lib/devicetrust/assertserver
 * (server) packages.
 *
 * Assertion ceremony flow:
 * -> AssertDeviceInit (client)
 * <- AssertDeviceChallenge (server)
 * -> AssertDeviceChallengeResponse (client)
 * <- DeviceAsserted (server)
 *
 * A successful ceremony signifies that the device is registered, enrolled and
 * passed the authentication challenge.
 *
 * @generated from protobuf message teleport.devicetrust.v1.AssertDeviceRequest
 */
export interface AssertDeviceRequest {
    /**
     * @generated from protobuf oneof: payload
     */
    payload: {
        oneofKind: "init";
        /**
         * @generated from protobuf field: teleport.devicetrust.v1.AssertDeviceInit init = 1;
         */
        init: AssertDeviceInit;
    } | {
        oneofKind: "challengeResponse";
        /**
         * @generated from protobuf field: teleport.devicetrust.v1.AuthenticateDeviceChallengeResponse challenge_response = 2;
         */
        challengeResponse: AuthenticateDeviceChallengeResponse;
    } | {
        oneofKind: "tpmChallengeResponse";
        /**
         * @generated from protobuf field: teleport.devicetrust.v1.TPMAuthenticateDeviceChallengeResponse tpm_challenge_response = 3;
         */
        tpmChallengeResponse: TPMAuthenticateDeviceChallengeResponse;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Response of the device assertion ceremony.
 * See [AssertDeviceRequest].
 *
 * @generated from protobuf message teleport.devicetrust.v1.AssertDeviceResponse
 */
export interface AssertDeviceResponse {
    /**
     * @generated from protobuf oneof: payload
     */
    payload: {
        oneofKind: "challenge";
        /**
         * @generated from protobuf field: teleport.devicetrust.v1.AuthenticateDeviceChallenge challenge = 1;
         */
        challenge: AuthenticateDeviceChallenge;
    } | {
        oneofKind: "tpmChallenge";
        /**
         * @generated from protobuf field: teleport.devicetrust.v1.TPMAuthenticateDeviceChallenge tpm_challenge = 2;
         */
        tpmChallenge: TPMAuthenticateDeviceChallenge;
    } | {
        oneofKind: "deviceAsserted";
        /**
         * @generated from protobuf field: teleport.devicetrust.v1.DeviceAsserted device_asserted = 3;
         */
        deviceAsserted: DeviceAsserted;
    } | {
        oneofKind: undefined;
    };
}
/**
 * AssertDeviceInit initiates the device assertion ceremony.
 * See [AssertDeviceRequest].
 *
 * @generated from protobuf message teleport.devicetrust.v1.AssertDeviceInit
 */
export interface AssertDeviceInit {
    /**
     * ID of the enrolled device credential.
     *
     * @generated from protobuf field: string credential_id = 1;
     */
    credentialId: string;
    /**
     * Device collected data.
     * Matched against the device registration information and any previously
     * collected data.
     *
     * @generated from protobuf field: teleport.devicetrust.v1.DeviceCollectedData device_data = 2;
     */
    deviceData?: DeviceCollectedData;
}
/**
 * DeviceAsserted marks a successful device assertion ceremony.
 * See [AssertDeviceRequest].
 *
 * @generated from protobuf message teleport.devicetrust.v1.DeviceAsserted
 */
export interface DeviceAsserted {
}
// @generated message type with reflection information, may provide speed optimized methods
class AssertDeviceRequest$Type extends MessageType<AssertDeviceRequest> {
    constructor() {
        super("teleport.devicetrust.v1.AssertDeviceRequest", [
            { no: 1, name: "init", kind: "message", oneof: "payload", T: () => AssertDeviceInit },
            { no: 2, name: "challenge_response", kind: "message", oneof: "payload", T: () => AuthenticateDeviceChallengeResponse },
            { no: 3, name: "tpm_challenge_response", kind: "message", oneof: "payload", T: () => TPMAuthenticateDeviceChallengeResponse }
        ]);
    }
    create(value?: PartialMessage<AssertDeviceRequest>): AssertDeviceRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.payload = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<AssertDeviceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AssertDeviceRequest): AssertDeviceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.devicetrust.v1.AssertDeviceInit init */ 1:
                    message.payload = {
                        oneofKind: "init",
                        init: AssertDeviceInit.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).init)
                    };
                    break;
                case /* teleport.devicetrust.v1.AuthenticateDeviceChallengeResponse challenge_response */ 2:
                    message.payload = {
                        oneofKind: "challengeResponse",
                        challengeResponse: AuthenticateDeviceChallengeResponse.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).challengeResponse)
                    };
                    break;
                case /* teleport.devicetrust.v1.TPMAuthenticateDeviceChallengeResponse tpm_challenge_response */ 3:
                    message.payload = {
                        oneofKind: "tpmChallengeResponse",
                        tpmChallengeResponse: TPMAuthenticateDeviceChallengeResponse.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).tpmChallengeResponse)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AssertDeviceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.devicetrust.v1.AssertDeviceInit init = 1; */
        if (message.payload.oneofKind === "init")
            AssertDeviceInit.internalBinaryWrite(message.payload.init, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* teleport.devicetrust.v1.AuthenticateDeviceChallengeResponse challenge_response = 2; */
        if (message.payload.oneofKind === "challengeResponse")
            AuthenticateDeviceChallengeResponse.internalBinaryWrite(message.payload.challengeResponse, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* teleport.devicetrust.v1.TPMAuthenticateDeviceChallengeResponse tpm_challenge_response = 3; */
        if (message.payload.oneofKind === "tpmChallengeResponse")
            TPMAuthenticateDeviceChallengeResponse.internalBinaryWrite(message.payload.tpmChallengeResponse, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.AssertDeviceRequest
 */
export const AssertDeviceRequest = new AssertDeviceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AssertDeviceResponse$Type extends MessageType<AssertDeviceResponse> {
    constructor() {
        super("teleport.devicetrust.v1.AssertDeviceResponse", [
            { no: 1, name: "challenge", kind: "message", oneof: "payload", T: () => AuthenticateDeviceChallenge },
            { no: 2, name: "tpm_challenge", kind: "message", oneof: "payload", T: () => TPMAuthenticateDeviceChallenge },
            { no: 3, name: "device_asserted", kind: "message", oneof: "payload", T: () => DeviceAsserted }
        ]);
    }
    create(value?: PartialMessage<AssertDeviceResponse>): AssertDeviceResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.payload = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<AssertDeviceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AssertDeviceResponse): AssertDeviceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.devicetrust.v1.AuthenticateDeviceChallenge challenge */ 1:
                    message.payload = {
                        oneofKind: "challenge",
                        challenge: AuthenticateDeviceChallenge.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).challenge)
                    };
                    break;
                case /* teleport.devicetrust.v1.TPMAuthenticateDeviceChallenge tpm_challenge */ 2:
                    message.payload = {
                        oneofKind: "tpmChallenge",
                        tpmChallenge: TPMAuthenticateDeviceChallenge.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).tpmChallenge)
                    };
                    break;
                case /* teleport.devicetrust.v1.DeviceAsserted device_asserted */ 3:
                    message.payload = {
                        oneofKind: "deviceAsserted",
                        deviceAsserted: DeviceAsserted.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).deviceAsserted)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AssertDeviceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.devicetrust.v1.AuthenticateDeviceChallenge challenge = 1; */
        if (message.payload.oneofKind === "challenge")
            AuthenticateDeviceChallenge.internalBinaryWrite(message.payload.challenge, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* teleport.devicetrust.v1.TPMAuthenticateDeviceChallenge tpm_challenge = 2; */
        if (message.payload.oneofKind === "tpmChallenge")
            TPMAuthenticateDeviceChallenge.internalBinaryWrite(message.payload.tpmChallenge, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* teleport.devicetrust.v1.DeviceAsserted device_asserted = 3; */
        if (message.payload.oneofKind === "deviceAsserted")
            DeviceAsserted.internalBinaryWrite(message.payload.deviceAsserted, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.AssertDeviceResponse
 */
export const AssertDeviceResponse = new AssertDeviceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AssertDeviceInit$Type extends MessageType<AssertDeviceInit> {
    constructor() {
        super("teleport.devicetrust.v1.AssertDeviceInit", [
            { no: 1, name: "credential_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "device_data", kind: "message", T: () => DeviceCollectedData }
        ]);
    }
    create(value?: PartialMessage<AssertDeviceInit>): AssertDeviceInit {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.credentialId = "";
        if (value !== undefined)
            reflectionMergePartial<AssertDeviceInit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AssertDeviceInit): AssertDeviceInit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string credential_id */ 1:
                    message.credentialId = reader.string();
                    break;
                case /* teleport.devicetrust.v1.DeviceCollectedData device_data */ 2:
                    message.deviceData = DeviceCollectedData.internalBinaryRead(reader, reader.uint32(), options, message.deviceData);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AssertDeviceInit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string credential_id = 1; */
        if (message.credentialId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.credentialId);
        /* teleport.devicetrust.v1.DeviceCollectedData device_data = 2; */
        if (message.deviceData)
            DeviceCollectedData.internalBinaryWrite(message.deviceData, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.AssertDeviceInit
 */
export const AssertDeviceInit = new AssertDeviceInit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeviceAsserted$Type extends MessageType<DeviceAsserted> {
    constructor() {
        super("teleport.devicetrust.v1.DeviceAsserted", []);
    }
    create(value?: PartialMessage<DeviceAsserted>): DeviceAsserted {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeviceAsserted>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeviceAsserted): DeviceAsserted {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DeviceAsserted, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.DeviceAsserted
 */
export const DeviceAsserted = new DeviceAsserted$Type();
