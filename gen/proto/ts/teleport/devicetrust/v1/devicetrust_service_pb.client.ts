/* eslint-disable */
// @generated by protobuf-ts 2.9.3 with parameter eslint_disable,add_pb_suffix,server_grpc1,ts_nocheck
// @generated from protobuf file "teleport/devicetrust/v1/devicetrust_service.proto" (package "teleport.devicetrust.v1", syntax proto3)
// tslint:disable
// @ts-nocheck
//
// Copyright 2022 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { DeviceTrustService } from "./devicetrust_service_pb";
import type { DevicesUsage } from "./usage_pb";
import type { GetDevicesUsageRequest } from "./devicetrust_service_pb";
import type { SyncInventoryResponse } from "./devicetrust_service_pb";
import type { SyncInventoryRequest } from "./devicetrust_service_pb";
import type { ConfirmDeviceWebAuthenticationResponse } from "./devicetrust_service_pb";
import type { ConfirmDeviceWebAuthenticationRequest } from "./devicetrust_service_pb";
import type { AuthenticateDeviceResponse } from "./devicetrust_service_pb";
import type { AuthenticateDeviceRequest } from "./devicetrust_service_pb";
import type { EnrollDeviceResponse } from "./devicetrust_service_pb";
import type { EnrollDeviceRequest } from "./devicetrust_service_pb";
import type { DuplexStreamingCall } from "@protobuf-ts/runtime-rpc";
import type { DeviceEnrollToken } from "./device_enroll_token_pb";
import type { CreateDeviceEnrollTokenRequest } from "./devicetrust_service_pb";
import type { BulkCreateDevicesResponse } from "./devicetrust_service_pb";
import type { BulkCreateDevicesRequest } from "./devicetrust_service_pb";
import type { ListDevicesResponse } from "./devicetrust_service_pb";
import type { ListDevicesRequest } from "./devicetrust_service_pb";
import type { GetDeviceRequest } from "./devicetrust_service_pb";
import type { FindDevicesResponse } from "./devicetrust_service_pb";
import type { FindDevicesRequest } from "./devicetrust_service_pb";
import type { Empty } from "../../../google/protobuf/empty_pb";
import type { DeleteDeviceRequest } from "./devicetrust_service_pb";
import type { UpsertDeviceRequest } from "./devicetrust_service_pb";
import type { UpdateDeviceRequest } from "./devicetrust_service_pb";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import type { Device } from "./device_pb";
import type { CreateDeviceRequest } from "./devicetrust_service_pb";
import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * DeviceTrustService provides methods to manage, enroll and authenticate
 * trusted devices.
 *
 * A trusted device is a device that is registered and enrolled with Teleport,
 * thus allowing the system to provide some guarantees about its provenance and
 * state.
 *
 * Managing devices requires the corresponding CRUD "device" permission.
 * Additionally, creating enrollment tokens requires the "create_enroll_token"
 * permission and enrolling devices requires the "enroll" permission. See
 * CreateDevice, CreateDeviceEnrollToken and EnrollDevice for reference.
 *
 * An authenticated, trusted device allows its user to perform device-aware
 * actions. Such actions include accessing an SSH node, managing sensitive
 * resources via `tctl`, etc. The enforcement mode is defined via cluster-wide
 * and/or per-role toggles. Device authentication is automatic for enrolled
 * devices communicating with Enterprise clusters. See AuthenticateDevice for
 * reference.
 *
 * Device Trust is a Teleport Enterprise feature. Open Source Teleport clusters
 * treat all Device RPCs as unimplemented (which, in fact, they are for OSS.)
 *
 * @generated from protobuf service teleport.devicetrust.v1.DeviceTrustService
 */
export interface IDeviceTrustServiceClient {
    /**
     * CreateDevice creates a device, effectively registering it on Teleport.
     * Devices need to be registered before they can be enrolled.
     *
     * It is possible to create both a Device and a DeviceEnrollToken in a
     * single invocation, see CreateDeviceRequest.create_enroll_token.
     *
     * @generated from protobuf rpc: CreateDevice(teleport.devicetrust.v1.CreateDeviceRequest) returns (teleport.devicetrust.v1.Device);
     */
    createDevice(input: CreateDeviceRequest, options?: RpcOptions): UnaryCall<CreateDeviceRequest, Device>;
    /**
     * UpdateDevice is a masked device update.
     *
     * Only certain fields may be updated, see Device for details.
     *
     * @generated from protobuf rpc: UpdateDevice(teleport.devicetrust.v1.UpdateDeviceRequest) returns (teleport.devicetrust.v1.Device);
     */
    updateDevice(input: UpdateDeviceRequest, options?: RpcOptions): UnaryCall<UpdateDeviceRequest, Device>;
    /**
     * UpsertDevice creates or updates a device.
     *
     * UpsertDevice attempts a write of all mutable fields on updates, therefore
     * reading a fresh copy of the device is recommended. Update semantics still
     * apply.
     *
     * @generated from protobuf rpc: UpsertDevice(teleport.devicetrust.v1.UpsertDeviceRequest) returns (teleport.devicetrust.v1.Device);
     */
    upsertDevice(input: UpsertDeviceRequest, options?: RpcOptions): UnaryCall<UpsertDeviceRequest, Device>;
    /**
     * DeleteDevice hard-deletes a device, removing it and all collected data
     * history from the system.
     *
     * Prefer locking the device instead (see the `tctl lock` command). Deleting a
     * device doesn't invalidate existing device certificates, but does prevent
     * new device authentication ceremonies from occurring.
     *
     * Use with caution.
     *
     * @generated from protobuf rpc: DeleteDevice(teleport.devicetrust.v1.DeleteDeviceRequest) returns (google.protobuf.Empty);
     */
    deleteDevice(input: DeleteDeviceRequest, options?: RpcOptions): UnaryCall<DeleteDeviceRequest, Empty>;
    /**
     * FindDevices retrieves devices by device ID and/or asset tag.
     *
     * It provides an in-between search between fetching a device by ID and
     * listing all devices.
     *
     * ID matches are guaranteed to be present in the response.
     *
     * @generated from protobuf rpc: FindDevices(teleport.devicetrust.v1.FindDevicesRequest) returns (teleport.devicetrust.v1.FindDevicesResponse);
     */
    findDevices(input: FindDevicesRequest, options?: RpcOptions): UnaryCall<FindDevicesRequest, FindDevicesResponse>;
    /**
     * GetDevice retrieves a device by ID.
     *
     * @generated from protobuf rpc: GetDevice(teleport.devicetrust.v1.GetDeviceRequest) returns (teleport.devicetrust.v1.Device);
     */
    getDevice(input: GetDeviceRequest, options?: RpcOptions): UnaryCall<GetDeviceRequest, Device>;
    /**
     * ListDevices lists all registered devices.
     *
     * @generated from protobuf rpc: ListDevices(teleport.devicetrust.v1.ListDevicesRequest) returns (teleport.devicetrust.v1.ListDevicesResponse);
     */
    listDevices(input: ListDevicesRequest, options?: RpcOptions): UnaryCall<ListDevicesRequest, ListDevicesResponse>;
    /**
     * BulkCreateDevices is a bulk variant of CreateDevice.
     *
     * Unlike CreateDevice, it does not support creation of enrollment tokens, as
     * it is meant for bulk inventory registration.
     *
     * @generated from protobuf rpc: BulkCreateDevices(teleport.devicetrust.v1.BulkCreateDevicesRequest) returns (teleport.devicetrust.v1.BulkCreateDevicesResponse);
     */
    bulkCreateDevices(input: BulkCreateDevicesRequest, options?: RpcOptions): UnaryCall<BulkCreateDevicesRequest, BulkCreateDevicesResponse>;
    /**
     * CreateDeviceEnrollToken creates a DeviceEnrollToken for a Device.
     * An enrollment token is required for the enrollment ceremony. See
     * EnrollDevice.
     *
     * @generated from protobuf rpc: CreateDeviceEnrollToken(teleport.devicetrust.v1.CreateDeviceEnrollTokenRequest) returns (teleport.devicetrust.v1.DeviceEnrollToken);
     */
    createDeviceEnrollToken(input: CreateDeviceEnrollTokenRequest, options?: RpcOptions): UnaryCall<CreateDeviceEnrollTokenRequest, DeviceEnrollToken>;
    /**
     * EnrollDevice performs the device enrollment ceremony.
     *
     * Enrollment requires a previously-registered Device and a DeviceEnrollToken,
     * see CreateDevice and CreateDeviceEnrollToken.
     *
     * An enrolled device is allowed, via AuthenticateDevice, to acquire
     * certificates containing device extensions, thus gaining access to
     * device-aware actions.
     *
     * macOS enrollment flow:
     * -> EnrollDeviceInit (client)
     * <- MacOSEnrollChallenge (server)
     * -> MacOSEnrollChallengeResponse
     * <- EnrollDeviceSuccess
     *
     * TPM enrollment flow:
     * -> EnrollDeviceInit (client)
     * <- TPMEnrollChallenge (server)
     * -> TPMEnrollChallengeResponse
     * <- EnrollDeviceSuccess
     *
     * @generated from protobuf rpc: EnrollDevice(stream teleport.devicetrust.v1.EnrollDeviceRequest) returns (stream teleport.devicetrust.v1.EnrollDeviceResponse);
     */
    enrollDevice(options?: RpcOptions): DuplexStreamingCall<EnrollDeviceRequest, EnrollDeviceResponse>;
    /**
     * AuthenticateDevice performs the device authentication ceremony.
     *
     * Device authentication exchanges existing user certificates without device
     * extensions for certificates augmented with device extensions. The new
     * certificates allow the user to perform device-aware actions.
     *
     * Only registered and enrolled devices may perform device authentication.
     *
     * @generated from protobuf rpc: AuthenticateDevice(stream teleport.devicetrust.v1.AuthenticateDeviceRequest) returns (stream teleport.devicetrust.v1.AuthenticateDeviceResponse);
     */
    authenticateDevice(options?: RpcOptions): DuplexStreamingCall<AuthenticateDeviceRequest, AuthenticateDeviceResponse>;
    /**
     * ConfirmDeviceWebAuthentication finalizes the device web authentication
     * ceremony started by the creation of a DeviceWebToken and subsequent
     * AuthenticateDevice call.
     *
     * The DeviceConfirmationToken issued by AuthenticateDevice is spent in this
     * method, which consequently augments the corresponding Web Session
     * certificates with device extensions.
     *
     * This method must be called by the Teleport Proxy, and the Proxy itself must
     * be called by the same browser that started the on-behalf-of authentication
     * attempt. See the /webapi/device/webconfirm endpoint.
     *
     * See
     * https://github.com/gravitational/teleport.e/blob/master/rfd/0009e-device-trust-web-support.md#device-web-authentication.
     *
     * @generated from protobuf rpc: ConfirmDeviceWebAuthentication(teleport.devicetrust.v1.ConfirmDeviceWebAuthenticationRequest) returns (teleport.devicetrust.v1.ConfirmDeviceWebAuthenticationResponse);
     */
    confirmDeviceWebAuthentication(input: ConfirmDeviceWebAuthenticationRequest, options?: RpcOptions): UnaryCall<ConfirmDeviceWebAuthenticationRequest, ConfirmDeviceWebAuthenticationResponse>;
    /**
     * Syncs device inventory from a source exterior to Teleport, for example an
     * MDM.
     * Allows both partial and full syncs; for the latter, devices missing from
     * the external inventory are handled as specified.
     * Authorized either by a valid MDM service certificate or the appropriate
     * "device" permissions (create/update/delete).
     *
     * @generated from protobuf rpc: SyncInventory(stream teleport.devicetrust.v1.SyncInventoryRequest) returns (stream teleport.devicetrust.v1.SyncInventoryResponse);
     */
    syncInventory(options?: RpcOptions): DuplexStreamingCall<SyncInventoryRequest, SyncInventoryResponse>;
    /**
     * Superseded by ResourceUsageService.GetUsage.
     *
     * @deprecated
     * @generated from protobuf rpc: GetDevicesUsage(teleport.devicetrust.v1.GetDevicesUsageRequest) returns (teleport.devicetrust.v1.DevicesUsage);
     */
    getDevicesUsage(input: GetDevicesUsageRequest, options?: RpcOptions): UnaryCall<GetDevicesUsageRequest, DevicesUsage>;
}
/**
 * DeviceTrustService provides methods to manage, enroll and authenticate
 * trusted devices.
 *
 * A trusted device is a device that is registered and enrolled with Teleport,
 * thus allowing the system to provide some guarantees about its provenance and
 * state.
 *
 * Managing devices requires the corresponding CRUD "device" permission.
 * Additionally, creating enrollment tokens requires the "create_enroll_token"
 * permission and enrolling devices requires the "enroll" permission. See
 * CreateDevice, CreateDeviceEnrollToken and EnrollDevice for reference.
 *
 * An authenticated, trusted device allows its user to perform device-aware
 * actions. Such actions include accessing an SSH node, managing sensitive
 * resources via `tctl`, etc. The enforcement mode is defined via cluster-wide
 * and/or per-role toggles. Device authentication is automatic for enrolled
 * devices communicating with Enterprise clusters. See AuthenticateDevice for
 * reference.
 *
 * Device Trust is a Teleport Enterprise feature. Open Source Teleport clusters
 * treat all Device RPCs as unimplemented (which, in fact, they are for OSS.)
 *
 * @generated from protobuf service teleport.devicetrust.v1.DeviceTrustService
 */
export class DeviceTrustServiceClient implements IDeviceTrustServiceClient, ServiceInfo {
    typeName = DeviceTrustService.typeName;
    methods = DeviceTrustService.methods;
    options = DeviceTrustService.options;
    constructor(private readonly _transport: RpcTransport) {
    }
    /**
     * CreateDevice creates a device, effectively registering it on Teleport.
     * Devices need to be registered before they can be enrolled.
     *
     * It is possible to create both a Device and a DeviceEnrollToken in a
     * single invocation, see CreateDeviceRequest.create_enroll_token.
     *
     * @generated from protobuf rpc: CreateDevice(teleport.devicetrust.v1.CreateDeviceRequest) returns (teleport.devicetrust.v1.Device);
     */
    createDevice(input: CreateDeviceRequest, options?: RpcOptions): UnaryCall<CreateDeviceRequest, Device> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept<CreateDeviceRequest, Device>("unary", this._transport, method, opt, input);
    }
    /**
     * UpdateDevice is a masked device update.
     *
     * Only certain fields may be updated, see Device for details.
     *
     * @generated from protobuf rpc: UpdateDevice(teleport.devicetrust.v1.UpdateDeviceRequest) returns (teleport.devicetrust.v1.Device);
     */
    updateDevice(input: UpdateDeviceRequest, options?: RpcOptions): UnaryCall<UpdateDeviceRequest, Device> {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return stackIntercept<UpdateDeviceRequest, Device>("unary", this._transport, method, opt, input);
    }
    /**
     * UpsertDevice creates or updates a device.
     *
     * UpsertDevice attempts a write of all mutable fields on updates, therefore
     * reading a fresh copy of the device is recommended. Update semantics still
     * apply.
     *
     * @generated from protobuf rpc: UpsertDevice(teleport.devicetrust.v1.UpsertDeviceRequest) returns (teleport.devicetrust.v1.Device);
     */
    upsertDevice(input: UpsertDeviceRequest, options?: RpcOptions): UnaryCall<UpsertDeviceRequest, Device> {
        const method = this.methods[2], opt = this._transport.mergeOptions(options);
        return stackIntercept<UpsertDeviceRequest, Device>("unary", this._transport, method, opt, input);
    }
    /**
     * DeleteDevice hard-deletes a device, removing it and all collected data
     * history from the system.
     *
     * Prefer locking the device instead (see the `tctl lock` command). Deleting a
     * device doesn't invalidate existing device certificates, but does prevent
     * new device authentication ceremonies from occurring.
     *
     * Use with caution.
     *
     * @generated from protobuf rpc: DeleteDevice(teleport.devicetrust.v1.DeleteDeviceRequest) returns (google.protobuf.Empty);
     */
    deleteDevice(input: DeleteDeviceRequest, options?: RpcOptions): UnaryCall<DeleteDeviceRequest, Empty> {
        const method = this.methods[3], opt = this._transport.mergeOptions(options);
        return stackIntercept<DeleteDeviceRequest, Empty>("unary", this._transport, method, opt, input);
    }
    /**
     * FindDevices retrieves devices by device ID and/or asset tag.
     *
     * It provides an in-between search between fetching a device by ID and
     * listing all devices.
     *
     * ID matches are guaranteed to be present in the response.
     *
     * @generated from protobuf rpc: FindDevices(teleport.devicetrust.v1.FindDevicesRequest) returns (teleport.devicetrust.v1.FindDevicesResponse);
     */
    findDevices(input: FindDevicesRequest, options?: RpcOptions): UnaryCall<FindDevicesRequest, FindDevicesResponse> {
        const method = this.methods[4], opt = this._transport.mergeOptions(options);
        return stackIntercept<FindDevicesRequest, FindDevicesResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetDevice retrieves a device by ID.
     *
     * @generated from protobuf rpc: GetDevice(teleport.devicetrust.v1.GetDeviceRequest) returns (teleport.devicetrust.v1.Device);
     */
    getDevice(input: GetDeviceRequest, options?: RpcOptions): UnaryCall<GetDeviceRequest, Device> {
        const method = this.methods[5], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetDeviceRequest, Device>("unary", this._transport, method, opt, input);
    }
    /**
     * ListDevices lists all registered devices.
     *
     * @generated from protobuf rpc: ListDevices(teleport.devicetrust.v1.ListDevicesRequest) returns (teleport.devicetrust.v1.ListDevicesResponse);
     */
    listDevices(input: ListDevicesRequest, options?: RpcOptions): UnaryCall<ListDevicesRequest, ListDevicesResponse> {
        const method = this.methods[6], opt = this._transport.mergeOptions(options);
        return stackIntercept<ListDevicesRequest, ListDevicesResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * BulkCreateDevices is a bulk variant of CreateDevice.
     *
     * Unlike CreateDevice, it does not support creation of enrollment tokens, as
     * it is meant for bulk inventory registration.
     *
     * @generated from protobuf rpc: BulkCreateDevices(teleport.devicetrust.v1.BulkCreateDevicesRequest) returns (teleport.devicetrust.v1.BulkCreateDevicesResponse);
     */
    bulkCreateDevices(input: BulkCreateDevicesRequest, options?: RpcOptions): UnaryCall<BulkCreateDevicesRequest, BulkCreateDevicesResponse> {
        const method = this.methods[7], opt = this._transport.mergeOptions(options);
        return stackIntercept<BulkCreateDevicesRequest, BulkCreateDevicesResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * CreateDeviceEnrollToken creates a DeviceEnrollToken for a Device.
     * An enrollment token is required for the enrollment ceremony. See
     * EnrollDevice.
     *
     * @generated from protobuf rpc: CreateDeviceEnrollToken(teleport.devicetrust.v1.CreateDeviceEnrollTokenRequest) returns (teleport.devicetrust.v1.DeviceEnrollToken);
     */
    createDeviceEnrollToken(input: CreateDeviceEnrollTokenRequest, options?: RpcOptions): UnaryCall<CreateDeviceEnrollTokenRequest, DeviceEnrollToken> {
        const method = this.methods[8], opt = this._transport.mergeOptions(options);
        return stackIntercept<CreateDeviceEnrollTokenRequest, DeviceEnrollToken>("unary", this._transport, method, opt, input);
    }
    /**
     * EnrollDevice performs the device enrollment ceremony.
     *
     * Enrollment requires a previously-registered Device and a DeviceEnrollToken,
     * see CreateDevice and CreateDeviceEnrollToken.
     *
     * An enrolled device is allowed, via AuthenticateDevice, to acquire
     * certificates containing device extensions, thus gaining access to
     * device-aware actions.
     *
     * macOS enrollment flow:
     * -> EnrollDeviceInit (client)
     * <- MacOSEnrollChallenge (server)
     * -> MacOSEnrollChallengeResponse
     * <- EnrollDeviceSuccess
     *
     * TPM enrollment flow:
     * -> EnrollDeviceInit (client)
     * <- TPMEnrollChallenge (server)
     * -> TPMEnrollChallengeResponse
     * <- EnrollDeviceSuccess
     *
     * @generated from protobuf rpc: EnrollDevice(stream teleport.devicetrust.v1.EnrollDeviceRequest) returns (stream teleport.devicetrust.v1.EnrollDeviceResponse);
     */
    enrollDevice(options?: RpcOptions): DuplexStreamingCall<EnrollDeviceRequest, EnrollDeviceResponse> {
        const method = this.methods[9], opt = this._transport.mergeOptions(options);
        return stackIntercept<EnrollDeviceRequest, EnrollDeviceResponse>("duplex", this._transport, method, opt);
    }
    /**
     * AuthenticateDevice performs the device authentication ceremony.
     *
     * Device authentication exchanges existing user certificates without device
     * extensions for certificates augmented with device extensions. The new
     * certificates allow the user to perform device-aware actions.
     *
     * Only registered and enrolled devices may perform device authentication.
     *
     * @generated from protobuf rpc: AuthenticateDevice(stream teleport.devicetrust.v1.AuthenticateDeviceRequest) returns (stream teleport.devicetrust.v1.AuthenticateDeviceResponse);
     */
    authenticateDevice(options?: RpcOptions): DuplexStreamingCall<AuthenticateDeviceRequest, AuthenticateDeviceResponse> {
        const method = this.methods[10], opt = this._transport.mergeOptions(options);
        return stackIntercept<AuthenticateDeviceRequest, AuthenticateDeviceResponse>("duplex", this._transport, method, opt);
    }
    /**
     * ConfirmDeviceWebAuthentication finalizes the device web authentication
     * ceremony started by the creation of a DeviceWebToken and subsequent
     * AuthenticateDevice call.
     *
     * The DeviceConfirmationToken issued by AuthenticateDevice is spent in this
     * method, which consequently augments the corresponding Web Session
     * certificates with device extensions.
     *
     * This method must be called by the Teleport Proxy, and the Proxy itself must
     * be called by the same browser that started the on-behalf-of authentication
     * attempt. See the /webapi/device/webconfirm endpoint.
     *
     * See
     * https://github.com/gravitational/teleport.e/blob/master/rfd/0009e-device-trust-web-support.md#device-web-authentication.
     *
     * @generated from protobuf rpc: ConfirmDeviceWebAuthentication(teleport.devicetrust.v1.ConfirmDeviceWebAuthenticationRequest) returns (teleport.devicetrust.v1.ConfirmDeviceWebAuthenticationResponse);
     */
    confirmDeviceWebAuthentication(input: ConfirmDeviceWebAuthenticationRequest, options?: RpcOptions): UnaryCall<ConfirmDeviceWebAuthenticationRequest, ConfirmDeviceWebAuthenticationResponse> {
        const method = this.methods[11], opt = this._transport.mergeOptions(options);
        return stackIntercept<ConfirmDeviceWebAuthenticationRequest, ConfirmDeviceWebAuthenticationResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Syncs device inventory from a source exterior to Teleport, for example an
     * MDM.
     * Allows both partial and full syncs; for the latter, devices missing from
     * the external inventory are handled as specified.
     * Authorized either by a valid MDM service certificate or the appropriate
     * "device" permissions (create/update/delete).
     *
     * @generated from protobuf rpc: SyncInventory(stream teleport.devicetrust.v1.SyncInventoryRequest) returns (stream teleport.devicetrust.v1.SyncInventoryResponse);
     */
    syncInventory(options?: RpcOptions): DuplexStreamingCall<SyncInventoryRequest, SyncInventoryResponse> {
        const method = this.methods[12], opt = this._transport.mergeOptions(options);
        return stackIntercept<SyncInventoryRequest, SyncInventoryResponse>("duplex", this._transport, method, opt);
    }
    /**
     * Superseded by ResourceUsageService.GetUsage.
     *
     * @deprecated
     * @generated from protobuf rpc: GetDevicesUsage(teleport.devicetrust.v1.GetDevicesUsageRequest) returns (teleport.devicetrust.v1.DevicesUsage);
     */
    getDevicesUsage(input: GetDevicesUsageRequest, options?: RpcOptions): UnaryCall<GetDevicesUsageRequest, DevicesUsage> {
        const method = this.methods[13], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetDevicesUsageRequest, DevicesUsage>("unary", this._transport, method, opt, input);
    }
}
