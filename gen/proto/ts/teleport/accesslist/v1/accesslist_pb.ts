/* eslint-disable */
// @generated by protobuf-ts 2.9.3 with parameter eslint_disable,add_pb_suffix,server_grpc1,ts_nocheck
// @generated from protobuf file "teleport/accesslist/v1/accesslist.proto" (package "teleport.accesslist.v1", syntax proto3)
// tslint:disable
// @ts-nocheck
//
// Copyright 2023 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Trait } from "../../trait/v1/trait_pb";
import { Duration } from "../../../google/protobuf/duration_pb";
import { Timestamp } from "../../../google/protobuf/timestamp_pb";
import { ResourceHeader } from "../../header/v1/resourceheader_pb";
/**
 * AccessList describes the basic building block of access grants, which are
 * similar to access requests but for longer lived permissions that need to be
 * regularly audited.
 *
 * @generated from protobuf message teleport.accesslist.v1.AccessList
 */
export interface AccessList {
    /**
     * header is the header for the resource.
     *
     * @generated from protobuf field: teleport.header.v1.ResourceHeader header = 1;
     */
    header?: ResourceHeader;
    /**
     * spec is the specification for the Access List.
     *
     * @generated from protobuf field: teleport.accesslist.v1.AccessListSpec spec = 2;
     */
    spec?: AccessListSpec;
    /**
     * status contains dynamically calculated fields.
     *
     * @generated from protobuf field: teleport.accesslist.v1.AccessListStatus status = 3;
     */
    status?: AccessListStatus;
}
/**
 * AccessListSpec is the specification for an Access List.
 *
 * @generated from protobuf message teleport.accesslist.v1.AccessListSpec
 */
export interface AccessListSpec {
    /**
     * description is an optional plaintext description of the Access List.
     *
     * @generated from protobuf field: string description = 1;
     */
    description: string;
    /**
     * owners is a list of owners of the Access List.
     *
     * @generated from protobuf field: repeated teleport.accesslist.v1.AccessListOwner owners = 2;
     */
    owners: AccessListOwner[];
    /**
     * audit describes the frequency that this Access List must be audited.
     *
     * @generated from protobuf field: teleport.accesslist.v1.AccessListAudit audit = 3;
     */
    audit?: AccessListAudit;
    /**
     * membership_requires describes the requirements for a user to be a member of
     * the Access List. For a membership to an Access List to be effective, the
     * user must meet the requirements of Membership_requires and must be in the
     * members list.
     *
     * @generated from protobuf field: teleport.accesslist.v1.AccessListRequires membership_requires = 4;
     */
    membershipRequires?: AccessListRequires;
    /**
     * ownership_requires describes the requirements for a user to be an owner of
     * the Access List. For ownership of an Access List to be effective, the user
     * must meet the requirements of ownership_requires and must be in the owners
     * list.
     *
     * @generated from protobuf field: teleport.accesslist.v1.AccessListRequires ownership_requires = 5;
     */
    ownershipRequires?: AccessListRequires;
    /**
     * grants describes the access granted by membership to this Access List.
     *
     * @generated from protobuf field: teleport.accesslist.v1.AccessListGrants grants = 6;
     */
    grants?: AccessListGrants;
    /**
     * title is a plaintext short description of the Access List.
     *
     * @generated from protobuf field: string title = 8;
     */
    title: string;
    /**
     * owner_grants describes the access granted by owners to this Access List.
     *
     * @generated from protobuf field: teleport.accesslist.v1.AccessListGrants owner_grants = 11;
     */
    ownerGrants?: AccessListGrants;
}
/**
 * AccessListOwner is an owner of an Access List.
 *
 * @generated from protobuf message teleport.accesslist.v1.AccessListOwner
 */
export interface AccessListOwner {
    /**
     * name is the username of the owner.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * description is the plaintext description of the owner and why they are an
     * owner.
     *
     * @generated from protobuf field: string description = 2;
     */
    description: string;
    /**
     * ineligible_status describes if this owner is eligible or not
     * and if not, describes how they're lacking eligibility.
     *
     * @generated from protobuf field: teleport.accesslist.v1.IneligibleStatus ineligible_status = 3;
     */
    ineligibleStatus: IneligibleStatus;
    /**
     * membership_kind describes the type of membership, either
     * `MEMBERSHIP_KIND_USER` or `MEMBERSHIP_KIND_LIST`.
     *
     * @generated from protobuf field: teleport.accesslist.v1.MembershipKind membership_kind = 4;
     */
    membershipKind: MembershipKind;
}
/**
 * AccessListAudit describes the audit configuration for an Access List.
 *
 * @generated from protobuf message teleport.accesslist.v1.AccessListAudit
 */
export interface AccessListAudit {
    /**
     * next_audit_date is when the next audit date should be done by.
     *
     * @generated from protobuf field: google.protobuf.Timestamp next_audit_date = 2;
     */
    nextAuditDate?: Timestamp;
    /**
     * recurrence is the recurrence definition
     *
     * @generated from protobuf field: teleport.accesslist.v1.Recurrence recurrence = 3;
     */
    recurrence?: Recurrence;
    /**
     * notifications is the configuration for notifying users.
     *
     * @generated from protobuf field: teleport.accesslist.v1.Notifications notifications = 4;
     */
    notifications?: Notifications;
}
/**
 * Recurrence is the definition for when reviews will be scheduled.
 *
 * @generated from protobuf message teleport.accesslist.v1.Recurrence
 */
export interface Recurrence {
    /**
     * frequency is the frequency of reviews. This represents the period in months
     * between two reviews.
     * Supported values are 0, 1, 3, 6, and 12.
     *
     * @generated from protobuf field: teleport.accesslist.v1.ReviewFrequency frequency = 1;
     */
    frequency: ReviewFrequency;
    /**
     * day_of_month is the day of month that reviews will be scheduled on.
     * Supported values are 0, 1, 15, and 31.
     *
     * @generated from protobuf field: teleport.accesslist.v1.ReviewDayOfMonth day_of_month = 2;
     */
    dayOfMonth: ReviewDayOfMonth;
}
/**
 * Notifications contains the configuration for notifying users of a nearing
 * next audit date.
 *
 * @generated from protobuf message teleport.accesslist.v1.Notifications
 */
export interface Notifications {
    /**
     * start specifies when to start notifying users that the next audit date is
     * coming up.
     *
     * @generated from protobuf field: google.protobuf.Duration start = 1;
     */
    start?: Duration;
}
/**
 * AccessListRequires describes a requirement section for an Access List. A user
 * must meet the following criteria to obtain the specific access to the list.
 *
 * @generated from protobuf message teleport.accesslist.v1.AccessListRequires
 */
export interface AccessListRequires {
    /**
     * roles are the user roles that must be present for the user to obtain
     * access.
     *
     * @generated from protobuf field: repeated string roles = 1;
     */
    roles: string[];
    /**
     * traits are the traits that must be present for the user to obtain access.
     *
     * @generated from protobuf field: repeated teleport.trait.v1.Trait traits = 2;
     */
    traits: Trait[];
}
/**
 * AccessListGrants describes what access is granted by membership to the Access
 * List.
 *
 * @generated from protobuf message teleport.accesslist.v1.AccessListGrants
 */
export interface AccessListGrants {
    /**
     * roles are the roles that are granted to users who are members of the Access
     * List.
     *
     * @generated from protobuf field: repeated string roles = 1;
     */
    roles: string[];
    /**
     * traits are the traits that are granted to users who are members of the
     * Access List.
     *
     * @generated from protobuf field: repeated teleport.trait.v1.Trait traits = 2;
     */
    traits: Trait[];
}
/**
 * Member describes a member of an Access List.
 *
 * @generated from protobuf message teleport.accesslist.v1.Member
 */
export interface Member {
    /**
     * header is the header for the resource.
     *
     * @generated from protobuf field: teleport.header.v1.ResourceHeader header = 1;
     */
    header?: ResourceHeader;
    /**
     * spec is the specification for the Access List member.
     *
     * @generated from protobuf field: teleport.accesslist.v1.MemberSpec spec = 2;
     */
    spec?: MemberSpec;
}
/**
 * MemberSpec is the specification for an Access List member.
 *
 * @generated from protobuf message teleport.accesslist.v1.MemberSpec
 */
export interface MemberSpec {
    /**
     * associated Access List
     *
     * @generated from protobuf field: string access_list = 1;
     */
    accessList: string;
    /**
     * name is the name of the member of the Access List.
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * joined is when the user joined the Access List.
     *
     * @generated from protobuf field: google.protobuf.Timestamp joined = 3;
     */
    joined?: Timestamp;
    /**
     * expires is when the user's membership to the Access List expires.
     *
     * @generated from protobuf field: google.protobuf.Timestamp expires = 4;
     */
    expires?: Timestamp;
    /**
     * reason is the reason this user was added to the Access List.
     *
     * @generated from protobuf field: string reason = 5;
     */
    reason: string;
    /**
     * added_by is the user that added this user to the Access List.
     *
     * @generated from protobuf field: string added_by = 6;
     */
    addedBy: string;
    /**
     * ineligible_status describes if this member is eligible or not
     * and if not, describes how they're lacking eligibility.
     *
     * @generated from protobuf field: teleport.accesslist.v1.IneligibleStatus ineligible_status = 7;
     */
    ineligibleStatus: IneligibleStatus;
    /**
     * membership_kind describes the type of membership, either
     * `MEMBERSHIP_KIND_USER` or `MEMBERSHIP_KIND_LIST`.
     *
     * @generated from protobuf field: teleport.accesslist.v1.MembershipKind membership_kind = 9;
     */
    membershipKind: MembershipKind;
}
/**
 * Review is a review of an Access List.
 *
 * @generated from protobuf message teleport.accesslist.v1.Review
 */
export interface Review {
    /**
     * header is the header for the resource.
     *
     * @generated from protobuf field: teleport.header.v1.ResourceHeader header = 1;
     */
    header?: ResourceHeader;
    /**
     * spec is the specification for the Access List review.
     *
     * @generated from protobuf field: teleport.accesslist.v1.ReviewSpec spec = 2;
     */
    spec?: ReviewSpec;
}
/**
 * ReviewSpec is the specification for an Access List review.
 *
 * @generated from protobuf message teleport.accesslist.v1.ReviewSpec
 */
export interface ReviewSpec {
    /**
     * access_list is the name of the Access List that this review is for.
     *
     * @generated from protobuf field: string access_list = 1;
     */
    accessList: string;
    /**
     * reviewers are the users who performed the review.
     *
     * @generated from protobuf field: repeated string reviewers = 2;
     */
    reviewers: string[];
    /**
     * review_date is the date that this review was created.
     *
     * @generated from protobuf field: google.protobuf.Timestamp review_date = 3;
     */
    reviewDate?: Timestamp;
    /**
     * notes is an optional plaintext attached to the review that can be used by
     * the review for arbitrary note taking on the review.
     *
     * @generated from protobuf field: string notes = 4;
     */
    notes: string;
    /**
     * changes are the changes made as part of the review.
     *
     * @generated from protobuf field: teleport.accesslist.v1.ReviewChanges changes = 5;
     */
    changes?: ReviewChanges;
}
/**
 * ReviewChanges are the changes that were made as part of the review.
 *
 * @generated from protobuf message teleport.accesslist.v1.ReviewChanges
 */
export interface ReviewChanges {
    /**
     * membership_requirements_changed is populated if the requirements were
     * changed as part of this review.
     *
     * @generated from protobuf field: teleport.accesslist.v1.AccessListRequires membership_requirements_changed = 2;
     */
    membershipRequirementsChanged?: AccessListRequires;
    /**
     * removed_members contains the members that were removed as part of this
     * review.
     *
     * @generated from protobuf field: repeated string removed_members = 3;
     */
    removedMembers: string[];
    /**
     * review_frequency_changed is populated if the review frequency has changed.
     *
     * @generated from protobuf field: teleport.accesslist.v1.ReviewFrequency review_frequency_changed = 4;
     */
    reviewFrequencyChanged: ReviewFrequency;
    /**
     * review_day_of_month_changed is populated if the review day of month has
     * changed.
     *
     * @generated from protobuf field: teleport.accesslist.v1.ReviewDayOfMonth review_day_of_month_changed = 5;
     */
    reviewDayOfMonthChanged: ReviewDayOfMonth;
}
/**
 * CurrentUserAssignments describes the current user's ownership and membership status in the access list.
 *
 * @generated from protobuf message teleport.accesslist.v1.CurrentUserAssignments
 */
export interface CurrentUserAssignments {
    /**
     * ownership_type represents the current user's ownership type (explicit, inherited, or none) in the access list.
     *
     * @generated from protobuf field: teleport.accesslist.v1.AccessListUserAssignmentType ownership_type = 1;
     */
    ownershipType: AccessListUserAssignmentType;
    /**
     * membership_type represents the current user's membership type (explicit, inherited, or none) in the access list.
     *
     * @generated from protobuf field: teleport.accesslist.v1.AccessListUserAssignmentType membership_type = 2;
     */
    membershipType: AccessListUserAssignmentType;
}
/**
 * AccessListStatus contains dynamic fields calculated during retrieval.
 *
 * @generated from protobuf message teleport.accesslist.v1.AccessListStatus
 */
export interface AccessListStatus {
    /**
     * member_count is the number of members in the Access List.
     *
     * @generated from protobuf field: optional uint32 member_count = 1;
     */
    memberCount?: number;
    /**
     * member_list_count is the number of nested list members in the Access List.
     *
     * @generated from protobuf field: optional uint32 member_list_count = 2;
     */
    memberListCount?: number;
    /**
     * owner_of describes Access Lists where this Access List is an explicit owner.
     *
     * @generated from protobuf field: repeated string owner_of = 3;
     */
    ownerOf: string[];
    /**
     * member_of describes Access Lists where this Access List is an explicit member.
     *
     * @generated from protobuf field: repeated string member_of = 4;
     */
    memberOf: string[];
    /**
     * current_user_assignments describes the current user's ownership and membership status in the access list.
     *
     * @generated from protobuf field: teleport.accesslist.v1.CurrentUserAssignments current_user_assignments = 5;
     */
    currentUserAssignments?: CurrentUserAssignments;
}
/**
 * ReviewFrequency is the frequency of reviews.
 *
 * @generated from protobuf enum teleport.accesslist.v1.ReviewFrequency
 */
export enum ReviewFrequency {
    /**
     * @generated from protobuf enum value: REVIEW_FREQUENCY_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: REVIEW_FREQUENCY_ONE_MONTH = 1;
     */
    ONE_MONTH = 1,
    /**
     * @generated from protobuf enum value: REVIEW_FREQUENCY_THREE_MONTHS = 3;
     */
    THREE_MONTHS = 3,
    /**
     * @generated from protobuf enum value: REVIEW_FREQUENCY_SIX_MONTHS = 6;
     */
    SIX_MONTHS = 6,
    /**
     * @generated from protobuf enum value: REVIEW_FREQUENCY_ONE_YEAR = 12;
     */
    ONE_YEAR = 12
}
/**
 * ReviewDayOfMonth is the day of month that reviews will repeat on.
 *
 * @generated from protobuf enum teleport.accesslist.v1.ReviewDayOfMonth
 */
export enum ReviewDayOfMonth {
    /**
     * @generated from protobuf enum value: REVIEW_DAY_OF_MONTH_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: REVIEW_DAY_OF_MONTH_FIRST = 1;
     */
    FIRST = 1,
    /**
     * @generated from protobuf enum value: REVIEW_DAY_OF_MONTH_FIFTEENTH = 15;
     */
    FIFTEENTH = 15,
    /**
     * @generated from protobuf enum value: REVIEW_DAY_OF_MONTH_LAST = 31;
     */
    LAST = 31
}
/**
 * MembershipKind represents the different kinds of list membership
 *
 * @generated from protobuf enum teleport.accesslist.v1.MembershipKind
 */
export enum MembershipKind {
    /**
     * MEMBERSHIP_KIND_UNSPECIFIED represents list members that are of
     * unknown membership kind, defaulting to being treated as type USER
     *
     * @generated from protobuf enum value: MEMBERSHIP_KIND_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * MEMBERSHIP_KIND_USER represents list members that are normal users
     *
     * @generated from protobuf enum value: MEMBERSHIP_KIND_USER = 1;
     */
    USER = 1,
    /**
     * MEMBERSHIP_KIND_LIST represents list members that are nested Access Lists
     *
     * @generated from protobuf enum value: MEMBERSHIP_KIND_LIST = 2;
     */
    LIST = 2
}
/**
 * IneligibleStatus describes how the user is ineligible.
 *
 * @generated from protobuf enum teleport.accesslist.v1.IneligibleStatus
 */
export enum IneligibleStatus {
    /**
     * INELIGIBLE_STATUS_UNSPECIFIED means eligiblity is unknown.
     *
     * @generated from protobuf enum value: INELIGIBLE_STATUS_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * INELIGIBLE_STATUS_ELIGIBLE means checks were done and user met all
     * requirements.
     *
     * @generated from protobuf enum value: INELIGIBLE_STATUS_ELIGIBLE = 1;
     */
    ELIGIBLE = 1,
    /**
     * INELIGIBLE_STATUS_USER_NOT_EXIST means user was not found in backend.
     *
     * @generated from protobuf enum value: INELIGIBLE_STATUS_USER_NOT_EXIST = 2;
     */
    USER_NOT_EXIST = 2,
    /**
     * INELIGIBLE_STATUS_MISSING_REQUIREMENTS means user is missing some
     * requirements defined by AccessListRequires (fields can be either
     * ownership_requires or membership_requires)
     *
     * @generated from protobuf enum value: INELIGIBLE_STATUS_MISSING_REQUIREMENTS = 3;
     */
    MISSING_REQUIREMENTS = 3,
    /**
     * INELIGIBLE_STATUS_EXPIRED means user is expired.
     * Only applicable to members.
     *
     * @generated from protobuf enum value: INELIGIBLE_STATUS_EXPIRED = 4;
     */
    EXPIRED = 4
}
/**
 * AccessListUserAssignmentType describes the type of membership anr/or ownership
 * a user has in an access list.
 *
 * @generated from protobuf enum teleport.accesslist.v1.AccessListUserAssignmentType
 */
export enum AccessListUserAssignmentType {
    /**
     * ACCESS_LIST_USER_ASSIGNMENT_TYPE_UNSPECIFIED means the user is not an explicit nor an inherited member or owner
     *
     * @generated from protobuf enum value: ACCESS_LIST_USER_ASSIGNMENT_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * ACCESS_LIST_USER_ASSIGNMENT_TYPE_EXPLICIT means the user has explicit membership or ownership
     *
     * @generated from protobuf enum value: ACCESS_LIST_USER_ASSIGNMENT_TYPE_EXPLICIT = 1;
     */
    EXPLICIT = 1,
    /**
     * ACCESS_LIST_USER_ASSIGNMENT_TYPE_INHERITED means the user has inherited membership or ownership
     *
     * @generated from protobuf enum value: ACCESS_LIST_USER_ASSIGNMENT_TYPE_INHERITED = 2;
     */
    INHERITED = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class AccessList$Type extends MessageType<AccessList> {
    constructor() {
        super("teleport.accesslist.v1.AccessList", [
            { no: 1, name: "header", kind: "message", T: () => ResourceHeader },
            { no: 2, name: "spec", kind: "message", T: () => AccessListSpec },
            { no: 3, name: "status", kind: "message", T: () => AccessListStatus }
        ]);
    }
    create(value?: PartialMessage<AccessList>): AccessList {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AccessList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessList): AccessList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.header.v1.ResourceHeader header */ 1:
                    message.header = ResourceHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* teleport.accesslist.v1.AccessListSpec spec */ 2:
                    message.spec = AccessListSpec.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                case /* teleport.accesslist.v1.AccessListStatus status */ 3:
                    message.status = AccessListStatus.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.header.v1.ResourceHeader header = 1; */
        if (message.header)
            ResourceHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* teleport.accesslist.v1.AccessListSpec spec = 2; */
        if (message.spec)
            AccessListSpec.internalBinaryWrite(message.spec, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* teleport.accesslist.v1.AccessListStatus status = 3; */
        if (message.status)
            AccessListStatus.internalBinaryWrite(message.status, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.AccessList
 */
export const AccessList = new AccessList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessListSpec$Type extends MessageType<AccessListSpec> {
    constructor() {
        super("teleport.accesslist.v1.AccessListSpec", [
            { no: 1, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "owners", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AccessListOwner },
            { no: 3, name: "audit", kind: "message", T: () => AccessListAudit },
            { no: 4, name: "membership_requires", kind: "message", T: () => AccessListRequires },
            { no: 5, name: "ownership_requires", kind: "message", T: () => AccessListRequires },
            { no: 6, name: "grants", kind: "message", T: () => AccessListGrants },
            { no: 8, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "owner_grants", kind: "message", T: () => AccessListGrants }
        ]);
    }
    create(value?: PartialMessage<AccessListSpec>): AccessListSpec {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.description = "";
        message.owners = [];
        message.title = "";
        if (value !== undefined)
            reflectionMergePartial<AccessListSpec>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessListSpec): AccessListSpec {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string description */ 1:
                    message.description = reader.string();
                    break;
                case /* repeated teleport.accesslist.v1.AccessListOwner owners */ 2:
                    message.owners.push(AccessListOwner.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* teleport.accesslist.v1.AccessListAudit audit */ 3:
                    message.audit = AccessListAudit.internalBinaryRead(reader, reader.uint32(), options, message.audit);
                    break;
                case /* teleport.accesslist.v1.AccessListRequires membership_requires */ 4:
                    message.membershipRequires = AccessListRequires.internalBinaryRead(reader, reader.uint32(), options, message.membershipRequires);
                    break;
                case /* teleport.accesslist.v1.AccessListRequires ownership_requires */ 5:
                    message.ownershipRequires = AccessListRequires.internalBinaryRead(reader, reader.uint32(), options, message.ownershipRequires);
                    break;
                case /* teleport.accesslist.v1.AccessListGrants grants */ 6:
                    message.grants = AccessListGrants.internalBinaryRead(reader, reader.uint32(), options, message.grants);
                    break;
                case /* string title */ 8:
                    message.title = reader.string();
                    break;
                case /* teleport.accesslist.v1.AccessListGrants owner_grants */ 11:
                    message.ownerGrants = AccessListGrants.internalBinaryRead(reader, reader.uint32(), options, message.ownerGrants);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessListSpec, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string description = 1; */
        if (message.description !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.description);
        /* repeated teleport.accesslist.v1.AccessListOwner owners = 2; */
        for (let i = 0; i < message.owners.length; i++)
            AccessListOwner.internalBinaryWrite(message.owners[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* teleport.accesslist.v1.AccessListAudit audit = 3; */
        if (message.audit)
            AccessListAudit.internalBinaryWrite(message.audit, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* teleport.accesslist.v1.AccessListRequires membership_requires = 4; */
        if (message.membershipRequires)
            AccessListRequires.internalBinaryWrite(message.membershipRequires, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* teleport.accesslist.v1.AccessListRequires ownership_requires = 5; */
        if (message.ownershipRequires)
            AccessListRequires.internalBinaryWrite(message.ownershipRequires, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* teleport.accesslist.v1.AccessListGrants grants = 6; */
        if (message.grants)
            AccessListGrants.internalBinaryWrite(message.grants, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* string title = 8; */
        if (message.title !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.title);
        /* teleport.accesslist.v1.AccessListGrants owner_grants = 11; */
        if (message.ownerGrants)
            AccessListGrants.internalBinaryWrite(message.ownerGrants, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.AccessListSpec
 */
export const AccessListSpec = new AccessListSpec$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessListOwner$Type extends MessageType<AccessListOwner> {
    constructor() {
        super("teleport.accesslist.v1.AccessListOwner", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "ineligible_status", kind: "enum", T: () => ["teleport.accesslist.v1.IneligibleStatus", IneligibleStatus, "INELIGIBLE_STATUS_"] },
            { no: 4, name: "membership_kind", kind: "enum", T: () => ["teleport.accesslist.v1.MembershipKind", MembershipKind, "MEMBERSHIP_KIND_"] }
        ]);
    }
    create(value?: PartialMessage<AccessListOwner>): AccessListOwner {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.description = "";
        message.ineligibleStatus = 0;
        message.membershipKind = 0;
        if (value !== undefined)
            reflectionMergePartial<AccessListOwner>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessListOwner): AccessListOwner {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* teleport.accesslist.v1.IneligibleStatus ineligible_status */ 3:
                    message.ineligibleStatus = reader.int32();
                    break;
                case /* teleport.accesslist.v1.MembershipKind membership_kind */ 4:
                    message.membershipKind = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessListOwner, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* teleport.accesslist.v1.IneligibleStatus ineligible_status = 3; */
        if (message.ineligibleStatus !== 0)
            writer.tag(3, WireType.Varint).int32(message.ineligibleStatus);
        /* teleport.accesslist.v1.MembershipKind membership_kind = 4; */
        if (message.membershipKind !== 0)
            writer.tag(4, WireType.Varint).int32(message.membershipKind);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.AccessListOwner
 */
export const AccessListOwner = new AccessListOwner$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessListAudit$Type extends MessageType<AccessListAudit> {
    constructor() {
        super("teleport.accesslist.v1.AccessListAudit", [
            { no: 2, name: "next_audit_date", kind: "message", T: () => Timestamp },
            { no: 3, name: "recurrence", kind: "message", T: () => Recurrence },
            { no: 4, name: "notifications", kind: "message", T: () => Notifications }
        ]);
    }
    create(value?: PartialMessage<AccessListAudit>): AccessListAudit {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AccessListAudit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessListAudit): AccessListAudit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Timestamp next_audit_date */ 2:
                    message.nextAuditDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.nextAuditDate);
                    break;
                case /* teleport.accesslist.v1.Recurrence recurrence */ 3:
                    message.recurrence = Recurrence.internalBinaryRead(reader, reader.uint32(), options, message.recurrence);
                    break;
                case /* teleport.accesslist.v1.Notifications notifications */ 4:
                    message.notifications = Notifications.internalBinaryRead(reader, reader.uint32(), options, message.notifications);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessListAudit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Timestamp next_audit_date = 2; */
        if (message.nextAuditDate)
            Timestamp.internalBinaryWrite(message.nextAuditDate, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* teleport.accesslist.v1.Recurrence recurrence = 3; */
        if (message.recurrence)
            Recurrence.internalBinaryWrite(message.recurrence, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* teleport.accesslist.v1.Notifications notifications = 4; */
        if (message.notifications)
            Notifications.internalBinaryWrite(message.notifications, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.AccessListAudit
 */
export const AccessListAudit = new AccessListAudit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Recurrence$Type extends MessageType<Recurrence> {
    constructor() {
        super("teleport.accesslist.v1.Recurrence", [
            { no: 1, name: "frequency", kind: "enum", T: () => ["teleport.accesslist.v1.ReviewFrequency", ReviewFrequency, "REVIEW_FREQUENCY_"] },
            { no: 2, name: "day_of_month", kind: "enum", T: () => ["teleport.accesslist.v1.ReviewDayOfMonth", ReviewDayOfMonth, "REVIEW_DAY_OF_MONTH_"] }
        ]);
    }
    create(value?: PartialMessage<Recurrence>): Recurrence {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.frequency = 0;
        message.dayOfMonth = 0;
        if (value !== undefined)
            reflectionMergePartial<Recurrence>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Recurrence): Recurrence {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.accesslist.v1.ReviewFrequency frequency */ 1:
                    message.frequency = reader.int32();
                    break;
                case /* teleport.accesslist.v1.ReviewDayOfMonth day_of_month */ 2:
                    message.dayOfMonth = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Recurrence, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.accesslist.v1.ReviewFrequency frequency = 1; */
        if (message.frequency !== 0)
            writer.tag(1, WireType.Varint).int32(message.frequency);
        /* teleport.accesslist.v1.ReviewDayOfMonth day_of_month = 2; */
        if (message.dayOfMonth !== 0)
            writer.tag(2, WireType.Varint).int32(message.dayOfMonth);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.Recurrence
 */
export const Recurrence = new Recurrence$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Notifications$Type extends MessageType<Notifications> {
    constructor() {
        super("teleport.accesslist.v1.Notifications", [
            { no: 1, name: "start", kind: "message", T: () => Duration }
        ]);
    }
    create(value?: PartialMessage<Notifications>): Notifications {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Notifications>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Notifications): Notifications {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Duration start */ 1:
                    message.start = Duration.internalBinaryRead(reader, reader.uint32(), options, message.start);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Notifications, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Duration start = 1; */
        if (message.start)
            Duration.internalBinaryWrite(message.start, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.Notifications
 */
export const Notifications = new Notifications$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessListRequires$Type extends MessageType<AccessListRequires> {
    constructor() {
        super("teleport.accesslist.v1.AccessListRequires", [
            { no: 1, name: "roles", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "traits", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Trait }
        ]);
    }
    create(value?: PartialMessage<AccessListRequires>): AccessListRequires {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.roles = [];
        message.traits = [];
        if (value !== undefined)
            reflectionMergePartial<AccessListRequires>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessListRequires): AccessListRequires {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string roles */ 1:
                    message.roles.push(reader.string());
                    break;
                case /* repeated teleport.trait.v1.Trait traits */ 2:
                    message.traits.push(Trait.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessListRequires, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string roles = 1; */
        for (let i = 0; i < message.roles.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.roles[i]);
        /* repeated teleport.trait.v1.Trait traits = 2; */
        for (let i = 0; i < message.traits.length; i++)
            Trait.internalBinaryWrite(message.traits[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.AccessListRequires
 */
export const AccessListRequires = new AccessListRequires$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessListGrants$Type extends MessageType<AccessListGrants> {
    constructor() {
        super("teleport.accesslist.v1.AccessListGrants", [
            { no: 1, name: "roles", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "traits", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Trait }
        ]);
    }
    create(value?: PartialMessage<AccessListGrants>): AccessListGrants {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.roles = [];
        message.traits = [];
        if (value !== undefined)
            reflectionMergePartial<AccessListGrants>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessListGrants): AccessListGrants {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string roles */ 1:
                    message.roles.push(reader.string());
                    break;
                case /* repeated teleport.trait.v1.Trait traits */ 2:
                    message.traits.push(Trait.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessListGrants, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string roles = 1; */
        for (let i = 0; i < message.roles.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.roles[i]);
        /* repeated teleport.trait.v1.Trait traits = 2; */
        for (let i = 0; i < message.traits.length; i++)
            Trait.internalBinaryWrite(message.traits[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.AccessListGrants
 */
export const AccessListGrants = new AccessListGrants$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Member$Type extends MessageType<Member> {
    constructor() {
        super("teleport.accesslist.v1.Member", [
            { no: 1, name: "header", kind: "message", T: () => ResourceHeader },
            { no: 2, name: "spec", kind: "message", T: () => MemberSpec }
        ]);
    }
    create(value?: PartialMessage<Member>): Member {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Member>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Member): Member {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.header.v1.ResourceHeader header */ 1:
                    message.header = ResourceHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* teleport.accesslist.v1.MemberSpec spec */ 2:
                    message.spec = MemberSpec.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Member, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.header.v1.ResourceHeader header = 1; */
        if (message.header)
            ResourceHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* teleport.accesslist.v1.MemberSpec spec = 2; */
        if (message.spec)
            MemberSpec.internalBinaryWrite(message.spec, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.Member
 */
export const Member = new Member$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MemberSpec$Type extends MessageType<MemberSpec> {
    constructor() {
        super("teleport.accesslist.v1.MemberSpec", [
            { no: 1, name: "access_list", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "joined", kind: "message", T: () => Timestamp },
            { no: 4, name: "expires", kind: "message", T: () => Timestamp },
            { no: 5, name: "reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "added_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "ineligible_status", kind: "enum", T: () => ["teleport.accesslist.v1.IneligibleStatus", IneligibleStatus, "INELIGIBLE_STATUS_"] },
            { no: 9, name: "membership_kind", kind: "enum", T: () => ["teleport.accesslist.v1.MembershipKind", MembershipKind, "MEMBERSHIP_KIND_"] }
        ]);
    }
    create(value?: PartialMessage<MemberSpec>): MemberSpec {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accessList = "";
        message.name = "";
        message.reason = "";
        message.addedBy = "";
        message.ineligibleStatus = 0;
        message.membershipKind = 0;
        if (value !== undefined)
            reflectionMergePartial<MemberSpec>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MemberSpec): MemberSpec {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string access_list */ 1:
                    message.accessList = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* google.protobuf.Timestamp joined */ 3:
                    message.joined = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.joined);
                    break;
                case /* google.protobuf.Timestamp expires */ 4:
                    message.expires = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expires);
                    break;
                case /* string reason */ 5:
                    message.reason = reader.string();
                    break;
                case /* string added_by */ 6:
                    message.addedBy = reader.string();
                    break;
                case /* teleport.accesslist.v1.IneligibleStatus ineligible_status */ 7:
                    message.ineligibleStatus = reader.int32();
                    break;
                case /* teleport.accesslist.v1.MembershipKind membership_kind */ 9:
                    message.membershipKind = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MemberSpec, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string access_list = 1; */
        if (message.accessList !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accessList);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* google.protobuf.Timestamp joined = 3; */
        if (message.joined)
            Timestamp.internalBinaryWrite(message.joined, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp expires = 4; */
        if (message.expires)
            Timestamp.internalBinaryWrite(message.expires, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string reason = 5; */
        if (message.reason !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.reason);
        /* string added_by = 6; */
        if (message.addedBy !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.addedBy);
        /* teleport.accesslist.v1.IneligibleStatus ineligible_status = 7; */
        if (message.ineligibleStatus !== 0)
            writer.tag(7, WireType.Varint).int32(message.ineligibleStatus);
        /* teleport.accesslist.v1.MembershipKind membership_kind = 9; */
        if (message.membershipKind !== 0)
            writer.tag(9, WireType.Varint).int32(message.membershipKind);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.MemberSpec
 */
export const MemberSpec = new MemberSpec$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Review$Type extends MessageType<Review> {
    constructor() {
        super("teleport.accesslist.v1.Review", [
            { no: 1, name: "header", kind: "message", T: () => ResourceHeader },
            { no: 2, name: "spec", kind: "message", T: () => ReviewSpec }
        ]);
    }
    create(value?: PartialMessage<Review>): Review {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Review>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Review): Review {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.header.v1.ResourceHeader header */ 1:
                    message.header = ResourceHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* teleport.accesslist.v1.ReviewSpec spec */ 2:
                    message.spec = ReviewSpec.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Review, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.header.v1.ResourceHeader header = 1; */
        if (message.header)
            ResourceHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* teleport.accesslist.v1.ReviewSpec spec = 2; */
        if (message.spec)
            ReviewSpec.internalBinaryWrite(message.spec, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.Review
 */
export const Review = new Review$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReviewSpec$Type extends MessageType<ReviewSpec> {
    constructor() {
        super("teleport.accesslist.v1.ReviewSpec", [
            { no: 1, name: "access_list", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "reviewers", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "review_date", kind: "message", T: () => Timestamp },
            { no: 4, name: "notes", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "changes", kind: "message", T: () => ReviewChanges }
        ]);
    }
    create(value?: PartialMessage<ReviewSpec>): ReviewSpec {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accessList = "";
        message.reviewers = [];
        message.notes = "";
        if (value !== undefined)
            reflectionMergePartial<ReviewSpec>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReviewSpec): ReviewSpec {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string access_list */ 1:
                    message.accessList = reader.string();
                    break;
                case /* repeated string reviewers */ 2:
                    message.reviewers.push(reader.string());
                    break;
                case /* google.protobuf.Timestamp review_date */ 3:
                    message.reviewDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.reviewDate);
                    break;
                case /* string notes */ 4:
                    message.notes = reader.string();
                    break;
                case /* teleport.accesslist.v1.ReviewChanges changes */ 5:
                    message.changes = ReviewChanges.internalBinaryRead(reader, reader.uint32(), options, message.changes);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReviewSpec, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string access_list = 1; */
        if (message.accessList !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accessList);
        /* repeated string reviewers = 2; */
        for (let i = 0; i < message.reviewers.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.reviewers[i]);
        /* google.protobuf.Timestamp review_date = 3; */
        if (message.reviewDate)
            Timestamp.internalBinaryWrite(message.reviewDate, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string notes = 4; */
        if (message.notes !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.notes);
        /* teleport.accesslist.v1.ReviewChanges changes = 5; */
        if (message.changes)
            ReviewChanges.internalBinaryWrite(message.changes, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.ReviewSpec
 */
export const ReviewSpec = new ReviewSpec$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReviewChanges$Type extends MessageType<ReviewChanges> {
    constructor() {
        super("teleport.accesslist.v1.ReviewChanges", [
            { no: 2, name: "membership_requirements_changed", kind: "message", T: () => AccessListRequires },
            { no: 3, name: "removed_members", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "review_frequency_changed", kind: "enum", T: () => ["teleport.accesslist.v1.ReviewFrequency", ReviewFrequency, "REVIEW_FREQUENCY_"] },
            { no: 5, name: "review_day_of_month_changed", kind: "enum", T: () => ["teleport.accesslist.v1.ReviewDayOfMonth", ReviewDayOfMonth, "REVIEW_DAY_OF_MONTH_"] }
        ]);
    }
    create(value?: PartialMessage<ReviewChanges>): ReviewChanges {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.removedMembers = [];
        message.reviewFrequencyChanged = 0;
        message.reviewDayOfMonthChanged = 0;
        if (value !== undefined)
            reflectionMergePartial<ReviewChanges>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReviewChanges): ReviewChanges {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.accesslist.v1.AccessListRequires membership_requirements_changed */ 2:
                    message.membershipRequirementsChanged = AccessListRequires.internalBinaryRead(reader, reader.uint32(), options, message.membershipRequirementsChanged);
                    break;
                case /* repeated string removed_members */ 3:
                    message.removedMembers.push(reader.string());
                    break;
                case /* teleport.accesslist.v1.ReviewFrequency review_frequency_changed */ 4:
                    message.reviewFrequencyChanged = reader.int32();
                    break;
                case /* teleport.accesslist.v1.ReviewDayOfMonth review_day_of_month_changed */ 5:
                    message.reviewDayOfMonthChanged = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReviewChanges, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.accesslist.v1.AccessListRequires membership_requirements_changed = 2; */
        if (message.membershipRequirementsChanged)
            AccessListRequires.internalBinaryWrite(message.membershipRequirementsChanged, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated string removed_members = 3; */
        for (let i = 0; i < message.removedMembers.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.removedMembers[i]);
        /* teleport.accesslist.v1.ReviewFrequency review_frequency_changed = 4; */
        if (message.reviewFrequencyChanged !== 0)
            writer.tag(4, WireType.Varint).int32(message.reviewFrequencyChanged);
        /* teleport.accesslist.v1.ReviewDayOfMonth review_day_of_month_changed = 5; */
        if (message.reviewDayOfMonthChanged !== 0)
            writer.tag(5, WireType.Varint).int32(message.reviewDayOfMonthChanged);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.ReviewChanges
 */
export const ReviewChanges = new ReviewChanges$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CurrentUserAssignments$Type extends MessageType<CurrentUserAssignments> {
    constructor() {
        super("teleport.accesslist.v1.CurrentUserAssignments", [
            { no: 1, name: "ownership_type", kind: "enum", T: () => ["teleport.accesslist.v1.AccessListUserAssignmentType", AccessListUserAssignmentType, "ACCESS_LIST_USER_ASSIGNMENT_TYPE_"] },
            { no: 2, name: "membership_type", kind: "enum", T: () => ["teleport.accesslist.v1.AccessListUserAssignmentType", AccessListUserAssignmentType, "ACCESS_LIST_USER_ASSIGNMENT_TYPE_"] }
        ]);
    }
    create(value?: PartialMessage<CurrentUserAssignments>): CurrentUserAssignments {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ownershipType = 0;
        message.membershipType = 0;
        if (value !== undefined)
            reflectionMergePartial<CurrentUserAssignments>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CurrentUserAssignments): CurrentUserAssignments {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.accesslist.v1.AccessListUserAssignmentType ownership_type */ 1:
                    message.ownershipType = reader.int32();
                    break;
                case /* teleport.accesslist.v1.AccessListUserAssignmentType membership_type */ 2:
                    message.membershipType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CurrentUserAssignments, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.accesslist.v1.AccessListUserAssignmentType ownership_type = 1; */
        if (message.ownershipType !== 0)
            writer.tag(1, WireType.Varint).int32(message.ownershipType);
        /* teleport.accesslist.v1.AccessListUserAssignmentType membership_type = 2; */
        if (message.membershipType !== 0)
            writer.tag(2, WireType.Varint).int32(message.membershipType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.CurrentUserAssignments
 */
export const CurrentUserAssignments = new CurrentUserAssignments$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessListStatus$Type extends MessageType<AccessListStatus> {
    constructor() {
        super("teleport.accesslist.v1.AccessListStatus", [
            { no: 1, name: "member_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "member_list_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "owner_of", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "member_of", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "current_user_assignments", kind: "message", T: () => CurrentUserAssignments }
        ]);
    }
    create(value?: PartialMessage<AccessListStatus>): AccessListStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ownerOf = [];
        message.memberOf = [];
        if (value !== undefined)
            reflectionMergePartial<AccessListStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessListStatus): AccessListStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 member_count */ 1:
                    message.memberCount = reader.uint32();
                    break;
                case /* optional uint32 member_list_count */ 2:
                    message.memberListCount = reader.uint32();
                    break;
                case /* repeated string owner_of */ 3:
                    message.ownerOf.push(reader.string());
                    break;
                case /* repeated string member_of */ 4:
                    message.memberOf.push(reader.string());
                    break;
                case /* teleport.accesslist.v1.CurrentUserAssignments current_user_assignments */ 5:
                    message.currentUserAssignments = CurrentUserAssignments.internalBinaryRead(reader, reader.uint32(), options, message.currentUserAssignments);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessListStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 member_count = 1; */
        if (message.memberCount !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.memberCount);
        /* optional uint32 member_list_count = 2; */
        if (message.memberListCount !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.memberListCount);
        /* repeated string owner_of = 3; */
        for (let i = 0; i < message.ownerOf.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.ownerOf[i]);
        /* repeated string member_of = 4; */
        for (let i = 0; i < message.memberOf.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.memberOf[i]);
        /* teleport.accesslist.v1.CurrentUserAssignments current_user_assignments = 5; */
        if (message.currentUserAssignments)
            CurrentUserAssignments.internalBinaryWrite(message.currentUserAssignments, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.AccessListStatus
 */
export const AccessListStatus = new AccessListStatus$Type();
