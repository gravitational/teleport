/* eslint-disable */
// @generated by protobuf-ts 2.9.3 with parameter long_type_number,eslint_disable,add_pb_suffix,server_grpc1,ts_nocheck
// @generated from protobuf file "teleport/accesslist/v1/accesslist_service.proto" (package "teleport.accesslist.v1", syntax proto3)
// tslint:disable
// @ts-nocheck
//
// Copyright 2023 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import { Empty } from "../../../google/protobuf/empty_pb";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { AccessRequestV3 } from "../../legacy/types/types_pb";
import { Timestamp } from "../../../google/protobuf/timestamp_pb";
import { Review } from "./accesslist_pb";
import { Member } from "./accesslist_pb";
import { AccessList } from "./accesslist_pb";
/**
 * GetAccessListsRequest is the request for getting all access lists.
 *
 * @generated from protobuf message teleport.accesslist.v1.GetAccessListsRequest
 */
export interface GetAccessListsRequest {
}
/**
 * GetAccessListsResponse is the response for getting all access lists.
 *
 * @generated from protobuf message teleport.accesslist.v1.GetAccessListsResponse
 */
export interface GetAccessListsResponse {
    /**
     * access_lists is the list of access lists.
     *
     * @generated from protobuf field: repeated teleport.accesslist.v1.AccessList access_lists = 1;
     */
    accessLists: AccessList[];
}
/**
 * ListAccessListsRequest is the request for getting paginated access lists.
 *
 * @generated from protobuf message teleport.accesslist.v1.ListAccessListsRequest
 */
export interface ListAccessListsRequest {
    /**
     * page_size is the size of the page to request.
     *
     * @generated from protobuf field: int32 page_size = 1;
     */
    pageSize: number;
    /**
     * next_token is the page token.
     *
     * @generated from protobuf field: string next_token = 2;
     */
    nextToken: string;
}
/**
 * ListAccessListsResponse is the response for getting paginated access lists.
 *
 * @generated from protobuf message teleport.accesslist.v1.ListAccessListsResponse
 */
export interface ListAccessListsResponse {
    /**
     * access_lists is the list of access lists.
     *
     * @generated from protobuf field: repeated teleport.accesslist.v1.AccessList access_lists = 1;
     */
    accessLists: AccessList[];
    /**
     * next_token is the next page token.
     *
     * @generated from protobuf field: string next_token = 2;
     */
    nextToken: string;
}
/**
 * GetAccessListRequest is the request for retrieving an access list.
 *
 * @generated from protobuf message teleport.accesslist.v1.GetAccessListRequest
 */
export interface GetAccessListRequest {
    /**
     * name is the name of the access list to retrieve.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * UpsertAccessListRequest is the request for upserting an access list.
 *
 * @generated from protobuf message teleport.accesslist.v1.UpsertAccessListRequest
 */
export interface UpsertAccessListRequest {
    /**
     * access_list is the access list to upsert.
     *
     * @generated from protobuf field: teleport.accesslist.v1.AccessList access_list = 1;
     */
    accessList?: AccessList;
}
/**
 * UpdateAccessListRequest is the request for updating an access list.
 *
 * @generated from protobuf message teleport.accesslist.v1.UpdateAccessListRequest
 */
export interface UpdateAccessListRequest {
    /**
     * access_list is the access list to upsert.
     *
     * @generated from protobuf field: teleport.accesslist.v1.AccessList access_list = 1;
     */
    accessList?: AccessList;
}
/**
 * DeleteAccessListRequest is the request for deleting an access list.
 *
 * @generated from protobuf message teleport.accesslist.v1.DeleteAccessListRequest
 */
export interface DeleteAccessListRequest {
    /**
     * name is the name of the access list to delete.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * DeleteAllAccessListsRequest is the request for deleting all access lists.
 *
 * @generated from protobuf message teleport.accesslist.v1.DeleteAllAccessListsRequest
 */
export interface DeleteAllAccessListsRequest {
}
/**
 * GetAccessListsToReviewRequest is the request for getting access lists that
 * the current user needs to review.
 *
 * @generated from protobuf message teleport.accesslist.v1.GetAccessListsToReviewRequest
 */
export interface GetAccessListsToReviewRequest {
}
/**
 * GetAccessListsToReviewResponse is the response for getting access lists that
 * the current user needs to review.
 *
 * @generated from protobuf message teleport.accesslist.v1.GetAccessListsToReviewResponse
 */
export interface GetAccessListsToReviewResponse {
    /**
     * @generated from protobuf field: repeated teleport.accesslist.v1.AccessList access_lists = 1;
     */
    accessLists: AccessList[];
}
/**
 * CountAccessListMembersRequest is the request for counting access list
 * members.
 *
 * @generated from protobuf message teleport.accesslist.v1.CountAccessListMembersRequest
 */
export interface CountAccessListMembersRequest {
    /**
     * access_list_name is the name of the access list to retrieve.
     *
     * @generated from protobuf field: string access_list_name = 1;
     */
    accessListName: string;
}
/**
 * CountAccessListMembersResponse is the response for counting access list
 * members.
 *
 * @generated from protobuf message teleport.accesslist.v1.CountAccessListMembersResponse
 */
export interface CountAccessListMembersResponse {
    /**
     * count is the number of access list members in the access list.
     *
     * @generated from protobuf field: uint32 count = 1;
     */
    count: number;
}
/**
 * ListAccessListMembersRequest is the request for getting paginated access list
 * members.
 *
 * @generated from protobuf message teleport.accesslist.v1.ListAccessListMembersRequest
 */
export interface ListAccessListMembersRequest {
    /**
     * page_size is the size of the page to request.
     *
     * @generated from protobuf field: int32 page_size = 1;
     */
    pageSize: number;
    /**
     * page_token is the page token.
     *
     * @generated from protobuf field: string page_token = 2;
     */
    pageToken: string;
    /**
     * access_list is the name of the access list that the member belongs to.
     *
     * @generated from protobuf field: string access_list = 3;
     */
    accessList: string;
}
/**
 * ListAccessListMembersResponse is the response for getting paginated access
 * list members.
 *
 * @generated from protobuf message teleport.accesslist.v1.ListAccessListMembersResponse
 */
export interface ListAccessListMembersResponse {
    /**
     * members is the list of access list members.
     *
     * @generated from protobuf field: repeated teleport.accesslist.v1.Member members = 1;
     */
    members: Member[];
    /**
     * next_page_token is the next page token.
     *
     * @generated from protobuf field: string next_page_token = 2;
     */
    nextPageToken: string;
}
/**
 * ListAllAccessListMembersRequest is the request for getting paginated access
 * list members for all access lists.
 *
 * @generated from protobuf message teleport.accesslist.v1.ListAllAccessListMembersRequest
 */
export interface ListAllAccessListMembersRequest {
    /**
     * page_size is the size of the page to request.
     *
     * @generated from protobuf field: int32 page_size = 1;
     */
    pageSize: number;
    /**
     * page_token is the page token.
     *
     * @generated from protobuf field: string page_token = 2;
     */
    pageToken: string;
}
/**
 * ListAllAccessListMembersResponse is the response for getting paginated access
 * list members for all access lists.
 *
 * @generated from protobuf message teleport.accesslist.v1.ListAllAccessListMembersResponse
 */
export interface ListAllAccessListMembersResponse {
    /**
     * members is the list of access list members.
     *
     * @generated from protobuf field: repeated teleport.accesslist.v1.Member members = 1;
     */
    members: Member[];
    /**
     * next_page_token is the next page token.
     *
     * @generated from protobuf field: string next_page_token = 2;
     */
    nextPageToken: string;
}
/**
 * UpsertAccessListWithMembers is the request for upserting an access list with
 * members.
 *
 * @generated from protobuf message teleport.accesslist.v1.UpsertAccessListWithMembersRequest
 */
export interface UpsertAccessListWithMembersRequest {
    /**
     * access_list is the access list to upsert.
     *
     * @generated from protobuf field: teleport.accesslist.v1.AccessList access_list = 1;
     */
    accessList?: AccessList;
    /**
     * members is the list of access list members.
     *
     * @generated from protobuf field: repeated teleport.accesslist.v1.Member members = 2;
     */
    members: Member[];
}
/**
 * UpsertAccessListWithMembersResponse is the response for upserting an access
 * list with members.
 *
 * @generated from protobuf message teleport.accesslist.v1.UpsertAccessListWithMembersResponse
 */
export interface UpsertAccessListWithMembersResponse {
    /**
     * access_list is the access list that was upserted.
     *
     * @generated from protobuf field: teleport.accesslist.v1.AccessList access_list = 1;
     */
    accessList?: AccessList;
    /**
     * members is the list of access list members that were upserted.
     *
     * @generated from protobuf field: repeated teleport.accesslist.v1.Member members = 2;
     */
    members: Member[];
}
/**
 * GetAccessListMemberRequest is the request for retrieving an access list
 * member.
 *
 * @generated from protobuf message teleport.accesslist.v1.GetAccessListMemberRequest
 */
export interface GetAccessListMemberRequest {
    /**
     * access_list is the name of the access list that the member belongs to.
     *
     * @generated from protobuf field: string access_list = 1;
     */
    accessList: string;
    /**
     * member_name is the name of the user that belongs to the access list.
     *
     * @generated from protobuf field: string member_name = 2;
     */
    memberName: string;
}
/**
 * UpsertAccessListMemberRequest is the request for upserting an access list
 * member.
 *
 * @generated from protobuf message teleport.accesslist.v1.UpsertAccessListMemberRequest
 */
export interface UpsertAccessListMemberRequest {
    /**
     * member is the access list member to upsert.
     *
     * @generated from protobuf field: teleport.accesslist.v1.Member member = 4;
     */
    member?: Member;
}
/**
 * UpdateAccessListMemberRequest is the request for updating an access list
 * member.
 *
 * @generated from protobuf message teleport.accesslist.v1.UpdateAccessListMemberRequest
 */
export interface UpdateAccessListMemberRequest {
    /**
     * member is the access list member to upsert.
     *
     * @generated from protobuf field: teleport.accesslist.v1.Member member = 1;
     */
    member?: Member;
}
/**
 * DeleteAccessListMemberRequest is the request for deleting a member from an
 * access list.
 *
 * @generated from protobuf message teleport.accesslist.v1.DeleteAccessListMemberRequest
 */
export interface DeleteAccessListMemberRequest {
    /**
     * access_list is the name of access list.
     *
     * @generated from protobuf field: string access_list = 1;
     */
    accessList: string;
    /**
     * member_name is the name of the user to delete.
     *
     * @generated from protobuf field: string member_name = 3;
     */
    memberName: string;
}
/**
 * DeleteAllAccessListMembersForAccessListRequest is the request for deleting
 * all members from an access list.
 *
 * @generated from protobuf message teleport.accesslist.v1.DeleteAllAccessListMembersForAccessListRequest
 */
export interface DeleteAllAccessListMembersForAccessListRequest {
    /**
     * access_list is the name of access list.
     *
     * @generated from protobuf field: string access_list = 1;
     */
    accessList: string;
}
/**
 * DeleteAllAccessListMembersRequest is the request for all access list members
 * in the backend.
 *
 * @generated from protobuf message teleport.accesslist.v1.DeleteAllAccessListMembersRequest
 */
export interface DeleteAllAccessListMembersRequest {
}
/**
 * ListAccessListReviewsRequest is the request for getting paginated access list
 * reviews for a particular access list.
 *
 * @generated from protobuf message teleport.accesslist.v1.ListAccessListReviewsRequest
 */
export interface ListAccessListReviewsRequest {
    /**
     * access_list is the name of the access list that we're listing reviews for.
     *
     * @generated from protobuf field: string access_list = 1;
     */
    accessList: string;
    /**
     * page_size is the size of the page to request.
     *
     * @generated from protobuf field: int32 page_size = 2;
     */
    pageSize: number;
    /**
     * next_token is the page token.
     *
     * @generated from protobuf field: string next_token = 3;
     */
    nextToken: string;
}
/**
 * ListAccessListReviewsResponse is the response for getting paginated access
 * list reviews for a particular access list.
 *
 * @generated from protobuf message teleport.accesslist.v1.ListAccessListReviewsResponse
 */
export interface ListAccessListReviewsResponse {
    /**
     * reviews is the list of access list reviews.
     *
     * @generated from protobuf field: repeated teleport.accesslist.v1.Review reviews = 1;
     */
    reviews: Review[];
    /**
     * next_token is the next page token.
     *
     * @generated from protobuf field: string next_token = 2;
     */
    nextToken: string;
}
/**
 * ListAllAccessListReviewsRequest is the request for getting paginated access
 * list reviews for all access lists.
 *
 * @generated from protobuf message teleport.accesslist.v1.ListAllAccessListReviewsRequest
 */
export interface ListAllAccessListReviewsRequest {
    /**
     * page_size is the size of the page to request.
     *
     * @generated from protobuf field: int32 page_size = 1;
     */
    pageSize: number;
    /**
     * next_token is the page token.
     *
     * @generated from protobuf field: string next_token = 2;
     */
    nextToken: string;
}
/**
 * ListAllAccessListReviewsResponse is the response for getting paginated access
 * list reviews for all access lists.
 *
 * @generated from protobuf message teleport.accesslist.v1.ListAllAccessListReviewsResponse
 */
export interface ListAllAccessListReviewsResponse {
    /**
     * reviews is the list of access list reviews.
     *
     * @generated from protobuf field: repeated teleport.accesslist.v1.Review reviews = 1;
     */
    reviews: Review[];
    /**
     * next_token is the next page token.
     *
     * @generated from protobuf field: string next_token = 2;
     */
    nextToken: string;
}
/**
 * CreateAccessListReviewRequest is the request for creating an access list
 * review.
 *
 * @generated from protobuf message teleport.accesslist.v1.CreateAccessListReviewRequest
 */
export interface CreateAccessListReviewRequest {
    /**
     * review is the actual review to create.
     *
     * @generated from protobuf field: teleport.accesslist.v1.Review review = 1;
     */
    review?: Review;
}
/**
 * CreateAccessListReviewResponse is the response for creating an access list
 * review.
 *
 * @generated from protobuf message teleport.accesslist.v1.CreateAccessListReviewResponse
 */
export interface CreateAccessListReviewResponse {
    /**
     * review_name is the name of the review that was just created.
     *
     * @generated from protobuf field: string review_name = 1;
     */
    reviewName: string;
    /**
     * next_audit_date is when the next audit should be done by.
     *
     * @generated from protobuf field: google.protobuf.Timestamp next_audit_date = 2;
     */
    nextAuditDate?: Timestamp;
}
/**
 * DeleteAccessListReviewRequest is the request for deleting an access list
 * review.
 *
 * @generated from protobuf message teleport.accesslist.v1.DeleteAccessListReviewRequest
 */
export interface DeleteAccessListReviewRequest {
    /**
     * review_name is the name of the review to delete.
     *
     * @generated from protobuf field: string review_name = 1;
     */
    reviewName: string;
    /**
     * access_list_name is the name of the access list to delete the review from.
     *
     * @generated from protobuf field: string access_list_name = 2;
     */
    accessListName: string;
}
/**
 * AccessRequestPromoteRequest is the request for promoting an access request to
 * an access list.
 *
 * @generated from protobuf message teleport.accesslist.v1.AccessRequestPromoteRequest
 */
export interface AccessRequestPromoteRequest {
    /**
     * RequestID is the unique ID of the request to be promoted.
     *
     * @generated from protobuf field: string request_id = 1;
     */
    requestId: string;
    /**
     * AccessListName is the name of the access list to promote the request to.
     *
     * @generated from protobuf field: string access_list_name = 2;
     */
    accessListName: string;
    /**
     * Reason is the access request review reason.
     *
     * @generated from protobuf field: string reason = 3;
     */
    reason: string;
}
/**
 * AccessRequestPromoteResponse is the response for promoting an access request
 * to an access list.
 *
 * @generated from protobuf message teleport.accesslist.v1.AccessRequestPromoteResponse
 */
export interface AccessRequestPromoteResponse {
    /**
     * AccessRequest is the updated access request.
     *
     * @generated from protobuf field: types.AccessRequestV3 access_request = 1;
     */
    accessRequest?: AccessRequestV3;
}
/**
 * GetSuggestedAccessListsRequest is the request for suggested access lists for
 * an access request.
 *
 * @generated from protobuf message teleport.accesslist.v1.GetSuggestedAccessListsRequest
 */
export interface GetSuggestedAccessListsRequest {
    /**
     * access_request_id is the unique ID of the request.
     *
     * @generated from protobuf field: string access_request_id = 1;
     */
    accessRequestId: string;
}
/**
 * GetSuggestedAccessListsResponse is the response for suggested access lists
 * for an access request.
 *
 * @generated from protobuf message teleport.accesslist.v1.GetSuggestedAccessListsResponse
 */
export interface GetSuggestedAccessListsResponse {
    /**
     * access_lists is the list of suggested lists.
     *
     * @generated from protobuf field: repeated teleport.accesslist.v1.AccessList access_lists = 1;
     */
    accessLists: AccessList[];
}
// @generated message type with reflection information, may provide speed optimized methods
class GetAccessListsRequest$Type extends MessageType<GetAccessListsRequest> {
    constructor() {
        super("teleport.accesslist.v1.GetAccessListsRequest", []);
    }
    create(value?: PartialMessage<GetAccessListsRequest>): GetAccessListsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetAccessListsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAccessListsRequest): GetAccessListsRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetAccessListsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.GetAccessListsRequest
 */
export const GetAccessListsRequest = new GetAccessListsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAccessListsResponse$Type extends MessageType<GetAccessListsResponse> {
    constructor() {
        super("teleport.accesslist.v1.GetAccessListsResponse", [
            { no: 1, name: "access_lists", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AccessList }
        ]);
    }
    create(value?: PartialMessage<GetAccessListsResponse>): GetAccessListsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accessLists = [];
        if (value !== undefined)
            reflectionMergePartial<GetAccessListsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAccessListsResponse): GetAccessListsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated teleport.accesslist.v1.AccessList access_lists */ 1:
                    message.accessLists.push(AccessList.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAccessListsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated teleport.accesslist.v1.AccessList access_lists = 1; */
        for (let i = 0; i < message.accessLists.length; i++)
            AccessList.internalBinaryWrite(message.accessLists[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.GetAccessListsResponse
 */
export const GetAccessListsResponse = new GetAccessListsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListAccessListsRequest$Type extends MessageType<ListAccessListsRequest> {
    constructor() {
        super("teleport.accesslist.v1.ListAccessListsRequest", [
            { no: 1, name: "page_size", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "next_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListAccessListsRequest>): ListAccessListsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pageSize = 0;
        message.nextToken = "";
        if (value !== undefined)
            reflectionMergePartial<ListAccessListsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListAccessListsRequest): ListAccessListsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 page_size */ 1:
                    message.pageSize = reader.int32();
                    break;
                case /* string next_token */ 2:
                    message.nextToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListAccessListsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 page_size = 1; */
        if (message.pageSize !== 0)
            writer.tag(1, WireType.Varint).int32(message.pageSize);
        /* string next_token = 2; */
        if (message.nextToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.nextToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.ListAccessListsRequest
 */
export const ListAccessListsRequest = new ListAccessListsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListAccessListsResponse$Type extends MessageType<ListAccessListsResponse> {
    constructor() {
        super("teleport.accesslist.v1.ListAccessListsResponse", [
            { no: 1, name: "access_lists", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AccessList },
            { no: 2, name: "next_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListAccessListsResponse>): ListAccessListsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accessLists = [];
        message.nextToken = "";
        if (value !== undefined)
            reflectionMergePartial<ListAccessListsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListAccessListsResponse): ListAccessListsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated teleport.accesslist.v1.AccessList access_lists */ 1:
                    message.accessLists.push(AccessList.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string next_token */ 2:
                    message.nextToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListAccessListsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated teleport.accesslist.v1.AccessList access_lists = 1; */
        for (let i = 0; i < message.accessLists.length; i++)
            AccessList.internalBinaryWrite(message.accessLists[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string next_token = 2; */
        if (message.nextToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.nextToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.ListAccessListsResponse
 */
export const ListAccessListsResponse = new ListAccessListsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAccessListRequest$Type extends MessageType<GetAccessListRequest> {
    constructor() {
        super("teleport.accesslist.v1.GetAccessListRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetAccessListRequest>): GetAccessListRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<GetAccessListRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAccessListRequest): GetAccessListRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAccessListRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.GetAccessListRequest
 */
export const GetAccessListRequest = new GetAccessListRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpsertAccessListRequest$Type extends MessageType<UpsertAccessListRequest> {
    constructor() {
        super("teleport.accesslist.v1.UpsertAccessListRequest", [
            { no: 1, name: "access_list", kind: "message", T: () => AccessList }
        ]);
    }
    create(value?: PartialMessage<UpsertAccessListRequest>): UpsertAccessListRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpsertAccessListRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpsertAccessListRequest): UpsertAccessListRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.accesslist.v1.AccessList access_list */ 1:
                    message.accessList = AccessList.internalBinaryRead(reader, reader.uint32(), options, message.accessList);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpsertAccessListRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.accesslist.v1.AccessList access_list = 1; */
        if (message.accessList)
            AccessList.internalBinaryWrite(message.accessList, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.UpsertAccessListRequest
 */
export const UpsertAccessListRequest = new UpsertAccessListRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateAccessListRequest$Type extends MessageType<UpdateAccessListRequest> {
    constructor() {
        super("teleport.accesslist.v1.UpdateAccessListRequest", [
            { no: 1, name: "access_list", kind: "message", T: () => AccessList }
        ]);
    }
    create(value?: PartialMessage<UpdateAccessListRequest>): UpdateAccessListRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdateAccessListRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateAccessListRequest): UpdateAccessListRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.accesslist.v1.AccessList access_list */ 1:
                    message.accessList = AccessList.internalBinaryRead(reader, reader.uint32(), options, message.accessList);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateAccessListRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.accesslist.v1.AccessList access_list = 1; */
        if (message.accessList)
            AccessList.internalBinaryWrite(message.accessList, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.UpdateAccessListRequest
 */
export const UpdateAccessListRequest = new UpdateAccessListRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteAccessListRequest$Type extends MessageType<DeleteAccessListRequest> {
    constructor() {
        super("teleport.accesslist.v1.DeleteAccessListRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteAccessListRequest>): DeleteAccessListRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteAccessListRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteAccessListRequest): DeleteAccessListRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteAccessListRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.DeleteAccessListRequest
 */
export const DeleteAccessListRequest = new DeleteAccessListRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteAllAccessListsRequest$Type extends MessageType<DeleteAllAccessListsRequest> {
    constructor() {
        super("teleport.accesslist.v1.DeleteAllAccessListsRequest", []);
    }
    create(value?: PartialMessage<DeleteAllAccessListsRequest>): DeleteAllAccessListsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeleteAllAccessListsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteAllAccessListsRequest): DeleteAllAccessListsRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DeleteAllAccessListsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.DeleteAllAccessListsRequest
 */
export const DeleteAllAccessListsRequest = new DeleteAllAccessListsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAccessListsToReviewRequest$Type extends MessageType<GetAccessListsToReviewRequest> {
    constructor() {
        super("teleport.accesslist.v1.GetAccessListsToReviewRequest", []);
    }
    create(value?: PartialMessage<GetAccessListsToReviewRequest>): GetAccessListsToReviewRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetAccessListsToReviewRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAccessListsToReviewRequest): GetAccessListsToReviewRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetAccessListsToReviewRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.GetAccessListsToReviewRequest
 */
export const GetAccessListsToReviewRequest = new GetAccessListsToReviewRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAccessListsToReviewResponse$Type extends MessageType<GetAccessListsToReviewResponse> {
    constructor() {
        super("teleport.accesslist.v1.GetAccessListsToReviewResponse", [
            { no: 1, name: "access_lists", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AccessList }
        ]);
    }
    create(value?: PartialMessage<GetAccessListsToReviewResponse>): GetAccessListsToReviewResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accessLists = [];
        if (value !== undefined)
            reflectionMergePartial<GetAccessListsToReviewResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAccessListsToReviewResponse): GetAccessListsToReviewResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated teleport.accesslist.v1.AccessList access_lists */ 1:
                    message.accessLists.push(AccessList.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAccessListsToReviewResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated teleport.accesslist.v1.AccessList access_lists = 1; */
        for (let i = 0; i < message.accessLists.length; i++)
            AccessList.internalBinaryWrite(message.accessLists[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.GetAccessListsToReviewResponse
 */
export const GetAccessListsToReviewResponse = new GetAccessListsToReviewResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CountAccessListMembersRequest$Type extends MessageType<CountAccessListMembersRequest> {
    constructor() {
        super("teleport.accesslist.v1.CountAccessListMembersRequest", [
            { no: 1, name: "access_list_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CountAccessListMembersRequest>): CountAccessListMembersRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accessListName = "";
        if (value !== undefined)
            reflectionMergePartial<CountAccessListMembersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CountAccessListMembersRequest): CountAccessListMembersRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string access_list_name */ 1:
                    message.accessListName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CountAccessListMembersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string access_list_name = 1; */
        if (message.accessListName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accessListName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.CountAccessListMembersRequest
 */
export const CountAccessListMembersRequest = new CountAccessListMembersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CountAccessListMembersResponse$Type extends MessageType<CountAccessListMembersResponse> {
    constructor() {
        super("teleport.accesslist.v1.CountAccessListMembersResponse", [
            { no: 1, name: "count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CountAccessListMembersResponse>): CountAccessListMembersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.count = 0;
        if (value !== undefined)
            reflectionMergePartial<CountAccessListMembersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CountAccessListMembersResponse): CountAccessListMembersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 count */ 1:
                    message.count = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CountAccessListMembersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 count = 1; */
        if (message.count !== 0)
            writer.tag(1, WireType.Varint).uint32(message.count);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.CountAccessListMembersResponse
 */
export const CountAccessListMembersResponse = new CountAccessListMembersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListAccessListMembersRequest$Type extends MessageType<ListAccessListMembersRequest> {
    constructor() {
        super("teleport.accesslist.v1.ListAccessListMembersRequest", [
            { no: 1, name: "page_size", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "access_list", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListAccessListMembersRequest>): ListAccessListMembersRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pageSize = 0;
        message.pageToken = "";
        message.accessList = "";
        if (value !== undefined)
            reflectionMergePartial<ListAccessListMembersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListAccessListMembersRequest): ListAccessListMembersRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 page_size */ 1:
                    message.pageSize = reader.int32();
                    break;
                case /* string page_token */ 2:
                    message.pageToken = reader.string();
                    break;
                case /* string access_list */ 3:
                    message.accessList = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListAccessListMembersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 page_size = 1; */
        if (message.pageSize !== 0)
            writer.tag(1, WireType.Varint).int32(message.pageSize);
        /* string page_token = 2; */
        if (message.pageToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.pageToken);
        /* string access_list = 3; */
        if (message.accessList !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.accessList);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.ListAccessListMembersRequest
 */
export const ListAccessListMembersRequest = new ListAccessListMembersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListAccessListMembersResponse$Type extends MessageType<ListAccessListMembersResponse> {
    constructor() {
        super("teleport.accesslist.v1.ListAccessListMembersResponse", [
            { no: 1, name: "members", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Member },
            { no: 2, name: "next_page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListAccessListMembersResponse>): ListAccessListMembersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.members = [];
        message.nextPageToken = "";
        if (value !== undefined)
            reflectionMergePartial<ListAccessListMembersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListAccessListMembersResponse): ListAccessListMembersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated teleport.accesslist.v1.Member members */ 1:
                    message.members.push(Member.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string next_page_token */ 2:
                    message.nextPageToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListAccessListMembersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated teleport.accesslist.v1.Member members = 1; */
        for (let i = 0; i < message.members.length; i++)
            Member.internalBinaryWrite(message.members[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string next_page_token = 2; */
        if (message.nextPageToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.nextPageToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.ListAccessListMembersResponse
 */
export const ListAccessListMembersResponse = new ListAccessListMembersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListAllAccessListMembersRequest$Type extends MessageType<ListAllAccessListMembersRequest> {
    constructor() {
        super("teleport.accesslist.v1.ListAllAccessListMembersRequest", [
            { no: 1, name: "page_size", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListAllAccessListMembersRequest>): ListAllAccessListMembersRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pageSize = 0;
        message.pageToken = "";
        if (value !== undefined)
            reflectionMergePartial<ListAllAccessListMembersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListAllAccessListMembersRequest): ListAllAccessListMembersRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 page_size */ 1:
                    message.pageSize = reader.int32();
                    break;
                case /* string page_token */ 2:
                    message.pageToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListAllAccessListMembersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 page_size = 1; */
        if (message.pageSize !== 0)
            writer.tag(1, WireType.Varint).int32(message.pageSize);
        /* string page_token = 2; */
        if (message.pageToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.pageToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.ListAllAccessListMembersRequest
 */
export const ListAllAccessListMembersRequest = new ListAllAccessListMembersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListAllAccessListMembersResponse$Type extends MessageType<ListAllAccessListMembersResponse> {
    constructor() {
        super("teleport.accesslist.v1.ListAllAccessListMembersResponse", [
            { no: 1, name: "members", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Member },
            { no: 2, name: "next_page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListAllAccessListMembersResponse>): ListAllAccessListMembersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.members = [];
        message.nextPageToken = "";
        if (value !== undefined)
            reflectionMergePartial<ListAllAccessListMembersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListAllAccessListMembersResponse): ListAllAccessListMembersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated teleport.accesslist.v1.Member members */ 1:
                    message.members.push(Member.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string next_page_token */ 2:
                    message.nextPageToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListAllAccessListMembersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated teleport.accesslist.v1.Member members = 1; */
        for (let i = 0; i < message.members.length; i++)
            Member.internalBinaryWrite(message.members[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string next_page_token = 2; */
        if (message.nextPageToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.nextPageToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.ListAllAccessListMembersResponse
 */
export const ListAllAccessListMembersResponse = new ListAllAccessListMembersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpsertAccessListWithMembersRequest$Type extends MessageType<UpsertAccessListWithMembersRequest> {
    constructor() {
        super("teleport.accesslist.v1.UpsertAccessListWithMembersRequest", [
            { no: 1, name: "access_list", kind: "message", T: () => AccessList },
            { no: 2, name: "members", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Member }
        ]);
    }
    create(value?: PartialMessage<UpsertAccessListWithMembersRequest>): UpsertAccessListWithMembersRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.members = [];
        if (value !== undefined)
            reflectionMergePartial<UpsertAccessListWithMembersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpsertAccessListWithMembersRequest): UpsertAccessListWithMembersRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.accesslist.v1.AccessList access_list */ 1:
                    message.accessList = AccessList.internalBinaryRead(reader, reader.uint32(), options, message.accessList);
                    break;
                case /* repeated teleport.accesslist.v1.Member members */ 2:
                    message.members.push(Member.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpsertAccessListWithMembersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.accesslist.v1.AccessList access_list = 1; */
        if (message.accessList)
            AccessList.internalBinaryWrite(message.accessList, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated teleport.accesslist.v1.Member members = 2; */
        for (let i = 0; i < message.members.length; i++)
            Member.internalBinaryWrite(message.members[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.UpsertAccessListWithMembersRequest
 */
export const UpsertAccessListWithMembersRequest = new UpsertAccessListWithMembersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpsertAccessListWithMembersResponse$Type extends MessageType<UpsertAccessListWithMembersResponse> {
    constructor() {
        super("teleport.accesslist.v1.UpsertAccessListWithMembersResponse", [
            { no: 1, name: "access_list", kind: "message", T: () => AccessList },
            { no: 2, name: "members", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Member }
        ]);
    }
    create(value?: PartialMessage<UpsertAccessListWithMembersResponse>): UpsertAccessListWithMembersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.members = [];
        if (value !== undefined)
            reflectionMergePartial<UpsertAccessListWithMembersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpsertAccessListWithMembersResponse): UpsertAccessListWithMembersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.accesslist.v1.AccessList access_list */ 1:
                    message.accessList = AccessList.internalBinaryRead(reader, reader.uint32(), options, message.accessList);
                    break;
                case /* repeated teleport.accesslist.v1.Member members */ 2:
                    message.members.push(Member.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpsertAccessListWithMembersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.accesslist.v1.AccessList access_list = 1; */
        if (message.accessList)
            AccessList.internalBinaryWrite(message.accessList, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated teleport.accesslist.v1.Member members = 2; */
        for (let i = 0; i < message.members.length; i++)
            Member.internalBinaryWrite(message.members[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.UpsertAccessListWithMembersResponse
 */
export const UpsertAccessListWithMembersResponse = new UpsertAccessListWithMembersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAccessListMemberRequest$Type extends MessageType<GetAccessListMemberRequest> {
    constructor() {
        super("teleport.accesslist.v1.GetAccessListMemberRequest", [
            { no: 1, name: "access_list", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "member_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetAccessListMemberRequest>): GetAccessListMemberRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accessList = "";
        message.memberName = "";
        if (value !== undefined)
            reflectionMergePartial<GetAccessListMemberRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAccessListMemberRequest): GetAccessListMemberRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string access_list */ 1:
                    message.accessList = reader.string();
                    break;
                case /* string member_name */ 2:
                    message.memberName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAccessListMemberRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string access_list = 1; */
        if (message.accessList !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accessList);
        /* string member_name = 2; */
        if (message.memberName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.memberName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.GetAccessListMemberRequest
 */
export const GetAccessListMemberRequest = new GetAccessListMemberRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpsertAccessListMemberRequest$Type extends MessageType<UpsertAccessListMemberRequest> {
    constructor() {
        super("teleport.accesslist.v1.UpsertAccessListMemberRequest", [
            { no: 4, name: "member", kind: "message", T: () => Member }
        ]);
    }
    create(value?: PartialMessage<UpsertAccessListMemberRequest>): UpsertAccessListMemberRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpsertAccessListMemberRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpsertAccessListMemberRequest): UpsertAccessListMemberRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.accesslist.v1.Member member */ 4:
                    message.member = Member.internalBinaryRead(reader, reader.uint32(), options, message.member);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpsertAccessListMemberRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.accesslist.v1.Member member = 4; */
        if (message.member)
            Member.internalBinaryWrite(message.member, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.UpsertAccessListMemberRequest
 */
export const UpsertAccessListMemberRequest = new UpsertAccessListMemberRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateAccessListMemberRequest$Type extends MessageType<UpdateAccessListMemberRequest> {
    constructor() {
        super("teleport.accesslist.v1.UpdateAccessListMemberRequest", [
            { no: 1, name: "member", kind: "message", T: () => Member }
        ]);
    }
    create(value?: PartialMessage<UpdateAccessListMemberRequest>): UpdateAccessListMemberRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdateAccessListMemberRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateAccessListMemberRequest): UpdateAccessListMemberRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.accesslist.v1.Member member */ 1:
                    message.member = Member.internalBinaryRead(reader, reader.uint32(), options, message.member);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateAccessListMemberRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.accesslist.v1.Member member = 1; */
        if (message.member)
            Member.internalBinaryWrite(message.member, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.UpdateAccessListMemberRequest
 */
export const UpdateAccessListMemberRequest = new UpdateAccessListMemberRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteAccessListMemberRequest$Type extends MessageType<DeleteAccessListMemberRequest> {
    constructor() {
        super("teleport.accesslist.v1.DeleteAccessListMemberRequest", [
            { no: 1, name: "access_list", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "member_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteAccessListMemberRequest>): DeleteAccessListMemberRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accessList = "";
        message.memberName = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteAccessListMemberRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteAccessListMemberRequest): DeleteAccessListMemberRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string access_list */ 1:
                    message.accessList = reader.string();
                    break;
                case /* string member_name */ 3:
                    message.memberName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteAccessListMemberRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string access_list = 1; */
        if (message.accessList !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accessList);
        /* string member_name = 3; */
        if (message.memberName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.memberName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.DeleteAccessListMemberRequest
 */
export const DeleteAccessListMemberRequest = new DeleteAccessListMemberRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteAllAccessListMembersForAccessListRequest$Type extends MessageType<DeleteAllAccessListMembersForAccessListRequest> {
    constructor() {
        super("teleport.accesslist.v1.DeleteAllAccessListMembersForAccessListRequest", [
            { no: 1, name: "access_list", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteAllAccessListMembersForAccessListRequest>): DeleteAllAccessListMembersForAccessListRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accessList = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteAllAccessListMembersForAccessListRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteAllAccessListMembersForAccessListRequest): DeleteAllAccessListMembersForAccessListRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string access_list */ 1:
                    message.accessList = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteAllAccessListMembersForAccessListRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string access_list = 1; */
        if (message.accessList !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accessList);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.DeleteAllAccessListMembersForAccessListRequest
 */
export const DeleteAllAccessListMembersForAccessListRequest = new DeleteAllAccessListMembersForAccessListRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteAllAccessListMembersRequest$Type extends MessageType<DeleteAllAccessListMembersRequest> {
    constructor() {
        super("teleport.accesslist.v1.DeleteAllAccessListMembersRequest", []);
    }
    create(value?: PartialMessage<DeleteAllAccessListMembersRequest>): DeleteAllAccessListMembersRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeleteAllAccessListMembersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteAllAccessListMembersRequest): DeleteAllAccessListMembersRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DeleteAllAccessListMembersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.DeleteAllAccessListMembersRequest
 */
export const DeleteAllAccessListMembersRequest = new DeleteAllAccessListMembersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListAccessListReviewsRequest$Type extends MessageType<ListAccessListReviewsRequest> {
    constructor() {
        super("teleport.accesslist.v1.ListAccessListReviewsRequest", [
            { no: 1, name: "access_list", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "page_size", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "next_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListAccessListReviewsRequest>): ListAccessListReviewsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accessList = "";
        message.pageSize = 0;
        message.nextToken = "";
        if (value !== undefined)
            reflectionMergePartial<ListAccessListReviewsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListAccessListReviewsRequest): ListAccessListReviewsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string access_list */ 1:
                    message.accessList = reader.string();
                    break;
                case /* int32 page_size */ 2:
                    message.pageSize = reader.int32();
                    break;
                case /* string next_token */ 3:
                    message.nextToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListAccessListReviewsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string access_list = 1; */
        if (message.accessList !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accessList);
        /* int32 page_size = 2; */
        if (message.pageSize !== 0)
            writer.tag(2, WireType.Varint).int32(message.pageSize);
        /* string next_token = 3; */
        if (message.nextToken !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.nextToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.ListAccessListReviewsRequest
 */
export const ListAccessListReviewsRequest = new ListAccessListReviewsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListAccessListReviewsResponse$Type extends MessageType<ListAccessListReviewsResponse> {
    constructor() {
        super("teleport.accesslist.v1.ListAccessListReviewsResponse", [
            { no: 1, name: "reviews", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Review },
            { no: 2, name: "next_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListAccessListReviewsResponse>): ListAccessListReviewsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.reviews = [];
        message.nextToken = "";
        if (value !== undefined)
            reflectionMergePartial<ListAccessListReviewsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListAccessListReviewsResponse): ListAccessListReviewsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated teleport.accesslist.v1.Review reviews */ 1:
                    message.reviews.push(Review.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string next_token */ 2:
                    message.nextToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListAccessListReviewsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated teleport.accesslist.v1.Review reviews = 1; */
        for (let i = 0; i < message.reviews.length; i++)
            Review.internalBinaryWrite(message.reviews[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string next_token = 2; */
        if (message.nextToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.nextToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.ListAccessListReviewsResponse
 */
export const ListAccessListReviewsResponse = new ListAccessListReviewsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListAllAccessListReviewsRequest$Type extends MessageType<ListAllAccessListReviewsRequest> {
    constructor() {
        super("teleport.accesslist.v1.ListAllAccessListReviewsRequest", [
            { no: 1, name: "page_size", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "next_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListAllAccessListReviewsRequest>): ListAllAccessListReviewsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pageSize = 0;
        message.nextToken = "";
        if (value !== undefined)
            reflectionMergePartial<ListAllAccessListReviewsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListAllAccessListReviewsRequest): ListAllAccessListReviewsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 page_size */ 1:
                    message.pageSize = reader.int32();
                    break;
                case /* string next_token */ 2:
                    message.nextToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListAllAccessListReviewsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 page_size = 1; */
        if (message.pageSize !== 0)
            writer.tag(1, WireType.Varint).int32(message.pageSize);
        /* string next_token = 2; */
        if (message.nextToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.nextToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.ListAllAccessListReviewsRequest
 */
export const ListAllAccessListReviewsRequest = new ListAllAccessListReviewsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListAllAccessListReviewsResponse$Type extends MessageType<ListAllAccessListReviewsResponse> {
    constructor() {
        super("teleport.accesslist.v1.ListAllAccessListReviewsResponse", [
            { no: 1, name: "reviews", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Review },
            { no: 2, name: "next_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListAllAccessListReviewsResponse>): ListAllAccessListReviewsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.reviews = [];
        message.nextToken = "";
        if (value !== undefined)
            reflectionMergePartial<ListAllAccessListReviewsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListAllAccessListReviewsResponse): ListAllAccessListReviewsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated teleport.accesslist.v1.Review reviews */ 1:
                    message.reviews.push(Review.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string next_token */ 2:
                    message.nextToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListAllAccessListReviewsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated teleport.accesslist.v1.Review reviews = 1; */
        for (let i = 0; i < message.reviews.length; i++)
            Review.internalBinaryWrite(message.reviews[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string next_token = 2; */
        if (message.nextToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.nextToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.ListAllAccessListReviewsResponse
 */
export const ListAllAccessListReviewsResponse = new ListAllAccessListReviewsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateAccessListReviewRequest$Type extends MessageType<CreateAccessListReviewRequest> {
    constructor() {
        super("teleport.accesslist.v1.CreateAccessListReviewRequest", [
            { no: 1, name: "review", kind: "message", T: () => Review }
        ]);
    }
    create(value?: PartialMessage<CreateAccessListReviewRequest>): CreateAccessListReviewRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CreateAccessListReviewRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateAccessListReviewRequest): CreateAccessListReviewRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.accesslist.v1.Review review */ 1:
                    message.review = Review.internalBinaryRead(reader, reader.uint32(), options, message.review);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateAccessListReviewRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.accesslist.v1.Review review = 1; */
        if (message.review)
            Review.internalBinaryWrite(message.review, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.CreateAccessListReviewRequest
 */
export const CreateAccessListReviewRequest = new CreateAccessListReviewRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateAccessListReviewResponse$Type extends MessageType<CreateAccessListReviewResponse> {
    constructor() {
        super("teleport.accesslist.v1.CreateAccessListReviewResponse", [
            { no: 1, name: "review_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "next_audit_date", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<CreateAccessListReviewResponse>): CreateAccessListReviewResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.reviewName = "";
        if (value !== undefined)
            reflectionMergePartial<CreateAccessListReviewResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateAccessListReviewResponse): CreateAccessListReviewResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string review_name */ 1:
                    message.reviewName = reader.string();
                    break;
                case /* google.protobuf.Timestamp next_audit_date */ 2:
                    message.nextAuditDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.nextAuditDate);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateAccessListReviewResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string review_name = 1; */
        if (message.reviewName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reviewName);
        /* google.protobuf.Timestamp next_audit_date = 2; */
        if (message.nextAuditDate)
            Timestamp.internalBinaryWrite(message.nextAuditDate, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.CreateAccessListReviewResponse
 */
export const CreateAccessListReviewResponse = new CreateAccessListReviewResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteAccessListReviewRequest$Type extends MessageType<DeleteAccessListReviewRequest> {
    constructor() {
        super("teleport.accesslist.v1.DeleteAccessListReviewRequest", [
            { no: 1, name: "review_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "access_list_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteAccessListReviewRequest>): DeleteAccessListReviewRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.reviewName = "";
        message.accessListName = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteAccessListReviewRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteAccessListReviewRequest): DeleteAccessListReviewRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string review_name */ 1:
                    message.reviewName = reader.string();
                    break;
                case /* string access_list_name */ 2:
                    message.accessListName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteAccessListReviewRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string review_name = 1; */
        if (message.reviewName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reviewName);
        /* string access_list_name = 2; */
        if (message.accessListName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.accessListName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.DeleteAccessListReviewRequest
 */
export const DeleteAccessListReviewRequest = new DeleteAccessListReviewRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessRequestPromoteRequest$Type extends MessageType<AccessRequestPromoteRequest> {
    constructor() {
        super("teleport.accesslist.v1.AccessRequestPromoteRequest", [
            { no: 1, name: "request_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "access_list_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AccessRequestPromoteRequest>): AccessRequestPromoteRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.requestId = "";
        message.accessListName = "";
        message.reason = "";
        if (value !== undefined)
            reflectionMergePartial<AccessRequestPromoteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessRequestPromoteRequest): AccessRequestPromoteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string request_id */ 1:
                    message.requestId = reader.string();
                    break;
                case /* string access_list_name */ 2:
                    message.accessListName = reader.string();
                    break;
                case /* string reason */ 3:
                    message.reason = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessRequestPromoteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string request_id = 1; */
        if (message.requestId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.requestId);
        /* string access_list_name = 2; */
        if (message.accessListName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.accessListName);
        /* string reason = 3; */
        if (message.reason !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.reason);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.AccessRequestPromoteRequest
 */
export const AccessRequestPromoteRequest = new AccessRequestPromoteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessRequestPromoteResponse$Type extends MessageType<AccessRequestPromoteResponse> {
    constructor() {
        super("teleport.accesslist.v1.AccessRequestPromoteResponse", [
            { no: 1, name: "access_request", kind: "message", T: () => AccessRequestV3 }
        ]);
    }
    create(value?: PartialMessage<AccessRequestPromoteResponse>): AccessRequestPromoteResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AccessRequestPromoteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessRequestPromoteResponse): AccessRequestPromoteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.AccessRequestV3 access_request */ 1:
                    message.accessRequest = AccessRequestV3.internalBinaryRead(reader, reader.uint32(), options, message.accessRequest);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessRequestPromoteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.AccessRequestV3 access_request = 1; */
        if (message.accessRequest)
            AccessRequestV3.internalBinaryWrite(message.accessRequest, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.AccessRequestPromoteResponse
 */
export const AccessRequestPromoteResponse = new AccessRequestPromoteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSuggestedAccessListsRequest$Type extends MessageType<GetSuggestedAccessListsRequest> {
    constructor() {
        super("teleport.accesslist.v1.GetSuggestedAccessListsRequest", [
            { no: 1, name: "access_request_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetSuggestedAccessListsRequest>): GetSuggestedAccessListsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accessRequestId = "";
        if (value !== undefined)
            reflectionMergePartial<GetSuggestedAccessListsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSuggestedAccessListsRequest): GetSuggestedAccessListsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string access_request_id */ 1:
                    message.accessRequestId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSuggestedAccessListsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string access_request_id = 1; */
        if (message.accessRequestId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accessRequestId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.GetSuggestedAccessListsRequest
 */
export const GetSuggestedAccessListsRequest = new GetSuggestedAccessListsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSuggestedAccessListsResponse$Type extends MessageType<GetSuggestedAccessListsResponse> {
    constructor() {
        super("teleport.accesslist.v1.GetSuggestedAccessListsResponse", [
            { no: 1, name: "access_lists", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AccessList }
        ]);
    }
    create(value?: PartialMessage<GetSuggestedAccessListsResponse>): GetSuggestedAccessListsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accessLists = [];
        if (value !== undefined)
            reflectionMergePartial<GetSuggestedAccessListsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSuggestedAccessListsResponse): GetSuggestedAccessListsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated teleport.accesslist.v1.AccessList access_lists */ 1:
                    message.accessLists.push(AccessList.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSuggestedAccessListsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated teleport.accesslist.v1.AccessList access_lists = 1; */
        for (let i = 0; i < message.accessLists.length; i++)
            AccessList.internalBinaryWrite(message.accessLists[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.accesslist.v1.GetSuggestedAccessListsResponse
 */
export const GetSuggestedAccessListsResponse = new GetSuggestedAccessListsResponse$Type();
/**
 * @generated ServiceType for protobuf service teleport.accesslist.v1.AccessListService
 */
export const AccessListService = new ServiceType("teleport.accesslist.v1.AccessListService", [
    { name: "GetAccessLists", options: {}, I: GetAccessListsRequest, O: GetAccessListsResponse },
    { name: "ListAccessLists", options: {}, I: ListAccessListsRequest, O: ListAccessListsResponse },
    { name: "GetAccessList", options: {}, I: GetAccessListRequest, O: AccessList },
    { name: "UpsertAccessList", options: {}, I: UpsertAccessListRequest, O: AccessList },
    { name: "UpdateAccessList", options: {}, I: UpdateAccessListRequest, O: AccessList },
    { name: "DeleteAccessList", options: {}, I: DeleteAccessListRequest, O: Empty },
    { name: "DeleteAllAccessLists", options: {}, I: DeleteAllAccessListsRequest, O: Empty },
    { name: "GetAccessListsToReview", options: {}, I: GetAccessListsToReviewRequest, O: GetAccessListsToReviewResponse },
    { name: "CountAccessListMembers", options: {}, I: CountAccessListMembersRequest, O: CountAccessListMembersResponse },
    { name: "ListAccessListMembers", options: {}, I: ListAccessListMembersRequest, O: ListAccessListMembersResponse },
    { name: "ListAllAccessListMembers", options: {}, I: ListAllAccessListMembersRequest, O: ListAllAccessListMembersResponse },
    { name: "GetAccessListMember", options: {}, I: GetAccessListMemberRequest, O: Member },
    { name: "UpsertAccessListMember", options: {}, I: UpsertAccessListMemberRequest, O: Member },
    { name: "UpdateAccessListMember", options: {}, I: UpdateAccessListMemberRequest, O: Member },
    { name: "DeleteAccessListMember", options: {}, I: DeleteAccessListMemberRequest, O: Empty },
    { name: "DeleteAllAccessListMembersForAccessList", options: {}, I: DeleteAllAccessListMembersForAccessListRequest, O: Empty },
    { name: "DeleteAllAccessListMembers", options: {}, I: DeleteAllAccessListMembersRequest, O: Empty },
    { name: "UpsertAccessListWithMembers", options: {}, I: UpsertAccessListWithMembersRequest, O: UpsertAccessListWithMembersResponse },
    { name: "ListAccessListReviews", options: {}, I: ListAccessListReviewsRequest, O: ListAccessListReviewsResponse },
    { name: "ListAllAccessListReviews", options: {}, I: ListAllAccessListReviewsRequest, O: ListAllAccessListReviewsResponse },
    { name: "CreateAccessListReview", options: {}, I: CreateAccessListReviewRequest, O: CreateAccessListReviewResponse },
    { name: "DeleteAccessListReview", options: {}, I: DeleteAccessListReviewRequest, O: Empty },
    { name: "AccessRequestPromote", options: {}, I: AccessRequestPromoteRequest, O: AccessRequestPromoteResponse },
    { name: "GetSuggestedAccessLists", options: {}, I: GetSuggestedAccessListsRequest, O: GetSuggestedAccessListsResponse }
]);
