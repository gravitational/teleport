/* eslint-disable */
// @generated by protobuf-ts 2.9.3 with parameter eslint_disable,add_pb_suffix,server_grpc1,ts_nocheck
// @generated from protobuf file "teleport/lib/vnet/diag/v1/diag.proto" (package "teleport.lib.vnet.diag.v1", syntax proto3)
// tslint:disable
// @ts-nocheck
//
// Teleport
// Copyright (C) 2025 Gravitational, Inc.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "../../../../../google/protobuf/timestamp_pb";
/**
 * Report represents the attempts at running individual checks. It also includes general information
 * about the network stack managed by VNet. It assumes that each individual check as well as getting
 * info about the network stack can fail.
 *
 * @generated from protobuf message teleport.lib.vnet.diag.v1.Report
 */
export interface Report {
    /**
     * created_at is the UTC timestamp at which the report was generated.
     *
     * @generated from protobuf field: google.protobuf.Timestamp created_at = 1;
     */
    createdAt?: Timestamp;
    /**
     * @generated from protobuf field: teleport.lib.vnet.diag.v1.NetworkStackAttempt network_stack_attempt = 2;
     */
    networkStackAttempt?: NetworkStackAttempt;
    /**
     * @generated from protobuf field: repeated teleport.lib.vnet.diag.v1.CheckAttempt checks = 3;
     */
    checks: CheckAttempt[];
}
/**
 * NetworkStackAttempt represents the attempt at getting information about the network stack managed
 * by VNet.
 *
 * @generated from protobuf message teleport.lib.vnet.diag.v1.NetworkStackAttempt
 */
export interface NetworkStackAttempt {
    /**
     * @generated from protobuf field: teleport.lib.vnet.diag.v1.CheckAttemptStatus status = 1;
     */
    status: CheckAttemptStatus;
    /**
     * error is present if status is CHECK_ATTEMPT_STATUS_ERROR.
     *
     * @generated from protobuf field: string error = 2;
     */
    error: string;
    /**
     * @generated from protobuf field: teleport.lib.vnet.diag.v1.NetworkStack network_stack = 3;
     */
    networkStack?: NetworkStack;
}
/**
 * NetworkStack describes the network stack managed by VNet.
 *
 * @generated from protobuf message teleport.lib.vnet.diag.v1.NetworkStack
 */
export interface NetworkStack {
    /**
     * interface_name is the name of the interface set up and used by VNet.
     *
     * @generated from protobuf field: string interface_name = 1;
     */
    interfaceName: string;
    /**
     * ipv4_cidr_ranges are all the possible ranges under which VNet is going to assign IPv4 addresses
     * for apps. The first IP of the first range is used for the TUN device.
     * Each root cluster can specify its own CIDR range to be used for apps within that profile.
     *
     * @generated from protobuf field: repeated string ipv4_cidr_ranges = 2;
     */
    ipv4CidrRanges: string[];
    /**
     * ipv6_prefix is the IPv6 prefix under which VNet creates IPv6 addresses for apps and its DNS
     * server.
     *
     * @generated from protobuf field: string ipv6_prefix = 3;
     */
    ipv6Prefix: string;
    /**
     * dns_zones lists domains for which DNS queries are supposed to be captured by VNet.
     *
     * @generated from protobuf field: repeated string dns_zones = 4;
     */
    dnsZones: string[];
}
/**
 * CheckAttempt describes the attempt at running a particular diagnostic check. If it succeeds
 * (status is CHECK_ATTEMPT_STATUS_OK), check_report can be inspected to see if the check has found
 * any issues.
 *
 * For example, a check that inspects network routes can succeed (CHECK_ATTEMPT_STATUS_OK) and it
 * might or might not find conflicting routes (CHECK_REPORT_STATUS_ISSUES_FOUND or
 * CHECK_REPORT_STATUS_OK). But it can also fail to run (CHECK_ATTEMPT_STATUS_ERROR) because the
 * syscall to list routes has failed.
 *
 * @generated from protobuf message teleport.lib.vnet.diag.v1.CheckAttempt
 */
export interface CheckAttempt {
    /**
     * status represents the status of an attempt at running a particular diagnostic check. This is
     * not the same as the status of CheckReport.
     *
     *
     * @generated from protobuf field: teleport.lib.vnet.diag.v1.CheckAttemptStatus status = 1;
     */
    status: CheckAttemptStatus;
    /**
     * error is present if the check failed to run (status is CHECK_ATTEMPT_STATUS_ERROR).
     *
     * @generated from protobuf field: string error = 2;
     */
    error: string;
    /**
     * check_report is the output of a particular check.
     *
     * If check failed to run (status is CHECK_ATTEMPT_STATUS_ERROR), the report oneof in check_report
     * is set to a specific member while the member itself is empty. This means that a particular
     * CheckAttempt can be distinguished from other attempts describing other checks even if the check
     * failed to run.
     *
     * @generated from protobuf field: teleport.lib.vnet.diag.v1.CheckReport check_report = 3;
     */
    checkReport?: CheckReport;
    /**
     * commands are the outputs from additional diagnostic commands executed by the diagnostic
     * check. They are meant to help inspect the general state of the OS related to the given check.
     * Unless a callsite specifically requests commands to be skipped, commands are present even if
     * status is CHECK_ATTEMPT_STATUS_ERROR, as they are useful even if the check failed.
     *
     * @generated from protobuf field: repeated teleport.lib.vnet.diag.v1.CommandAttempt commands = 4;
     */
    commands: CommandAttempt[];
}
/**
 * CheckReport is the output of a successful attempt at running a particular check.
 *
 * @generated from protobuf message teleport.lib.vnet.diag.v1.CheckReport
 */
export interface CheckReport {
    /**
     * status indicates if the check has found any issues. This is so that a callsite operating on
     * a CheckReport can understand the outcome of the check without having to understand the
     * semantics of the output included under report.
     *
     * @generated from protobuf field: teleport.lib.vnet.diag.v1.CheckReportStatus status = 1;
     */
    status: CheckReportStatus;
    /**
     * @generated from protobuf oneof: report
     */
    report: {
        oneofKind: "routeConflictReport";
        /**
         * route_conflict reports whether there are routes that might conflict with routes set up by
         * VNet.
         *
         * @generated from protobuf field: teleport.lib.vnet.diag.v1.RouteConflictReport route_conflict_report = 2;
         */
        routeConflictReport: RouteConflictReport;
    } | {
        oneofKind: "sshConfigurationReport";
        /**
         * ssh_configuration_report reports the status of the system's SSH configuration.
         *
         * @generated from protobuf field: teleport.lib.vnet.diag.v1.SSHConfigurationReport ssh_configuration_report = 3;
         */
        sshConfigurationReport: SSHConfigurationReport;
    } | {
        oneofKind: undefined;
    };
}
/**
 * CommandAttempt describes the attempt at running a particular command associated with a diagnostic
 * check.
 *
 * @generated from protobuf message teleport.lib.vnet.diag.v1.CommandAttempt
 */
export interface CommandAttempt {
    /**
     * @generated from protobuf field: teleport.lib.vnet.diag.v1.CommandAttemptStatus status = 1;
     */
    status: CommandAttemptStatus;
    /**
     * error is present if status is COMMAND_ATTEMPT_STATUS_ERROR.
     *
     * @generated from protobuf field: string error = 2;
     */
    error: string;
    /**
     * command shows which command was executed along with its arguments, e.g., "netstat -rn -f inet".
     *
     * @generated from protobuf field: string command = 3;
     */
    command: string;
    /**
     * output is stdout from the command if status is COMMAND_ATTEMPT_STATUS_OK.
     *
     * @generated from protobuf field: string output = 4;
     */
    output: string;
}
/**
 * RouteConflictReport describes conflicting routes found by RouteConflictDiag.
 *
 * @generated from protobuf message teleport.lib.vnet.diag.v1.RouteConflictReport
 */
export interface RouteConflictReport {
    /**
     * @generated from protobuf field: repeated teleport.lib.vnet.diag.v1.RouteConflict route_conflicts = 1;
     */
    routeConflicts: RouteConflict[];
}
/**
 * RouteConflict describes a conflict between a route set up by a 3rd-party app where the
 * destination overlaps with a destination in a route set up by VNet.
 *
 * @generated from protobuf message teleport.lib.vnet.diag.v1.RouteConflict
 */
export interface RouteConflict {
    /**
     * dest is the destination of the conflicting route.
     *
     * @generated from protobuf field: string dest = 1;
     */
    dest: string;
    /**
     * vnet_dest is the destination of a VNet route that Dest overlaps with.
     *
     * @generated from protobuf field: string vnet_dest = 2;
     */
    vnetDest: string;
    /**
     * interface_name is the name of the interface the route uses, e.g. "utun4".
     *
     * @generated from protobuf field: string interface_name = 3;
     */
    interfaceName: string;
    /**
     * interface_app may contain the name of the application responsible for setting up the interface.
     * At the moment, the only source of this information is NetworkExtension description included in
     * the output of `ifconfig -v <interface name>`. Not all VPN applications use this framework, so
     * it's likely to be empty.
     *
     * @generated from protobuf field: string interface_app = 4;
     */
    interfaceApp: string;
}
/**
 * SSHConfigurationReport describes the state of the system's SSH configuration.
 *
 * @generated from protobuf message teleport.lib.vnet.diag.v1.SSHConfigurationReport
 */
export interface SSHConfigurationReport {
    /**
     * user_openssh_config_path is the full path to the user's default OpenSSH
     * config file (~/.ssh/config).
     *
     * @generated from protobuf field: string user_openssh_config_path = 1;
     */
    userOpensshConfigPath: string;
    /**
     * vnet_ssh_config_path is the path to VNet's generated OpenSSH-compatible
     * config file.
     *
     * @generated from protobuf field: string vnet_ssh_config_path = 2;
     */
    vnetSshConfigPath: string;
    /**
     * user_openssh_config_includes_vnet_ssh_config is true if the default
     * OpenSSH user configuration file includes VNet's SSH config file.
     *
     * @generated from protobuf field: bool user_openssh_config_includes_vnet_ssh_config = 3;
     */
    userOpensshConfigIncludesVnetSshConfig: boolean;
    /**
     * user_openssh_config_exists is true if a file exists at
     * user_openssh_config_path (~/.ssh/config).
     *
     * @generated from protobuf field: bool user_openssh_config_exists = 4;
     */
    userOpensshConfigExists: boolean;
    /**
     * user_openssh_config_contents contains the contents of the file at
     * user_openssh_config_path if it exists.
     *
     * @generated from protobuf field: string user_openssh_config_contents = 5;
     */
    userOpensshConfigContents: string;
}
/**
 * CheckAttemptStatus describes whether CheckAttempt finished successfully. This is different from
 * CheckReportStatus, which describes whether a successful attempt at running a check has found any
 * issues. See the comment for CheckAttempt for an example.
 *
 * @generated from protobuf enum teleport.lib.vnet.diag.v1.CheckAttemptStatus
 */
export enum CheckAttemptStatus {
    /**
     * @generated from protobuf enum value: CHECK_ATTEMPT_STATUS_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * CHECK_ATTEMPT_STATUS_OK indicates that the check ran successfully.
     *
     * @generated from protobuf enum value: CHECK_ATTEMPT_STATUS_OK = 1;
     */
    OK = 1,
    /**
     * CHECK_ATTEMPT_STATUS_ERROR indicates that the check failed to run.
     *
     * @generated from protobuf enum value: CHECK_ATTEMPT_STATUS_ERROR = 2;
     */
    ERROR = 2
}
/**
 * CheckReportStatus describes the outcome of a successful attempt at running a check.
 *
 * @generated from protobuf enum teleport.lib.vnet.diag.v1.CheckReportStatus
 */
export enum CheckReportStatus {
    /**
     * @generated from protobuf enum value: CHECK_REPORT_STATUS_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * CHECK_REPORT_STATUS_OK indicates that the check has not found any issues.
     *
     * @generated from protobuf enum value: CHECK_REPORT_STATUS_OK = 1;
     */
    OK = 1,
    /**
     * CHECK_REPORT_STATUS_ISSUES_FOUND indicates that the check has found at least one issue.
     *
     * @generated from protobuf enum value: CHECK_REPORT_STATUS_ISSUES_FOUND = 2;
     */
    ISSUES_FOUND = 2
}
/**
 * CommandAttemptStatus describes the status of CommandAttempt.
 *
 * @generated from protobuf enum teleport.lib.vnet.diag.v1.CommandAttemptStatus
 */
export enum CommandAttemptStatus {
    /**
     * @generated from protobuf enum value: COMMAND_ATTEMPT_STATUS_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: COMMAND_ATTEMPT_STATUS_OK = 1;
     */
    OK = 1,
    /**
     * @generated from protobuf enum value: COMMAND_ATTEMPT_STATUS_ERROR = 2;
     */
    ERROR = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class Report$Type extends MessageType<Report> {
    constructor() {
        super("teleport.lib.vnet.diag.v1.Report", [
            { no: 1, name: "created_at", kind: "message", T: () => Timestamp },
            { no: 2, name: "network_stack_attempt", kind: "message", T: () => NetworkStackAttempt },
            { no: 3, name: "checks", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CheckAttempt }
        ]);
    }
    create(value?: PartialMessage<Report>): Report {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.checks = [];
        if (value !== undefined)
            reflectionMergePartial<Report>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Report): Report {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Timestamp created_at */ 1:
                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                case /* teleport.lib.vnet.diag.v1.NetworkStackAttempt network_stack_attempt */ 2:
                    message.networkStackAttempt = NetworkStackAttempt.internalBinaryRead(reader, reader.uint32(), options, message.networkStackAttempt);
                    break;
                case /* repeated teleport.lib.vnet.diag.v1.CheckAttempt checks */ 3:
                    message.checks.push(CheckAttempt.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Report, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Timestamp created_at = 1; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(message.createdAt, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* teleport.lib.vnet.diag.v1.NetworkStackAttempt network_stack_attempt = 2; */
        if (message.networkStackAttempt)
            NetworkStackAttempt.internalBinaryWrite(message.networkStackAttempt, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated teleport.lib.vnet.diag.v1.CheckAttempt checks = 3; */
        for (let i = 0; i < message.checks.length; i++)
            CheckAttempt.internalBinaryWrite(message.checks[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.vnet.diag.v1.Report
 */
export const Report = new Report$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NetworkStackAttempt$Type extends MessageType<NetworkStackAttempt> {
    constructor() {
        super("teleport.lib.vnet.diag.v1.NetworkStackAttempt", [
            { no: 1, name: "status", kind: "enum", T: () => ["teleport.lib.vnet.diag.v1.CheckAttemptStatus", CheckAttemptStatus, "CHECK_ATTEMPT_STATUS_"] },
            { no: 2, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "network_stack", kind: "message", T: () => NetworkStack }
        ]);
    }
    create(value?: PartialMessage<NetworkStackAttempt>): NetworkStackAttempt {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = 0;
        message.error = "";
        if (value !== undefined)
            reflectionMergePartial<NetworkStackAttempt>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NetworkStackAttempt): NetworkStackAttempt {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.lib.vnet.diag.v1.CheckAttemptStatus status */ 1:
                    message.status = reader.int32();
                    break;
                case /* string error */ 2:
                    message.error = reader.string();
                    break;
                case /* teleport.lib.vnet.diag.v1.NetworkStack network_stack */ 3:
                    message.networkStack = NetworkStack.internalBinaryRead(reader, reader.uint32(), options, message.networkStack);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NetworkStackAttempt, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.lib.vnet.diag.v1.CheckAttemptStatus status = 1; */
        if (message.status !== 0)
            writer.tag(1, WireType.Varint).int32(message.status);
        /* string error = 2; */
        if (message.error !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.error);
        /* teleport.lib.vnet.diag.v1.NetworkStack network_stack = 3; */
        if (message.networkStack)
            NetworkStack.internalBinaryWrite(message.networkStack, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.vnet.diag.v1.NetworkStackAttempt
 */
export const NetworkStackAttempt = new NetworkStackAttempt$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NetworkStack$Type extends MessageType<NetworkStack> {
    constructor() {
        super("teleport.lib.vnet.diag.v1.NetworkStack", [
            { no: 1, name: "interface_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ipv4_cidr_ranges", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "ipv6_prefix", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "dns_zones", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<NetworkStack>): NetworkStack {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.interfaceName = "";
        message.ipv4CidrRanges = [];
        message.ipv6Prefix = "";
        message.dnsZones = [];
        if (value !== undefined)
            reflectionMergePartial<NetworkStack>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NetworkStack): NetworkStack {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string interface_name */ 1:
                    message.interfaceName = reader.string();
                    break;
                case /* repeated string ipv4_cidr_ranges */ 2:
                    message.ipv4CidrRanges.push(reader.string());
                    break;
                case /* string ipv6_prefix */ 3:
                    message.ipv6Prefix = reader.string();
                    break;
                case /* repeated string dns_zones */ 4:
                    message.dnsZones.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NetworkStack, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string interface_name = 1; */
        if (message.interfaceName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.interfaceName);
        /* repeated string ipv4_cidr_ranges = 2; */
        for (let i = 0; i < message.ipv4CidrRanges.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.ipv4CidrRanges[i]);
        /* string ipv6_prefix = 3; */
        if (message.ipv6Prefix !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.ipv6Prefix);
        /* repeated string dns_zones = 4; */
        for (let i = 0; i < message.dnsZones.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.dnsZones[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.vnet.diag.v1.NetworkStack
 */
export const NetworkStack = new NetworkStack$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckAttempt$Type extends MessageType<CheckAttempt> {
    constructor() {
        super("teleport.lib.vnet.diag.v1.CheckAttempt", [
            { no: 1, name: "status", kind: "enum", T: () => ["teleport.lib.vnet.diag.v1.CheckAttemptStatus", CheckAttemptStatus, "CHECK_ATTEMPT_STATUS_"] },
            { no: 2, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "check_report", kind: "message", T: () => CheckReport },
            { no: 4, name: "commands", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CommandAttempt }
        ]);
    }
    create(value?: PartialMessage<CheckAttempt>): CheckAttempt {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = 0;
        message.error = "";
        message.commands = [];
        if (value !== undefined)
            reflectionMergePartial<CheckAttempt>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CheckAttempt): CheckAttempt {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.lib.vnet.diag.v1.CheckAttemptStatus status */ 1:
                    message.status = reader.int32();
                    break;
                case /* string error */ 2:
                    message.error = reader.string();
                    break;
                case /* teleport.lib.vnet.diag.v1.CheckReport check_report */ 3:
                    message.checkReport = CheckReport.internalBinaryRead(reader, reader.uint32(), options, message.checkReport);
                    break;
                case /* repeated teleport.lib.vnet.diag.v1.CommandAttempt commands */ 4:
                    message.commands.push(CommandAttempt.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CheckAttempt, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.lib.vnet.diag.v1.CheckAttemptStatus status = 1; */
        if (message.status !== 0)
            writer.tag(1, WireType.Varint).int32(message.status);
        /* string error = 2; */
        if (message.error !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.error);
        /* teleport.lib.vnet.diag.v1.CheckReport check_report = 3; */
        if (message.checkReport)
            CheckReport.internalBinaryWrite(message.checkReport, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated teleport.lib.vnet.diag.v1.CommandAttempt commands = 4; */
        for (let i = 0; i < message.commands.length; i++)
            CommandAttempt.internalBinaryWrite(message.commands[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.vnet.diag.v1.CheckAttempt
 */
export const CheckAttempt = new CheckAttempt$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckReport$Type extends MessageType<CheckReport> {
    constructor() {
        super("teleport.lib.vnet.diag.v1.CheckReport", [
            { no: 1, name: "status", kind: "enum", T: () => ["teleport.lib.vnet.diag.v1.CheckReportStatus", CheckReportStatus, "CHECK_REPORT_STATUS_"] },
            { no: 2, name: "route_conflict_report", kind: "message", oneof: "report", T: () => RouteConflictReport },
            { no: 3, name: "ssh_configuration_report", kind: "message", oneof: "report", T: () => SSHConfigurationReport }
        ]);
    }
    create(value?: PartialMessage<CheckReport>): CheckReport {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = 0;
        message.report = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<CheckReport>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CheckReport): CheckReport {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.lib.vnet.diag.v1.CheckReportStatus status */ 1:
                    message.status = reader.int32();
                    break;
                case /* teleport.lib.vnet.diag.v1.RouteConflictReport route_conflict_report */ 2:
                    message.report = {
                        oneofKind: "routeConflictReport",
                        routeConflictReport: RouteConflictReport.internalBinaryRead(reader, reader.uint32(), options, (message.report as any).routeConflictReport)
                    };
                    break;
                case /* teleport.lib.vnet.diag.v1.SSHConfigurationReport ssh_configuration_report */ 3:
                    message.report = {
                        oneofKind: "sshConfigurationReport",
                        sshConfigurationReport: SSHConfigurationReport.internalBinaryRead(reader, reader.uint32(), options, (message.report as any).sshConfigurationReport)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CheckReport, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.lib.vnet.diag.v1.CheckReportStatus status = 1; */
        if (message.status !== 0)
            writer.tag(1, WireType.Varint).int32(message.status);
        /* teleport.lib.vnet.diag.v1.RouteConflictReport route_conflict_report = 2; */
        if (message.report.oneofKind === "routeConflictReport")
            RouteConflictReport.internalBinaryWrite(message.report.routeConflictReport, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* teleport.lib.vnet.diag.v1.SSHConfigurationReport ssh_configuration_report = 3; */
        if (message.report.oneofKind === "sshConfigurationReport")
            SSHConfigurationReport.internalBinaryWrite(message.report.sshConfigurationReport, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.vnet.diag.v1.CheckReport
 */
export const CheckReport = new CheckReport$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandAttempt$Type extends MessageType<CommandAttempt> {
    constructor() {
        super("teleport.lib.vnet.diag.v1.CommandAttempt", [
            { no: 1, name: "status", kind: "enum", T: () => ["teleport.lib.vnet.diag.v1.CommandAttemptStatus", CommandAttemptStatus, "COMMAND_ATTEMPT_STATUS_"] },
            { no: 2, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "command", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "output", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CommandAttempt>): CommandAttempt {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = 0;
        message.error = "";
        message.command = "";
        message.output = "";
        if (value !== undefined)
            reflectionMergePartial<CommandAttempt>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CommandAttempt): CommandAttempt {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.lib.vnet.diag.v1.CommandAttemptStatus status */ 1:
                    message.status = reader.int32();
                    break;
                case /* string error */ 2:
                    message.error = reader.string();
                    break;
                case /* string command */ 3:
                    message.command = reader.string();
                    break;
                case /* string output */ 4:
                    message.output = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CommandAttempt, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.lib.vnet.diag.v1.CommandAttemptStatus status = 1; */
        if (message.status !== 0)
            writer.tag(1, WireType.Varint).int32(message.status);
        /* string error = 2; */
        if (message.error !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.error);
        /* string command = 3; */
        if (message.command !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.command);
        /* string output = 4; */
        if (message.output !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.output);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.vnet.diag.v1.CommandAttempt
 */
export const CommandAttempt = new CommandAttempt$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteConflictReport$Type extends MessageType<RouteConflictReport> {
    constructor() {
        super("teleport.lib.vnet.diag.v1.RouteConflictReport", [
            { no: 1, name: "route_conflicts", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RouteConflict }
        ]);
    }
    create(value?: PartialMessage<RouteConflictReport>): RouteConflictReport {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.routeConflicts = [];
        if (value !== undefined)
            reflectionMergePartial<RouteConflictReport>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RouteConflictReport): RouteConflictReport {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated teleport.lib.vnet.diag.v1.RouteConflict route_conflicts */ 1:
                    message.routeConflicts.push(RouteConflict.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RouteConflictReport, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated teleport.lib.vnet.diag.v1.RouteConflict route_conflicts = 1; */
        for (let i = 0; i < message.routeConflicts.length; i++)
            RouteConflict.internalBinaryWrite(message.routeConflicts[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.vnet.diag.v1.RouteConflictReport
 */
export const RouteConflictReport = new RouteConflictReport$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteConflict$Type extends MessageType<RouteConflict> {
    constructor() {
        super("teleport.lib.vnet.diag.v1.RouteConflict", [
            { no: 1, name: "dest", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "vnet_dest", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "interface_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "interface_app", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RouteConflict>): RouteConflict {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.dest = "";
        message.vnetDest = "";
        message.interfaceName = "";
        message.interfaceApp = "";
        if (value !== undefined)
            reflectionMergePartial<RouteConflict>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RouteConflict): RouteConflict {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string dest */ 1:
                    message.dest = reader.string();
                    break;
                case /* string vnet_dest */ 2:
                    message.vnetDest = reader.string();
                    break;
                case /* string interface_name */ 3:
                    message.interfaceName = reader.string();
                    break;
                case /* string interface_app */ 4:
                    message.interfaceApp = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RouteConflict, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string dest = 1; */
        if (message.dest !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.dest);
        /* string vnet_dest = 2; */
        if (message.vnetDest !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.vnetDest);
        /* string interface_name = 3; */
        if (message.interfaceName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.interfaceName);
        /* string interface_app = 4; */
        if (message.interfaceApp !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.interfaceApp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.vnet.diag.v1.RouteConflict
 */
export const RouteConflict = new RouteConflict$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SSHConfigurationReport$Type extends MessageType<SSHConfigurationReport> {
    constructor() {
        super("teleport.lib.vnet.diag.v1.SSHConfigurationReport", [
            { no: 1, name: "user_openssh_config_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "vnet_ssh_config_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "user_openssh_config_includes_vnet_ssh_config", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "user_openssh_config_exists", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "user_openssh_config_contents", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SSHConfigurationReport>): SSHConfigurationReport {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userOpensshConfigPath = "";
        message.vnetSshConfigPath = "";
        message.userOpensshConfigIncludesVnetSshConfig = false;
        message.userOpensshConfigExists = false;
        message.userOpensshConfigContents = "";
        if (value !== undefined)
            reflectionMergePartial<SSHConfigurationReport>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SSHConfigurationReport): SSHConfigurationReport {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_openssh_config_path */ 1:
                    message.userOpensshConfigPath = reader.string();
                    break;
                case /* string vnet_ssh_config_path */ 2:
                    message.vnetSshConfigPath = reader.string();
                    break;
                case /* bool user_openssh_config_includes_vnet_ssh_config */ 3:
                    message.userOpensshConfigIncludesVnetSshConfig = reader.bool();
                    break;
                case /* bool user_openssh_config_exists */ 4:
                    message.userOpensshConfigExists = reader.bool();
                    break;
                case /* string user_openssh_config_contents */ 5:
                    message.userOpensshConfigContents = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SSHConfigurationReport, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_openssh_config_path = 1; */
        if (message.userOpensshConfigPath !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userOpensshConfigPath);
        /* string vnet_ssh_config_path = 2; */
        if (message.vnetSshConfigPath !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.vnetSshConfigPath);
        /* bool user_openssh_config_includes_vnet_ssh_config = 3; */
        if (message.userOpensshConfigIncludesVnetSshConfig !== false)
            writer.tag(3, WireType.Varint).bool(message.userOpensshConfigIncludesVnetSshConfig);
        /* bool user_openssh_config_exists = 4; */
        if (message.userOpensshConfigExists !== false)
            writer.tag(4, WireType.Varint).bool(message.userOpensshConfigExists);
        /* string user_openssh_config_contents = 5; */
        if (message.userOpensshConfigContents !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.userOpensshConfigContents);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.vnet.diag.v1.SSHConfigurationReport
 */
export const SSHConfigurationReport = new SSHConfigurationReport$Type();
