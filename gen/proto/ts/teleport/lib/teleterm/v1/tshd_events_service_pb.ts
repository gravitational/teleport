/* eslint-disable */
// @generated by protobuf-ts 2.9.3 with parameter eslint_disable,add_pb_suffix,server_grpc1,ts_nocheck
// @generated from protobuf file "teleport/lib/teleterm/v1/tshd_events_service.proto" (package "teleport.lib.teleterm.v1", syntax proto3)
// tslint:disable
// @ts-nocheck
//
//
// Teleport
// Copyright (C) 2023  Gravitational, Inc.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * Request for Relogin.
 *
 * @generated from protobuf message teleport.lib.teleterm.v1.ReloginRequest
 */
export interface ReloginRequest {
    /**
     * @generated from protobuf field: string root_cluster_uri = 1;
     */
    rootClusterUri: string;
    /**
     * @generated from protobuf oneof: reason
     */
    reason: {
        oneofKind: "gatewayCertExpired";
        /**
         * @generated from protobuf field: teleport.lib.teleterm.v1.GatewayCertExpired gateway_cert_expired = 2;
         */
        gatewayCertExpired: GatewayCertExpired;
    } | {
        oneofKind: "vnetCertExpired";
        /**
         * @generated from protobuf field: teleport.lib.teleterm.v1.VnetCertExpired vnet_cert_expired = 3;
         */
        vnetCertExpired: VnetCertExpired;
    } | {
        oneofKind: undefined;
    };
}
/**
 * GatewayCertExpired is given as the reason when a database client attempts to make a connection
 * through the gateway, the gateway middleware notices that the db cert has expired and tries to
 * connect to the cluster to reissue the cert, but fails because the user cert has expired as well.
 *
 * At that point in order to let the connection through, tshd needs the Electron app to refresh the
 * user cert by asking the user to log in again.
 *
 * @generated from protobuf message teleport.lib.teleterm.v1.GatewayCertExpired
 */
export interface GatewayCertExpired {
    /**
     * @generated from protobuf field: string gateway_uri = 1;
     */
    gatewayUri: string;
    /**
     * @generated from protobuf field: string target_uri = 2;
     */
    targetUri: string;
}
/**
 * VnetCertExpired describes which app the user was trying to reach with an expired cert.
 *
 * @generated from protobuf message teleport.lib.teleterm.v1.VnetCertExpired
 */
export interface VnetCertExpired {
    /**
     * target_uri for now points solely at apps, but it's not called app_uri to make it future-proof.
     *
     * @generated from protobuf field: string target_uri = 1;
     */
    targetUri: string;
    /**
     * public_addr is the public address of the app that the user tried to access.
     *
     * @generated from protobuf field: string public_addr = 2;
     */
    publicAddr: string;
}
/**
 * Response for Relogin.
 *
 * @generated from protobuf message teleport.lib.teleterm.v1.ReloginResponse
 */
export interface ReloginResponse {
}
/**
 * SendNotificationRequest includes details behind a notification.
 *
 * Rather than including arbitrary text strings, SendNotificationRequest should contain minimal
 * details. The Electron app can then consume and format them as needed, without having to change
 * what is sent over the wire.
 *
 * @generated from protobuf message teleport.lib.teleterm.v1.SendNotificationRequest
 */
export interface SendNotificationRequest {
    /**
     * @generated from protobuf oneof: subject
     */
    subject: {
        oneofKind: "cannotProxyGatewayConnection";
        /**
         * @generated from protobuf field: teleport.lib.teleterm.v1.CannotProxyGatewayConnection cannot_proxy_gateway_connection = 1;
         */
        cannotProxyGatewayConnection: CannotProxyGatewayConnection;
    } | {
        oneofKind: "cannotProxyVnetConnection";
        /**
         * @generated from protobuf field: teleport.lib.teleterm.v1.CannotProxyVnetConnection cannot_proxy_vnet_connection = 2;
         */
        cannotProxyVnetConnection: CannotProxyVnetConnection;
    } | {
        oneofKind: undefined;
    };
}
/**
 * CannotProxyGatewayConnection is the subject when the middleware used by the gateway encounters an
 * unrecoverable error and cannot let the connection through. The middleware code is executed within
 * a separate goroutine so if the error wasn't passed to the Electron app, it would have been
 * visible only in the logs.
 *
 * @generated from protobuf message teleport.lib.teleterm.v1.CannotProxyGatewayConnection
 */
export interface CannotProxyGatewayConnection {
    /**
     * @generated from protobuf field: string gateway_uri = 1;
     */
    gatewayUri: string;
    /**
     * @generated from protobuf field: string target_uri = 2;
     */
    targetUri: string;
    /**
     * @generated from protobuf field: string error = 3;
     */
    error: string;
}
/**
 * CannotProxyVnetConnection describes which app couldn't have been proxied through VNet and why.
 * At the moment this is used solely when refreshing an expired cert.
 *
 * @generated from protobuf message teleport.lib.teleterm.v1.CannotProxyVnetConnection
 */
export interface CannotProxyVnetConnection {
    /**
     * @generated from protobuf field: string target_uri = 1;
     */
    targetUri: string;
    /**
     * @generated from protobuf field: string error = 2;
     */
    error: string;
    /**
     * public_addr is the public address of the app that the user tried to access.
     *
     * @generated from protobuf field: string public_addr = 3;
     */
    publicAddr: string;
}
/**
 * Response for SendNotification.
 *
 * @generated from protobuf message teleport.lib.teleterm.v1.SendNotificationResponse
 */
export interface SendNotificationResponse {
}
/**
 * Request for SendPendingHeadlessAuthentication.
 *
 * @generated from protobuf message teleport.lib.teleterm.v1.SendPendingHeadlessAuthenticationRequest
 */
export interface SendPendingHeadlessAuthenticationRequest {
    /**
     * @generated from protobuf field: string root_cluster_uri = 1;
     */
    rootClusterUri: string;
    /**
     * @generated from protobuf field: string headless_authentication_id = 2;
     */
    headlessAuthenticationId: string;
    /**
     * @generated from protobuf field: string headless_authentication_client_ip = 3;
     */
    headlessAuthenticationClientIp: string;
}
/**
 * Response for SendPendingHeadlessAuthentication.
 *
 * @generated from protobuf message teleport.lib.teleterm.v1.SendPendingHeadlessAuthenticationResponse
 */
export interface SendPendingHeadlessAuthenticationResponse {
}
/**
 * Request for PromptMFA.
 *
 * @generated from protobuf message teleport.lib.teleterm.v1.PromptMFARequest
 */
export interface PromptMFARequest {
    /**
     * @generated from protobuf field: string reason = 2;
     */
    reason: string;
    /**
     * @generated from protobuf field: bool totp = 3;
     */
    totp: boolean;
    /**
     * @generated from protobuf field: bool webauthn = 4;
     */
    webauthn: boolean;
    /**
     * @generated from protobuf field: string cluster_uri = 5;
     */
    clusterUri: string;
}
/**
 * Response for PromptMFA.
 *
 * @generated from protobuf message teleport.lib.teleterm.v1.PromptMFAResponse
 */
export interface PromptMFAResponse {
    /**
     * @generated from protobuf field: string totp_code = 1;
     */
    totpCode: string;
}
/**
 * Request for GetUsageReportingSettings.
 *
 * @generated from protobuf message teleport.lib.teleterm.v1.GetUsageReportingSettingsRequest
 */
export interface GetUsageReportingSettingsRequest {
}
/**
 * Response for GetUsageReportingSettings.
 *
 * @generated from protobuf message teleport.lib.teleterm.v1.GetUsageReportingSettingsResponse
 */
export interface GetUsageReportingSettingsResponse {
    /**
     * @generated from protobuf field: teleport.lib.teleterm.v1.UsageReportingSettings usage_reporting_settings = 1;
     */
    usageReportingSettings?: UsageReportingSettings;
}
/**
 * UsageReportingSettings contains information about usage reporting as understood by the Electron
 * app.
 *
 * @generated from protobuf message teleport.lib.teleterm.v1.UsageReportingSettings
 */
export interface UsageReportingSettings {
    /**
     * @generated from protobuf field: bool enabled = 1;
     */
    enabled: boolean;
}
/**
 * Request for ReportUnexpectedVnetShutdown.
 *
 * @generated from protobuf message teleport.lib.teleterm.v1.ReportUnexpectedVnetShutdownRequest
 */
export interface ReportUnexpectedVnetShutdownRequest {
    /**
     * error is the error message with which VNet was shut down. Technically it can be empty, so
     * consumers should account for that.
     *
     * @generated from protobuf field: string error = 1;
     */
    error: string;
}
/**
 * Response for ReportUnexpectedVnetShutdown.
 *
 * @generated from protobuf message teleport.lib.teleterm.v1.ReportUnexpectedVnetShutdownResponse
 */
export interface ReportUnexpectedVnetShutdownResponse {
}
// @generated message type with reflection information, may provide speed optimized methods
class ReloginRequest$Type extends MessageType<ReloginRequest> {
    constructor() {
        super("teleport.lib.teleterm.v1.ReloginRequest", [
            { no: 1, name: "root_cluster_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "gateway_cert_expired", kind: "message", oneof: "reason", T: () => GatewayCertExpired },
            { no: 3, name: "vnet_cert_expired", kind: "message", oneof: "reason", T: () => VnetCertExpired }
        ]);
    }
    create(value?: PartialMessage<ReloginRequest>): ReloginRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rootClusterUri = "";
        message.reason = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ReloginRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReloginRequest): ReloginRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string root_cluster_uri */ 1:
                    message.rootClusterUri = reader.string();
                    break;
                case /* teleport.lib.teleterm.v1.GatewayCertExpired gateway_cert_expired */ 2:
                    message.reason = {
                        oneofKind: "gatewayCertExpired",
                        gatewayCertExpired: GatewayCertExpired.internalBinaryRead(reader, reader.uint32(), options, (message.reason as any).gatewayCertExpired)
                    };
                    break;
                case /* teleport.lib.teleterm.v1.VnetCertExpired vnet_cert_expired */ 3:
                    message.reason = {
                        oneofKind: "vnetCertExpired",
                        vnetCertExpired: VnetCertExpired.internalBinaryRead(reader, reader.uint32(), options, (message.reason as any).vnetCertExpired)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReloginRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string root_cluster_uri = 1; */
        if (message.rootClusterUri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.rootClusterUri);
        /* teleport.lib.teleterm.v1.GatewayCertExpired gateway_cert_expired = 2; */
        if (message.reason.oneofKind === "gatewayCertExpired")
            GatewayCertExpired.internalBinaryWrite(message.reason.gatewayCertExpired, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* teleport.lib.teleterm.v1.VnetCertExpired vnet_cert_expired = 3; */
        if (message.reason.oneofKind === "vnetCertExpired")
            VnetCertExpired.internalBinaryWrite(message.reason.vnetCertExpired, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.ReloginRequest
 */
export const ReloginRequest = new ReloginRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GatewayCertExpired$Type extends MessageType<GatewayCertExpired> {
    constructor() {
        super("teleport.lib.teleterm.v1.GatewayCertExpired", [
            { no: 1, name: "gateway_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "target_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GatewayCertExpired>): GatewayCertExpired {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.gatewayUri = "";
        message.targetUri = "";
        if (value !== undefined)
            reflectionMergePartial<GatewayCertExpired>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GatewayCertExpired): GatewayCertExpired {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string gateway_uri */ 1:
                    message.gatewayUri = reader.string();
                    break;
                case /* string target_uri */ 2:
                    message.targetUri = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GatewayCertExpired, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string gateway_uri = 1; */
        if (message.gatewayUri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.gatewayUri);
        /* string target_uri = 2; */
        if (message.targetUri !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.targetUri);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.GatewayCertExpired
 */
export const GatewayCertExpired = new GatewayCertExpired$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VnetCertExpired$Type extends MessageType<VnetCertExpired> {
    constructor() {
        super("teleport.lib.teleterm.v1.VnetCertExpired", [
            { no: 1, name: "target_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "public_addr", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<VnetCertExpired>): VnetCertExpired {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.targetUri = "";
        message.publicAddr = "";
        if (value !== undefined)
            reflectionMergePartial<VnetCertExpired>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VnetCertExpired): VnetCertExpired {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string target_uri */ 1:
                    message.targetUri = reader.string();
                    break;
                case /* string public_addr */ 2:
                    message.publicAddr = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VnetCertExpired, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string target_uri = 1; */
        if (message.targetUri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.targetUri);
        /* string public_addr = 2; */
        if (message.publicAddr !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.publicAddr);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.VnetCertExpired
 */
export const VnetCertExpired = new VnetCertExpired$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReloginResponse$Type extends MessageType<ReloginResponse> {
    constructor() {
        super("teleport.lib.teleterm.v1.ReloginResponse", []);
    }
    create(value?: PartialMessage<ReloginResponse>): ReloginResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ReloginResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReloginResponse): ReloginResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ReloginResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.ReloginResponse
 */
export const ReloginResponse = new ReloginResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SendNotificationRequest$Type extends MessageType<SendNotificationRequest> {
    constructor() {
        super("teleport.lib.teleterm.v1.SendNotificationRequest", [
            { no: 1, name: "cannot_proxy_gateway_connection", kind: "message", oneof: "subject", T: () => CannotProxyGatewayConnection },
            { no: 2, name: "cannot_proxy_vnet_connection", kind: "message", oneof: "subject", T: () => CannotProxyVnetConnection }
        ]);
    }
    create(value?: PartialMessage<SendNotificationRequest>): SendNotificationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subject = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<SendNotificationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SendNotificationRequest): SendNotificationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.lib.teleterm.v1.CannotProxyGatewayConnection cannot_proxy_gateway_connection */ 1:
                    message.subject = {
                        oneofKind: "cannotProxyGatewayConnection",
                        cannotProxyGatewayConnection: CannotProxyGatewayConnection.internalBinaryRead(reader, reader.uint32(), options, (message.subject as any).cannotProxyGatewayConnection)
                    };
                    break;
                case /* teleport.lib.teleterm.v1.CannotProxyVnetConnection cannot_proxy_vnet_connection */ 2:
                    message.subject = {
                        oneofKind: "cannotProxyVnetConnection",
                        cannotProxyVnetConnection: CannotProxyVnetConnection.internalBinaryRead(reader, reader.uint32(), options, (message.subject as any).cannotProxyVnetConnection)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SendNotificationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.lib.teleterm.v1.CannotProxyGatewayConnection cannot_proxy_gateway_connection = 1; */
        if (message.subject.oneofKind === "cannotProxyGatewayConnection")
            CannotProxyGatewayConnection.internalBinaryWrite(message.subject.cannotProxyGatewayConnection, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* teleport.lib.teleterm.v1.CannotProxyVnetConnection cannot_proxy_vnet_connection = 2; */
        if (message.subject.oneofKind === "cannotProxyVnetConnection")
            CannotProxyVnetConnection.internalBinaryWrite(message.subject.cannotProxyVnetConnection, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.SendNotificationRequest
 */
export const SendNotificationRequest = new SendNotificationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CannotProxyGatewayConnection$Type extends MessageType<CannotProxyGatewayConnection> {
    constructor() {
        super("teleport.lib.teleterm.v1.CannotProxyGatewayConnection", [
            { no: 1, name: "gateway_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "target_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CannotProxyGatewayConnection>): CannotProxyGatewayConnection {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.gatewayUri = "";
        message.targetUri = "";
        message.error = "";
        if (value !== undefined)
            reflectionMergePartial<CannotProxyGatewayConnection>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CannotProxyGatewayConnection): CannotProxyGatewayConnection {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string gateway_uri */ 1:
                    message.gatewayUri = reader.string();
                    break;
                case /* string target_uri */ 2:
                    message.targetUri = reader.string();
                    break;
                case /* string error */ 3:
                    message.error = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CannotProxyGatewayConnection, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string gateway_uri = 1; */
        if (message.gatewayUri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.gatewayUri);
        /* string target_uri = 2; */
        if (message.targetUri !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.targetUri);
        /* string error = 3; */
        if (message.error !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.CannotProxyGatewayConnection
 */
export const CannotProxyGatewayConnection = new CannotProxyGatewayConnection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CannotProxyVnetConnection$Type extends MessageType<CannotProxyVnetConnection> {
    constructor() {
        super("teleport.lib.teleterm.v1.CannotProxyVnetConnection", [
            { no: 1, name: "target_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "public_addr", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CannotProxyVnetConnection>): CannotProxyVnetConnection {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.targetUri = "";
        message.error = "";
        message.publicAddr = "";
        if (value !== undefined)
            reflectionMergePartial<CannotProxyVnetConnection>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CannotProxyVnetConnection): CannotProxyVnetConnection {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string target_uri */ 1:
                    message.targetUri = reader.string();
                    break;
                case /* string error */ 2:
                    message.error = reader.string();
                    break;
                case /* string public_addr */ 3:
                    message.publicAddr = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CannotProxyVnetConnection, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string target_uri = 1; */
        if (message.targetUri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.targetUri);
        /* string error = 2; */
        if (message.error !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.error);
        /* string public_addr = 3; */
        if (message.publicAddr !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.publicAddr);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.CannotProxyVnetConnection
 */
export const CannotProxyVnetConnection = new CannotProxyVnetConnection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SendNotificationResponse$Type extends MessageType<SendNotificationResponse> {
    constructor() {
        super("teleport.lib.teleterm.v1.SendNotificationResponse", []);
    }
    create(value?: PartialMessage<SendNotificationResponse>): SendNotificationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SendNotificationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SendNotificationResponse): SendNotificationResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SendNotificationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.SendNotificationResponse
 */
export const SendNotificationResponse = new SendNotificationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SendPendingHeadlessAuthenticationRequest$Type extends MessageType<SendPendingHeadlessAuthenticationRequest> {
    constructor() {
        super("teleport.lib.teleterm.v1.SendPendingHeadlessAuthenticationRequest", [
            { no: 1, name: "root_cluster_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "headless_authentication_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "headless_authentication_client_ip", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SendPendingHeadlessAuthenticationRequest>): SendPendingHeadlessAuthenticationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rootClusterUri = "";
        message.headlessAuthenticationId = "";
        message.headlessAuthenticationClientIp = "";
        if (value !== undefined)
            reflectionMergePartial<SendPendingHeadlessAuthenticationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SendPendingHeadlessAuthenticationRequest): SendPendingHeadlessAuthenticationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string root_cluster_uri */ 1:
                    message.rootClusterUri = reader.string();
                    break;
                case /* string headless_authentication_id */ 2:
                    message.headlessAuthenticationId = reader.string();
                    break;
                case /* string headless_authentication_client_ip */ 3:
                    message.headlessAuthenticationClientIp = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SendPendingHeadlessAuthenticationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string root_cluster_uri = 1; */
        if (message.rootClusterUri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.rootClusterUri);
        /* string headless_authentication_id = 2; */
        if (message.headlessAuthenticationId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.headlessAuthenticationId);
        /* string headless_authentication_client_ip = 3; */
        if (message.headlessAuthenticationClientIp !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.headlessAuthenticationClientIp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.SendPendingHeadlessAuthenticationRequest
 */
export const SendPendingHeadlessAuthenticationRequest = new SendPendingHeadlessAuthenticationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SendPendingHeadlessAuthenticationResponse$Type extends MessageType<SendPendingHeadlessAuthenticationResponse> {
    constructor() {
        super("teleport.lib.teleterm.v1.SendPendingHeadlessAuthenticationResponse", []);
    }
    create(value?: PartialMessage<SendPendingHeadlessAuthenticationResponse>): SendPendingHeadlessAuthenticationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SendPendingHeadlessAuthenticationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SendPendingHeadlessAuthenticationResponse): SendPendingHeadlessAuthenticationResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SendPendingHeadlessAuthenticationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.SendPendingHeadlessAuthenticationResponse
 */
export const SendPendingHeadlessAuthenticationResponse = new SendPendingHeadlessAuthenticationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PromptMFARequest$Type extends MessageType<PromptMFARequest> {
    constructor() {
        super("teleport.lib.teleterm.v1.PromptMFARequest", [
            { no: 2, name: "reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "totp", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "webauthn", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "cluster_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PromptMFARequest>): PromptMFARequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.reason = "";
        message.totp = false;
        message.webauthn = false;
        message.clusterUri = "";
        if (value !== undefined)
            reflectionMergePartial<PromptMFARequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PromptMFARequest): PromptMFARequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reason */ 2:
                    message.reason = reader.string();
                    break;
                case /* bool totp */ 3:
                    message.totp = reader.bool();
                    break;
                case /* bool webauthn */ 4:
                    message.webauthn = reader.bool();
                    break;
                case /* string cluster_uri */ 5:
                    message.clusterUri = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PromptMFARequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reason = 2; */
        if (message.reason !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.reason);
        /* bool totp = 3; */
        if (message.totp !== false)
            writer.tag(3, WireType.Varint).bool(message.totp);
        /* bool webauthn = 4; */
        if (message.webauthn !== false)
            writer.tag(4, WireType.Varint).bool(message.webauthn);
        /* string cluster_uri = 5; */
        if (message.clusterUri !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.clusterUri);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.PromptMFARequest
 */
export const PromptMFARequest = new PromptMFARequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PromptMFAResponse$Type extends MessageType<PromptMFAResponse> {
    constructor() {
        super("teleport.lib.teleterm.v1.PromptMFAResponse", [
            { no: 1, name: "totp_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PromptMFAResponse>): PromptMFAResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.totpCode = "";
        if (value !== undefined)
            reflectionMergePartial<PromptMFAResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PromptMFAResponse): PromptMFAResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string totp_code */ 1:
                    message.totpCode = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PromptMFAResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string totp_code = 1; */
        if (message.totpCode !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.totpCode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.PromptMFAResponse
 */
export const PromptMFAResponse = new PromptMFAResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetUsageReportingSettingsRequest$Type extends MessageType<GetUsageReportingSettingsRequest> {
    constructor() {
        super("teleport.lib.teleterm.v1.GetUsageReportingSettingsRequest", []);
    }
    create(value?: PartialMessage<GetUsageReportingSettingsRequest>): GetUsageReportingSettingsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetUsageReportingSettingsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUsageReportingSettingsRequest): GetUsageReportingSettingsRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetUsageReportingSettingsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.GetUsageReportingSettingsRequest
 */
export const GetUsageReportingSettingsRequest = new GetUsageReportingSettingsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetUsageReportingSettingsResponse$Type extends MessageType<GetUsageReportingSettingsResponse> {
    constructor() {
        super("teleport.lib.teleterm.v1.GetUsageReportingSettingsResponse", [
            { no: 1, name: "usage_reporting_settings", kind: "message", T: () => UsageReportingSettings }
        ]);
    }
    create(value?: PartialMessage<GetUsageReportingSettingsResponse>): GetUsageReportingSettingsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetUsageReportingSettingsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUsageReportingSettingsResponse): GetUsageReportingSettingsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.lib.teleterm.v1.UsageReportingSettings usage_reporting_settings */ 1:
                    message.usageReportingSettings = UsageReportingSettings.internalBinaryRead(reader, reader.uint32(), options, message.usageReportingSettings);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetUsageReportingSettingsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.lib.teleterm.v1.UsageReportingSettings usage_reporting_settings = 1; */
        if (message.usageReportingSettings)
            UsageReportingSettings.internalBinaryWrite(message.usageReportingSettings, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.GetUsageReportingSettingsResponse
 */
export const GetUsageReportingSettingsResponse = new GetUsageReportingSettingsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UsageReportingSettings$Type extends MessageType<UsageReportingSettings> {
    constructor() {
        super("teleport.lib.teleterm.v1.UsageReportingSettings", [
            { no: 1, name: "enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<UsageReportingSettings>): UsageReportingSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.enabled = false;
        if (value !== undefined)
            reflectionMergePartial<UsageReportingSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UsageReportingSettings): UsageReportingSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool enabled */ 1:
                    message.enabled = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UsageReportingSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool enabled = 1; */
        if (message.enabled !== false)
            writer.tag(1, WireType.Varint).bool(message.enabled);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.UsageReportingSettings
 */
export const UsageReportingSettings = new UsageReportingSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReportUnexpectedVnetShutdownRequest$Type extends MessageType<ReportUnexpectedVnetShutdownRequest> {
    constructor() {
        super("teleport.lib.teleterm.v1.ReportUnexpectedVnetShutdownRequest", [
            { no: 1, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ReportUnexpectedVnetShutdownRequest>): ReportUnexpectedVnetShutdownRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.error = "";
        if (value !== undefined)
            reflectionMergePartial<ReportUnexpectedVnetShutdownRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReportUnexpectedVnetShutdownRequest): ReportUnexpectedVnetShutdownRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string error */ 1:
                    message.error = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReportUnexpectedVnetShutdownRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string error = 1; */
        if (message.error !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.ReportUnexpectedVnetShutdownRequest
 */
export const ReportUnexpectedVnetShutdownRequest = new ReportUnexpectedVnetShutdownRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReportUnexpectedVnetShutdownResponse$Type extends MessageType<ReportUnexpectedVnetShutdownResponse> {
    constructor() {
        super("teleport.lib.teleterm.v1.ReportUnexpectedVnetShutdownResponse", []);
    }
    create(value?: PartialMessage<ReportUnexpectedVnetShutdownResponse>): ReportUnexpectedVnetShutdownResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ReportUnexpectedVnetShutdownResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReportUnexpectedVnetShutdownResponse): ReportUnexpectedVnetShutdownResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ReportUnexpectedVnetShutdownResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.ReportUnexpectedVnetShutdownResponse
 */
export const ReportUnexpectedVnetShutdownResponse = new ReportUnexpectedVnetShutdownResponse$Type();
/**
 * @generated ServiceType for protobuf service teleport.lib.teleterm.v1.TshdEventsService
 */
export const TshdEventsService = new ServiceType("teleport.lib.teleterm.v1.TshdEventsService", [
    { name: "Relogin", options: {}, I: ReloginRequest, O: ReloginResponse },
    { name: "SendNotification", options: {}, I: SendNotificationRequest, O: SendNotificationResponse },
    { name: "SendPendingHeadlessAuthentication", options: {}, I: SendPendingHeadlessAuthenticationRequest, O: SendPendingHeadlessAuthenticationResponse },
    { name: "PromptMFA", options: {}, I: PromptMFARequest, O: PromptMFAResponse },
    { name: "GetUsageReportingSettings", options: {}, I: GetUsageReportingSettingsRequest, O: GetUsageReportingSettingsResponse },
    { name: "ReportUnexpectedVnetShutdown", options: {}, I: ReportUnexpectedVnetShutdownRequest, O: ReportUnexpectedVnetShutdownResponse }
]);
