/* eslint-disable */
// @generated by protobuf-ts 2.9.3 with parameter eslint_disable,add_pb_suffix,server_grpc1,ts_nocheck
// @generated from protobuf file "teleport/lib/teleterm/v1/service.proto" (package "teleport.lib.teleterm.v1", syntax proto3)
// tslint:disable
// @ts-nocheck
//
//
// Teleport
// Copyright (C) 2023  Gravitational, Inc.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
import { ReportUsageEventRequest } from "./usage_events_pb";
import { AuthSettings } from "./auth_settings_pb";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { DeviceConfirmationToken } from "../../../devicetrust/v1/device_confirmation_token_pb";
import { DeviceWebToken } from "../../../devicetrust/v1/device_web_token_pb";
import { UnifiedResourcePreferences } from "../../../userpreferences/v1/unified_resource_preferences_pb";
import { ClusterUserPreferences } from "../../../userpreferences/v1/cluster_preferences_pb";
import { App } from "./app_pb";
import { Kube } from "./kube_pb";
import { Database } from "./database_pb";
import { Server } from "./server_pb";
import { Gateway } from "./gateway_pb";
import { Cluster } from "./cluster_pb";
import { AccessList } from "../../../accesslist/v1/accesslist_pb";
import { Timestamp } from "../../../../google/protobuf/timestamp_pb";
import { ResourceID } from "./access_request_pb";
import { AccessRequest } from "./access_request_pb";
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.EmptyResponse
 */
export interface EmptyResponse {
}
/**
 * RemoveClusterRequest describes RemoveClusterRequest
 *
 * @generated from protobuf message teleport.lib.teleterm.v1.RemoveClusterRequest
 */
export interface RemoveClusterRequest {
    /**
     * @generated from protobuf field: string cluster_uri = 1;
     */
    clusterUri: string;
}
/**
 * GetClusterRequest describes GetClusterRequest
 *
 * @generated from protobuf message teleport.lib.teleterm.v1.GetClusterRequest
 */
export interface GetClusterRequest {
    /**
     * @generated from protobuf field: string cluster_uri = 1;
     */
    clusterUri: string;
}
/**
 * LogoutRequest describes LogoutRequest
 *
 * @generated from protobuf message teleport.lib.teleterm.v1.LogoutRequest
 */
export interface LogoutRequest {
    /**
     * @generated from protobuf field: string cluster_uri = 1;
     */
    clusterUri: string;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.GetAccessRequestRequest
 */
export interface GetAccessRequestRequest {
    /**
     * @generated from protobuf field: string cluster_uri = 1;
     */
    clusterUri: string;
    /**
     * specifcies a specific request id
     *
     * @generated from protobuf field: string access_request_id = 2;
     */
    accessRequestId: string;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.GetAccessRequestsRequest
 */
export interface GetAccessRequestsRequest {
    /**
     * cluster_uri is the cluster uri
     *
     * @generated from protobuf field: string cluster_uri = 1;
     */
    clusterUri: string;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.GetAccessRequestResponse
 */
export interface GetAccessRequestResponse {
    /**
     * @generated from protobuf field: teleport.lib.teleterm.v1.AccessRequest request = 1;
     */
    request?: AccessRequest;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.GetAccessRequestsResponse
 */
export interface GetAccessRequestsResponse {
    /**
     * @generated from protobuf field: repeated teleport.lib.teleterm.v1.AccessRequest requests = 1;
     */
    requests: AccessRequest[];
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.DeleteAccessRequestRequest
 */
export interface DeleteAccessRequestRequest {
    /**
     * @generated from protobuf field: string root_cluster_uri = 1;
     */
    rootClusterUri: string;
    /**
     * @generated from protobuf field: string access_request_id = 2;
     */
    accessRequestId: string;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.CreateAccessRequestRequest
 */
export interface CreateAccessRequestRequest {
    /**
     * @generated from protobuf field: string root_cluster_uri = 1;
     */
    rootClusterUri: string;
    /**
     * @generated from protobuf field: string reason = 2;
     */
    reason: string;
    /**
     * a list of roles requested
     *
     * @generated from protobuf field: repeated string roles = 3;
     */
    roles: string[];
    /**
     * suggested_reviewers is a suggested list of reviewers that can review a request.
     *
     * @generated from protobuf field: repeated string suggested_reviewers = 4;
     */
    suggestedReviewers: string[];
    /**
     * TODO(avatus) remove the resource_ids field once the changes to rely on resources instead is merged
     * a list of resourceIDs requested in the AccessRequest
     *
     * @generated from protobuf field: repeated teleport.lib.teleterm.v1.ResourceID resource_ids = 5;
     */
    resourceIds: ResourceID[];
    /**
     * assume_start_time is the time after which the requested access can be assumed.
     *
     * @generated from protobuf field: google.protobuf.Timestamp assume_start_time = 6;
     */
    assumeStartTime?: Timestamp;
    /**
     * dry_run is a flag that indicates whether the request is a dry run to check and set defaults,
     * and return before actually creating the request in the backend.
     *
     * @generated from protobuf field: bool dry_run = 7;
     */
    dryRun: boolean;
    /**
     * max_duration is the maximum duration for which the request is valid.
     *
     * @generated from protobuf field: google.protobuf.Timestamp max_duration = 8;
     */
    maxDuration?: Timestamp;
    /**
     * request_ttl is the expiration time of the request (how long it will await
     * approval).
     *
     * @generated from protobuf field: google.protobuf.Timestamp request_ttl = 9;
     */
    requestTtl?: Timestamp;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.CreateAccessRequestResponse
 */
export interface CreateAccessRequestResponse {
    /**
     * @generated from protobuf field: teleport.lib.teleterm.v1.AccessRequest request = 1;
     */
    request?: AccessRequest;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.AssumeRoleRequest
 */
export interface AssumeRoleRequest {
    /**
     * @generated from protobuf field: string root_cluster_uri = 1;
     */
    rootClusterUri: string;
    /**
     * @generated from protobuf field: repeated string access_request_ids = 2;
     */
    accessRequestIds: string[];
    /**
     * @generated from protobuf field: repeated string drop_request_ids = 3;
     */
    dropRequestIds: string[];
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.GetRequestableRolesRequest
 */
export interface GetRequestableRolesRequest {
    /**
     * @generated from protobuf field: string cluster_uri = 1;
     */
    clusterUri: string;
    /**
     * @generated from protobuf field: repeated teleport.lib.teleterm.v1.ResourceID resource_ids = 2;
     */
    resourceIds: ResourceID[];
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.GetRequestableRolesResponse
 */
export interface GetRequestableRolesResponse {
    /**
     * @generated from protobuf field: repeated string roles = 1;
     */
    roles: string[];
    /**
     * @generated from protobuf field: repeated string applicable_roles = 2;
     */
    applicableRoles: string[];
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.ReviewAccessRequestRequest
 */
export interface ReviewAccessRequestRequest {
    /**
     * @generated from protobuf field: string root_cluster_uri = 1;
     */
    rootClusterUri: string;
    /**
     * @generated from protobuf field: string state = 2;
     */
    state: string;
    /**
     * @generated from protobuf field: string reason = 3;
     */
    reason: string;
    /**
     * @generated from protobuf field: repeated string roles = 4;
     */
    roles: string[];
    /**
     * @generated from protobuf field: string access_request_id = 5;
     */
    accessRequestId: string;
    /**
     * Overwrites the requested start time (optional).
     *
     * @generated from protobuf field: google.protobuf.Timestamp assume_start_time = 6;
     */
    assumeStartTime?: Timestamp;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.ReviewAccessRequestResponse
 */
export interface ReviewAccessRequestResponse {
    /**
     * @generated from protobuf field: teleport.lib.teleterm.v1.AccessRequest request = 1;
     */
    request?: AccessRequest;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.PromoteAccessRequestRequest
 */
export interface PromoteAccessRequestRequest {
    /**
     * @generated from protobuf field: string root_cluster_uri = 1;
     */
    rootClusterUri: string;
    /**
     * @generated from protobuf field: string access_list_id = 2;
     */
    accessListId: string;
    /**
     * @generated from protobuf field: string reason = 3;
     */
    reason: string;
    /**
     * @generated from protobuf field: string access_request_id = 4;
     */
    accessRequestId: string;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.PromoteAccessRequestResponse
 */
export interface PromoteAccessRequestResponse {
    /**
     * @generated from protobuf field: teleport.lib.teleterm.v1.AccessRequest request = 1;
     */
    request?: AccessRequest;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.GetSuggestedAccessListsRequest
 */
export interface GetSuggestedAccessListsRequest {
    /**
     * @generated from protobuf field: string root_cluster_uri = 1;
     */
    rootClusterUri: string;
    /**
     * @generated from protobuf field: string access_request_id = 2;
     */
    accessRequestId: string;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.GetSuggestedAccessListsResponse
 */
export interface GetSuggestedAccessListsResponse {
    /**
     * @generated from protobuf field: repeated teleport.accesslist.v1.AccessList access_lists = 1;
     */
    accessLists: AccessList[];
}
/**
 * CredentialInfo holds fields related to a user's WebAuthn credential.
 *
 * @generated from protobuf message teleport.lib.teleterm.v1.CredentialInfo
 */
export interface CredentialInfo {
    /**
     * @generated from protobuf field: string username = 1;
     */
    username: string;
}
/**
 * LoginPasswordlessResponse is a message sent by the server during the
 * passwordless login flow.
 *
 * @generated from protobuf message teleport.lib.teleterm.v1.LoginPasswordlessResponse
 */
export interface LoginPasswordlessResponse {
    /**
     * @generated from protobuf field: teleport.lib.teleterm.v1.PasswordlessPrompt prompt = 1;
     */
    prompt: PasswordlessPrompt;
    /**
     * @generated from protobuf field: repeated teleport.lib.teleterm.v1.CredentialInfo credentials = 2;
     */
    credentials: CredentialInfo[];
}
/**
 * LoginPasswordlessRequest is a message sent by the client during the passwordless login flow.
 *
 * @generated from protobuf message teleport.lib.teleterm.v1.LoginPasswordlessRequest
 */
export interface LoginPasswordlessRequest {
    /**
     * @generated from protobuf oneof: request
     */
    request: {
        oneofKind: "init";
        /**
         * @generated from protobuf field: teleport.lib.teleterm.v1.LoginPasswordlessRequest.LoginPasswordlessRequestInit init = 1;
         */
        init: LoginPasswordlessRequest_LoginPasswordlessRequestInit;
    } | {
        oneofKind: "pin";
        /**
         * @generated from protobuf field: teleport.lib.teleterm.v1.LoginPasswordlessRequest.LoginPasswordlessPINResponse pin = 2;
         */
        pin: LoginPasswordlessRequest_LoginPasswordlessPINResponse;
    } | {
        oneofKind: "credential";
        /**
         * @generated from protobuf field: teleport.lib.teleterm.v1.LoginPasswordlessRequest.LoginPasswordlessCredentialResponse credential = 3;
         */
        credential: LoginPasswordlessRequest_LoginPasswordlessCredentialResponse;
    } | {
        oneofKind: undefined;
    };
}
/**
 * LoginPasswordlessRequestInit contains fields needed to init the stream request.
 *
 * @generated from protobuf message teleport.lib.teleterm.v1.LoginPasswordlessRequest.LoginPasswordlessRequestInit
 */
export interface LoginPasswordlessRequest_LoginPasswordlessRequestInit {
    /**
     * cluster_uri is needed to resolve cluster by its uri.
     *
     * @generated from protobuf field: string cluster_uri = 1;
     */
    clusterUri: string;
}
/**
 * LoginPasswordlessPINResponse contains fields related to request from webauthncli.PromptPIN.
 *
 * @generated from protobuf message teleport.lib.teleterm.v1.LoginPasswordlessRequest.LoginPasswordlessPINResponse
 */
export interface LoginPasswordlessRequest_LoginPasswordlessPINResponse {
    /**
     * pin is the user's device's pin.
     *
     * @generated from protobuf field: string pin = 1;
     */
    pin: string;
}
/**
 * LoginPasswordlessPINResponse contains fields related to request from
 * webauthncli.PromptCredential.
 *
 * @generated from protobuf message teleport.lib.teleterm.v1.LoginPasswordlessRequest.LoginPasswordlessCredentialResponse
 */
export interface LoginPasswordlessRequest_LoginPasswordlessCredentialResponse {
    /**
     * index is the associated number in the list of credentials that the user selected to log
     * in as.
     *
     * @generated from protobuf field: int64 index = 1;
     */
    index: bigint;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.FileTransferRequest
 */
export interface FileTransferRequest {
    /**
     * login is the SSH username to use for the transfer.
     *
     * @generated from protobuf field: string login = 2;
     */
    login: string;
    /**
     * source path of the transferred file.
     *
     * @generated from protobuf field: string source = 4;
     */
    source: string;
    /**
     * destination path of the transferred file.
     *
     * @generated from protobuf field: string destination = 5;
     */
    destination: string;
    /**
     * direction indicates whether the file is uploaded/downloaded.
     *
     * @generated from protobuf field: teleport.lib.teleterm.v1.FileTransferDirection direction = 6;
     */
    direction: FileTransferDirection;
    /**
     * @generated from protobuf field: string server_uri = 7;
     */
    serverUri: string;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.FileTransferProgress
 */
export interface FileTransferProgress {
    /**
     * @generated from protobuf field: uint32 percentage = 1;
     */
    percentage: number;
}
/**
 * LoginRequest describes cluster login request
 *
 * @generated from protobuf message teleport.lib.teleterm.v1.LoginRequest
 */
export interface LoginRequest {
    /**
     * cluster_uri is the cluster uri
     *
     * @generated from protobuf field: string cluster_uri = 1;
     */
    clusterUri: string;
    /**
     * @generated from protobuf oneof: params
     */
    params: {
        oneofKind: "local";
        /**
         * local holds parameters for local logins
         *
         * @generated from protobuf field: teleport.lib.teleterm.v1.LoginRequest.LocalParams local = 2;
         */
        local: LoginRequest_LocalParams;
    } | {
        oneofKind: "sso";
        /**
         * sso holds parameters for sso logins
         *
         * @generated from protobuf field: teleport.lib.teleterm.v1.LoginRequest.SsoParams sso = 3;
         */
        sso: LoginRequest_SsoParams;
    } | {
        oneofKind: undefined;
    };
}
/**
 * LocalParams describes parameters for local user logins
 *
 * @generated from protobuf message teleport.lib.teleterm.v1.LoginRequest.LocalParams
 */
export interface LoginRequest_LocalParams {
    /**
     * user is the user name
     *
     * @generated from protobuf field: string user = 1;
     */
    user: string;
    /**
     * password is the user password
     *
     * @generated from protobuf field: string password = 2;
     */
    password: string;
    /**
     * token is the 2FA token
     *
     * @generated from protobuf field: string token = 3;
     */
    token: string;
}
/**
 * SsoParams describes SSO parameters
 *
 * @generated from protobuf message teleport.lib.teleterm.v1.LoginRequest.SsoParams
 */
export interface LoginRequest_SsoParams {
    /**
     * provider_type is the provider type
     *
     * @generated from protobuf field: string provider_type = 1;
     */
    providerType: string;
    /**
     * provider_name is the provider name
     *
     * @generated from protobuf field: string provider_name = 2;
     */
    providerName: string;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.AddClusterRequest
 */
export interface AddClusterRequest {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.ListClustersRequest
 */
export interface ListClustersRequest {
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.ListClustersResponse
 */
export interface ListClustersResponse {
    /**
     * @generated from protobuf field: repeated teleport.lib.teleterm.v1.Cluster clusters = 1;
     */
    clusters: Cluster[];
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.GetDatabasesRequest
 */
export interface GetDatabasesRequest {
    /**
     * @generated from protobuf field: string cluster_uri = 1;
     */
    clusterUri: string;
    /**
     * @generated from protobuf field: int32 limit = 2;
     */
    limit: number;
    /**
     * @generated from protobuf field: string start_key = 3;
     */
    startKey: string;
    /**
     * @generated from protobuf field: string search = 4;
     */
    search: string;
    /**
     * @generated from protobuf field: string query = 5;
     */
    query: string;
    /**
     * @generated from protobuf field: string sort_by = 6;
     */
    sortBy: string;
    /**
     * @generated from protobuf field: string search_as_roles = 7;
     */
    searchAsRoles: string;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.ListLeafClustersRequest
 */
export interface ListLeafClustersRequest {
    /**
     * @generated from protobuf field: string cluster_uri = 1;
     */
    clusterUri: string;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.ListDatabaseUsersRequest
 */
export interface ListDatabaseUsersRequest {
    /**
     * @generated from protobuf field: string db_uri = 1;
     */
    dbUri: string;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.ListDatabaseUsersResponse
 */
export interface ListDatabaseUsersResponse {
    /**
     * @generated from protobuf field: repeated string users = 1;
     */
    users: string[];
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.CreateGatewayRequest
 */
export interface CreateGatewayRequest {
    /**
     * @generated from protobuf field: string target_uri = 1;
     */
    targetUri: string;
    /**
     * @generated from protobuf field: string target_user = 2;
     */
    targetUser: string;
    /**
     * @generated from protobuf field: string local_port = 3;
     */
    localPort: string;
    /**
     * @generated from protobuf field: string target_subresource_name = 4;
     */
    targetSubresourceName: string;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.ListGatewaysRequest
 */
export interface ListGatewaysRequest {
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.ListGatewaysResponse
 */
export interface ListGatewaysResponse {
    /**
     * @generated from protobuf field: repeated teleport.lib.teleterm.v1.Gateway gateways = 1;
     */
    gateways: Gateway[];
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.RemoveGatewayRequest
 */
export interface RemoveGatewayRequest {
    /**
     * @generated from protobuf field: string gateway_uri = 1;
     */
    gatewayUri: string;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.SetGatewayTargetSubresourceNameRequest
 */
export interface SetGatewayTargetSubresourceNameRequest {
    /**
     * @generated from protobuf field: string gateway_uri = 1;
     */
    gatewayUri: string;
    /**
     * @generated from protobuf field: string target_subresource_name = 2;
     */
    targetSubresourceName: string;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.SetGatewayLocalPortRequest
 */
export interface SetGatewayLocalPortRequest {
    /**
     * @generated from protobuf field: string gateway_uri = 1;
     */
    gatewayUri: string;
    /**
     * @generated from protobuf field: string local_port = 2;
     */
    localPort: string;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.GetServersRequest
 */
export interface GetServersRequest {
    /**
     * @generated from protobuf field: string cluster_uri = 1;
     */
    clusterUri: string;
    /**
     * @generated from protobuf field: int32 limit = 2;
     */
    limit: number;
    /**
     * @generated from protobuf field: string start_key = 3;
     */
    startKey: string;
    /**
     * @generated from protobuf field: string search = 4;
     */
    search: string;
    /**
     * @generated from protobuf field: string query = 5;
     */
    query: string;
    /**
     * @generated from protobuf field: string sort_by = 6;
     */
    sortBy: string;
    /**
     * @generated from protobuf field: string search_as_roles = 7;
     */
    searchAsRoles: string;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.GetServersResponse
 */
export interface GetServersResponse {
    /**
     * @generated from protobuf field: repeated teleport.lib.teleterm.v1.Server agents = 1;
     */
    agents: Server[];
    /**
     * @generated from protobuf field: int32 total_count = 2;
     */
    totalCount: number;
    /**
     * @generated from protobuf field: string start_key = 3;
     */
    startKey: string;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.GetDatabasesResponse
 */
export interface GetDatabasesResponse {
    /**
     * @generated from protobuf field: repeated teleport.lib.teleterm.v1.Database agents = 1;
     */
    agents: Database[];
    /**
     * @generated from protobuf field: int32 total_count = 2;
     */
    totalCount: number;
    /**
     * @generated from protobuf field: string start_key = 3;
     */
    startKey: string;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.GetKubesRequest
 */
export interface GetKubesRequest {
    /**
     * @generated from protobuf field: string cluster_uri = 1;
     */
    clusterUri: string;
    /**
     * @generated from protobuf field: int32 limit = 2;
     */
    limit: number;
    /**
     * @generated from protobuf field: string start_key = 3;
     */
    startKey: string;
    /**
     * @generated from protobuf field: string search = 4;
     */
    search: string;
    /**
     * @generated from protobuf field: string query = 5;
     */
    query: string;
    /**
     * @generated from protobuf field: string sort_by = 6;
     */
    sortBy: string;
    /**
     * @generated from protobuf field: string search_as_roles = 7;
     */
    searchAsRoles: string;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.GetKubesResponse
 */
export interface GetKubesResponse {
    /**
     * @generated from protobuf field: repeated teleport.lib.teleterm.v1.Kube agents = 1;
     */
    agents: Kube[];
    /**
     * @generated from protobuf field: int32 total_count = 2;
     */
    totalCount: number;
    /**
     * @generated from protobuf field: string start_key = 3;
     */
    startKey: string;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.GetAppsRequest
 */
export interface GetAppsRequest {
    /**
     * @generated from protobuf field: string cluster_uri = 1;
     */
    clusterUri: string;
    /**
     * @generated from protobuf field: int32 limit = 2;
     */
    limit: number;
    /**
     * @generated from protobuf field: string start_key = 3;
     */
    startKey: string;
    /**
     * @generated from protobuf field: string search = 4;
     */
    search: string;
    /**
     * @generated from protobuf field: string query = 5;
     */
    query: string;
    /**
     * @generated from protobuf field: string sort_by = 6;
     */
    sortBy: string;
    /**
     * @generated from protobuf field: string search_as_roles = 7;
     */
    searchAsRoles: string;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.GetAppsResponse
 */
export interface GetAppsResponse {
    /**
     * @generated from protobuf field: repeated teleport.lib.teleterm.v1.App agents = 1;
     */
    agents: App[];
    /**
     * @generated from protobuf field: int32 total_count = 2;
     */
    totalCount: number;
    /**
     * @generated from protobuf field: string start_key = 3;
     */
    startKey: string;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.GetAuthSettingsRequest
 */
export interface GetAuthSettingsRequest {
    /**
     * @generated from protobuf field: string cluster_uri = 1;
     */
    clusterUri: string;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.UpdateTshdEventsServerAddressRequest
 */
export interface UpdateTshdEventsServerAddressRequest {
    /**
     * @generated from protobuf field: string address = 1;
     */
    address: string;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.UpdateTshdEventsServerAddressResponse
 */
export interface UpdateTshdEventsServerAddressResponse {
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.UpdateHeadlessAuthenticationStateRequest
 */
export interface UpdateHeadlessAuthenticationStateRequest {
    /**
     * @generated from protobuf field: string root_cluster_uri = 1;
     */
    rootClusterUri: string;
    /**
     * @generated from protobuf field: string headless_authentication_id = 2;
     */
    headlessAuthenticationId: string;
    /**
     * @generated from protobuf field: teleport.lib.teleterm.v1.HeadlessAuthenticationState state = 3;
     */
    state: HeadlessAuthenticationState;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.UpdateHeadlessAuthenticationStateResponse
 */
export interface UpdateHeadlessAuthenticationStateResponse {
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.CreateConnectMyComputerRoleRequest
 */
export interface CreateConnectMyComputerRoleRequest {
    /**
     * @generated from protobuf field: string root_cluster_uri = 1;
     */
    rootClusterUri: string;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.CreateConnectMyComputerRoleResponse
 */
export interface CreateConnectMyComputerRoleResponse {
    /**
     * certs_reloaded signals to the Electron app that tshd has reloaded the certs in order to refresh
     * the role list. The Electron app should refresh the details from the user cert as well.
     *
     * @generated from protobuf field: bool certs_reloaded = 1;
     */
    certsReloaded: boolean;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.CreateConnectMyComputerNodeTokenRequest
 */
export interface CreateConnectMyComputerNodeTokenRequest {
    /**
     * @generated from protobuf field: string root_cluster_uri = 1;
     */
    rootClusterUri: string;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.CreateConnectMyComputerNodeTokenResponse
 */
export interface CreateConnectMyComputerNodeTokenResponse {
    /**
     * @generated from protobuf field: string token = 1;
     */
    token: string;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.WaitForConnectMyComputerNodeJoinRequest
 */
export interface WaitForConnectMyComputerNodeJoinRequest {
    /**
     * @generated from protobuf field: string root_cluster_uri = 1;
     */
    rootClusterUri: string;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.WaitForConnectMyComputerNodeJoinResponse
 */
export interface WaitForConnectMyComputerNodeJoinResponse {
    /**
     * @generated from protobuf field: teleport.lib.teleterm.v1.Server server = 1;
     */
    server?: Server;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.DeleteConnectMyComputerNodeRequest
 */
export interface DeleteConnectMyComputerNodeRequest {
    /**
     * @generated from protobuf field: string root_cluster_uri = 1;
     */
    rootClusterUri: string;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.DeleteConnectMyComputerNodeResponse
 */
export interface DeleteConnectMyComputerNodeResponse {
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.GetConnectMyComputerNodeNameRequest
 */
export interface GetConnectMyComputerNodeNameRequest {
    /**
     * @generated from protobuf field: string root_cluster_uri = 1;
     */
    rootClusterUri: string;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.GetConnectMyComputerNodeNameResponse
 */
export interface GetConnectMyComputerNodeNameResponse {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.ListUnifiedResourcesRequest
 */
export interface ListUnifiedResourcesRequest {
    /**
     * @generated from protobuf field: string cluster_uri = 1;
     */
    clusterUri: string;
    /**
     * A list of kinds to match against a resource's kind. This can be used in a
     * unified resource request that can include multiple types.
     *
     * @generated from protobuf field: repeated string kinds = 2;
     */
    kinds: string[];
    /**
     * The maximum number of resources to retrieve.
     *
     * @generated from protobuf field: int32 limit = 3;
     */
    limit: number;
    /**
     * Starts listing resources from a specific spot.
     * It should be set to the next_key from ListUnifiedResourcesResponse if
     * using pagination, or left empty.
     *
     * @generated from protobuf field: string start_key = 4;
     */
    startKey: string;
    /**
     * If defined, the advanced search is used. The search field should be left empty.
     *
     * @generated from protobuf field: string query = 5;
     */
    query: string;
    /**
     * If defined, the regular search is used. The query field should be left empty.
     *
     * @generated from protobuf field: string search = 6;
     */
    search: string;
    /**
     * SortBy describes which resource field and which direction to sort by.
     *
     * @generated from protobuf field: teleport.lib.teleterm.v1.SortBy sort_by = 7;
     */
    sortBy?: SortBy;
    /**
     * When true, all resources that the user can request access to are returned.
     *
     * @generated from protobuf field: bool search_as_roles = 8;
     */
    searchAsRoles: boolean;
    /**
     * Only the pinned resources will be returned for the requesting user.
     *
     * @generated from protobuf field: bool pinned_only = 9;
     */
    pinnedOnly: boolean;
    /**
     * include_requestable indicates that the response should include resources that the user must request access to.
     *
     * @generated from protobuf field: bool include_requestable = 10;
     */
    includeRequestable: boolean;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.SortBy
 */
export interface SortBy {
    /**
     * A sort direction flag where if true the direction is descending, else ascending.
     *
     * @generated from protobuf field: bool is_desc = 1;
     */
    isDesc: boolean;
    /**
     * Name of an object's field to sort by. Resources can be sorted by name and kind.
     *
     * @generated from protobuf field: string field = 2;
     */
    field: string;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.ListUnifiedResourcesResponse
 */
export interface ListUnifiedResourcesResponse {
    /**
     * @generated from protobuf field: repeated teleport.lib.teleterm.v1.PaginatedResource resources = 1;
     */
    resources: PaginatedResource[];
    /**
     * A key to use as start_key in a ListResourcesRequest to continue retrieving
     * the next pages. If it is empty, there are no more pages.
     *
     * @generated from protobuf field: string next_key = 2;
     */
    nextKey: string;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.PaginatedResource
 */
export interface PaginatedResource {
    /**
     * @generated from protobuf oneof: resource
     */
    resource: {
        oneofKind: "database";
        /**
         * @generated from protobuf field: teleport.lib.teleterm.v1.Database database = 1;
         */
        database: Database;
    } | {
        oneofKind: "server";
        /**
         * @generated from protobuf field: teleport.lib.teleterm.v1.Server server = 2;
         */
        server: Server;
    } | {
        oneofKind: "kube";
        /**
         * @generated from protobuf field: teleport.lib.teleterm.v1.Kube kube = 3;
         */
        kube: Kube;
    } | {
        oneofKind: "app";
        /**
         * @generated from protobuf field: teleport.lib.teleterm.v1.App app = 4;
         */
        app: App;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: bool requires_request = 5;
     */
    requiresRequest: boolean;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.GetUserPreferencesRequest
 */
export interface GetUserPreferencesRequest {
    /**
     * @generated from protobuf field: string cluster_uri = 1;
     */
    clusterUri: string;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.GetUserPreferencesResponse
 */
export interface GetUserPreferencesResponse {
    /**
     * @generated from protobuf field: teleport.lib.teleterm.v1.UserPreferences user_preferences = 1;
     */
    userPreferences?: UserPreferences;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.UpdateUserPreferencesRequest
 */
export interface UpdateUserPreferencesRequest {
    /**
     * @generated from protobuf field: string cluster_uri = 1;
     */
    clusterUri: string;
    /**
     * @generated from protobuf field: teleport.lib.teleterm.v1.UserPreferences user_preferences = 2;
     */
    userPreferences?: UserPreferences;
}
/**
 * @generated from protobuf message teleport.lib.teleterm.v1.UpdateUserPreferencesResponse
 */
export interface UpdateUserPreferencesResponse {
    /**
     * @generated from protobuf field: teleport.lib.teleterm.v1.UserPreferences user_preferences = 1;
     */
    userPreferences?: UserPreferences;
}
/**
 * UserPreferences is a subset of teleport.userpreferences.v1.UserPreferences.
 * It contains preferences that are relevant to Connect.
 *
 * @generated from protobuf message teleport.lib.teleterm.v1.UserPreferences
 */
export interface UserPreferences {
    /**
     * @generated from protobuf field: teleport.userpreferences.v1.ClusterUserPreferences cluster_preferences = 1;
     */
    clusterPreferences?: ClusterUserPreferences;
    /**
     * @generated from protobuf field: teleport.userpreferences.v1.UnifiedResourcePreferences unified_resource_preferences = 2;
     */
    unifiedResourcePreferences?: UnifiedResourcePreferences;
}
/**
 * Request for AuthenticateWebDevice.
 *
 * @generated from protobuf message teleport.lib.teleterm.v1.AuthenticateWebDeviceRequest
 */
export interface AuthenticateWebDeviceRequest {
    /**
     * Device web token to be spent in exchange for the device authentication
     * attempt.
     *
     * @generated from protobuf field: teleport.devicetrust.v1.DeviceWebToken device_web_token = 1;
     */
    deviceWebToken?: DeviceWebToken;
    /**
     * @generated from protobuf field: string root_cluster_uri = 2;
     */
    rootClusterUri: string;
}
/**
 * Response for AuthenticateWebDevice.
 *
 * @generated from protobuf message teleport.lib.teleterm.v1.AuthenticateWebDeviceResponse
 */
export interface AuthenticateWebDeviceResponse {
    /**
     * Device confirmation token to be sent to the browser that originated the
     * authentication attempt.
     *
     * @generated from protobuf field: teleport.devicetrust.v1.DeviceConfirmationToken confirmation_token = 1;
     */
    confirmationToken?: DeviceConfirmationToken;
}
/**
 * PasswordlessPrompt describes different prompts we need from users
 * during the passwordless login flow.
 *
 * @generated from protobuf enum teleport.lib.teleterm.v1.PasswordlessPrompt
 */
export enum PasswordlessPrompt {
    /**
     * @generated from protobuf enum value: PASSWORDLESS_PROMPT_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * PASSWORDLESS_PROMPT_PIN is used when we need a user's pin.
     *
     * @generated from protobuf enum value: PASSWORDLESS_PROMPT_PIN = 1;
     */
    PIN = 1,
    /**
     * PASSWORDLESS_PROMPT_TAP is used when we require a user to tap their device.
     *
     * @generated from protobuf enum value: PASSWORDLESS_PROMPT_TAP = 2;
     */
    TAP = 2,
    /**
     * PASSWORDLESS_PROMPT_CREDENTIAL is used when we require a user to select a username
     * associated with their account.
     *
     * @generated from protobuf enum value: PASSWORDLESS_PROMPT_CREDENTIAL = 3;
     */
    CREDENTIAL = 3
}
/**
 * FileTransferDirection describes directions of a file transfer
 *
 * @generated from protobuf enum teleport.lib.teleterm.v1.FileTransferDirection
 */
export enum FileTransferDirection {
    /**
     * @generated from protobuf enum value: FILE_TRANSFER_DIRECTION_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: FILE_TRANSFER_DIRECTION_DOWNLOAD = 1;
     */
    DOWNLOAD = 1,
    /**
     * @generated from protobuf enum value: FILE_TRANSFER_DIRECTION_UPLOAD = 2;
     */
    UPLOAD = 2
}
/**
 * HeadlessAuthenticationState is a headless authentication state.
 *
 * @generated from protobuf enum teleport.lib.teleterm.v1.HeadlessAuthenticationState
 */
export enum HeadlessAuthenticationState {
    /**
     * @generated from protobuf enum value: HEADLESS_AUTHENTICATION_STATE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: HEADLESS_AUTHENTICATION_STATE_PENDING = 1;
     */
    PENDING = 1,
    /**
     * @generated from protobuf enum value: HEADLESS_AUTHENTICATION_STATE_DENIED = 2;
     */
    DENIED = 2,
    /**
     * @generated from protobuf enum value: HEADLESS_AUTHENTICATION_STATE_APPROVED = 3;
     */
    APPROVED = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class EmptyResponse$Type extends MessageType<EmptyResponse> {
    constructor() {
        super("teleport.lib.teleterm.v1.EmptyResponse", []);
    }
    create(value?: PartialMessage<EmptyResponse>): EmptyResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<EmptyResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EmptyResponse): EmptyResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: EmptyResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.EmptyResponse
 */
export const EmptyResponse = new EmptyResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoveClusterRequest$Type extends MessageType<RemoveClusterRequest> {
    constructor() {
        super("teleport.lib.teleterm.v1.RemoveClusterRequest", [
            { no: 1, name: "cluster_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RemoveClusterRequest>): RemoveClusterRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterUri = "";
        if (value !== undefined)
            reflectionMergePartial<RemoveClusterRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RemoveClusterRequest): RemoveClusterRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_uri */ 1:
                    message.clusterUri = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RemoveClusterRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_uri = 1; */
        if (message.clusterUri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterUri);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.RemoveClusterRequest
 */
export const RemoveClusterRequest = new RemoveClusterRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetClusterRequest$Type extends MessageType<GetClusterRequest> {
    constructor() {
        super("teleport.lib.teleterm.v1.GetClusterRequest", [
            { no: 1, name: "cluster_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetClusterRequest>): GetClusterRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterUri = "";
        if (value !== undefined)
            reflectionMergePartial<GetClusterRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetClusterRequest): GetClusterRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_uri */ 1:
                    message.clusterUri = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetClusterRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_uri = 1; */
        if (message.clusterUri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterUri);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.GetClusterRequest
 */
export const GetClusterRequest = new GetClusterRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LogoutRequest$Type extends MessageType<LogoutRequest> {
    constructor() {
        super("teleport.lib.teleterm.v1.LogoutRequest", [
            { no: 1, name: "cluster_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LogoutRequest>): LogoutRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterUri = "";
        if (value !== undefined)
            reflectionMergePartial<LogoutRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LogoutRequest): LogoutRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_uri */ 1:
                    message.clusterUri = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LogoutRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_uri = 1; */
        if (message.clusterUri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterUri);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.LogoutRequest
 */
export const LogoutRequest = new LogoutRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAccessRequestRequest$Type extends MessageType<GetAccessRequestRequest> {
    constructor() {
        super("teleport.lib.teleterm.v1.GetAccessRequestRequest", [
            { no: 1, name: "cluster_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "access_request_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetAccessRequestRequest>): GetAccessRequestRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterUri = "";
        message.accessRequestId = "";
        if (value !== undefined)
            reflectionMergePartial<GetAccessRequestRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAccessRequestRequest): GetAccessRequestRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_uri */ 1:
                    message.clusterUri = reader.string();
                    break;
                case /* string access_request_id */ 2:
                    message.accessRequestId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAccessRequestRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_uri = 1; */
        if (message.clusterUri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterUri);
        /* string access_request_id = 2; */
        if (message.accessRequestId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.accessRequestId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.GetAccessRequestRequest
 */
export const GetAccessRequestRequest = new GetAccessRequestRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAccessRequestsRequest$Type extends MessageType<GetAccessRequestsRequest> {
    constructor() {
        super("teleport.lib.teleterm.v1.GetAccessRequestsRequest", [
            { no: 1, name: "cluster_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetAccessRequestsRequest>): GetAccessRequestsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterUri = "";
        if (value !== undefined)
            reflectionMergePartial<GetAccessRequestsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAccessRequestsRequest): GetAccessRequestsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_uri */ 1:
                    message.clusterUri = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAccessRequestsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_uri = 1; */
        if (message.clusterUri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterUri);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.GetAccessRequestsRequest
 */
export const GetAccessRequestsRequest = new GetAccessRequestsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAccessRequestResponse$Type extends MessageType<GetAccessRequestResponse> {
    constructor() {
        super("teleport.lib.teleterm.v1.GetAccessRequestResponse", [
            { no: 1, name: "request", kind: "message", T: () => AccessRequest }
        ]);
    }
    create(value?: PartialMessage<GetAccessRequestResponse>): GetAccessRequestResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetAccessRequestResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAccessRequestResponse): GetAccessRequestResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.lib.teleterm.v1.AccessRequest request */ 1:
                    message.request = AccessRequest.internalBinaryRead(reader, reader.uint32(), options, message.request);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAccessRequestResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.lib.teleterm.v1.AccessRequest request = 1; */
        if (message.request)
            AccessRequest.internalBinaryWrite(message.request, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.GetAccessRequestResponse
 */
export const GetAccessRequestResponse = new GetAccessRequestResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAccessRequestsResponse$Type extends MessageType<GetAccessRequestsResponse> {
    constructor() {
        super("teleport.lib.teleterm.v1.GetAccessRequestsResponse", [
            { no: 1, name: "requests", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AccessRequest }
        ]);
    }
    create(value?: PartialMessage<GetAccessRequestsResponse>): GetAccessRequestsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.requests = [];
        if (value !== undefined)
            reflectionMergePartial<GetAccessRequestsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAccessRequestsResponse): GetAccessRequestsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated teleport.lib.teleterm.v1.AccessRequest requests */ 1:
                    message.requests.push(AccessRequest.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAccessRequestsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated teleport.lib.teleterm.v1.AccessRequest requests = 1; */
        for (let i = 0; i < message.requests.length; i++)
            AccessRequest.internalBinaryWrite(message.requests[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.GetAccessRequestsResponse
 */
export const GetAccessRequestsResponse = new GetAccessRequestsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteAccessRequestRequest$Type extends MessageType<DeleteAccessRequestRequest> {
    constructor() {
        super("teleport.lib.teleterm.v1.DeleteAccessRequestRequest", [
            { no: 1, name: "root_cluster_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "access_request_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteAccessRequestRequest>): DeleteAccessRequestRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rootClusterUri = "";
        message.accessRequestId = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteAccessRequestRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteAccessRequestRequest): DeleteAccessRequestRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string root_cluster_uri */ 1:
                    message.rootClusterUri = reader.string();
                    break;
                case /* string access_request_id */ 2:
                    message.accessRequestId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteAccessRequestRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string root_cluster_uri = 1; */
        if (message.rootClusterUri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.rootClusterUri);
        /* string access_request_id = 2; */
        if (message.accessRequestId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.accessRequestId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.DeleteAccessRequestRequest
 */
export const DeleteAccessRequestRequest = new DeleteAccessRequestRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateAccessRequestRequest$Type extends MessageType<CreateAccessRequestRequest> {
    constructor() {
        super("teleport.lib.teleterm.v1.CreateAccessRequestRequest", [
            { no: 1, name: "root_cluster_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "roles", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "suggested_reviewers", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "resource_ids", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ResourceID },
            { no: 6, name: "assume_start_time", kind: "message", T: () => Timestamp },
            { no: 7, name: "dry_run", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "max_duration", kind: "message", T: () => Timestamp },
            { no: 9, name: "request_ttl", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<CreateAccessRequestRequest>): CreateAccessRequestRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rootClusterUri = "";
        message.reason = "";
        message.roles = [];
        message.suggestedReviewers = [];
        message.resourceIds = [];
        message.dryRun = false;
        if (value !== undefined)
            reflectionMergePartial<CreateAccessRequestRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateAccessRequestRequest): CreateAccessRequestRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string root_cluster_uri */ 1:
                    message.rootClusterUri = reader.string();
                    break;
                case /* string reason */ 2:
                    message.reason = reader.string();
                    break;
                case /* repeated string roles */ 3:
                    message.roles.push(reader.string());
                    break;
                case /* repeated string suggested_reviewers */ 4:
                    message.suggestedReviewers.push(reader.string());
                    break;
                case /* repeated teleport.lib.teleterm.v1.ResourceID resource_ids */ 5:
                    message.resourceIds.push(ResourceID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.Timestamp assume_start_time */ 6:
                    message.assumeStartTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.assumeStartTime);
                    break;
                case /* bool dry_run */ 7:
                    message.dryRun = reader.bool();
                    break;
                case /* google.protobuf.Timestamp max_duration */ 8:
                    message.maxDuration = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.maxDuration);
                    break;
                case /* google.protobuf.Timestamp request_ttl */ 9:
                    message.requestTtl = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.requestTtl);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateAccessRequestRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string root_cluster_uri = 1; */
        if (message.rootClusterUri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.rootClusterUri);
        /* string reason = 2; */
        if (message.reason !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.reason);
        /* repeated string roles = 3; */
        for (let i = 0; i < message.roles.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.roles[i]);
        /* repeated string suggested_reviewers = 4; */
        for (let i = 0; i < message.suggestedReviewers.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.suggestedReviewers[i]);
        /* repeated teleport.lib.teleterm.v1.ResourceID resource_ids = 5; */
        for (let i = 0; i < message.resourceIds.length; i++)
            ResourceID.internalBinaryWrite(message.resourceIds[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp assume_start_time = 6; */
        if (message.assumeStartTime)
            Timestamp.internalBinaryWrite(message.assumeStartTime, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* bool dry_run = 7; */
        if (message.dryRun !== false)
            writer.tag(7, WireType.Varint).bool(message.dryRun);
        /* google.protobuf.Timestamp max_duration = 8; */
        if (message.maxDuration)
            Timestamp.internalBinaryWrite(message.maxDuration, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp request_ttl = 9; */
        if (message.requestTtl)
            Timestamp.internalBinaryWrite(message.requestTtl, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.CreateAccessRequestRequest
 */
export const CreateAccessRequestRequest = new CreateAccessRequestRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateAccessRequestResponse$Type extends MessageType<CreateAccessRequestResponse> {
    constructor() {
        super("teleport.lib.teleterm.v1.CreateAccessRequestResponse", [
            { no: 1, name: "request", kind: "message", T: () => AccessRequest }
        ]);
    }
    create(value?: PartialMessage<CreateAccessRequestResponse>): CreateAccessRequestResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CreateAccessRequestResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateAccessRequestResponse): CreateAccessRequestResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.lib.teleterm.v1.AccessRequest request */ 1:
                    message.request = AccessRequest.internalBinaryRead(reader, reader.uint32(), options, message.request);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateAccessRequestResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.lib.teleterm.v1.AccessRequest request = 1; */
        if (message.request)
            AccessRequest.internalBinaryWrite(message.request, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.CreateAccessRequestResponse
 */
export const CreateAccessRequestResponse = new CreateAccessRequestResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AssumeRoleRequest$Type extends MessageType<AssumeRoleRequest> {
    constructor() {
        super("teleport.lib.teleterm.v1.AssumeRoleRequest", [
            { no: 1, name: "root_cluster_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "access_request_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "drop_request_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AssumeRoleRequest>): AssumeRoleRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rootClusterUri = "";
        message.accessRequestIds = [];
        message.dropRequestIds = [];
        if (value !== undefined)
            reflectionMergePartial<AssumeRoleRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AssumeRoleRequest): AssumeRoleRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string root_cluster_uri */ 1:
                    message.rootClusterUri = reader.string();
                    break;
                case /* repeated string access_request_ids */ 2:
                    message.accessRequestIds.push(reader.string());
                    break;
                case /* repeated string drop_request_ids */ 3:
                    message.dropRequestIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AssumeRoleRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string root_cluster_uri = 1; */
        if (message.rootClusterUri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.rootClusterUri);
        /* repeated string access_request_ids = 2; */
        for (let i = 0; i < message.accessRequestIds.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.accessRequestIds[i]);
        /* repeated string drop_request_ids = 3; */
        for (let i = 0; i < message.dropRequestIds.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.dropRequestIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.AssumeRoleRequest
 */
export const AssumeRoleRequest = new AssumeRoleRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRequestableRolesRequest$Type extends MessageType<GetRequestableRolesRequest> {
    constructor() {
        super("teleport.lib.teleterm.v1.GetRequestableRolesRequest", [
            { no: 1, name: "cluster_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "resource_ids", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ResourceID }
        ]);
    }
    create(value?: PartialMessage<GetRequestableRolesRequest>): GetRequestableRolesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterUri = "";
        message.resourceIds = [];
        if (value !== undefined)
            reflectionMergePartial<GetRequestableRolesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetRequestableRolesRequest): GetRequestableRolesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_uri */ 1:
                    message.clusterUri = reader.string();
                    break;
                case /* repeated teleport.lib.teleterm.v1.ResourceID resource_ids */ 2:
                    message.resourceIds.push(ResourceID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetRequestableRolesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_uri = 1; */
        if (message.clusterUri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterUri);
        /* repeated teleport.lib.teleterm.v1.ResourceID resource_ids = 2; */
        for (let i = 0; i < message.resourceIds.length; i++)
            ResourceID.internalBinaryWrite(message.resourceIds[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.GetRequestableRolesRequest
 */
export const GetRequestableRolesRequest = new GetRequestableRolesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRequestableRolesResponse$Type extends MessageType<GetRequestableRolesResponse> {
    constructor() {
        super("teleport.lib.teleterm.v1.GetRequestableRolesResponse", [
            { no: 1, name: "roles", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "applicable_roles", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetRequestableRolesResponse>): GetRequestableRolesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.roles = [];
        message.applicableRoles = [];
        if (value !== undefined)
            reflectionMergePartial<GetRequestableRolesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetRequestableRolesResponse): GetRequestableRolesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string roles */ 1:
                    message.roles.push(reader.string());
                    break;
                case /* repeated string applicable_roles */ 2:
                    message.applicableRoles.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetRequestableRolesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string roles = 1; */
        for (let i = 0; i < message.roles.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.roles[i]);
        /* repeated string applicable_roles = 2; */
        for (let i = 0; i < message.applicableRoles.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.applicableRoles[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.GetRequestableRolesResponse
 */
export const GetRequestableRolesResponse = new GetRequestableRolesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReviewAccessRequestRequest$Type extends MessageType<ReviewAccessRequestRequest> {
    constructor() {
        super("teleport.lib.teleterm.v1.ReviewAccessRequestRequest", [
            { no: 1, name: "root_cluster_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "roles", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "access_request_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "assume_start_time", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<ReviewAccessRequestRequest>): ReviewAccessRequestRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rootClusterUri = "";
        message.state = "";
        message.reason = "";
        message.roles = [];
        message.accessRequestId = "";
        if (value !== undefined)
            reflectionMergePartial<ReviewAccessRequestRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReviewAccessRequestRequest): ReviewAccessRequestRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string root_cluster_uri */ 1:
                    message.rootClusterUri = reader.string();
                    break;
                case /* string state */ 2:
                    message.state = reader.string();
                    break;
                case /* string reason */ 3:
                    message.reason = reader.string();
                    break;
                case /* repeated string roles */ 4:
                    message.roles.push(reader.string());
                    break;
                case /* string access_request_id */ 5:
                    message.accessRequestId = reader.string();
                    break;
                case /* google.protobuf.Timestamp assume_start_time */ 6:
                    message.assumeStartTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.assumeStartTime);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReviewAccessRequestRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string root_cluster_uri = 1; */
        if (message.rootClusterUri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.rootClusterUri);
        /* string state = 2; */
        if (message.state !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.state);
        /* string reason = 3; */
        if (message.reason !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.reason);
        /* repeated string roles = 4; */
        for (let i = 0; i < message.roles.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.roles[i]);
        /* string access_request_id = 5; */
        if (message.accessRequestId !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.accessRequestId);
        /* google.protobuf.Timestamp assume_start_time = 6; */
        if (message.assumeStartTime)
            Timestamp.internalBinaryWrite(message.assumeStartTime, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.ReviewAccessRequestRequest
 */
export const ReviewAccessRequestRequest = new ReviewAccessRequestRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReviewAccessRequestResponse$Type extends MessageType<ReviewAccessRequestResponse> {
    constructor() {
        super("teleport.lib.teleterm.v1.ReviewAccessRequestResponse", [
            { no: 1, name: "request", kind: "message", T: () => AccessRequest }
        ]);
    }
    create(value?: PartialMessage<ReviewAccessRequestResponse>): ReviewAccessRequestResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ReviewAccessRequestResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReviewAccessRequestResponse): ReviewAccessRequestResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.lib.teleterm.v1.AccessRequest request */ 1:
                    message.request = AccessRequest.internalBinaryRead(reader, reader.uint32(), options, message.request);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReviewAccessRequestResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.lib.teleterm.v1.AccessRequest request = 1; */
        if (message.request)
            AccessRequest.internalBinaryWrite(message.request, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.ReviewAccessRequestResponse
 */
export const ReviewAccessRequestResponse = new ReviewAccessRequestResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PromoteAccessRequestRequest$Type extends MessageType<PromoteAccessRequestRequest> {
    constructor() {
        super("teleport.lib.teleterm.v1.PromoteAccessRequestRequest", [
            { no: 1, name: "root_cluster_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "access_list_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "access_request_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PromoteAccessRequestRequest>): PromoteAccessRequestRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rootClusterUri = "";
        message.accessListId = "";
        message.reason = "";
        message.accessRequestId = "";
        if (value !== undefined)
            reflectionMergePartial<PromoteAccessRequestRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PromoteAccessRequestRequest): PromoteAccessRequestRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string root_cluster_uri */ 1:
                    message.rootClusterUri = reader.string();
                    break;
                case /* string access_list_id */ 2:
                    message.accessListId = reader.string();
                    break;
                case /* string reason */ 3:
                    message.reason = reader.string();
                    break;
                case /* string access_request_id */ 4:
                    message.accessRequestId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PromoteAccessRequestRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string root_cluster_uri = 1; */
        if (message.rootClusterUri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.rootClusterUri);
        /* string access_list_id = 2; */
        if (message.accessListId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.accessListId);
        /* string reason = 3; */
        if (message.reason !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.reason);
        /* string access_request_id = 4; */
        if (message.accessRequestId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.accessRequestId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.PromoteAccessRequestRequest
 */
export const PromoteAccessRequestRequest = new PromoteAccessRequestRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PromoteAccessRequestResponse$Type extends MessageType<PromoteAccessRequestResponse> {
    constructor() {
        super("teleport.lib.teleterm.v1.PromoteAccessRequestResponse", [
            { no: 1, name: "request", kind: "message", T: () => AccessRequest }
        ]);
    }
    create(value?: PartialMessage<PromoteAccessRequestResponse>): PromoteAccessRequestResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PromoteAccessRequestResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PromoteAccessRequestResponse): PromoteAccessRequestResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.lib.teleterm.v1.AccessRequest request */ 1:
                    message.request = AccessRequest.internalBinaryRead(reader, reader.uint32(), options, message.request);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PromoteAccessRequestResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.lib.teleterm.v1.AccessRequest request = 1; */
        if (message.request)
            AccessRequest.internalBinaryWrite(message.request, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.PromoteAccessRequestResponse
 */
export const PromoteAccessRequestResponse = new PromoteAccessRequestResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSuggestedAccessListsRequest$Type extends MessageType<GetSuggestedAccessListsRequest> {
    constructor() {
        super("teleport.lib.teleterm.v1.GetSuggestedAccessListsRequest", [
            { no: 1, name: "root_cluster_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "access_request_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetSuggestedAccessListsRequest>): GetSuggestedAccessListsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rootClusterUri = "";
        message.accessRequestId = "";
        if (value !== undefined)
            reflectionMergePartial<GetSuggestedAccessListsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSuggestedAccessListsRequest): GetSuggestedAccessListsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string root_cluster_uri */ 1:
                    message.rootClusterUri = reader.string();
                    break;
                case /* string access_request_id */ 2:
                    message.accessRequestId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSuggestedAccessListsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string root_cluster_uri = 1; */
        if (message.rootClusterUri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.rootClusterUri);
        /* string access_request_id = 2; */
        if (message.accessRequestId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.accessRequestId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.GetSuggestedAccessListsRequest
 */
export const GetSuggestedAccessListsRequest = new GetSuggestedAccessListsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSuggestedAccessListsResponse$Type extends MessageType<GetSuggestedAccessListsResponse> {
    constructor() {
        super("teleport.lib.teleterm.v1.GetSuggestedAccessListsResponse", [
            { no: 1, name: "access_lists", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AccessList }
        ]);
    }
    create(value?: PartialMessage<GetSuggestedAccessListsResponse>): GetSuggestedAccessListsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accessLists = [];
        if (value !== undefined)
            reflectionMergePartial<GetSuggestedAccessListsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSuggestedAccessListsResponse): GetSuggestedAccessListsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated teleport.accesslist.v1.AccessList access_lists */ 1:
                    message.accessLists.push(AccessList.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSuggestedAccessListsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated teleport.accesslist.v1.AccessList access_lists = 1; */
        for (let i = 0; i < message.accessLists.length; i++)
            AccessList.internalBinaryWrite(message.accessLists[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.GetSuggestedAccessListsResponse
 */
export const GetSuggestedAccessListsResponse = new GetSuggestedAccessListsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CredentialInfo$Type extends MessageType<CredentialInfo> {
    constructor() {
        super("teleport.lib.teleterm.v1.CredentialInfo", [
            { no: 1, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CredentialInfo>): CredentialInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.username = "";
        if (value !== undefined)
            reflectionMergePartial<CredentialInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CredentialInfo): CredentialInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string username */ 1:
                    message.username = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CredentialInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string username = 1; */
        if (message.username !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.username);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.CredentialInfo
 */
export const CredentialInfo = new CredentialInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoginPasswordlessResponse$Type extends MessageType<LoginPasswordlessResponse> {
    constructor() {
        super("teleport.lib.teleterm.v1.LoginPasswordlessResponse", [
            { no: 1, name: "prompt", kind: "enum", T: () => ["teleport.lib.teleterm.v1.PasswordlessPrompt", PasswordlessPrompt, "PASSWORDLESS_PROMPT_"] },
            { no: 2, name: "credentials", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CredentialInfo }
        ]);
    }
    create(value?: PartialMessage<LoginPasswordlessResponse>): LoginPasswordlessResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.prompt = 0;
        message.credentials = [];
        if (value !== undefined)
            reflectionMergePartial<LoginPasswordlessResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoginPasswordlessResponse): LoginPasswordlessResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.lib.teleterm.v1.PasswordlessPrompt prompt */ 1:
                    message.prompt = reader.int32();
                    break;
                case /* repeated teleport.lib.teleterm.v1.CredentialInfo credentials */ 2:
                    message.credentials.push(CredentialInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoginPasswordlessResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.lib.teleterm.v1.PasswordlessPrompt prompt = 1; */
        if (message.prompt !== 0)
            writer.tag(1, WireType.Varint).int32(message.prompt);
        /* repeated teleport.lib.teleterm.v1.CredentialInfo credentials = 2; */
        for (let i = 0; i < message.credentials.length; i++)
            CredentialInfo.internalBinaryWrite(message.credentials[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.LoginPasswordlessResponse
 */
export const LoginPasswordlessResponse = new LoginPasswordlessResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoginPasswordlessRequest$Type extends MessageType<LoginPasswordlessRequest> {
    constructor() {
        super("teleport.lib.teleterm.v1.LoginPasswordlessRequest", [
            { no: 1, name: "init", kind: "message", oneof: "request", T: () => LoginPasswordlessRequest_LoginPasswordlessRequestInit },
            { no: 2, name: "pin", kind: "message", oneof: "request", T: () => LoginPasswordlessRequest_LoginPasswordlessPINResponse },
            { no: 3, name: "credential", kind: "message", oneof: "request", T: () => LoginPasswordlessRequest_LoginPasswordlessCredentialResponse }
        ]);
    }
    create(value?: PartialMessage<LoginPasswordlessRequest>): LoginPasswordlessRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.request = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<LoginPasswordlessRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoginPasswordlessRequest): LoginPasswordlessRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.lib.teleterm.v1.LoginPasswordlessRequest.LoginPasswordlessRequestInit init */ 1:
                    message.request = {
                        oneofKind: "init",
                        init: LoginPasswordlessRequest_LoginPasswordlessRequestInit.internalBinaryRead(reader, reader.uint32(), options, (message.request as any).init)
                    };
                    break;
                case /* teleport.lib.teleterm.v1.LoginPasswordlessRequest.LoginPasswordlessPINResponse pin */ 2:
                    message.request = {
                        oneofKind: "pin",
                        pin: LoginPasswordlessRequest_LoginPasswordlessPINResponse.internalBinaryRead(reader, reader.uint32(), options, (message.request as any).pin)
                    };
                    break;
                case /* teleport.lib.teleterm.v1.LoginPasswordlessRequest.LoginPasswordlessCredentialResponse credential */ 3:
                    message.request = {
                        oneofKind: "credential",
                        credential: LoginPasswordlessRequest_LoginPasswordlessCredentialResponse.internalBinaryRead(reader, reader.uint32(), options, (message.request as any).credential)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoginPasswordlessRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.lib.teleterm.v1.LoginPasswordlessRequest.LoginPasswordlessRequestInit init = 1; */
        if (message.request.oneofKind === "init")
            LoginPasswordlessRequest_LoginPasswordlessRequestInit.internalBinaryWrite(message.request.init, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* teleport.lib.teleterm.v1.LoginPasswordlessRequest.LoginPasswordlessPINResponse pin = 2; */
        if (message.request.oneofKind === "pin")
            LoginPasswordlessRequest_LoginPasswordlessPINResponse.internalBinaryWrite(message.request.pin, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* teleport.lib.teleterm.v1.LoginPasswordlessRequest.LoginPasswordlessCredentialResponse credential = 3; */
        if (message.request.oneofKind === "credential")
            LoginPasswordlessRequest_LoginPasswordlessCredentialResponse.internalBinaryWrite(message.request.credential, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.LoginPasswordlessRequest
 */
export const LoginPasswordlessRequest = new LoginPasswordlessRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoginPasswordlessRequest_LoginPasswordlessRequestInit$Type extends MessageType<LoginPasswordlessRequest_LoginPasswordlessRequestInit> {
    constructor() {
        super("teleport.lib.teleterm.v1.LoginPasswordlessRequest.LoginPasswordlessRequestInit", [
            { no: 1, name: "cluster_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LoginPasswordlessRequest_LoginPasswordlessRequestInit>): LoginPasswordlessRequest_LoginPasswordlessRequestInit {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterUri = "";
        if (value !== undefined)
            reflectionMergePartial<LoginPasswordlessRequest_LoginPasswordlessRequestInit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoginPasswordlessRequest_LoginPasswordlessRequestInit): LoginPasswordlessRequest_LoginPasswordlessRequestInit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_uri */ 1:
                    message.clusterUri = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoginPasswordlessRequest_LoginPasswordlessRequestInit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_uri = 1; */
        if (message.clusterUri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterUri);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.LoginPasswordlessRequest.LoginPasswordlessRequestInit
 */
export const LoginPasswordlessRequest_LoginPasswordlessRequestInit = new LoginPasswordlessRequest_LoginPasswordlessRequestInit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoginPasswordlessRequest_LoginPasswordlessPINResponse$Type extends MessageType<LoginPasswordlessRequest_LoginPasswordlessPINResponse> {
    constructor() {
        super("teleport.lib.teleterm.v1.LoginPasswordlessRequest.LoginPasswordlessPINResponse", [
            { no: 1, name: "pin", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LoginPasswordlessRequest_LoginPasswordlessPINResponse>): LoginPasswordlessRequest_LoginPasswordlessPINResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pin = "";
        if (value !== undefined)
            reflectionMergePartial<LoginPasswordlessRequest_LoginPasswordlessPINResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoginPasswordlessRequest_LoginPasswordlessPINResponse): LoginPasswordlessRequest_LoginPasswordlessPINResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string pin */ 1:
                    message.pin = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoginPasswordlessRequest_LoginPasswordlessPINResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string pin = 1; */
        if (message.pin !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.pin);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.LoginPasswordlessRequest.LoginPasswordlessPINResponse
 */
export const LoginPasswordlessRequest_LoginPasswordlessPINResponse = new LoginPasswordlessRequest_LoginPasswordlessPINResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoginPasswordlessRequest_LoginPasswordlessCredentialResponse$Type extends MessageType<LoginPasswordlessRequest_LoginPasswordlessCredentialResponse> {
    constructor() {
        super("teleport.lib.teleterm.v1.LoginPasswordlessRequest.LoginPasswordlessCredentialResponse", [
            { no: 1, name: "index", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<LoginPasswordlessRequest_LoginPasswordlessCredentialResponse>): LoginPasswordlessRequest_LoginPasswordlessCredentialResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.index = 0n;
        if (value !== undefined)
            reflectionMergePartial<LoginPasswordlessRequest_LoginPasswordlessCredentialResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoginPasswordlessRequest_LoginPasswordlessCredentialResponse): LoginPasswordlessRequest_LoginPasswordlessCredentialResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 index */ 1:
                    message.index = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoginPasswordlessRequest_LoginPasswordlessCredentialResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 index = 1; */
        if (message.index !== 0n)
            writer.tag(1, WireType.Varint).int64(message.index);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.LoginPasswordlessRequest.LoginPasswordlessCredentialResponse
 */
export const LoginPasswordlessRequest_LoginPasswordlessCredentialResponse = new LoginPasswordlessRequest_LoginPasswordlessCredentialResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FileTransferRequest$Type extends MessageType<FileTransferRequest> {
    constructor() {
        super("teleport.lib.teleterm.v1.FileTransferRequest", [
            { no: 2, name: "login", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "source", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "destination", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "direction", kind: "enum", T: () => ["teleport.lib.teleterm.v1.FileTransferDirection", FileTransferDirection, "FILE_TRANSFER_DIRECTION_"] },
            { no: 7, name: "server_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FileTransferRequest>): FileTransferRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.login = "";
        message.source = "";
        message.destination = "";
        message.direction = 0;
        message.serverUri = "";
        if (value !== undefined)
            reflectionMergePartial<FileTransferRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FileTransferRequest): FileTransferRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string login */ 2:
                    message.login = reader.string();
                    break;
                case /* string source */ 4:
                    message.source = reader.string();
                    break;
                case /* string destination */ 5:
                    message.destination = reader.string();
                    break;
                case /* teleport.lib.teleterm.v1.FileTransferDirection direction */ 6:
                    message.direction = reader.int32();
                    break;
                case /* string server_uri */ 7:
                    message.serverUri = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FileTransferRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string login = 2; */
        if (message.login !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.login);
        /* string source = 4; */
        if (message.source !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.source);
        /* string destination = 5; */
        if (message.destination !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.destination);
        /* teleport.lib.teleterm.v1.FileTransferDirection direction = 6; */
        if (message.direction !== 0)
            writer.tag(6, WireType.Varint).int32(message.direction);
        /* string server_uri = 7; */
        if (message.serverUri !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.serverUri);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.FileTransferRequest
 */
export const FileTransferRequest = new FileTransferRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FileTransferProgress$Type extends MessageType<FileTransferProgress> {
    constructor() {
        super("teleport.lib.teleterm.v1.FileTransferProgress", [
            { no: 1, name: "percentage", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<FileTransferProgress>): FileTransferProgress {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.percentage = 0;
        if (value !== undefined)
            reflectionMergePartial<FileTransferProgress>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FileTransferProgress): FileTransferProgress {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 percentage */ 1:
                    message.percentage = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FileTransferProgress, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 percentage = 1; */
        if (message.percentage !== 0)
            writer.tag(1, WireType.Varint).uint32(message.percentage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.FileTransferProgress
 */
export const FileTransferProgress = new FileTransferProgress$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoginRequest$Type extends MessageType<LoginRequest> {
    constructor() {
        super("teleport.lib.teleterm.v1.LoginRequest", [
            { no: 1, name: "cluster_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "local", kind: "message", oneof: "params", T: () => LoginRequest_LocalParams },
            { no: 3, name: "sso", kind: "message", oneof: "params", T: () => LoginRequest_SsoParams }
        ]);
    }
    create(value?: PartialMessage<LoginRequest>): LoginRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterUri = "";
        message.params = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<LoginRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoginRequest): LoginRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_uri */ 1:
                    message.clusterUri = reader.string();
                    break;
                case /* teleport.lib.teleterm.v1.LoginRequest.LocalParams local */ 2:
                    message.params = {
                        oneofKind: "local",
                        local: LoginRequest_LocalParams.internalBinaryRead(reader, reader.uint32(), options, (message.params as any).local)
                    };
                    break;
                case /* teleport.lib.teleterm.v1.LoginRequest.SsoParams sso */ 3:
                    message.params = {
                        oneofKind: "sso",
                        sso: LoginRequest_SsoParams.internalBinaryRead(reader, reader.uint32(), options, (message.params as any).sso)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoginRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_uri = 1; */
        if (message.clusterUri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterUri);
        /* teleport.lib.teleterm.v1.LoginRequest.LocalParams local = 2; */
        if (message.params.oneofKind === "local")
            LoginRequest_LocalParams.internalBinaryWrite(message.params.local, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* teleport.lib.teleterm.v1.LoginRequest.SsoParams sso = 3; */
        if (message.params.oneofKind === "sso")
            LoginRequest_SsoParams.internalBinaryWrite(message.params.sso, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.LoginRequest
 */
export const LoginRequest = new LoginRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoginRequest_LocalParams$Type extends MessageType<LoginRequest_LocalParams> {
    constructor() {
        super("teleport.lib.teleterm.v1.LoginRequest.LocalParams", [
            { no: 1, name: "user", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LoginRequest_LocalParams>): LoginRequest_LocalParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.user = "";
        message.password = "";
        message.token = "";
        if (value !== undefined)
            reflectionMergePartial<LoginRequest_LocalParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoginRequest_LocalParams): LoginRequest_LocalParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user */ 1:
                    message.user = reader.string();
                    break;
                case /* string password */ 2:
                    message.password = reader.string();
                    break;
                case /* string token */ 3:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoginRequest_LocalParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user = 1; */
        if (message.user !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.user);
        /* string password = 2; */
        if (message.password !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.password);
        /* string token = 3; */
        if (message.token !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.LoginRequest.LocalParams
 */
export const LoginRequest_LocalParams = new LoginRequest_LocalParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoginRequest_SsoParams$Type extends MessageType<LoginRequest_SsoParams> {
    constructor() {
        super("teleport.lib.teleterm.v1.LoginRequest.SsoParams", [
            { no: 1, name: "provider_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "provider_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LoginRequest_SsoParams>): LoginRequest_SsoParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.providerType = "";
        message.providerName = "";
        if (value !== undefined)
            reflectionMergePartial<LoginRequest_SsoParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoginRequest_SsoParams): LoginRequest_SsoParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string provider_type */ 1:
                    message.providerType = reader.string();
                    break;
                case /* string provider_name */ 2:
                    message.providerName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoginRequest_SsoParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string provider_type = 1; */
        if (message.providerType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.providerType);
        /* string provider_name = 2; */
        if (message.providerName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.providerName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.LoginRequest.SsoParams
 */
export const LoginRequest_SsoParams = new LoginRequest_SsoParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddClusterRequest$Type extends MessageType<AddClusterRequest> {
    constructor() {
        super("teleport.lib.teleterm.v1.AddClusterRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AddClusterRequest>): AddClusterRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<AddClusterRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AddClusterRequest): AddClusterRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AddClusterRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.AddClusterRequest
 */
export const AddClusterRequest = new AddClusterRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListClustersRequest$Type extends MessageType<ListClustersRequest> {
    constructor() {
        super("teleport.lib.teleterm.v1.ListClustersRequest", []);
    }
    create(value?: PartialMessage<ListClustersRequest>): ListClustersRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ListClustersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListClustersRequest): ListClustersRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ListClustersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.ListClustersRequest
 */
export const ListClustersRequest = new ListClustersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListClustersResponse$Type extends MessageType<ListClustersResponse> {
    constructor() {
        super("teleport.lib.teleterm.v1.ListClustersResponse", [
            { no: 1, name: "clusters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Cluster }
        ]);
    }
    create(value?: PartialMessage<ListClustersResponse>): ListClustersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusters = [];
        if (value !== undefined)
            reflectionMergePartial<ListClustersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListClustersResponse): ListClustersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated teleport.lib.teleterm.v1.Cluster clusters */ 1:
                    message.clusters.push(Cluster.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListClustersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated teleport.lib.teleterm.v1.Cluster clusters = 1; */
        for (let i = 0; i < message.clusters.length; i++)
            Cluster.internalBinaryWrite(message.clusters[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.ListClustersResponse
 */
export const ListClustersResponse = new ListClustersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDatabasesRequest$Type extends MessageType<GetDatabasesRequest> {
    constructor() {
        super("teleport.lib.teleterm.v1.GetDatabasesRequest", [
            { no: 1, name: "cluster_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "limit", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "start_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "search", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "query", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "sort_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "search_as_roles", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetDatabasesRequest>): GetDatabasesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterUri = "";
        message.limit = 0;
        message.startKey = "";
        message.search = "";
        message.query = "";
        message.sortBy = "";
        message.searchAsRoles = "";
        if (value !== undefined)
            reflectionMergePartial<GetDatabasesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDatabasesRequest): GetDatabasesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_uri */ 1:
                    message.clusterUri = reader.string();
                    break;
                case /* int32 limit */ 2:
                    message.limit = reader.int32();
                    break;
                case /* string start_key */ 3:
                    message.startKey = reader.string();
                    break;
                case /* string search */ 4:
                    message.search = reader.string();
                    break;
                case /* string query */ 5:
                    message.query = reader.string();
                    break;
                case /* string sort_by */ 6:
                    message.sortBy = reader.string();
                    break;
                case /* string search_as_roles */ 7:
                    message.searchAsRoles = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDatabasesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_uri = 1; */
        if (message.clusterUri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterUri);
        /* int32 limit = 2; */
        if (message.limit !== 0)
            writer.tag(2, WireType.Varint).int32(message.limit);
        /* string start_key = 3; */
        if (message.startKey !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.startKey);
        /* string search = 4; */
        if (message.search !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.search);
        /* string query = 5; */
        if (message.query !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.query);
        /* string sort_by = 6; */
        if (message.sortBy !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.sortBy);
        /* string search_as_roles = 7; */
        if (message.searchAsRoles !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.searchAsRoles);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.GetDatabasesRequest
 */
export const GetDatabasesRequest = new GetDatabasesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListLeafClustersRequest$Type extends MessageType<ListLeafClustersRequest> {
    constructor() {
        super("teleport.lib.teleterm.v1.ListLeafClustersRequest", [
            { no: 1, name: "cluster_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListLeafClustersRequest>): ListLeafClustersRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterUri = "";
        if (value !== undefined)
            reflectionMergePartial<ListLeafClustersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListLeafClustersRequest): ListLeafClustersRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_uri */ 1:
                    message.clusterUri = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListLeafClustersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_uri = 1; */
        if (message.clusterUri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterUri);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.ListLeafClustersRequest
 */
export const ListLeafClustersRequest = new ListLeafClustersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListDatabaseUsersRequest$Type extends MessageType<ListDatabaseUsersRequest> {
    constructor() {
        super("teleport.lib.teleterm.v1.ListDatabaseUsersRequest", [
            { no: 1, name: "db_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListDatabaseUsersRequest>): ListDatabaseUsersRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.dbUri = "";
        if (value !== undefined)
            reflectionMergePartial<ListDatabaseUsersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListDatabaseUsersRequest): ListDatabaseUsersRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string db_uri */ 1:
                    message.dbUri = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListDatabaseUsersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string db_uri = 1; */
        if (message.dbUri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.dbUri);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.ListDatabaseUsersRequest
 */
export const ListDatabaseUsersRequest = new ListDatabaseUsersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListDatabaseUsersResponse$Type extends MessageType<ListDatabaseUsersResponse> {
    constructor() {
        super("teleport.lib.teleterm.v1.ListDatabaseUsersResponse", [
            { no: 1, name: "users", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListDatabaseUsersResponse>): ListDatabaseUsersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.users = [];
        if (value !== undefined)
            reflectionMergePartial<ListDatabaseUsersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListDatabaseUsersResponse): ListDatabaseUsersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string users */ 1:
                    message.users.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListDatabaseUsersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string users = 1; */
        for (let i = 0; i < message.users.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.users[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.ListDatabaseUsersResponse
 */
export const ListDatabaseUsersResponse = new ListDatabaseUsersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateGatewayRequest$Type extends MessageType<CreateGatewayRequest> {
    constructor() {
        super("teleport.lib.teleterm.v1.CreateGatewayRequest", [
            { no: 1, name: "target_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "target_user", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "local_port", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "target_subresource_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CreateGatewayRequest>): CreateGatewayRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.targetUri = "";
        message.targetUser = "";
        message.localPort = "";
        message.targetSubresourceName = "";
        if (value !== undefined)
            reflectionMergePartial<CreateGatewayRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateGatewayRequest): CreateGatewayRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string target_uri */ 1:
                    message.targetUri = reader.string();
                    break;
                case /* string target_user */ 2:
                    message.targetUser = reader.string();
                    break;
                case /* string local_port */ 3:
                    message.localPort = reader.string();
                    break;
                case /* string target_subresource_name */ 4:
                    message.targetSubresourceName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateGatewayRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string target_uri = 1; */
        if (message.targetUri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.targetUri);
        /* string target_user = 2; */
        if (message.targetUser !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.targetUser);
        /* string local_port = 3; */
        if (message.localPort !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.localPort);
        /* string target_subresource_name = 4; */
        if (message.targetSubresourceName !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.targetSubresourceName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.CreateGatewayRequest
 */
export const CreateGatewayRequest = new CreateGatewayRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListGatewaysRequest$Type extends MessageType<ListGatewaysRequest> {
    constructor() {
        super("teleport.lib.teleterm.v1.ListGatewaysRequest", []);
    }
    create(value?: PartialMessage<ListGatewaysRequest>): ListGatewaysRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ListGatewaysRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListGatewaysRequest): ListGatewaysRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ListGatewaysRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.ListGatewaysRequest
 */
export const ListGatewaysRequest = new ListGatewaysRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListGatewaysResponse$Type extends MessageType<ListGatewaysResponse> {
    constructor() {
        super("teleport.lib.teleterm.v1.ListGatewaysResponse", [
            { no: 1, name: "gateways", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Gateway }
        ]);
    }
    create(value?: PartialMessage<ListGatewaysResponse>): ListGatewaysResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.gateways = [];
        if (value !== undefined)
            reflectionMergePartial<ListGatewaysResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListGatewaysResponse): ListGatewaysResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated teleport.lib.teleterm.v1.Gateway gateways */ 1:
                    message.gateways.push(Gateway.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListGatewaysResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated teleport.lib.teleterm.v1.Gateway gateways = 1; */
        for (let i = 0; i < message.gateways.length; i++)
            Gateway.internalBinaryWrite(message.gateways[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.ListGatewaysResponse
 */
export const ListGatewaysResponse = new ListGatewaysResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoveGatewayRequest$Type extends MessageType<RemoveGatewayRequest> {
    constructor() {
        super("teleport.lib.teleterm.v1.RemoveGatewayRequest", [
            { no: 1, name: "gateway_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RemoveGatewayRequest>): RemoveGatewayRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.gatewayUri = "";
        if (value !== undefined)
            reflectionMergePartial<RemoveGatewayRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RemoveGatewayRequest): RemoveGatewayRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string gateway_uri */ 1:
                    message.gatewayUri = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RemoveGatewayRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string gateway_uri = 1; */
        if (message.gatewayUri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.gatewayUri);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.RemoveGatewayRequest
 */
export const RemoveGatewayRequest = new RemoveGatewayRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetGatewayTargetSubresourceNameRequest$Type extends MessageType<SetGatewayTargetSubresourceNameRequest> {
    constructor() {
        super("teleport.lib.teleterm.v1.SetGatewayTargetSubresourceNameRequest", [
            { no: 1, name: "gateway_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "target_subresource_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SetGatewayTargetSubresourceNameRequest>): SetGatewayTargetSubresourceNameRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.gatewayUri = "";
        message.targetSubresourceName = "";
        if (value !== undefined)
            reflectionMergePartial<SetGatewayTargetSubresourceNameRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetGatewayTargetSubresourceNameRequest): SetGatewayTargetSubresourceNameRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string gateway_uri */ 1:
                    message.gatewayUri = reader.string();
                    break;
                case /* string target_subresource_name */ 2:
                    message.targetSubresourceName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetGatewayTargetSubresourceNameRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string gateway_uri = 1; */
        if (message.gatewayUri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.gatewayUri);
        /* string target_subresource_name = 2; */
        if (message.targetSubresourceName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.targetSubresourceName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.SetGatewayTargetSubresourceNameRequest
 */
export const SetGatewayTargetSubresourceNameRequest = new SetGatewayTargetSubresourceNameRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetGatewayLocalPortRequest$Type extends MessageType<SetGatewayLocalPortRequest> {
    constructor() {
        super("teleport.lib.teleterm.v1.SetGatewayLocalPortRequest", [
            { no: 1, name: "gateway_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "local_port", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SetGatewayLocalPortRequest>): SetGatewayLocalPortRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.gatewayUri = "";
        message.localPort = "";
        if (value !== undefined)
            reflectionMergePartial<SetGatewayLocalPortRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetGatewayLocalPortRequest): SetGatewayLocalPortRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string gateway_uri */ 1:
                    message.gatewayUri = reader.string();
                    break;
                case /* string local_port */ 2:
                    message.localPort = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetGatewayLocalPortRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string gateway_uri = 1; */
        if (message.gatewayUri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.gatewayUri);
        /* string local_port = 2; */
        if (message.localPort !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.localPort);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.SetGatewayLocalPortRequest
 */
export const SetGatewayLocalPortRequest = new SetGatewayLocalPortRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetServersRequest$Type extends MessageType<GetServersRequest> {
    constructor() {
        super("teleport.lib.teleterm.v1.GetServersRequest", [
            { no: 1, name: "cluster_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "limit", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "start_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "search", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "query", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "sort_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "search_as_roles", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetServersRequest>): GetServersRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterUri = "";
        message.limit = 0;
        message.startKey = "";
        message.search = "";
        message.query = "";
        message.sortBy = "";
        message.searchAsRoles = "";
        if (value !== undefined)
            reflectionMergePartial<GetServersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetServersRequest): GetServersRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_uri */ 1:
                    message.clusterUri = reader.string();
                    break;
                case /* int32 limit */ 2:
                    message.limit = reader.int32();
                    break;
                case /* string start_key */ 3:
                    message.startKey = reader.string();
                    break;
                case /* string search */ 4:
                    message.search = reader.string();
                    break;
                case /* string query */ 5:
                    message.query = reader.string();
                    break;
                case /* string sort_by */ 6:
                    message.sortBy = reader.string();
                    break;
                case /* string search_as_roles */ 7:
                    message.searchAsRoles = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetServersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_uri = 1; */
        if (message.clusterUri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterUri);
        /* int32 limit = 2; */
        if (message.limit !== 0)
            writer.tag(2, WireType.Varint).int32(message.limit);
        /* string start_key = 3; */
        if (message.startKey !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.startKey);
        /* string search = 4; */
        if (message.search !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.search);
        /* string query = 5; */
        if (message.query !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.query);
        /* string sort_by = 6; */
        if (message.sortBy !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.sortBy);
        /* string search_as_roles = 7; */
        if (message.searchAsRoles !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.searchAsRoles);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.GetServersRequest
 */
export const GetServersRequest = new GetServersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetServersResponse$Type extends MessageType<GetServersResponse> {
    constructor() {
        super("teleport.lib.teleterm.v1.GetServersResponse", [
            { no: 1, name: "agents", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Server },
            { no: 2, name: "total_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "start_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetServersResponse>): GetServersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.agents = [];
        message.totalCount = 0;
        message.startKey = "";
        if (value !== undefined)
            reflectionMergePartial<GetServersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetServersResponse): GetServersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated teleport.lib.teleterm.v1.Server agents */ 1:
                    message.agents.push(Server.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 total_count */ 2:
                    message.totalCount = reader.int32();
                    break;
                case /* string start_key */ 3:
                    message.startKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetServersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated teleport.lib.teleterm.v1.Server agents = 1; */
        for (let i = 0; i < message.agents.length; i++)
            Server.internalBinaryWrite(message.agents[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int32 total_count = 2; */
        if (message.totalCount !== 0)
            writer.tag(2, WireType.Varint).int32(message.totalCount);
        /* string start_key = 3; */
        if (message.startKey !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.startKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.GetServersResponse
 */
export const GetServersResponse = new GetServersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDatabasesResponse$Type extends MessageType<GetDatabasesResponse> {
    constructor() {
        super("teleport.lib.teleterm.v1.GetDatabasesResponse", [
            { no: 1, name: "agents", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Database },
            { no: 2, name: "total_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "start_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetDatabasesResponse>): GetDatabasesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.agents = [];
        message.totalCount = 0;
        message.startKey = "";
        if (value !== undefined)
            reflectionMergePartial<GetDatabasesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDatabasesResponse): GetDatabasesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated teleport.lib.teleterm.v1.Database agents */ 1:
                    message.agents.push(Database.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 total_count */ 2:
                    message.totalCount = reader.int32();
                    break;
                case /* string start_key */ 3:
                    message.startKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDatabasesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated teleport.lib.teleterm.v1.Database agents = 1; */
        for (let i = 0; i < message.agents.length; i++)
            Database.internalBinaryWrite(message.agents[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int32 total_count = 2; */
        if (message.totalCount !== 0)
            writer.tag(2, WireType.Varint).int32(message.totalCount);
        /* string start_key = 3; */
        if (message.startKey !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.startKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.GetDatabasesResponse
 */
export const GetDatabasesResponse = new GetDatabasesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetKubesRequest$Type extends MessageType<GetKubesRequest> {
    constructor() {
        super("teleport.lib.teleterm.v1.GetKubesRequest", [
            { no: 1, name: "cluster_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "limit", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "start_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "search", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "query", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "sort_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "search_as_roles", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetKubesRequest>): GetKubesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterUri = "";
        message.limit = 0;
        message.startKey = "";
        message.search = "";
        message.query = "";
        message.sortBy = "";
        message.searchAsRoles = "";
        if (value !== undefined)
            reflectionMergePartial<GetKubesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetKubesRequest): GetKubesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_uri */ 1:
                    message.clusterUri = reader.string();
                    break;
                case /* int32 limit */ 2:
                    message.limit = reader.int32();
                    break;
                case /* string start_key */ 3:
                    message.startKey = reader.string();
                    break;
                case /* string search */ 4:
                    message.search = reader.string();
                    break;
                case /* string query */ 5:
                    message.query = reader.string();
                    break;
                case /* string sort_by */ 6:
                    message.sortBy = reader.string();
                    break;
                case /* string search_as_roles */ 7:
                    message.searchAsRoles = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetKubesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_uri = 1; */
        if (message.clusterUri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterUri);
        /* int32 limit = 2; */
        if (message.limit !== 0)
            writer.tag(2, WireType.Varint).int32(message.limit);
        /* string start_key = 3; */
        if (message.startKey !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.startKey);
        /* string search = 4; */
        if (message.search !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.search);
        /* string query = 5; */
        if (message.query !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.query);
        /* string sort_by = 6; */
        if (message.sortBy !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.sortBy);
        /* string search_as_roles = 7; */
        if (message.searchAsRoles !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.searchAsRoles);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.GetKubesRequest
 */
export const GetKubesRequest = new GetKubesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetKubesResponse$Type extends MessageType<GetKubesResponse> {
    constructor() {
        super("teleport.lib.teleterm.v1.GetKubesResponse", [
            { no: 1, name: "agents", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Kube },
            { no: 2, name: "total_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "start_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetKubesResponse>): GetKubesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.agents = [];
        message.totalCount = 0;
        message.startKey = "";
        if (value !== undefined)
            reflectionMergePartial<GetKubesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetKubesResponse): GetKubesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated teleport.lib.teleterm.v1.Kube agents */ 1:
                    message.agents.push(Kube.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 total_count */ 2:
                    message.totalCount = reader.int32();
                    break;
                case /* string start_key */ 3:
                    message.startKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetKubesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated teleport.lib.teleterm.v1.Kube agents = 1; */
        for (let i = 0; i < message.agents.length; i++)
            Kube.internalBinaryWrite(message.agents[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int32 total_count = 2; */
        if (message.totalCount !== 0)
            writer.tag(2, WireType.Varint).int32(message.totalCount);
        /* string start_key = 3; */
        if (message.startKey !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.startKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.GetKubesResponse
 */
export const GetKubesResponse = new GetKubesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAppsRequest$Type extends MessageType<GetAppsRequest> {
    constructor() {
        super("teleport.lib.teleterm.v1.GetAppsRequest", [
            { no: 1, name: "cluster_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "limit", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "start_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "search", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "query", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "sort_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "search_as_roles", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetAppsRequest>): GetAppsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterUri = "";
        message.limit = 0;
        message.startKey = "";
        message.search = "";
        message.query = "";
        message.sortBy = "";
        message.searchAsRoles = "";
        if (value !== undefined)
            reflectionMergePartial<GetAppsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAppsRequest): GetAppsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_uri */ 1:
                    message.clusterUri = reader.string();
                    break;
                case /* int32 limit */ 2:
                    message.limit = reader.int32();
                    break;
                case /* string start_key */ 3:
                    message.startKey = reader.string();
                    break;
                case /* string search */ 4:
                    message.search = reader.string();
                    break;
                case /* string query */ 5:
                    message.query = reader.string();
                    break;
                case /* string sort_by */ 6:
                    message.sortBy = reader.string();
                    break;
                case /* string search_as_roles */ 7:
                    message.searchAsRoles = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAppsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_uri = 1; */
        if (message.clusterUri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterUri);
        /* int32 limit = 2; */
        if (message.limit !== 0)
            writer.tag(2, WireType.Varint).int32(message.limit);
        /* string start_key = 3; */
        if (message.startKey !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.startKey);
        /* string search = 4; */
        if (message.search !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.search);
        /* string query = 5; */
        if (message.query !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.query);
        /* string sort_by = 6; */
        if (message.sortBy !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.sortBy);
        /* string search_as_roles = 7; */
        if (message.searchAsRoles !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.searchAsRoles);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.GetAppsRequest
 */
export const GetAppsRequest = new GetAppsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAppsResponse$Type extends MessageType<GetAppsResponse> {
    constructor() {
        super("teleport.lib.teleterm.v1.GetAppsResponse", [
            { no: 1, name: "agents", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => App },
            { no: 2, name: "total_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "start_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetAppsResponse>): GetAppsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.agents = [];
        message.totalCount = 0;
        message.startKey = "";
        if (value !== undefined)
            reflectionMergePartial<GetAppsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAppsResponse): GetAppsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated teleport.lib.teleterm.v1.App agents */ 1:
                    message.agents.push(App.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 total_count */ 2:
                    message.totalCount = reader.int32();
                    break;
                case /* string start_key */ 3:
                    message.startKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAppsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated teleport.lib.teleterm.v1.App agents = 1; */
        for (let i = 0; i < message.agents.length; i++)
            App.internalBinaryWrite(message.agents[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int32 total_count = 2; */
        if (message.totalCount !== 0)
            writer.tag(2, WireType.Varint).int32(message.totalCount);
        /* string start_key = 3; */
        if (message.startKey !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.startKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.GetAppsResponse
 */
export const GetAppsResponse = new GetAppsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAuthSettingsRequest$Type extends MessageType<GetAuthSettingsRequest> {
    constructor() {
        super("teleport.lib.teleterm.v1.GetAuthSettingsRequest", [
            { no: 1, name: "cluster_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetAuthSettingsRequest>): GetAuthSettingsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterUri = "";
        if (value !== undefined)
            reflectionMergePartial<GetAuthSettingsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAuthSettingsRequest): GetAuthSettingsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_uri */ 1:
                    message.clusterUri = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAuthSettingsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_uri = 1; */
        if (message.clusterUri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterUri);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.GetAuthSettingsRequest
 */
export const GetAuthSettingsRequest = new GetAuthSettingsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateTshdEventsServerAddressRequest$Type extends MessageType<UpdateTshdEventsServerAddressRequest> {
    constructor() {
        super("teleport.lib.teleterm.v1.UpdateTshdEventsServerAddressRequest", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateTshdEventsServerAddressRequest>): UpdateTshdEventsServerAddressRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.address = "";
        if (value !== undefined)
            reflectionMergePartial<UpdateTshdEventsServerAddressRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateTshdEventsServerAddressRequest): UpdateTshdEventsServerAddressRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateTshdEventsServerAddressRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.UpdateTshdEventsServerAddressRequest
 */
export const UpdateTshdEventsServerAddressRequest = new UpdateTshdEventsServerAddressRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateTshdEventsServerAddressResponse$Type extends MessageType<UpdateTshdEventsServerAddressResponse> {
    constructor() {
        super("teleport.lib.teleterm.v1.UpdateTshdEventsServerAddressResponse", []);
    }
    create(value?: PartialMessage<UpdateTshdEventsServerAddressResponse>): UpdateTshdEventsServerAddressResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdateTshdEventsServerAddressResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateTshdEventsServerAddressResponse): UpdateTshdEventsServerAddressResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: UpdateTshdEventsServerAddressResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.UpdateTshdEventsServerAddressResponse
 */
export const UpdateTshdEventsServerAddressResponse = new UpdateTshdEventsServerAddressResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateHeadlessAuthenticationStateRequest$Type extends MessageType<UpdateHeadlessAuthenticationStateRequest> {
    constructor() {
        super("teleport.lib.teleterm.v1.UpdateHeadlessAuthenticationStateRequest", [
            { no: 1, name: "root_cluster_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "headless_authentication_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "state", kind: "enum", T: () => ["teleport.lib.teleterm.v1.HeadlessAuthenticationState", HeadlessAuthenticationState, "HEADLESS_AUTHENTICATION_STATE_"] }
        ]);
    }
    create(value?: PartialMessage<UpdateHeadlessAuthenticationStateRequest>): UpdateHeadlessAuthenticationStateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rootClusterUri = "";
        message.headlessAuthenticationId = "";
        message.state = 0;
        if (value !== undefined)
            reflectionMergePartial<UpdateHeadlessAuthenticationStateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateHeadlessAuthenticationStateRequest): UpdateHeadlessAuthenticationStateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string root_cluster_uri */ 1:
                    message.rootClusterUri = reader.string();
                    break;
                case /* string headless_authentication_id */ 2:
                    message.headlessAuthenticationId = reader.string();
                    break;
                case /* teleport.lib.teleterm.v1.HeadlessAuthenticationState state */ 3:
                    message.state = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateHeadlessAuthenticationStateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string root_cluster_uri = 1; */
        if (message.rootClusterUri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.rootClusterUri);
        /* string headless_authentication_id = 2; */
        if (message.headlessAuthenticationId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.headlessAuthenticationId);
        /* teleport.lib.teleterm.v1.HeadlessAuthenticationState state = 3; */
        if (message.state !== 0)
            writer.tag(3, WireType.Varint).int32(message.state);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.UpdateHeadlessAuthenticationStateRequest
 */
export const UpdateHeadlessAuthenticationStateRequest = new UpdateHeadlessAuthenticationStateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateHeadlessAuthenticationStateResponse$Type extends MessageType<UpdateHeadlessAuthenticationStateResponse> {
    constructor() {
        super("teleport.lib.teleterm.v1.UpdateHeadlessAuthenticationStateResponse", []);
    }
    create(value?: PartialMessage<UpdateHeadlessAuthenticationStateResponse>): UpdateHeadlessAuthenticationStateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdateHeadlessAuthenticationStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateHeadlessAuthenticationStateResponse): UpdateHeadlessAuthenticationStateResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: UpdateHeadlessAuthenticationStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.UpdateHeadlessAuthenticationStateResponse
 */
export const UpdateHeadlessAuthenticationStateResponse = new UpdateHeadlessAuthenticationStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateConnectMyComputerRoleRequest$Type extends MessageType<CreateConnectMyComputerRoleRequest> {
    constructor() {
        super("teleport.lib.teleterm.v1.CreateConnectMyComputerRoleRequest", [
            { no: 1, name: "root_cluster_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CreateConnectMyComputerRoleRequest>): CreateConnectMyComputerRoleRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rootClusterUri = "";
        if (value !== undefined)
            reflectionMergePartial<CreateConnectMyComputerRoleRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateConnectMyComputerRoleRequest): CreateConnectMyComputerRoleRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string root_cluster_uri */ 1:
                    message.rootClusterUri = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateConnectMyComputerRoleRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string root_cluster_uri = 1; */
        if (message.rootClusterUri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.rootClusterUri);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.CreateConnectMyComputerRoleRequest
 */
export const CreateConnectMyComputerRoleRequest = new CreateConnectMyComputerRoleRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateConnectMyComputerRoleResponse$Type extends MessageType<CreateConnectMyComputerRoleResponse> {
    constructor() {
        super("teleport.lib.teleterm.v1.CreateConnectMyComputerRoleResponse", [
            { no: 1, name: "certs_reloaded", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CreateConnectMyComputerRoleResponse>): CreateConnectMyComputerRoleResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.certsReloaded = false;
        if (value !== undefined)
            reflectionMergePartial<CreateConnectMyComputerRoleResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateConnectMyComputerRoleResponse): CreateConnectMyComputerRoleResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool certs_reloaded */ 1:
                    message.certsReloaded = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateConnectMyComputerRoleResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool certs_reloaded = 1; */
        if (message.certsReloaded !== false)
            writer.tag(1, WireType.Varint).bool(message.certsReloaded);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.CreateConnectMyComputerRoleResponse
 */
export const CreateConnectMyComputerRoleResponse = new CreateConnectMyComputerRoleResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateConnectMyComputerNodeTokenRequest$Type extends MessageType<CreateConnectMyComputerNodeTokenRequest> {
    constructor() {
        super("teleport.lib.teleterm.v1.CreateConnectMyComputerNodeTokenRequest", [
            { no: 1, name: "root_cluster_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CreateConnectMyComputerNodeTokenRequest>): CreateConnectMyComputerNodeTokenRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rootClusterUri = "";
        if (value !== undefined)
            reflectionMergePartial<CreateConnectMyComputerNodeTokenRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateConnectMyComputerNodeTokenRequest): CreateConnectMyComputerNodeTokenRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string root_cluster_uri */ 1:
                    message.rootClusterUri = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateConnectMyComputerNodeTokenRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string root_cluster_uri = 1; */
        if (message.rootClusterUri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.rootClusterUri);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.CreateConnectMyComputerNodeTokenRequest
 */
export const CreateConnectMyComputerNodeTokenRequest = new CreateConnectMyComputerNodeTokenRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateConnectMyComputerNodeTokenResponse$Type extends MessageType<CreateConnectMyComputerNodeTokenResponse> {
    constructor() {
        super("teleport.lib.teleterm.v1.CreateConnectMyComputerNodeTokenResponse", [
            { no: 1, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CreateConnectMyComputerNodeTokenResponse>): CreateConnectMyComputerNodeTokenResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.token = "";
        if (value !== undefined)
            reflectionMergePartial<CreateConnectMyComputerNodeTokenResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateConnectMyComputerNodeTokenResponse): CreateConnectMyComputerNodeTokenResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string token */ 1:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateConnectMyComputerNodeTokenResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string token = 1; */
        if (message.token !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.CreateConnectMyComputerNodeTokenResponse
 */
export const CreateConnectMyComputerNodeTokenResponse = new CreateConnectMyComputerNodeTokenResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WaitForConnectMyComputerNodeJoinRequest$Type extends MessageType<WaitForConnectMyComputerNodeJoinRequest> {
    constructor() {
        super("teleport.lib.teleterm.v1.WaitForConnectMyComputerNodeJoinRequest", [
            { no: 1, name: "root_cluster_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WaitForConnectMyComputerNodeJoinRequest>): WaitForConnectMyComputerNodeJoinRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rootClusterUri = "";
        if (value !== undefined)
            reflectionMergePartial<WaitForConnectMyComputerNodeJoinRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WaitForConnectMyComputerNodeJoinRequest): WaitForConnectMyComputerNodeJoinRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string root_cluster_uri */ 1:
                    message.rootClusterUri = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WaitForConnectMyComputerNodeJoinRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string root_cluster_uri = 1; */
        if (message.rootClusterUri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.rootClusterUri);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.WaitForConnectMyComputerNodeJoinRequest
 */
export const WaitForConnectMyComputerNodeJoinRequest = new WaitForConnectMyComputerNodeJoinRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WaitForConnectMyComputerNodeJoinResponse$Type extends MessageType<WaitForConnectMyComputerNodeJoinResponse> {
    constructor() {
        super("teleport.lib.teleterm.v1.WaitForConnectMyComputerNodeJoinResponse", [
            { no: 1, name: "server", kind: "message", T: () => Server }
        ]);
    }
    create(value?: PartialMessage<WaitForConnectMyComputerNodeJoinResponse>): WaitForConnectMyComputerNodeJoinResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<WaitForConnectMyComputerNodeJoinResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WaitForConnectMyComputerNodeJoinResponse): WaitForConnectMyComputerNodeJoinResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.lib.teleterm.v1.Server server */ 1:
                    message.server = Server.internalBinaryRead(reader, reader.uint32(), options, message.server);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WaitForConnectMyComputerNodeJoinResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.lib.teleterm.v1.Server server = 1; */
        if (message.server)
            Server.internalBinaryWrite(message.server, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.WaitForConnectMyComputerNodeJoinResponse
 */
export const WaitForConnectMyComputerNodeJoinResponse = new WaitForConnectMyComputerNodeJoinResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteConnectMyComputerNodeRequest$Type extends MessageType<DeleteConnectMyComputerNodeRequest> {
    constructor() {
        super("teleport.lib.teleterm.v1.DeleteConnectMyComputerNodeRequest", [
            { no: 1, name: "root_cluster_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteConnectMyComputerNodeRequest>): DeleteConnectMyComputerNodeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rootClusterUri = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteConnectMyComputerNodeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteConnectMyComputerNodeRequest): DeleteConnectMyComputerNodeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string root_cluster_uri */ 1:
                    message.rootClusterUri = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteConnectMyComputerNodeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string root_cluster_uri = 1; */
        if (message.rootClusterUri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.rootClusterUri);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.DeleteConnectMyComputerNodeRequest
 */
export const DeleteConnectMyComputerNodeRequest = new DeleteConnectMyComputerNodeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteConnectMyComputerNodeResponse$Type extends MessageType<DeleteConnectMyComputerNodeResponse> {
    constructor() {
        super("teleport.lib.teleterm.v1.DeleteConnectMyComputerNodeResponse", []);
    }
    create(value?: PartialMessage<DeleteConnectMyComputerNodeResponse>): DeleteConnectMyComputerNodeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeleteConnectMyComputerNodeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteConnectMyComputerNodeResponse): DeleteConnectMyComputerNodeResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DeleteConnectMyComputerNodeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.DeleteConnectMyComputerNodeResponse
 */
export const DeleteConnectMyComputerNodeResponse = new DeleteConnectMyComputerNodeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetConnectMyComputerNodeNameRequest$Type extends MessageType<GetConnectMyComputerNodeNameRequest> {
    constructor() {
        super("teleport.lib.teleterm.v1.GetConnectMyComputerNodeNameRequest", [
            { no: 1, name: "root_cluster_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetConnectMyComputerNodeNameRequest>): GetConnectMyComputerNodeNameRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rootClusterUri = "";
        if (value !== undefined)
            reflectionMergePartial<GetConnectMyComputerNodeNameRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetConnectMyComputerNodeNameRequest): GetConnectMyComputerNodeNameRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string root_cluster_uri */ 1:
                    message.rootClusterUri = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetConnectMyComputerNodeNameRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string root_cluster_uri = 1; */
        if (message.rootClusterUri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.rootClusterUri);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.GetConnectMyComputerNodeNameRequest
 */
export const GetConnectMyComputerNodeNameRequest = new GetConnectMyComputerNodeNameRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetConnectMyComputerNodeNameResponse$Type extends MessageType<GetConnectMyComputerNodeNameResponse> {
    constructor() {
        super("teleport.lib.teleterm.v1.GetConnectMyComputerNodeNameResponse", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetConnectMyComputerNodeNameResponse>): GetConnectMyComputerNodeNameResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<GetConnectMyComputerNodeNameResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetConnectMyComputerNodeNameResponse): GetConnectMyComputerNodeNameResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetConnectMyComputerNodeNameResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.GetConnectMyComputerNodeNameResponse
 */
export const GetConnectMyComputerNodeNameResponse = new GetConnectMyComputerNodeNameResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListUnifiedResourcesRequest$Type extends MessageType<ListUnifiedResourcesRequest> {
    constructor() {
        super("teleport.lib.teleterm.v1.ListUnifiedResourcesRequest", [
            { no: 1, name: "cluster_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "kinds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "limit", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "start_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "query", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "search", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "sort_by", kind: "message", T: () => SortBy },
            { no: 8, name: "search_as_roles", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "pinned_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "include_requestable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ListUnifiedResourcesRequest>): ListUnifiedResourcesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterUri = "";
        message.kinds = [];
        message.limit = 0;
        message.startKey = "";
        message.query = "";
        message.search = "";
        message.searchAsRoles = false;
        message.pinnedOnly = false;
        message.includeRequestable = false;
        if (value !== undefined)
            reflectionMergePartial<ListUnifiedResourcesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListUnifiedResourcesRequest): ListUnifiedResourcesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_uri */ 1:
                    message.clusterUri = reader.string();
                    break;
                case /* repeated string kinds */ 2:
                    message.kinds.push(reader.string());
                    break;
                case /* int32 limit */ 3:
                    message.limit = reader.int32();
                    break;
                case /* string start_key */ 4:
                    message.startKey = reader.string();
                    break;
                case /* string query */ 5:
                    message.query = reader.string();
                    break;
                case /* string search */ 6:
                    message.search = reader.string();
                    break;
                case /* teleport.lib.teleterm.v1.SortBy sort_by */ 7:
                    message.sortBy = SortBy.internalBinaryRead(reader, reader.uint32(), options, message.sortBy);
                    break;
                case /* bool search_as_roles */ 8:
                    message.searchAsRoles = reader.bool();
                    break;
                case /* bool pinned_only */ 9:
                    message.pinnedOnly = reader.bool();
                    break;
                case /* bool include_requestable */ 10:
                    message.includeRequestable = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListUnifiedResourcesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_uri = 1; */
        if (message.clusterUri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterUri);
        /* repeated string kinds = 2; */
        for (let i = 0; i < message.kinds.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.kinds[i]);
        /* int32 limit = 3; */
        if (message.limit !== 0)
            writer.tag(3, WireType.Varint).int32(message.limit);
        /* string start_key = 4; */
        if (message.startKey !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.startKey);
        /* string query = 5; */
        if (message.query !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.query);
        /* string search = 6; */
        if (message.search !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.search);
        /* teleport.lib.teleterm.v1.SortBy sort_by = 7; */
        if (message.sortBy)
            SortBy.internalBinaryWrite(message.sortBy, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* bool search_as_roles = 8; */
        if (message.searchAsRoles !== false)
            writer.tag(8, WireType.Varint).bool(message.searchAsRoles);
        /* bool pinned_only = 9; */
        if (message.pinnedOnly !== false)
            writer.tag(9, WireType.Varint).bool(message.pinnedOnly);
        /* bool include_requestable = 10; */
        if (message.includeRequestable !== false)
            writer.tag(10, WireType.Varint).bool(message.includeRequestable);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.ListUnifiedResourcesRequest
 */
export const ListUnifiedResourcesRequest = new ListUnifiedResourcesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SortBy$Type extends MessageType<SortBy> {
    constructor() {
        super("teleport.lib.teleterm.v1.SortBy", [
            { no: 1, name: "is_desc", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "field", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SortBy>): SortBy {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isDesc = false;
        message.field = "";
        if (value !== undefined)
            reflectionMergePartial<SortBy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SortBy): SortBy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_desc */ 1:
                    message.isDesc = reader.bool();
                    break;
                case /* string field */ 2:
                    message.field = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SortBy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_desc = 1; */
        if (message.isDesc !== false)
            writer.tag(1, WireType.Varint).bool(message.isDesc);
        /* string field = 2; */
        if (message.field !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.field);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.SortBy
 */
export const SortBy = new SortBy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListUnifiedResourcesResponse$Type extends MessageType<ListUnifiedResourcesResponse> {
    constructor() {
        super("teleport.lib.teleterm.v1.ListUnifiedResourcesResponse", [
            { no: 1, name: "resources", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PaginatedResource },
            { no: 2, name: "next_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListUnifiedResourcesResponse>): ListUnifiedResourcesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.resources = [];
        message.nextKey = "";
        if (value !== undefined)
            reflectionMergePartial<ListUnifiedResourcesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListUnifiedResourcesResponse): ListUnifiedResourcesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated teleport.lib.teleterm.v1.PaginatedResource resources */ 1:
                    message.resources.push(PaginatedResource.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string next_key */ 2:
                    message.nextKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListUnifiedResourcesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated teleport.lib.teleterm.v1.PaginatedResource resources = 1; */
        for (let i = 0; i < message.resources.length; i++)
            PaginatedResource.internalBinaryWrite(message.resources[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string next_key = 2; */
        if (message.nextKey !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.nextKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.ListUnifiedResourcesResponse
 */
export const ListUnifiedResourcesResponse = new ListUnifiedResourcesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PaginatedResource$Type extends MessageType<PaginatedResource> {
    constructor() {
        super("teleport.lib.teleterm.v1.PaginatedResource", [
            { no: 1, name: "database", kind: "message", oneof: "resource", T: () => Database },
            { no: 2, name: "server", kind: "message", oneof: "resource", T: () => Server },
            { no: 3, name: "kube", kind: "message", oneof: "resource", T: () => Kube },
            { no: 4, name: "app", kind: "message", oneof: "resource", T: () => App },
            { no: 5, name: "requires_request", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<PaginatedResource>): PaginatedResource {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.resource = { oneofKind: undefined };
        message.requiresRequest = false;
        if (value !== undefined)
            reflectionMergePartial<PaginatedResource>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PaginatedResource): PaginatedResource {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.lib.teleterm.v1.Database database */ 1:
                    message.resource = {
                        oneofKind: "database",
                        database: Database.internalBinaryRead(reader, reader.uint32(), options, (message.resource as any).database)
                    };
                    break;
                case /* teleport.lib.teleterm.v1.Server server */ 2:
                    message.resource = {
                        oneofKind: "server",
                        server: Server.internalBinaryRead(reader, reader.uint32(), options, (message.resource as any).server)
                    };
                    break;
                case /* teleport.lib.teleterm.v1.Kube kube */ 3:
                    message.resource = {
                        oneofKind: "kube",
                        kube: Kube.internalBinaryRead(reader, reader.uint32(), options, (message.resource as any).kube)
                    };
                    break;
                case /* teleport.lib.teleterm.v1.App app */ 4:
                    message.resource = {
                        oneofKind: "app",
                        app: App.internalBinaryRead(reader, reader.uint32(), options, (message.resource as any).app)
                    };
                    break;
                case /* bool requires_request */ 5:
                    message.requiresRequest = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PaginatedResource, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.lib.teleterm.v1.Database database = 1; */
        if (message.resource.oneofKind === "database")
            Database.internalBinaryWrite(message.resource.database, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* teleport.lib.teleterm.v1.Server server = 2; */
        if (message.resource.oneofKind === "server")
            Server.internalBinaryWrite(message.resource.server, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* teleport.lib.teleterm.v1.Kube kube = 3; */
        if (message.resource.oneofKind === "kube")
            Kube.internalBinaryWrite(message.resource.kube, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* teleport.lib.teleterm.v1.App app = 4; */
        if (message.resource.oneofKind === "app")
            App.internalBinaryWrite(message.resource.app, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bool requires_request = 5; */
        if (message.requiresRequest !== false)
            writer.tag(5, WireType.Varint).bool(message.requiresRequest);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.PaginatedResource
 */
export const PaginatedResource = new PaginatedResource$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetUserPreferencesRequest$Type extends MessageType<GetUserPreferencesRequest> {
    constructor() {
        super("teleport.lib.teleterm.v1.GetUserPreferencesRequest", [
            { no: 1, name: "cluster_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetUserPreferencesRequest>): GetUserPreferencesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterUri = "";
        if (value !== undefined)
            reflectionMergePartial<GetUserPreferencesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUserPreferencesRequest): GetUserPreferencesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_uri */ 1:
                    message.clusterUri = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetUserPreferencesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_uri = 1; */
        if (message.clusterUri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterUri);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.GetUserPreferencesRequest
 */
export const GetUserPreferencesRequest = new GetUserPreferencesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetUserPreferencesResponse$Type extends MessageType<GetUserPreferencesResponse> {
    constructor() {
        super("teleport.lib.teleterm.v1.GetUserPreferencesResponse", [
            { no: 1, name: "user_preferences", kind: "message", T: () => UserPreferences }
        ]);
    }
    create(value?: PartialMessage<GetUserPreferencesResponse>): GetUserPreferencesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetUserPreferencesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUserPreferencesResponse): GetUserPreferencesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.lib.teleterm.v1.UserPreferences user_preferences */ 1:
                    message.userPreferences = UserPreferences.internalBinaryRead(reader, reader.uint32(), options, message.userPreferences);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetUserPreferencesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.lib.teleterm.v1.UserPreferences user_preferences = 1; */
        if (message.userPreferences)
            UserPreferences.internalBinaryWrite(message.userPreferences, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.GetUserPreferencesResponse
 */
export const GetUserPreferencesResponse = new GetUserPreferencesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateUserPreferencesRequest$Type extends MessageType<UpdateUserPreferencesRequest> {
    constructor() {
        super("teleport.lib.teleterm.v1.UpdateUserPreferencesRequest", [
            { no: 1, name: "cluster_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "user_preferences", kind: "message", T: () => UserPreferences }
        ]);
    }
    create(value?: PartialMessage<UpdateUserPreferencesRequest>): UpdateUserPreferencesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterUri = "";
        if (value !== undefined)
            reflectionMergePartial<UpdateUserPreferencesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateUserPreferencesRequest): UpdateUserPreferencesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_uri */ 1:
                    message.clusterUri = reader.string();
                    break;
                case /* teleport.lib.teleterm.v1.UserPreferences user_preferences */ 2:
                    message.userPreferences = UserPreferences.internalBinaryRead(reader, reader.uint32(), options, message.userPreferences);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateUserPreferencesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_uri = 1; */
        if (message.clusterUri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterUri);
        /* teleport.lib.teleterm.v1.UserPreferences user_preferences = 2; */
        if (message.userPreferences)
            UserPreferences.internalBinaryWrite(message.userPreferences, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.UpdateUserPreferencesRequest
 */
export const UpdateUserPreferencesRequest = new UpdateUserPreferencesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateUserPreferencesResponse$Type extends MessageType<UpdateUserPreferencesResponse> {
    constructor() {
        super("teleport.lib.teleterm.v1.UpdateUserPreferencesResponse", [
            { no: 1, name: "user_preferences", kind: "message", T: () => UserPreferences }
        ]);
    }
    create(value?: PartialMessage<UpdateUserPreferencesResponse>): UpdateUserPreferencesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdateUserPreferencesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateUserPreferencesResponse): UpdateUserPreferencesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.lib.teleterm.v1.UserPreferences user_preferences */ 1:
                    message.userPreferences = UserPreferences.internalBinaryRead(reader, reader.uint32(), options, message.userPreferences);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateUserPreferencesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.lib.teleterm.v1.UserPreferences user_preferences = 1; */
        if (message.userPreferences)
            UserPreferences.internalBinaryWrite(message.userPreferences, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.UpdateUserPreferencesResponse
 */
export const UpdateUserPreferencesResponse = new UpdateUserPreferencesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserPreferences$Type extends MessageType<UserPreferences> {
    constructor() {
        super("teleport.lib.teleterm.v1.UserPreferences", [
            { no: 1, name: "cluster_preferences", kind: "message", T: () => ClusterUserPreferences },
            { no: 2, name: "unified_resource_preferences", kind: "message", T: () => UnifiedResourcePreferences }
        ]);
    }
    create(value?: PartialMessage<UserPreferences>): UserPreferences {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UserPreferences>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserPreferences): UserPreferences {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.userpreferences.v1.ClusterUserPreferences cluster_preferences */ 1:
                    message.clusterPreferences = ClusterUserPreferences.internalBinaryRead(reader, reader.uint32(), options, message.clusterPreferences);
                    break;
                case /* teleport.userpreferences.v1.UnifiedResourcePreferences unified_resource_preferences */ 2:
                    message.unifiedResourcePreferences = UnifiedResourcePreferences.internalBinaryRead(reader, reader.uint32(), options, message.unifiedResourcePreferences);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserPreferences, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.userpreferences.v1.ClusterUserPreferences cluster_preferences = 1; */
        if (message.clusterPreferences)
            ClusterUserPreferences.internalBinaryWrite(message.clusterPreferences, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* teleport.userpreferences.v1.UnifiedResourcePreferences unified_resource_preferences = 2; */
        if (message.unifiedResourcePreferences)
            UnifiedResourcePreferences.internalBinaryWrite(message.unifiedResourcePreferences, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.UserPreferences
 */
export const UserPreferences = new UserPreferences$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthenticateWebDeviceRequest$Type extends MessageType<AuthenticateWebDeviceRequest> {
    constructor() {
        super("teleport.lib.teleterm.v1.AuthenticateWebDeviceRequest", [
            { no: 1, name: "device_web_token", kind: "message", T: () => DeviceWebToken },
            { no: 2, name: "root_cluster_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AuthenticateWebDeviceRequest>): AuthenticateWebDeviceRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rootClusterUri = "";
        if (value !== undefined)
            reflectionMergePartial<AuthenticateWebDeviceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthenticateWebDeviceRequest): AuthenticateWebDeviceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.devicetrust.v1.DeviceWebToken device_web_token */ 1:
                    message.deviceWebToken = DeviceWebToken.internalBinaryRead(reader, reader.uint32(), options, message.deviceWebToken);
                    break;
                case /* string root_cluster_uri */ 2:
                    message.rootClusterUri = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthenticateWebDeviceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.devicetrust.v1.DeviceWebToken device_web_token = 1; */
        if (message.deviceWebToken)
            DeviceWebToken.internalBinaryWrite(message.deviceWebToken, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string root_cluster_uri = 2; */
        if (message.rootClusterUri !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.rootClusterUri);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.AuthenticateWebDeviceRequest
 */
export const AuthenticateWebDeviceRequest = new AuthenticateWebDeviceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthenticateWebDeviceResponse$Type extends MessageType<AuthenticateWebDeviceResponse> {
    constructor() {
        super("teleport.lib.teleterm.v1.AuthenticateWebDeviceResponse", [
            { no: 1, name: "confirmation_token", kind: "message", T: () => DeviceConfirmationToken }
        ]);
    }
    create(value?: PartialMessage<AuthenticateWebDeviceResponse>): AuthenticateWebDeviceResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AuthenticateWebDeviceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthenticateWebDeviceResponse): AuthenticateWebDeviceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.devicetrust.v1.DeviceConfirmationToken confirmation_token */ 1:
                    message.confirmationToken = DeviceConfirmationToken.internalBinaryRead(reader, reader.uint32(), options, message.confirmationToken);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthenticateWebDeviceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.devicetrust.v1.DeviceConfirmationToken confirmation_token = 1; */
        if (message.confirmationToken)
            DeviceConfirmationToken.internalBinaryWrite(message.confirmationToken, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.v1.AuthenticateWebDeviceResponse
 */
export const AuthenticateWebDeviceResponse = new AuthenticateWebDeviceResponse$Type();
/**
 * @generated ServiceType for protobuf service teleport.lib.teleterm.v1.TerminalService
 */
export const TerminalService = new ServiceType("teleport.lib.teleterm.v1.TerminalService", [
    { name: "UpdateTshdEventsServerAddress", options: {}, I: UpdateTshdEventsServerAddressRequest, O: UpdateTshdEventsServerAddressResponse },
    { name: "ListRootClusters", options: {}, I: ListClustersRequest, O: ListClustersResponse },
    { name: "ListLeafClusters", options: {}, I: ListLeafClustersRequest, O: ListClustersResponse },
    { name: "GetDatabases", options: {}, I: GetDatabasesRequest, O: GetDatabasesResponse },
    { name: "ListDatabaseUsers", options: {}, I: ListDatabaseUsersRequest, O: ListDatabaseUsersResponse },
    { name: "GetServers", options: {}, I: GetServersRequest, O: GetServersResponse },
    { name: "GetAccessRequests", options: {}, I: GetAccessRequestsRequest, O: GetAccessRequestsResponse },
    { name: "GetAccessRequest", options: {}, I: GetAccessRequestRequest, O: GetAccessRequestResponse },
    { name: "DeleteAccessRequest", options: {}, I: DeleteAccessRequestRequest, O: EmptyResponse },
    { name: "CreateAccessRequest", options: {}, I: CreateAccessRequestRequest, O: CreateAccessRequestResponse },
    { name: "ReviewAccessRequest", options: {}, I: ReviewAccessRequestRequest, O: ReviewAccessRequestResponse },
    { name: "GetRequestableRoles", options: {}, I: GetRequestableRolesRequest, O: GetRequestableRolesResponse },
    { name: "AssumeRole", options: {}, I: AssumeRoleRequest, O: EmptyResponse },
    { name: "PromoteAccessRequest", options: {}, I: PromoteAccessRequestRequest, O: PromoteAccessRequestResponse },
    { name: "GetSuggestedAccessLists", options: {}, I: GetSuggestedAccessListsRequest, O: GetSuggestedAccessListsResponse },
    { name: "GetKubes", options: {}, I: GetKubesRequest, O: GetKubesResponse },
    { name: "GetApps", options: {}, I: GetAppsRequest, O: GetAppsResponse },
    { name: "AddCluster", options: {}, I: AddClusterRequest, O: Cluster },
    { name: "RemoveCluster", options: {}, I: RemoveClusterRequest, O: EmptyResponse },
    { name: "ListGateways", options: {}, I: ListGatewaysRequest, O: ListGatewaysResponse },
    { name: "CreateGateway", options: {}, I: CreateGatewayRequest, O: Gateway },
    { name: "RemoveGateway", options: {}, I: RemoveGatewayRequest, O: EmptyResponse },
    { name: "SetGatewayTargetSubresourceName", options: {}, I: SetGatewayTargetSubresourceNameRequest, O: Gateway },
    { name: "SetGatewayLocalPort", options: {}, I: SetGatewayLocalPortRequest, O: Gateway },
    { name: "GetAuthSettings", options: {}, I: GetAuthSettingsRequest, O: AuthSettings },
    { name: "GetCluster", options: {}, I: GetClusterRequest, O: Cluster },
    { name: "Login", options: {}, I: LoginRequest, O: EmptyResponse },
    { name: "LoginPasswordless", serverStreaming: true, clientStreaming: true, options: {}, I: LoginPasswordlessRequest, O: LoginPasswordlessResponse },
    { name: "Logout", options: {}, I: LogoutRequest, O: EmptyResponse },
    { name: "TransferFile", serverStreaming: true, options: {}, I: FileTransferRequest, O: FileTransferProgress },
    { name: "ReportUsageEvent", options: {}, I: ReportUsageEventRequest, O: EmptyResponse },
    { name: "UpdateHeadlessAuthenticationState", options: {}, I: UpdateHeadlessAuthenticationStateRequest, O: UpdateHeadlessAuthenticationStateResponse },
    { name: "CreateConnectMyComputerRole", options: {}, I: CreateConnectMyComputerRoleRequest, O: CreateConnectMyComputerRoleResponse },
    { name: "CreateConnectMyComputerNodeToken", options: {}, I: CreateConnectMyComputerNodeTokenRequest, O: CreateConnectMyComputerNodeTokenResponse },
    { name: "WaitForConnectMyComputerNodeJoin", options: {}, I: WaitForConnectMyComputerNodeJoinRequest, O: WaitForConnectMyComputerNodeJoinResponse },
    { name: "DeleteConnectMyComputerNode", options: {}, I: DeleteConnectMyComputerNodeRequest, O: DeleteConnectMyComputerNodeResponse },
    { name: "GetConnectMyComputerNodeName", options: {}, I: GetConnectMyComputerNodeNameRequest, O: GetConnectMyComputerNodeNameResponse },
    { name: "ListUnifiedResources", options: {}, I: ListUnifiedResourcesRequest, O: ListUnifiedResourcesResponse },
    { name: "GetUserPreferences", options: {}, I: GetUserPreferencesRequest, O: GetUserPreferencesResponse },
    { name: "UpdateUserPreferences", options: {}, I: UpdateUserPreferencesRequest, O: UpdateUserPreferencesResponse },
    { name: "AuthenticateWebDevice", options: {}, I: AuthenticateWebDeviceRequest, O: AuthenticateWebDeviceResponse }
]);
