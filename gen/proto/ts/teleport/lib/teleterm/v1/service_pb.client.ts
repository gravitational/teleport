/* eslint-disable */
// @generated by protobuf-ts 2.9.3 with parameter eslint_disable,add_pb_suffix,server_grpc1,ts_nocheck
// @generated from protobuf file "teleport/lib/teleterm/v1/service.proto" (package "teleport.lib.teleterm.v1", syntax proto3)
// tslint:disable
// @ts-nocheck
//
//
// Teleport
// Copyright (C) 2023  Gravitational, Inc.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { TerminalService } from "./service_pb";
import type { GetAppResponse } from "./service_pb";
import type { GetAppRequest } from "./service_pb";
import type { AuthenticateWebDeviceResponse } from "./service_pb";
import type { AuthenticateWebDeviceRequest } from "./service_pb";
import type { UpdateUserPreferencesResponse } from "./service_pb";
import type { UpdateUserPreferencesRequest } from "./service_pb";
import type { GetUserPreferencesResponse } from "./service_pb";
import type { GetUserPreferencesRequest } from "./service_pb";
import type { ListUnifiedResourcesResponse } from "./service_pb";
import type { ListUnifiedResourcesRequest } from "./service_pb";
import type { GetConnectMyComputerNodeNameResponse } from "./service_pb";
import type { GetConnectMyComputerNodeNameRequest } from "./service_pb";
import type { DeleteConnectMyComputerNodeResponse } from "./service_pb";
import type { DeleteConnectMyComputerNodeRequest } from "./service_pb";
import type { WaitForConnectMyComputerNodeJoinResponse } from "./service_pb";
import type { WaitForConnectMyComputerNodeJoinRequest } from "./service_pb";
import type { CreateConnectMyComputerNodeTokenResponse } from "./service_pb";
import type { CreateConnectMyComputerNodeTokenRequest } from "./service_pb";
import type { CreateConnectMyComputerRoleResponse } from "./service_pb";
import type { CreateConnectMyComputerRoleRequest } from "./service_pb";
import type { UpdateHeadlessAuthenticationStateResponse } from "./service_pb";
import type { UpdateHeadlessAuthenticationStateRequest } from "./service_pb";
import type { ReportUsageEventRequest } from "./usage_events_pb";
import type { FileTransferProgress } from "./service_pb";
import type { FileTransferRequest } from "./service_pb";
import type { ServerStreamingCall } from "@protobuf-ts/runtime-rpc";
import type { LogoutRequest } from "./service_pb";
import type { LoginPasswordlessResponse } from "./service_pb";
import type { LoginPasswordlessRequest } from "./service_pb";
import type { DuplexStreamingCall } from "@protobuf-ts/runtime-rpc";
import type { LoginRequest } from "./service_pb";
import type { GetClusterRequest } from "./service_pb";
import type { AuthSettings } from "./auth_settings_pb";
import type { GetAuthSettingsRequest } from "./service_pb";
import type { SetGatewayLocalPortRequest } from "./service_pb";
import type { SetGatewayTargetSubresourceNameRequest } from "./service_pb";
import type { RemoveGatewayRequest } from "./service_pb";
import type { Gateway } from "./gateway_pb";
import type { CreateGatewayRequest } from "./service_pb";
import type { ListGatewaysResponse } from "./service_pb";
import type { ListGatewaysRequest } from "./service_pb";
import type { RemoveClusterRequest } from "./service_pb";
import type { Cluster } from "./cluster_pb";
import type { AddClusterRequest } from "./service_pb";
import type { ListKubernetesResourcesResponse } from "./service_pb";
import type { ListKubernetesResourcesRequest } from "./service_pb";
import type { GetSuggestedAccessListsResponse } from "./service_pb";
import type { GetSuggestedAccessListsRequest } from "./service_pb";
import type { PromoteAccessRequestResponse } from "./service_pb";
import type { PromoteAccessRequestRequest } from "./service_pb";
import type { AssumeRoleRequest } from "./service_pb";
import type { GetRequestableRolesResponse } from "./service_pb";
import type { GetRequestableRolesRequest } from "./service_pb";
import type { ReviewAccessRequestResponse } from "./service_pb";
import type { ReviewAccessRequestRequest } from "./service_pb";
import type { CreateAccessRequestResponse } from "./service_pb";
import type { CreateAccessRequestRequest } from "./service_pb";
import type { EmptyResponse } from "./service_pb";
import type { DeleteAccessRequestRequest } from "./service_pb";
import type { GetAccessRequestResponse } from "./service_pb";
import type { GetAccessRequestRequest } from "./service_pb";
import type { GetAccessRequestsResponse } from "./service_pb";
import type { GetAccessRequestsRequest } from "./service_pb";
import type { GetServersResponse } from "./service_pb";
import type { GetServersRequest } from "./service_pb";
import type { ListDatabaseUsersResponse } from "./service_pb";
import type { ListDatabaseUsersRequest } from "./service_pb";
import type { StartHeadlessWatcherResponse } from "./service_pb";
import type { StartHeadlessWatcherRequest } from "./service_pb";
import type { ListLeafClustersRequest } from "./service_pb";
import type { ListClustersResponse } from "./service_pb";
import type { ListClustersRequest } from "./service_pb";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import type { UpdateTshdEventsServerAddressResponse } from "./service_pb";
import type { UpdateTshdEventsServerAddressRequest } from "./service_pb";
import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * TerminalService is used by the Electron app to communicate with the tsh daemon.
 *
 * While we aim to preserve backwards compatibility in order to satisfy CI checks and follow the
 * proto practices used within the company, this service is not guaranteed to be stable across
 * versions. The packaging process of Teleport Connect ensures that the server and the client use
 * the same version of the service.
 *
 * @generated from protobuf service teleport.lib.teleterm.v1.TerminalService
 */
export interface ITerminalServiceClient {
    /**
     * UpdateTshdEventsServerAddress lets the Electron app update the address the tsh daemon is
     * supposed to use when connecting to the tshd events gRPC service. This RPC needs to be made
     * before any other from this service.
     *
     * The service is supposed to return a response from this call only after the client is ready.
     *
     * @generated from protobuf rpc: UpdateTshdEventsServerAddress(teleport.lib.teleterm.v1.UpdateTshdEventsServerAddressRequest) returns (teleport.lib.teleterm.v1.UpdateTshdEventsServerAddressResponse);
     */
    updateTshdEventsServerAddress(input: UpdateTshdEventsServerAddressRequest, options?: RpcOptions): UnaryCall<UpdateTshdEventsServerAddressRequest, UpdateTshdEventsServerAddressResponse>;
    /**
     * ListRootClusters lists root clusters
     * Does not include detailed cluster information that would require a network request.
     *
     * @generated from protobuf rpc: ListRootClusters(teleport.lib.teleterm.v1.ListClustersRequest) returns (teleport.lib.teleterm.v1.ListClustersResponse);
     */
    listRootClusters(input: ListClustersRequest, options?: RpcOptions): UnaryCall<ListClustersRequest, ListClustersResponse>;
    /**
     * ListLeafClusters lists leaf clusters
     * Does not include detailed cluster information that would require a network request.
     *
     * @generated from protobuf rpc: ListLeafClusters(teleport.lib.teleterm.v1.ListLeafClustersRequest) returns (teleport.lib.teleterm.v1.ListClustersResponse);
     */
    listLeafClusters(input: ListLeafClustersRequest, options?: RpcOptions): UnaryCall<ListLeafClustersRequest, ListClustersResponse>;
    /**
     * StartHeadlessWatcher starts a headless watcher.
     * If the watcher is already running, it is restarted.
     *
     * @generated from protobuf rpc: StartHeadlessWatcher(teleport.lib.teleterm.v1.StartHeadlessWatcherRequest) returns (teleport.lib.teleterm.v1.StartHeadlessWatcherResponse);
     */
    startHeadlessWatcher(input: StartHeadlessWatcherRequest, options?: RpcOptions): UnaryCall<StartHeadlessWatcherRequest, StartHeadlessWatcherResponse>;
    /**
     * ListDatabaseUsers lists allowed users for the given database based on the role set.
     *
     * @generated from protobuf rpc: ListDatabaseUsers(teleport.lib.teleterm.v1.ListDatabaseUsersRequest) returns (teleport.lib.teleterm.v1.ListDatabaseUsersResponse);
     */
    listDatabaseUsers(input: ListDatabaseUsersRequest, options?: RpcOptions): UnaryCall<ListDatabaseUsersRequest, ListDatabaseUsersResponse>;
    /**
     * GetServers returns filtered, sorted, and paginated servers
     *
     * Deprecated: Use ListUnifiedResources instead.
     *
     * @deprecated
     * @generated from protobuf rpc: GetServers(teleport.lib.teleterm.v1.GetServersRequest) returns (teleport.lib.teleterm.v1.GetServersResponse);
     */
    getServers(input: GetServersRequest, options?: RpcOptions): UnaryCall<GetServersRequest, GetServersResponse>;
    /**
     * GetAccessRequests lists filtered AccessRequests
     *
     * @generated from protobuf rpc: GetAccessRequests(teleport.lib.teleterm.v1.GetAccessRequestsRequest) returns (teleport.lib.teleterm.v1.GetAccessRequestsResponse);
     */
    getAccessRequests(input: GetAccessRequestsRequest, options?: RpcOptions): UnaryCall<GetAccessRequestsRequest, GetAccessRequestsResponse>;
    /**
     * GetAccessRequest retreives a single Access Request
     *
     * @generated from protobuf rpc: GetAccessRequest(teleport.lib.teleterm.v1.GetAccessRequestRequest) returns (teleport.lib.teleterm.v1.GetAccessRequestResponse);
     */
    getAccessRequest(input: GetAccessRequestRequest, options?: RpcOptions): UnaryCall<GetAccessRequestRequest, GetAccessRequestResponse>;
    /**
     * DeleteAccessRequest deletes the access request by id
     *
     * @generated from protobuf rpc: DeleteAccessRequest(teleport.lib.teleterm.v1.DeleteAccessRequestRequest) returns (teleport.lib.teleterm.v1.EmptyResponse);
     */
    deleteAccessRequest(input: DeleteAccessRequestRequest, options?: RpcOptions): UnaryCall<DeleteAccessRequestRequest, EmptyResponse>;
    /**
     * CreateAccessRequest creates an access request
     *
     * @generated from protobuf rpc: CreateAccessRequest(teleport.lib.teleterm.v1.CreateAccessRequestRequest) returns (teleport.lib.teleterm.v1.CreateAccessRequestResponse);
     */
    createAccessRequest(input: CreateAccessRequestRequest, options?: RpcOptions): UnaryCall<CreateAccessRequestRequest, CreateAccessRequestResponse>;
    /**
     * ReviewAccessRequest submits a review for an Access Request
     *
     * @generated from protobuf rpc: ReviewAccessRequest(teleport.lib.teleterm.v1.ReviewAccessRequestRequest) returns (teleport.lib.teleterm.v1.ReviewAccessRequestResponse);
     */
    reviewAccessRequest(input: ReviewAccessRequestRequest, options?: RpcOptions): UnaryCall<ReviewAccessRequestRequest, ReviewAccessRequestResponse>;
    /**
     * GetRequestableRoles gets all requestable roles
     *
     * @generated from protobuf rpc: GetRequestableRoles(teleport.lib.teleterm.v1.GetRequestableRolesRequest) returns (teleport.lib.teleterm.v1.GetRequestableRolesResponse);
     */
    getRequestableRoles(input: GetRequestableRolesRequest, options?: RpcOptions): UnaryCall<GetRequestableRolesRequest, GetRequestableRolesResponse>;
    /**
     * AssumeRole assumes the role of the given access request
     *
     * @generated from protobuf rpc: AssumeRole(teleport.lib.teleterm.v1.AssumeRoleRequest) returns (teleport.lib.teleterm.v1.EmptyResponse);
     */
    assumeRole(input: AssumeRoleRequest, options?: RpcOptions): UnaryCall<AssumeRoleRequest, EmptyResponse>;
    /**
     * PromoteAccessRequest promotes an access request to an access list.
     *
     * @generated from protobuf rpc: PromoteAccessRequest(teleport.lib.teleterm.v1.PromoteAccessRequestRequest) returns (teleport.lib.teleterm.v1.PromoteAccessRequestResponse);
     */
    promoteAccessRequest(input: PromoteAccessRequestRequest, options?: RpcOptions): UnaryCall<PromoteAccessRequestRequest, PromoteAccessRequestResponse>;
    /**
     * GetSuggestedAccessLists returns suggested access lists for an access request.
     *
     * @generated from protobuf rpc: GetSuggestedAccessLists(teleport.lib.teleterm.v1.GetSuggestedAccessListsRequest) returns (teleport.lib.teleterm.v1.GetSuggestedAccessListsResponse);
     */
    getSuggestedAccessLists(input: GetSuggestedAccessListsRequest, options?: RpcOptions): UnaryCall<GetSuggestedAccessListsRequest, GetSuggestedAccessListsResponse>;
    /**
     * ListKubernetesResourcesRequest defines a request to retrieve kube resources paginated.
     * Only one type of kube resource can be retrieved per request (eg: namespace, pods, secrets, etc.)
     *
     * @generated from protobuf rpc: ListKubernetesResources(teleport.lib.teleterm.v1.ListKubernetesResourcesRequest) returns (teleport.lib.teleterm.v1.ListKubernetesResourcesResponse);
     */
    listKubernetesResources(input: ListKubernetesResourcesRequest, options?: RpcOptions): UnaryCall<ListKubernetesResourcesRequest, ListKubernetesResourcesResponse>;
    /**
     * AddCluster adds a cluster to profile
     *
     * @generated from protobuf rpc: AddCluster(teleport.lib.teleterm.v1.AddClusterRequest) returns (teleport.lib.teleterm.v1.Cluster);
     */
    addCluster(input: AddClusterRequest, options?: RpcOptions): UnaryCall<AddClusterRequest, Cluster>;
    /**
     * RemoveCluster removes a cluster from profile
     *
     * @generated from protobuf rpc: RemoveCluster(teleport.lib.teleterm.v1.RemoveClusterRequest) returns (teleport.lib.teleterm.v1.EmptyResponse);
     */
    removeCluster(input: RemoveClusterRequest, options?: RpcOptions): UnaryCall<RemoveClusterRequest, EmptyResponse>;
    /**
     * ListGateways lists gateways
     *
     * @generated from protobuf rpc: ListGateways(teleport.lib.teleterm.v1.ListGatewaysRequest) returns (teleport.lib.teleterm.v1.ListGatewaysResponse);
     */
    listGateways(input: ListGatewaysRequest, options?: RpcOptions): UnaryCall<ListGatewaysRequest, ListGatewaysResponse>;
    /**
     * CreateGateway creates a gateway
     *
     * @generated from protobuf rpc: CreateGateway(teleport.lib.teleterm.v1.CreateGatewayRequest) returns (teleport.lib.teleterm.v1.Gateway);
     */
    createGateway(input: CreateGatewayRequest, options?: RpcOptions): UnaryCall<CreateGatewayRequest, Gateway>;
    /**
     * RemoveGateway removes a gateway
     *
     * @generated from protobuf rpc: RemoveGateway(teleport.lib.teleterm.v1.RemoveGatewayRequest) returns (teleport.lib.teleterm.v1.EmptyResponse);
     */
    removeGateway(input: RemoveGatewayRequest, options?: RpcOptions): UnaryCall<RemoveGatewayRequest, EmptyResponse>;
    /**
     * SetGatewayTargetSubresourceName changes the TargetSubresourceName field of gateway.Gateway
     * and returns the updated version of gateway.Gateway.
     *
     * In Connect this is used to update the db name of a db connection along with the CLI command.
     *
     * @generated from protobuf rpc: SetGatewayTargetSubresourceName(teleport.lib.teleterm.v1.SetGatewayTargetSubresourceNameRequest) returns (teleport.lib.teleterm.v1.Gateway);
     */
    setGatewayTargetSubresourceName(input: SetGatewayTargetSubresourceNameRequest, options?: RpcOptions): UnaryCall<SetGatewayTargetSubresourceNameRequest, Gateway>;
    /**
     * SetGatewayLocalPort starts a new gateway on the new port, stops the old gateway and then
     * assigns the URI of the old gateway to the new one. It does so without fetching a new db cert.
     *
     * @generated from protobuf rpc: SetGatewayLocalPort(teleport.lib.teleterm.v1.SetGatewayLocalPortRequest) returns (teleport.lib.teleterm.v1.Gateway);
     */
    setGatewayLocalPort(input: SetGatewayLocalPortRequest, options?: RpcOptions): UnaryCall<SetGatewayLocalPortRequest, Gateway>;
    /**
     * GetAuthSettings returns cluster auth settigns
     *
     * @generated from protobuf rpc: GetAuthSettings(teleport.lib.teleterm.v1.GetAuthSettingsRequest) returns (teleport.lib.teleterm.v1.AuthSettings);
     */
    getAuthSettings(input: GetAuthSettingsRequest, options?: RpcOptions): UnaryCall<GetAuthSettingsRequest, AuthSettings>;
    /**
     * GetCluster returns cluster. Makes a network request and includes detailed
     * information about enterprise features availabed on the connected auth server
     *
     * @generated from protobuf rpc: GetCluster(teleport.lib.teleterm.v1.GetClusterRequest) returns (teleport.lib.teleterm.v1.Cluster);
     */
    getCluster(input: GetClusterRequest, options?: RpcOptions): UnaryCall<GetClusterRequest, Cluster>;
    /**
     * Login logs in a user to a cluster
     *
     * @generated from protobuf rpc: Login(teleport.lib.teleterm.v1.LoginRequest) returns (teleport.lib.teleterm.v1.EmptyResponse);
     */
    login(input: LoginRequest, options?: RpcOptions): UnaryCall<LoginRequest, EmptyResponse>;
    /**
     * LoginPasswordless logs in a user to a cluster passwordlessly.
     *
     * The RPC is streaming both ways and the message sequence example for hardware keys are:
     * (-> means client-to-server, <- means server-to-client)
     *
     * Hardware keys:
     * -> Init
     * <- Send PasswordlessPrompt enum TAP to choose a device
     * -> Receive TAP device response
     * <- Send PasswordlessPrompt enum PIN
     * -> Receive PIN response
     * <- Send PasswordlessPrompt enum RETAP to confirm
     * -> Receive RETAP device response
     * <- Send list of credentials (e.g. usernames) associated with device
     * -> Receive the index number associated with the selected credential in list
     * <- End
     *
     * @generated from protobuf rpc: LoginPasswordless(stream teleport.lib.teleterm.v1.LoginPasswordlessRequest) returns (stream teleport.lib.teleterm.v1.LoginPasswordlessResponse);
     */
    loginPasswordless(options?: RpcOptions): DuplexStreamingCall<LoginPasswordlessRequest, LoginPasswordlessResponse>;
    /**
     * ClusterLogin logs out a user from cluster
     *
     * @generated from protobuf rpc: Logout(teleport.lib.teleterm.v1.LogoutRequest) returns (teleport.lib.teleterm.v1.EmptyResponse);
     */
    logout(input: LogoutRequest, options?: RpcOptions): UnaryCall<LogoutRequest, EmptyResponse>;
    /**
     * TransferFile sends a request to download/upload a file
     *
     * @generated from protobuf rpc: TransferFile(teleport.lib.teleterm.v1.FileTransferRequest) returns (stream teleport.lib.teleterm.v1.FileTransferProgress);
     */
    transferFile(input: FileTransferRequest, options?: RpcOptions): ServerStreamingCall<FileTransferRequest, FileTransferProgress>;
    /**
     * ReportUsageEvent allows to send usage events that are then anonymized and forwarded to prehog
     *
     * @generated from protobuf rpc: ReportUsageEvent(teleport.lib.teleterm.v1.ReportUsageEventRequest) returns (teleport.lib.teleterm.v1.EmptyResponse);
     */
    reportUsageEvent(input: ReportUsageEventRequest, options?: RpcOptions): UnaryCall<ReportUsageEventRequest, EmptyResponse>;
    /**
     * UpdateHeadlessAuthenticationState updates a headless authentication resource's state.
     * An MFA challenge will be prompted when approving a headless authentication.
     *
     * @generated from protobuf rpc: UpdateHeadlessAuthenticationState(teleport.lib.teleterm.v1.UpdateHeadlessAuthenticationStateRequest) returns (teleport.lib.teleterm.v1.UpdateHeadlessAuthenticationStateResponse);
     */
    updateHeadlessAuthenticationState(input: UpdateHeadlessAuthenticationStateRequest, options?: RpcOptions): UnaryCall<UpdateHeadlessAuthenticationStateRequest, UpdateHeadlessAuthenticationStateResponse>;
    /**
     * CreateConnectMyComputerRole creates a role which allows access to nodes with the label
     * teleport.dev/connect-my-computer/owner: <cluster user> and allows logging in to those nodes as
     * the current system user.
     *
     * @generated from protobuf rpc: CreateConnectMyComputerRole(teleport.lib.teleterm.v1.CreateConnectMyComputerRoleRequest) returns (teleport.lib.teleterm.v1.CreateConnectMyComputerRoleResponse);
     */
    createConnectMyComputerRole(input: CreateConnectMyComputerRoleRequest, options?: RpcOptions): UnaryCall<CreateConnectMyComputerRoleRequest, CreateConnectMyComputerRoleResponse>;
    /**
     * CreateConnectMyComputerNodeToken creates a node join token that is valid for 5 minutes
     *
     * @generated from protobuf rpc: CreateConnectMyComputerNodeToken(teleport.lib.teleterm.v1.CreateConnectMyComputerNodeTokenRequest) returns (teleport.lib.teleterm.v1.CreateConnectMyComputerNodeTokenResponse);
     */
    createConnectMyComputerNodeToken(input: CreateConnectMyComputerNodeTokenRequest, options?: RpcOptions): UnaryCall<CreateConnectMyComputerNodeTokenRequest, CreateConnectMyComputerNodeTokenResponse>;
    /**
     * WaitForConnectMyComputerNodeJoin sets up a watcher and returns a response only after detecting
     * that the Connect My Computer node for the particular cluster has joined the cluster (the
     * OpPut event).
     *
     * This RPC times out by itself after a minute to prevent the request from hanging forever, in
     * case the client didn't set a deadline or doesn't abort the request.
     *
     * @generated from protobuf rpc: WaitForConnectMyComputerNodeJoin(teleport.lib.teleterm.v1.WaitForConnectMyComputerNodeJoinRequest) returns (teleport.lib.teleterm.v1.WaitForConnectMyComputerNodeJoinResponse);
     */
    waitForConnectMyComputerNodeJoin(input: WaitForConnectMyComputerNodeJoinRequest, options?: RpcOptions): UnaryCall<WaitForConnectMyComputerNodeJoinRequest, WaitForConnectMyComputerNodeJoinResponse>;
    /**
     * DeleteConnectMyComputerNode deletes the Connect My Computer node.
     *
     * @generated from protobuf rpc: DeleteConnectMyComputerNode(teleport.lib.teleterm.v1.DeleteConnectMyComputerNodeRequest) returns (teleport.lib.teleterm.v1.DeleteConnectMyComputerNodeResponse);
     */
    deleteConnectMyComputerNode(input: DeleteConnectMyComputerNodeRequest, options?: RpcOptions): UnaryCall<DeleteConnectMyComputerNodeRequest, DeleteConnectMyComputerNodeResponse>;
    /**
     * GetConnectMyComputerNodeName reads the Connect My Computer node name (UUID) from a disk.
     *
     * @generated from protobuf rpc: GetConnectMyComputerNodeName(teleport.lib.teleterm.v1.GetConnectMyComputerNodeNameRequest) returns (teleport.lib.teleterm.v1.GetConnectMyComputerNodeNameResponse);
     */
    getConnectMyComputerNodeName(input: GetConnectMyComputerNodeNameRequest, options?: RpcOptions): UnaryCall<GetConnectMyComputerNodeNameRequest, GetConnectMyComputerNodeNameResponse>;
    /**
     * ListUnifiedResources retrieves a paginated list of all resource types displayable in the UI.
     *
     * @generated from protobuf rpc: ListUnifiedResources(teleport.lib.teleterm.v1.ListUnifiedResourcesRequest) returns (teleport.lib.teleterm.v1.ListUnifiedResourcesResponse);
     */
    listUnifiedResources(input: ListUnifiedResourcesRequest, options?: RpcOptions): UnaryCall<ListUnifiedResourcesRequest, ListUnifiedResourcesResponse>;
    /**
     * GetUserPreferences returns the combined (root + leaf cluster) preferences for a given user.
     *
     * @generated from protobuf rpc: GetUserPreferences(teleport.lib.teleterm.v1.GetUserPreferencesRequest) returns (teleport.lib.teleterm.v1.GetUserPreferencesResponse);
     */
    getUserPreferences(input: GetUserPreferencesRequest, options?: RpcOptions): UnaryCall<GetUserPreferencesRequest, GetUserPreferencesResponse>;
    /**
     * UpdateUserPreferences updates the preferences for a given user in appropriate root and leaf clusters.
     * Only the properties that are set (cluster_preferences, unified_resource_preferences) will be updated.
     *
     * @generated from protobuf rpc: UpdateUserPreferences(teleport.lib.teleterm.v1.UpdateUserPreferencesRequest) returns (teleport.lib.teleterm.v1.UpdateUserPreferencesResponse);
     */
    updateUserPreferences(input: UpdateUserPreferencesRequest, options?: RpcOptions): UnaryCall<UpdateUserPreferencesRequest, UpdateUserPreferencesResponse>;
    /**
     * AuthenticateWebDevice blesses a web session with device trust by performing
     * the on-behalf-of device authentication ceremony.
     *
     * See
     * https://github.com/gravitational/teleport.e/blob/master/rfd/0009e-device-trust-web-support.md#device-web-authentication.
     *
     * @generated from protobuf rpc: AuthenticateWebDevice(teleport.lib.teleterm.v1.AuthenticateWebDeviceRequest) returns (teleport.lib.teleterm.v1.AuthenticateWebDeviceResponse);
     */
    authenticateWebDevice(input: AuthenticateWebDeviceRequest, options?: RpcOptions): UnaryCall<AuthenticateWebDeviceRequest, AuthenticateWebDeviceResponse>;
    /**
     * GetApp returns details of an app resource. It does not include information about AWS roles and
     * FQDN.
     *
     * @generated from protobuf rpc: GetApp(teleport.lib.teleterm.v1.GetAppRequest) returns (teleport.lib.teleterm.v1.GetAppResponse);
     */
    getApp(input: GetAppRequest, options?: RpcOptions): UnaryCall<GetAppRequest, GetAppResponse>;
}
/**
 * TerminalService is used by the Electron app to communicate with the tsh daemon.
 *
 * While we aim to preserve backwards compatibility in order to satisfy CI checks and follow the
 * proto practices used within the company, this service is not guaranteed to be stable across
 * versions. The packaging process of Teleport Connect ensures that the server and the client use
 * the same version of the service.
 *
 * @generated from protobuf service teleport.lib.teleterm.v1.TerminalService
 */
export class TerminalServiceClient implements ITerminalServiceClient, ServiceInfo {
    typeName = TerminalService.typeName;
    methods = TerminalService.methods;
    options = TerminalService.options;
    constructor(private readonly _transport: RpcTransport) {
    }
    /**
     * UpdateTshdEventsServerAddress lets the Electron app update the address the tsh daemon is
     * supposed to use when connecting to the tshd events gRPC service. This RPC needs to be made
     * before any other from this service.
     *
     * The service is supposed to return a response from this call only after the client is ready.
     *
     * @generated from protobuf rpc: UpdateTshdEventsServerAddress(teleport.lib.teleterm.v1.UpdateTshdEventsServerAddressRequest) returns (teleport.lib.teleterm.v1.UpdateTshdEventsServerAddressResponse);
     */
    updateTshdEventsServerAddress(input: UpdateTshdEventsServerAddressRequest, options?: RpcOptions): UnaryCall<UpdateTshdEventsServerAddressRequest, UpdateTshdEventsServerAddressResponse> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept<UpdateTshdEventsServerAddressRequest, UpdateTshdEventsServerAddressResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ListRootClusters lists root clusters
     * Does not include detailed cluster information that would require a network request.
     *
     * @generated from protobuf rpc: ListRootClusters(teleport.lib.teleterm.v1.ListClustersRequest) returns (teleport.lib.teleterm.v1.ListClustersResponse);
     */
    listRootClusters(input: ListClustersRequest, options?: RpcOptions): UnaryCall<ListClustersRequest, ListClustersResponse> {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return stackIntercept<ListClustersRequest, ListClustersResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ListLeafClusters lists leaf clusters
     * Does not include detailed cluster information that would require a network request.
     *
     * @generated from protobuf rpc: ListLeafClusters(teleport.lib.teleterm.v1.ListLeafClustersRequest) returns (teleport.lib.teleterm.v1.ListClustersResponse);
     */
    listLeafClusters(input: ListLeafClustersRequest, options?: RpcOptions): UnaryCall<ListLeafClustersRequest, ListClustersResponse> {
        const method = this.methods[2], opt = this._transport.mergeOptions(options);
        return stackIntercept<ListLeafClustersRequest, ListClustersResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * StartHeadlessWatcher starts a headless watcher.
     * If the watcher is already running, it is restarted.
     *
     * @generated from protobuf rpc: StartHeadlessWatcher(teleport.lib.teleterm.v1.StartHeadlessWatcherRequest) returns (teleport.lib.teleterm.v1.StartHeadlessWatcherResponse);
     */
    startHeadlessWatcher(input: StartHeadlessWatcherRequest, options?: RpcOptions): UnaryCall<StartHeadlessWatcherRequest, StartHeadlessWatcherResponse> {
        const method = this.methods[3], opt = this._transport.mergeOptions(options);
        return stackIntercept<StartHeadlessWatcherRequest, StartHeadlessWatcherResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ListDatabaseUsers lists allowed users for the given database based on the role set.
     *
     * @generated from protobuf rpc: ListDatabaseUsers(teleport.lib.teleterm.v1.ListDatabaseUsersRequest) returns (teleport.lib.teleterm.v1.ListDatabaseUsersResponse);
     */
    listDatabaseUsers(input: ListDatabaseUsersRequest, options?: RpcOptions): UnaryCall<ListDatabaseUsersRequest, ListDatabaseUsersResponse> {
        const method = this.methods[4], opt = this._transport.mergeOptions(options);
        return stackIntercept<ListDatabaseUsersRequest, ListDatabaseUsersResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetServers returns filtered, sorted, and paginated servers
     *
     * Deprecated: Use ListUnifiedResources instead.
     *
     * @deprecated
     * @generated from protobuf rpc: GetServers(teleport.lib.teleterm.v1.GetServersRequest) returns (teleport.lib.teleterm.v1.GetServersResponse);
     */
    getServers(input: GetServersRequest, options?: RpcOptions): UnaryCall<GetServersRequest, GetServersResponse> {
        const method = this.methods[5], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetServersRequest, GetServersResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetAccessRequests lists filtered AccessRequests
     *
     * @generated from protobuf rpc: GetAccessRequests(teleport.lib.teleterm.v1.GetAccessRequestsRequest) returns (teleport.lib.teleterm.v1.GetAccessRequestsResponse);
     */
    getAccessRequests(input: GetAccessRequestsRequest, options?: RpcOptions): UnaryCall<GetAccessRequestsRequest, GetAccessRequestsResponse> {
        const method = this.methods[6], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetAccessRequestsRequest, GetAccessRequestsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetAccessRequest retreives a single Access Request
     *
     * @generated from protobuf rpc: GetAccessRequest(teleport.lib.teleterm.v1.GetAccessRequestRequest) returns (teleport.lib.teleterm.v1.GetAccessRequestResponse);
     */
    getAccessRequest(input: GetAccessRequestRequest, options?: RpcOptions): UnaryCall<GetAccessRequestRequest, GetAccessRequestResponse> {
        const method = this.methods[7], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetAccessRequestRequest, GetAccessRequestResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * DeleteAccessRequest deletes the access request by id
     *
     * @generated from protobuf rpc: DeleteAccessRequest(teleport.lib.teleterm.v1.DeleteAccessRequestRequest) returns (teleport.lib.teleterm.v1.EmptyResponse);
     */
    deleteAccessRequest(input: DeleteAccessRequestRequest, options?: RpcOptions): UnaryCall<DeleteAccessRequestRequest, EmptyResponse> {
        const method = this.methods[8], opt = this._transport.mergeOptions(options);
        return stackIntercept<DeleteAccessRequestRequest, EmptyResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * CreateAccessRequest creates an access request
     *
     * @generated from protobuf rpc: CreateAccessRequest(teleport.lib.teleterm.v1.CreateAccessRequestRequest) returns (teleport.lib.teleterm.v1.CreateAccessRequestResponse);
     */
    createAccessRequest(input: CreateAccessRequestRequest, options?: RpcOptions): UnaryCall<CreateAccessRequestRequest, CreateAccessRequestResponse> {
        const method = this.methods[9], opt = this._transport.mergeOptions(options);
        return stackIntercept<CreateAccessRequestRequest, CreateAccessRequestResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ReviewAccessRequest submits a review for an Access Request
     *
     * @generated from protobuf rpc: ReviewAccessRequest(teleport.lib.teleterm.v1.ReviewAccessRequestRequest) returns (teleport.lib.teleterm.v1.ReviewAccessRequestResponse);
     */
    reviewAccessRequest(input: ReviewAccessRequestRequest, options?: RpcOptions): UnaryCall<ReviewAccessRequestRequest, ReviewAccessRequestResponse> {
        const method = this.methods[10], opt = this._transport.mergeOptions(options);
        return stackIntercept<ReviewAccessRequestRequest, ReviewAccessRequestResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetRequestableRoles gets all requestable roles
     *
     * @generated from protobuf rpc: GetRequestableRoles(teleport.lib.teleterm.v1.GetRequestableRolesRequest) returns (teleport.lib.teleterm.v1.GetRequestableRolesResponse);
     */
    getRequestableRoles(input: GetRequestableRolesRequest, options?: RpcOptions): UnaryCall<GetRequestableRolesRequest, GetRequestableRolesResponse> {
        const method = this.methods[11], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetRequestableRolesRequest, GetRequestableRolesResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * AssumeRole assumes the role of the given access request
     *
     * @generated from protobuf rpc: AssumeRole(teleport.lib.teleterm.v1.AssumeRoleRequest) returns (teleport.lib.teleterm.v1.EmptyResponse);
     */
    assumeRole(input: AssumeRoleRequest, options?: RpcOptions): UnaryCall<AssumeRoleRequest, EmptyResponse> {
        const method = this.methods[12], opt = this._transport.mergeOptions(options);
        return stackIntercept<AssumeRoleRequest, EmptyResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * PromoteAccessRequest promotes an access request to an access list.
     *
     * @generated from protobuf rpc: PromoteAccessRequest(teleport.lib.teleterm.v1.PromoteAccessRequestRequest) returns (teleport.lib.teleterm.v1.PromoteAccessRequestResponse);
     */
    promoteAccessRequest(input: PromoteAccessRequestRequest, options?: RpcOptions): UnaryCall<PromoteAccessRequestRequest, PromoteAccessRequestResponse> {
        const method = this.methods[13], opt = this._transport.mergeOptions(options);
        return stackIntercept<PromoteAccessRequestRequest, PromoteAccessRequestResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetSuggestedAccessLists returns suggested access lists for an access request.
     *
     * @generated from protobuf rpc: GetSuggestedAccessLists(teleport.lib.teleterm.v1.GetSuggestedAccessListsRequest) returns (teleport.lib.teleterm.v1.GetSuggestedAccessListsResponse);
     */
    getSuggestedAccessLists(input: GetSuggestedAccessListsRequest, options?: RpcOptions): UnaryCall<GetSuggestedAccessListsRequest, GetSuggestedAccessListsResponse> {
        const method = this.methods[14], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetSuggestedAccessListsRequest, GetSuggestedAccessListsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ListKubernetesResourcesRequest defines a request to retrieve kube resources paginated.
     * Only one type of kube resource can be retrieved per request (eg: namespace, pods, secrets, etc.)
     *
     * @generated from protobuf rpc: ListKubernetesResources(teleport.lib.teleterm.v1.ListKubernetesResourcesRequest) returns (teleport.lib.teleterm.v1.ListKubernetesResourcesResponse);
     */
    listKubernetesResources(input: ListKubernetesResourcesRequest, options?: RpcOptions): UnaryCall<ListKubernetesResourcesRequest, ListKubernetesResourcesResponse> {
        const method = this.methods[15], opt = this._transport.mergeOptions(options);
        return stackIntercept<ListKubernetesResourcesRequest, ListKubernetesResourcesResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * AddCluster adds a cluster to profile
     *
     * @generated from protobuf rpc: AddCluster(teleport.lib.teleterm.v1.AddClusterRequest) returns (teleport.lib.teleterm.v1.Cluster);
     */
    addCluster(input: AddClusterRequest, options?: RpcOptions): UnaryCall<AddClusterRequest, Cluster> {
        const method = this.methods[16], opt = this._transport.mergeOptions(options);
        return stackIntercept<AddClusterRequest, Cluster>("unary", this._transport, method, opt, input);
    }
    /**
     * RemoveCluster removes a cluster from profile
     *
     * @generated from protobuf rpc: RemoveCluster(teleport.lib.teleterm.v1.RemoveClusterRequest) returns (teleport.lib.teleterm.v1.EmptyResponse);
     */
    removeCluster(input: RemoveClusterRequest, options?: RpcOptions): UnaryCall<RemoveClusterRequest, EmptyResponse> {
        const method = this.methods[17], opt = this._transport.mergeOptions(options);
        return stackIntercept<RemoveClusterRequest, EmptyResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ListGateways lists gateways
     *
     * @generated from protobuf rpc: ListGateways(teleport.lib.teleterm.v1.ListGatewaysRequest) returns (teleport.lib.teleterm.v1.ListGatewaysResponse);
     */
    listGateways(input: ListGatewaysRequest, options?: RpcOptions): UnaryCall<ListGatewaysRequest, ListGatewaysResponse> {
        const method = this.methods[18], opt = this._transport.mergeOptions(options);
        return stackIntercept<ListGatewaysRequest, ListGatewaysResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * CreateGateway creates a gateway
     *
     * @generated from protobuf rpc: CreateGateway(teleport.lib.teleterm.v1.CreateGatewayRequest) returns (teleport.lib.teleterm.v1.Gateway);
     */
    createGateway(input: CreateGatewayRequest, options?: RpcOptions): UnaryCall<CreateGatewayRequest, Gateway> {
        const method = this.methods[19], opt = this._transport.mergeOptions(options);
        return stackIntercept<CreateGatewayRequest, Gateway>("unary", this._transport, method, opt, input);
    }
    /**
     * RemoveGateway removes a gateway
     *
     * @generated from protobuf rpc: RemoveGateway(teleport.lib.teleterm.v1.RemoveGatewayRequest) returns (teleport.lib.teleterm.v1.EmptyResponse);
     */
    removeGateway(input: RemoveGatewayRequest, options?: RpcOptions): UnaryCall<RemoveGatewayRequest, EmptyResponse> {
        const method = this.methods[20], opt = this._transport.mergeOptions(options);
        return stackIntercept<RemoveGatewayRequest, EmptyResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * SetGatewayTargetSubresourceName changes the TargetSubresourceName field of gateway.Gateway
     * and returns the updated version of gateway.Gateway.
     *
     * In Connect this is used to update the db name of a db connection along with the CLI command.
     *
     * @generated from protobuf rpc: SetGatewayTargetSubresourceName(teleport.lib.teleterm.v1.SetGatewayTargetSubresourceNameRequest) returns (teleport.lib.teleterm.v1.Gateway);
     */
    setGatewayTargetSubresourceName(input: SetGatewayTargetSubresourceNameRequest, options?: RpcOptions): UnaryCall<SetGatewayTargetSubresourceNameRequest, Gateway> {
        const method = this.methods[21], opt = this._transport.mergeOptions(options);
        return stackIntercept<SetGatewayTargetSubresourceNameRequest, Gateway>("unary", this._transport, method, opt, input);
    }
    /**
     * SetGatewayLocalPort starts a new gateway on the new port, stops the old gateway and then
     * assigns the URI of the old gateway to the new one. It does so without fetching a new db cert.
     *
     * @generated from protobuf rpc: SetGatewayLocalPort(teleport.lib.teleterm.v1.SetGatewayLocalPortRequest) returns (teleport.lib.teleterm.v1.Gateway);
     */
    setGatewayLocalPort(input: SetGatewayLocalPortRequest, options?: RpcOptions): UnaryCall<SetGatewayLocalPortRequest, Gateway> {
        const method = this.methods[22], opt = this._transport.mergeOptions(options);
        return stackIntercept<SetGatewayLocalPortRequest, Gateway>("unary", this._transport, method, opt, input);
    }
    /**
     * GetAuthSettings returns cluster auth settigns
     *
     * @generated from protobuf rpc: GetAuthSettings(teleport.lib.teleterm.v1.GetAuthSettingsRequest) returns (teleport.lib.teleterm.v1.AuthSettings);
     */
    getAuthSettings(input: GetAuthSettingsRequest, options?: RpcOptions): UnaryCall<GetAuthSettingsRequest, AuthSettings> {
        const method = this.methods[23], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetAuthSettingsRequest, AuthSettings>("unary", this._transport, method, opt, input);
    }
    /**
     * GetCluster returns cluster. Makes a network request and includes detailed
     * information about enterprise features availabed on the connected auth server
     *
     * @generated from protobuf rpc: GetCluster(teleport.lib.teleterm.v1.GetClusterRequest) returns (teleport.lib.teleterm.v1.Cluster);
     */
    getCluster(input: GetClusterRequest, options?: RpcOptions): UnaryCall<GetClusterRequest, Cluster> {
        const method = this.methods[24], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetClusterRequest, Cluster>("unary", this._transport, method, opt, input);
    }
    /**
     * Login logs in a user to a cluster
     *
     * @generated from protobuf rpc: Login(teleport.lib.teleterm.v1.LoginRequest) returns (teleport.lib.teleterm.v1.EmptyResponse);
     */
    login(input: LoginRequest, options?: RpcOptions): UnaryCall<LoginRequest, EmptyResponse> {
        const method = this.methods[25], opt = this._transport.mergeOptions(options);
        return stackIntercept<LoginRequest, EmptyResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * LoginPasswordless logs in a user to a cluster passwordlessly.
     *
     * The RPC is streaming both ways and the message sequence example for hardware keys are:
     * (-> means client-to-server, <- means server-to-client)
     *
     * Hardware keys:
     * -> Init
     * <- Send PasswordlessPrompt enum TAP to choose a device
     * -> Receive TAP device response
     * <- Send PasswordlessPrompt enum PIN
     * -> Receive PIN response
     * <- Send PasswordlessPrompt enum RETAP to confirm
     * -> Receive RETAP device response
     * <- Send list of credentials (e.g. usernames) associated with device
     * -> Receive the index number associated with the selected credential in list
     * <- End
     *
     * @generated from protobuf rpc: LoginPasswordless(stream teleport.lib.teleterm.v1.LoginPasswordlessRequest) returns (stream teleport.lib.teleterm.v1.LoginPasswordlessResponse);
     */
    loginPasswordless(options?: RpcOptions): DuplexStreamingCall<LoginPasswordlessRequest, LoginPasswordlessResponse> {
        const method = this.methods[26], opt = this._transport.mergeOptions(options);
        return stackIntercept<LoginPasswordlessRequest, LoginPasswordlessResponse>("duplex", this._transport, method, opt);
    }
    /**
     * ClusterLogin logs out a user from cluster
     *
     * @generated from protobuf rpc: Logout(teleport.lib.teleterm.v1.LogoutRequest) returns (teleport.lib.teleterm.v1.EmptyResponse);
     */
    logout(input: LogoutRequest, options?: RpcOptions): UnaryCall<LogoutRequest, EmptyResponse> {
        const method = this.methods[27], opt = this._transport.mergeOptions(options);
        return stackIntercept<LogoutRequest, EmptyResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * TransferFile sends a request to download/upload a file
     *
     * @generated from protobuf rpc: TransferFile(teleport.lib.teleterm.v1.FileTransferRequest) returns (stream teleport.lib.teleterm.v1.FileTransferProgress);
     */
    transferFile(input: FileTransferRequest, options?: RpcOptions): ServerStreamingCall<FileTransferRequest, FileTransferProgress> {
        const method = this.methods[28], opt = this._transport.mergeOptions(options);
        return stackIntercept<FileTransferRequest, FileTransferProgress>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * ReportUsageEvent allows to send usage events that are then anonymized and forwarded to prehog
     *
     * @generated from protobuf rpc: ReportUsageEvent(teleport.lib.teleterm.v1.ReportUsageEventRequest) returns (teleport.lib.teleterm.v1.EmptyResponse);
     */
    reportUsageEvent(input: ReportUsageEventRequest, options?: RpcOptions): UnaryCall<ReportUsageEventRequest, EmptyResponse> {
        const method = this.methods[29], opt = this._transport.mergeOptions(options);
        return stackIntercept<ReportUsageEventRequest, EmptyResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * UpdateHeadlessAuthenticationState updates a headless authentication resource's state.
     * An MFA challenge will be prompted when approving a headless authentication.
     *
     * @generated from protobuf rpc: UpdateHeadlessAuthenticationState(teleport.lib.teleterm.v1.UpdateHeadlessAuthenticationStateRequest) returns (teleport.lib.teleterm.v1.UpdateHeadlessAuthenticationStateResponse);
     */
    updateHeadlessAuthenticationState(input: UpdateHeadlessAuthenticationStateRequest, options?: RpcOptions): UnaryCall<UpdateHeadlessAuthenticationStateRequest, UpdateHeadlessAuthenticationStateResponse> {
        const method = this.methods[30], opt = this._transport.mergeOptions(options);
        return stackIntercept<UpdateHeadlessAuthenticationStateRequest, UpdateHeadlessAuthenticationStateResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * CreateConnectMyComputerRole creates a role which allows access to nodes with the label
     * teleport.dev/connect-my-computer/owner: <cluster user> and allows logging in to those nodes as
     * the current system user.
     *
     * @generated from protobuf rpc: CreateConnectMyComputerRole(teleport.lib.teleterm.v1.CreateConnectMyComputerRoleRequest) returns (teleport.lib.teleterm.v1.CreateConnectMyComputerRoleResponse);
     */
    createConnectMyComputerRole(input: CreateConnectMyComputerRoleRequest, options?: RpcOptions): UnaryCall<CreateConnectMyComputerRoleRequest, CreateConnectMyComputerRoleResponse> {
        const method = this.methods[31], opt = this._transport.mergeOptions(options);
        return stackIntercept<CreateConnectMyComputerRoleRequest, CreateConnectMyComputerRoleResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * CreateConnectMyComputerNodeToken creates a node join token that is valid for 5 minutes
     *
     * @generated from protobuf rpc: CreateConnectMyComputerNodeToken(teleport.lib.teleterm.v1.CreateConnectMyComputerNodeTokenRequest) returns (teleport.lib.teleterm.v1.CreateConnectMyComputerNodeTokenResponse);
     */
    createConnectMyComputerNodeToken(input: CreateConnectMyComputerNodeTokenRequest, options?: RpcOptions): UnaryCall<CreateConnectMyComputerNodeTokenRequest, CreateConnectMyComputerNodeTokenResponse> {
        const method = this.methods[32], opt = this._transport.mergeOptions(options);
        return stackIntercept<CreateConnectMyComputerNodeTokenRequest, CreateConnectMyComputerNodeTokenResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * WaitForConnectMyComputerNodeJoin sets up a watcher and returns a response only after detecting
     * that the Connect My Computer node for the particular cluster has joined the cluster (the
     * OpPut event).
     *
     * This RPC times out by itself after a minute to prevent the request from hanging forever, in
     * case the client didn't set a deadline or doesn't abort the request.
     *
     * @generated from protobuf rpc: WaitForConnectMyComputerNodeJoin(teleport.lib.teleterm.v1.WaitForConnectMyComputerNodeJoinRequest) returns (teleport.lib.teleterm.v1.WaitForConnectMyComputerNodeJoinResponse);
     */
    waitForConnectMyComputerNodeJoin(input: WaitForConnectMyComputerNodeJoinRequest, options?: RpcOptions): UnaryCall<WaitForConnectMyComputerNodeJoinRequest, WaitForConnectMyComputerNodeJoinResponse> {
        const method = this.methods[33], opt = this._transport.mergeOptions(options);
        return stackIntercept<WaitForConnectMyComputerNodeJoinRequest, WaitForConnectMyComputerNodeJoinResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * DeleteConnectMyComputerNode deletes the Connect My Computer node.
     *
     * @generated from protobuf rpc: DeleteConnectMyComputerNode(teleport.lib.teleterm.v1.DeleteConnectMyComputerNodeRequest) returns (teleport.lib.teleterm.v1.DeleteConnectMyComputerNodeResponse);
     */
    deleteConnectMyComputerNode(input: DeleteConnectMyComputerNodeRequest, options?: RpcOptions): UnaryCall<DeleteConnectMyComputerNodeRequest, DeleteConnectMyComputerNodeResponse> {
        const method = this.methods[34], opt = this._transport.mergeOptions(options);
        return stackIntercept<DeleteConnectMyComputerNodeRequest, DeleteConnectMyComputerNodeResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetConnectMyComputerNodeName reads the Connect My Computer node name (UUID) from a disk.
     *
     * @generated from protobuf rpc: GetConnectMyComputerNodeName(teleport.lib.teleterm.v1.GetConnectMyComputerNodeNameRequest) returns (teleport.lib.teleterm.v1.GetConnectMyComputerNodeNameResponse);
     */
    getConnectMyComputerNodeName(input: GetConnectMyComputerNodeNameRequest, options?: RpcOptions): UnaryCall<GetConnectMyComputerNodeNameRequest, GetConnectMyComputerNodeNameResponse> {
        const method = this.methods[35], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetConnectMyComputerNodeNameRequest, GetConnectMyComputerNodeNameResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ListUnifiedResources retrieves a paginated list of all resource types displayable in the UI.
     *
     * @generated from protobuf rpc: ListUnifiedResources(teleport.lib.teleterm.v1.ListUnifiedResourcesRequest) returns (teleport.lib.teleterm.v1.ListUnifiedResourcesResponse);
     */
    listUnifiedResources(input: ListUnifiedResourcesRequest, options?: RpcOptions): UnaryCall<ListUnifiedResourcesRequest, ListUnifiedResourcesResponse> {
        const method = this.methods[36], opt = this._transport.mergeOptions(options);
        return stackIntercept<ListUnifiedResourcesRequest, ListUnifiedResourcesResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetUserPreferences returns the combined (root + leaf cluster) preferences for a given user.
     *
     * @generated from protobuf rpc: GetUserPreferences(teleport.lib.teleterm.v1.GetUserPreferencesRequest) returns (teleport.lib.teleterm.v1.GetUserPreferencesResponse);
     */
    getUserPreferences(input: GetUserPreferencesRequest, options?: RpcOptions): UnaryCall<GetUserPreferencesRequest, GetUserPreferencesResponse> {
        const method = this.methods[37], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetUserPreferencesRequest, GetUserPreferencesResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * UpdateUserPreferences updates the preferences for a given user in appropriate root and leaf clusters.
     * Only the properties that are set (cluster_preferences, unified_resource_preferences) will be updated.
     *
     * @generated from protobuf rpc: UpdateUserPreferences(teleport.lib.teleterm.v1.UpdateUserPreferencesRequest) returns (teleport.lib.teleterm.v1.UpdateUserPreferencesResponse);
     */
    updateUserPreferences(input: UpdateUserPreferencesRequest, options?: RpcOptions): UnaryCall<UpdateUserPreferencesRequest, UpdateUserPreferencesResponse> {
        const method = this.methods[38], opt = this._transport.mergeOptions(options);
        return stackIntercept<UpdateUserPreferencesRequest, UpdateUserPreferencesResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * AuthenticateWebDevice blesses a web session with device trust by performing
     * the on-behalf-of device authentication ceremony.
     *
     * See
     * https://github.com/gravitational/teleport.e/blob/master/rfd/0009e-device-trust-web-support.md#device-web-authentication.
     *
     * @generated from protobuf rpc: AuthenticateWebDevice(teleport.lib.teleterm.v1.AuthenticateWebDeviceRequest) returns (teleport.lib.teleterm.v1.AuthenticateWebDeviceResponse);
     */
    authenticateWebDevice(input: AuthenticateWebDeviceRequest, options?: RpcOptions): UnaryCall<AuthenticateWebDeviceRequest, AuthenticateWebDeviceResponse> {
        const method = this.methods[39], opt = this._transport.mergeOptions(options);
        return stackIntercept<AuthenticateWebDeviceRequest, AuthenticateWebDeviceResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetApp returns details of an app resource. It does not include information about AWS roles and
     * FQDN.
     *
     * @generated from protobuf rpc: GetApp(teleport.lib.teleterm.v1.GetAppRequest) returns (teleport.lib.teleterm.v1.GetAppResponse);
     */
    getApp(input: GetAppRequest, options?: RpcOptions): UnaryCall<GetAppRequest, GetAppResponse> {
        const method = this.methods[40], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetAppRequest, GetAppResponse>("unary", this._transport, method, opt, input);
    }
}
