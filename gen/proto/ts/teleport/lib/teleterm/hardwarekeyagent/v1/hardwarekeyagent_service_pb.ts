/* eslint-disable */
// @generated by protobuf-ts 2.9.3 with parameter eslint_disable,add_pb_suffix,server_grpc1,ts_nocheck
// @generated from protobuf file "teleport/lib/teleterm/hardwarekeyagent/v1/hardwarekeyagent_service.proto" (package "teleport.lib.teleterm.hardwarekeyagent.v1", syntax proto3)
// tslint:disable
// @ts-nocheck
//
// Teleport
// Copyright (C) 2025 Gravitational, Inc.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * PingRequest is a request to Ping.
 *
 * @generated from protobuf message teleport.lib.teleterm.hardwarekeyagent.v1.PingRequest
 */
export interface PingRequest {
}
/**
 * PingResponse is a response to Ping.
 *
 * @generated from protobuf message teleport.lib.teleterm.hardwarekeyagent.v1.PingResponse
 */
export interface PingResponse {
    /**
     * PID is the PID of the client process running the agent.
     *
     * @generated from protobuf field: uint32 pid = 1;
     */
    pid: number;
}
/**
 * SignRequest is a request to perform a signature with a specific hardware private key.
 *
 * @generated from protobuf message teleport.lib.teleterm.hardwarekeyagent.v1.SignRequest
 */
export interface SignRequest {
    /**
     * Digest is a hashed message to sign.
     *
     * @generated from protobuf field: bytes digest = 1;
     */
    digest: Uint8Array;
    /**
     * Hash is the hash function used to prepare the digest.
     *
     * @generated from protobuf field: teleport.lib.teleterm.hardwarekeyagent.v1.Hash hash = 2;
     */
    hash: Hash;
    /**
     * SaltLength specifies the length of the salt added to the digest before a signature.
     * This salt length is precomputed by the client, following the crypto/rsa implementation.
     * Only used, and required, for PSS RSA signatures.
     *
     * @generated from protobuf field: uint32 salt_length = 3;
     */
    saltLength: number;
    /**
     * KeyRef references a specific hardware private key.
     *
     * @generated from protobuf field: teleport.lib.teleterm.hardwarekeyagent.v1.KeyRef key_ref = 4;
     */
    keyRef?: KeyRef;
    /**
     * KeyInfo contains additional, optional key info which generally will improve UX by
     * giving the agent context about the key, such as whether PIN/touch prompts are
     * expected, or what cluster login is trying to interface with the key.
     *
     * @generated from protobuf field: teleport.lib.teleterm.hardwarekeyagent.v1.KeyInfo key_info = 5;
     */
    keyInfo?: KeyInfo;
    /**
     * Command is the client command or action requiring a signature, e.g. "tsh ssh server01".
     * The agent can include this detail in PIN/touch prompts to show the origin of the
     * signature request to the user.
     *
     * @generated from protobuf field: string command = 6;
     */
    command: string;
}
/**
 * Signature is a private key signature.
 *
 * @generated from protobuf message teleport.lib.teleterm.hardwarekeyagent.v1.Signature
 */
export interface Signature {
    /**
     * For an RSA key, signature should be either a PKCS #1 v1.5 or PSS signature,
     * depending on the hash and salt chosen. For an (EC)DSA key, it should be a
     * DER-serialised, ASN.1 signature structure.
     *
     * @generated from protobuf field: bytes signature = 1;
     */
    signature: Uint8Array;
}
/**
 * KeyRef references a specific hardware private key.
 *
 * @generated from protobuf message teleport.lib.teleterm.hardwarekeyagent.v1.KeyRef
 */
export interface KeyRef {
    /**
     * SerialNumber is the serial number of the hardware key.
     *
     * @generated from protobuf field: uint32 serial_number = 1;
     */
    serialNumber: number;
    /**
     * SlotKey is a PIV slot key reference.
     *
     * @generated from protobuf field: teleport.lib.teleterm.hardwarekeyagent.v1.PIVSlotKey slot_key = 2;
     */
    slotKey: PIVSlotKey;
    /**
     * PublicKey is the public key encoded in PKIX, ASN.1 DER form. If the public key does
     * not match the private key currently in the hardware key's PIV slot, the signature
     * will fail early.
     *
     * @generated from protobuf field: bytes public_key_der = 3;
     */
    publicKeyDer: Uint8Array;
}
/**
 * KeyInfo contains additional information about a hardware private key.
 *
 * @generated from protobuf message teleport.lib.teleterm.hardwarekeyagent.v1.KeyInfo
 */
export interface KeyInfo {
    /**
     * TouchRequired is a client hint as to whether the hardware private key requires touch.
     * The agent will use this to provide the ideal UX for the touch prompt. If this client
     * hint is incorrect, touch will still be prompted.
     *
     * @generated from protobuf field: bool touch_required = 1;
     */
    touchRequired: boolean;
    /**
     * PinRequired is a client hint as to whether the hardware private key requires PIN.
     * The agent will use this to provide the ideal UX for the PIN prompt. If this client
     * hint is incorrect, PIN will still be prompted for YubiKey versions >= 4.3.0, and
     * failing with an auth error otherwise.
     *
     * @generated from protobuf field: bool pin_required = 2;
     */
    pinRequired: boolean;
    /**
     * ProxyHost is a Teleport proxy hostname that the key is associated with.
     * May be used to add context to PIN/touch prompts.
     *
     * @generated from protobuf field: string proxy_host = 3;
     */
    proxyHost: string;
    /**
     * Username is a Teleport username that the key is associated with.
     * May be used to add context to PIN/touch prompts.
     *
     * @generated from protobuf field: string username = 4;
     */
    username: string;
    /**
     * ClusterName is a Teleport cluster name that the key is associated with.
     * May be used to add context to PIN/touch prompts.
     *
     * @generated from protobuf field: string cluster_name = 5;
     */
    clusterName: string;
}
/**
 * PIVSlotKey is the key reference for a specific PIV slot.
 *
 * @generated from protobuf enum teleport.lib.teleterm.hardwarekeyagent.v1.PIVSlotKey
 */
export enum PIVSlotKey {
    /**
     * PIV slot key not specified.
     *
     * @generated from protobuf enum value: PIV_SLOT_KEY_UNSPECIFIED = 0;
     */
    PIV_SLOT_KEY_UNSPECIFIED = 0,
    /**
     * PIV slot key 9a. This is the default slot for pin_policy=never, touch_policy=never.
     *
     * @generated from protobuf enum value: PIV_SLOT_KEY_9A = 1;
     */
    PIV_SLOT_KEY_9A = 1,
    /**
     * PIV slot key 9c. This is the default slot for pin_policy=never, touch_policy=cached.
     *
     * @generated from protobuf enum value: PIV_SLOT_KEY_9C = 2;
     */
    PIV_SLOT_KEY_9C = 2,
    /**
     * PIV slot key 9d. This is the default slot for pin_policy=once, touch_policy=cached.
     *
     * @generated from protobuf enum value: PIV_SLOT_KEY_9D = 3;
     */
    PIV_SLOT_KEY_9D = 3,
    /**
     * PIV slot key 9e. This is the default slot for pin_policy=once, touch_policy=never.
     *
     * @generated from protobuf enum value: PIV_SLOT_KEY_9E = 4;
     */
    PIV_SLOT_KEY_9E = 4
}
/**
 * Hash refers to a specific hash function used during signing.
 *
 * @generated from protobuf enum teleport.lib.teleterm.hardwarekeyagent.v1.Hash
 */
export enum Hash {
    /**
     * @generated from protobuf enum value: HASH_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: HASH_NONE = 1;
     */
    NONE = 1,
    /**
     * @generated from protobuf enum value: HASH_SHA256 = 2;
     */
    SHA256 = 2,
    /**
     * @generated from protobuf enum value: HASH_SHA512 = 3;
     */
    SHA512 = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class PingRequest$Type extends MessageType<PingRequest> {
    constructor() {
        super("teleport.lib.teleterm.hardwarekeyagent.v1.PingRequest", []);
    }
    create(value?: PartialMessage<PingRequest>): PingRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PingRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PingRequest): PingRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: PingRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.hardwarekeyagent.v1.PingRequest
 */
export const PingRequest = new PingRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PingResponse$Type extends MessageType<PingResponse> {
    constructor() {
        super("teleport.lib.teleterm.hardwarekeyagent.v1.PingResponse", [
            { no: 1, name: "pid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<PingResponse>): PingResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pid = 0;
        if (value !== undefined)
            reflectionMergePartial<PingResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PingResponse): PingResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 pid */ 1:
                    message.pid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 pid = 1; */
        if (message.pid !== 0)
            writer.tag(1, WireType.Varint).uint32(message.pid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.hardwarekeyagent.v1.PingResponse
 */
export const PingResponse = new PingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SignRequest$Type extends MessageType<SignRequest> {
    constructor() {
        super("teleport.lib.teleterm.hardwarekeyagent.v1.SignRequest", [
            { no: 1, name: "digest", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "hash", kind: "enum", T: () => ["teleport.lib.teleterm.hardwarekeyagent.v1.Hash", Hash, "HASH_"] },
            { no: 3, name: "salt_length", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "key_ref", kind: "message", T: () => KeyRef },
            { no: 5, name: "key_info", kind: "message", T: () => KeyInfo },
            { no: 6, name: "command", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SignRequest>): SignRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.digest = new Uint8Array(0);
        message.hash = 0;
        message.saltLength = 0;
        message.command = "";
        if (value !== undefined)
            reflectionMergePartial<SignRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SignRequest): SignRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes digest */ 1:
                    message.digest = reader.bytes();
                    break;
                case /* teleport.lib.teleterm.hardwarekeyagent.v1.Hash hash */ 2:
                    message.hash = reader.int32();
                    break;
                case /* uint32 salt_length */ 3:
                    message.saltLength = reader.uint32();
                    break;
                case /* teleport.lib.teleterm.hardwarekeyagent.v1.KeyRef key_ref */ 4:
                    message.keyRef = KeyRef.internalBinaryRead(reader, reader.uint32(), options, message.keyRef);
                    break;
                case /* teleport.lib.teleterm.hardwarekeyagent.v1.KeyInfo key_info */ 5:
                    message.keyInfo = KeyInfo.internalBinaryRead(reader, reader.uint32(), options, message.keyInfo);
                    break;
                case /* string command */ 6:
                    message.command = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SignRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes digest = 1; */
        if (message.digest.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.digest);
        /* teleport.lib.teleterm.hardwarekeyagent.v1.Hash hash = 2; */
        if (message.hash !== 0)
            writer.tag(2, WireType.Varint).int32(message.hash);
        /* uint32 salt_length = 3; */
        if (message.saltLength !== 0)
            writer.tag(3, WireType.Varint).uint32(message.saltLength);
        /* teleport.lib.teleterm.hardwarekeyagent.v1.KeyRef key_ref = 4; */
        if (message.keyRef)
            KeyRef.internalBinaryWrite(message.keyRef, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* teleport.lib.teleterm.hardwarekeyagent.v1.KeyInfo key_info = 5; */
        if (message.keyInfo)
            KeyInfo.internalBinaryWrite(message.keyInfo, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string command = 6; */
        if (message.command !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.command);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.hardwarekeyagent.v1.SignRequest
 */
export const SignRequest = new SignRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Signature$Type extends MessageType<Signature> {
    constructor() {
        super("teleport.lib.teleterm.hardwarekeyagent.v1.Signature", [
            { no: 1, name: "signature", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Signature>): Signature {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.signature = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<Signature>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Signature): Signature {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes signature */ 1:
                    message.signature = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Signature, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes signature = 1; */
        if (message.signature.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.signature);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.hardwarekeyagent.v1.Signature
 */
export const Signature = new Signature$Type();
// @generated message type with reflection information, may provide speed optimized methods
class KeyRef$Type extends MessageType<KeyRef> {
    constructor() {
        super("teleport.lib.teleterm.hardwarekeyagent.v1.KeyRef", [
            { no: 1, name: "serial_number", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "slot_key", kind: "enum", T: () => ["teleport.lib.teleterm.hardwarekeyagent.v1.PIVSlotKey", PIVSlotKey] },
            { no: 3, name: "public_key_der", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<KeyRef>): KeyRef {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.serialNumber = 0;
        message.slotKey = 0;
        message.publicKeyDer = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<KeyRef>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KeyRef): KeyRef {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 serial_number */ 1:
                    message.serialNumber = reader.uint32();
                    break;
                case /* teleport.lib.teleterm.hardwarekeyagent.v1.PIVSlotKey slot_key */ 2:
                    message.slotKey = reader.int32();
                    break;
                case /* bytes public_key_der */ 3:
                    message.publicKeyDer = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: KeyRef, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 serial_number = 1; */
        if (message.serialNumber !== 0)
            writer.tag(1, WireType.Varint).uint32(message.serialNumber);
        /* teleport.lib.teleterm.hardwarekeyagent.v1.PIVSlotKey slot_key = 2; */
        if (message.slotKey !== 0)
            writer.tag(2, WireType.Varint).int32(message.slotKey);
        /* bytes public_key_der = 3; */
        if (message.publicKeyDer.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.publicKeyDer);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.hardwarekeyagent.v1.KeyRef
 */
export const KeyRef = new KeyRef$Type();
// @generated message type with reflection information, may provide speed optimized methods
class KeyInfo$Type extends MessageType<KeyInfo> {
    constructor() {
        super("teleport.lib.teleterm.hardwarekeyagent.v1.KeyInfo", [
            { no: 1, name: "touch_required", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "pin_required", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "proxy_host", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "cluster_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<KeyInfo>): KeyInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.touchRequired = false;
        message.pinRequired = false;
        message.proxyHost = "";
        message.username = "";
        message.clusterName = "";
        if (value !== undefined)
            reflectionMergePartial<KeyInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KeyInfo): KeyInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool touch_required */ 1:
                    message.touchRequired = reader.bool();
                    break;
                case /* bool pin_required */ 2:
                    message.pinRequired = reader.bool();
                    break;
                case /* string proxy_host */ 3:
                    message.proxyHost = reader.string();
                    break;
                case /* string username */ 4:
                    message.username = reader.string();
                    break;
                case /* string cluster_name */ 5:
                    message.clusterName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: KeyInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool touch_required = 1; */
        if (message.touchRequired !== false)
            writer.tag(1, WireType.Varint).bool(message.touchRequired);
        /* bool pin_required = 2; */
        if (message.pinRequired !== false)
            writer.tag(2, WireType.Varint).bool(message.pinRequired);
        /* string proxy_host = 3; */
        if (message.proxyHost !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.proxyHost);
        /* string username = 4; */
        if (message.username !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.username);
        /* string cluster_name = 5; */
        if (message.clusterName !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.clusterName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.hardwarekeyagent.v1.KeyInfo
 */
export const KeyInfo = new KeyInfo$Type();
/**
 * @generated ServiceType for protobuf service teleport.lib.teleterm.hardwarekeyagent.v1.HardwareKeyAgentService
 */
export const HardwareKeyAgentService = new ServiceType("teleport.lib.teleterm.hardwarekeyagent.v1.HardwareKeyAgentService", [
    { name: "Ping", options: {}, I: PingRequest, O: PingResponse },
    { name: "Sign", options: {}, I: SignRequest, O: Signature }
]);
