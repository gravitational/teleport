/* eslint-disable */
// @generated by protobuf-ts 2.9.3 with parameter eslint_disable,add_pb_suffix,server_grpc1,ts_nocheck
// @generated from protobuf file "teleport/lib/teleterm/hardwarekeyagent/v1/hardwarekeyagent_service.proto" (package "teleport.lib.teleterm.hardwarekeyagent.v1", syntax proto3)
// tslint:disable
// @ts-nocheck
//
// Teleport
// Copyright (C) 2025 Gravitational, Inc.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { AttestationStatement } from "../../../../attestation/v1/attestation_pb";
/**
 * SignRequest is a request to perform a signature with a specific hardware private key.
 *
 * @generated from protobuf message teleport.lib.teleterm.hardwarekeyagent.v1.SignRequest
 */
export interface SignRequest {
    /**
     * KeyRef references a specific hardware private key.
     *
     * @generated from protobuf field: teleport.lib.teleterm.hardwarekeyagent.v1.KeyRef key_ref = 1;
     */
    keyRef?: KeyRef;
    /**
     * PublicKeyDer is a public key encoded in PKIX, ASN.1 DER form.
     * This is provided to verify that the hardware private key has not
     * been swapped out against the public key expected by the client.
     *
     * @generated from protobuf field: bytes public_key_der = 2;
     */
    publicKeyDer: Uint8Array;
    /**
     * Digest is a hashed message to sign.
     *
     * @generated from protobuf field: bytes digest = 3;
     */
    digest: Uint8Array;
    /**
     * HashName is the name of the hash used to generate the digest.
     *
     * @generated from protobuf field: teleport.lib.teleterm.hardwarekeyagent.v1.HashName hash_name = 4;
     */
    hashName: HashName;
    /**
     * @generated from protobuf oneof: salt_length
     */
    saltLength: {
        oneofKind: "length";
        /**
         * Length specifies an exact salt length to use.
         *
         * @generated from protobuf field: uint32 length = 5;
         */
        length: number;
    } | {
        oneofKind: "auto";
        /**
         * Auto specifies how the signing process should automatically pick a salt length
         * based on the hash length and key length.
         *
         * @generated from protobuf field: teleport.lib.teleterm.hardwarekeyagent.v1.SaltLengthAuto auto = 6;
         */
        auto: SaltLengthAuto;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Signature is a private key signature.
 *
 * @generated from protobuf message teleport.lib.teleterm.hardwarekeyagent.v1.Signature
 */
export interface Signature {
    /**
     * For an RSA key, signature should be either a PKCS #1 v1.5 or PSS signature,
     * depending on the hash and salt chosen. For an (EC)DSA key, it should be a
     * DER-serialised, ASN.1 signature structure.
     *
     * @generated from protobuf field: bytes signature = 1;
     */
    signature: Uint8Array;
}
/**
 * KeyRef references a specific hardware private key.
 *
 * @generated from protobuf message teleport.lib.teleterm.hardwarekeyagent.v1.KeyRef
 */
export interface KeyRef {
    /**
     * SerialNumber is the serial number of the hardware key.
     *
     * @generated from protobuf field: uint32 serial_number = 1;
     */
    serialNumber: number;
    /**
     * PivSlot is a specific PIV slot on the hardware key.
     *
     * @generated from protobuf field: teleport.lib.teleterm.hardwarekeyagent.v1.PIVSlot piv_slot = 2;
     */
    pivSlot: PIVSlot;
}
/**
 * GetAttestationRequest is a response to GetAttestation
 *
 * @generated from protobuf message teleport.lib.teleterm.hardwarekeyagent.v1.GetAttestationRequest
 */
export interface GetAttestationRequest {
    /**
     * KeyRef references a specific hardware private key.
     *
     * @generated from protobuf field: teleport.lib.teleterm.hardwarekeyagent.v1.KeyRef key_ref = 1;
     */
    keyRef?: KeyRef;
}
/**
 * GetAttestationResponse is a response to GetAttestationResponse.
 *
 * @generated from protobuf message teleport.lib.teleterm.hardwarekeyagent.v1.GetAttestationResponse
 */
export interface GetAttestationResponse {
    /**
     * AttestationStatement is a hardware key attestation statement corresponding
     * to a hardware private key.
     *
     * @generated from protobuf field: teleport.attestation.v1.AttestationStatement attestation_statement = 1;
     */
    attestationStatement?: AttestationStatement;
}
/**
 * PIVSlot is a specific PIV slot on a hardware key.
 *
 * @generated from protobuf enum teleport.lib.teleterm.hardwarekeyagent.v1.PIVSlot
 */
export enum PIVSlot {
    /**
     * PIV slot not specified.
     *
     * @generated from protobuf enum value: PIV_SLOT_UNSPECIFIED = 0;
     */
    PIV_SLOT_UNSPECIFIED = 0,
    /**
     * PIV slot 9a. This is the default slot for pin_policy=never, touch_policy=never.
     *
     * @generated from protobuf enum value: PIV_SLOT_9A = 1;
     */
    PIV_SLOT_9A = 1,
    /**
     * PIV slot 9c. This is the default slot for pin_policy=never, touch_policy=cached.
     *
     * @generated from protobuf enum value: PIV_SLOT_9C = 2;
     */
    PIV_SLOT_9C = 2,
    /**
     * PIV slot 9d. This is the default slot for pin_policy=once, touch_policy=cached.
     *
     * @generated from protobuf enum value: PIV_SLOT_9D = 3;
     */
    PIV_SLOT_9D = 3,
    /**
     * PIV slot 9e. This is the default slot for pin_policy=once, touch_policy=never.
     *
     * @generated from protobuf enum value: PIV_SLOT_9E = 4;
     */
    PIV_SLOT_9E = 4
}
/**
 * HashName is the name of a specific hashing algorithm.
 * These values match the Go [crypto] standard library.
 *
 * @generated from protobuf enum teleport.lib.teleterm.hardwarekeyagent.v1.HashName
 */
export enum HashName {
    /**
     * TODO: remove unneeded hash functions. Check with a custom RSA, ECDSA and ED25519 hardware key.
     *
     * @generated from protobuf enum value: HASH_NAME_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: HASH_NAME_MD4 = 1;
     */
    MD4 = 1,
    /**
     * @generated from protobuf enum value: HASH_NAME_MD5 = 2;
     */
    MD5 = 2,
    /**
     * @generated from protobuf enum value: HASH_NAME_SHA1 = 3;
     */
    SHA1 = 3,
    /**
     * @generated from protobuf enum value: HASH_NAME_SHA224 = 4;
     */
    SHA224 = 4,
    /**
     * @generated from protobuf enum value: HASH_NAME_SHA256 = 5;
     */
    SHA256 = 5,
    /**
     * @generated from protobuf enum value: HASH_NAME_SHA384 = 6;
     */
    SHA384 = 6,
    /**
     * @generated from protobuf enum value: HASH_NAME_SHA512 = 7;
     */
    SHA512 = 7,
    /**
     * @generated from protobuf enum value: HASH_NAME_MD5SHA1 = 8;
     */
    MD5SHA1 = 8,
    /**
     * @generated from protobuf enum value: HASH_NAME_RIPEMD160 = 9;
     */
    RIPEMD160 = 9,
    /**
     * @generated from protobuf enum value: HASH_NAME_SHA3_224 = 10;
     */
    SHA3_224 = 10,
    /**
     * @generated from protobuf enum value: HASH_NAME_SHA3_256 = 11;
     */
    SHA3_256 = 11,
    /**
     * @generated from protobuf enum value: HASH_NAME_SHA3_384 = 12;
     */
    SHA3_384 = 12,
    /**
     * @generated from protobuf enum value: HASH_NAME_SHA3_512 = 13;
     */
    SHA3_512 = 13,
    /**
     * @generated from protobuf enum value: HASH_NAME_SHA512_224 = 14;
     */
    SHA512_224 = 14,
    /**
     * @generated from protobuf enum value: HASH_NAME_SHA512_256 = 15;
     */
    SHA512_256 = 15,
    /**
     * @generated from protobuf enum value: HASH_NAME_BLAKE2S_256 = 16;
     */
    BLAKE2S_256 = 16,
    /**
     * @generated from protobuf enum value: HASH_NAME_BLAKE2B_256 = 17;
     */
    BLAKE2B_256 = 17,
    /**
     * @generated from protobuf enum value: HASH_NAME_BLAKE2B_384 = 18;
     */
    BLAKE2B_384 = 18,
    /**
     * @generated from protobuf enum value: HASH_NAME_BLAKE2B_512 = 19;
     */
    BLAKE2B_512 = 19
}
/**
 * SaltLengthAuto is the length of the salt added to the digest before a signature.
 *
 * @generated from protobuf enum teleport.lib.teleterm.hardwarekeyagent.v1.SaltLengthAuto
 */
export enum SaltLengthAuto {
    /**
     * @generated from protobuf enum value: SALT_LENGTH_AUTO_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Use the maximum salt length for a given public key size and hash function size.
     *
     * @generated from protobuf enum value: SALT_LENGTH_AUTO_MAX = 1;
     */
    MAX = 1,
    /**
     * Use a salt equal in length to the chosen hash used.
     *
     * @generated from protobuf enum value: SALT_LENGTH_AUTO_HASH_LENGTH = 2;
     */
    HASH_LENGTH = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class SignRequest$Type extends MessageType<SignRequest> {
    constructor() {
        super("teleport.lib.teleterm.hardwarekeyagent.v1.SignRequest", [
            { no: 1, name: "key_ref", kind: "message", T: () => KeyRef },
            { no: 2, name: "public_key_der", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "digest", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "hash_name", kind: "enum", T: () => ["teleport.lib.teleterm.hardwarekeyagent.v1.HashName", HashName, "HASH_NAME_"] },
            { no: 5, name: "length", kind: "scalar", oneof: "saltLength", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "auto", kind: "enum", oneof: "saltLength", T: () => ["teleport.lib.teleterm.hardwarekeyagent.v1.SaltLengthAuto", SaltLengthAuto, "SALT_LENGTH_AUTO_"] }
        ]);
    }
    create(value?: PartialMessage<SignRequest>): SignRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.publicKeyDer = new Uint8Array(0);
        message.digest = new Uint8Array(0);
        message.hashName = 0;
        message.saltLength = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<SignRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SignRequest): SignRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.lib.teleterm.hardwarekeyagent.v1.KeyRef key_ref */ 1:
                    message.keyRef = KeyRef.internalBinaryRead(reader, reader.uint32(), options, message.keyRef);
                    break;
                case /* bytes public_key_der */ 2:
                    message.publicKeyDer = reader.bytes();
                    break;
                case /* bytes digest */ 3:
                    message.digest = reader.bytes();
                    break;
                case /* teleport.lib.teleterm.hardwarekeyagent.v1.HashName hash_name */ 4:
                    message.hashName = reader.int32();
                    break;
                case /* uint32 length */ 5:
                    message.saltLength = {
                        oneofKind: "length",
                        length: reader.uint32()
                    };
                    break;
                case /* teleport.lib.teleterm.hardwarekeyagent.v1.SaltLengthAuto auto */ 6:
                    message.saltLength = {
                        oneofKind: "auto",
                        auto: reader.int32()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SignRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.lib.teleterm.hardwarekeyagent.v1.KeyRef key_ref = 1; */
        if (message.keyRef)
            KeyRef.internalBinaryWrite(message.keyRef, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bytes public_key_der = 2; */
        if (message.publicKeyDer.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.publicKeyDer);
        /* bytes digest = 3; */
        if (message.digest.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.digest);
        /* teleport.lib.teleterm.hardwarekeyagent.v1.HashName hash_name = 4; */
        if (message.hashName !== 0)
            writer.tag(4, WireType.Varint).int32(message.hashName);
        /* uint32 length = 5; */
        if (message.saltLength.oneofKind === "length")
            writer.tag(5, WireType.Varint).uint32(message.saltLength.length);
        /* teleport.lib.teleterm.hardwarekeyagent.v1.SaltLengthAuto auto = 6; */
        if (message.saltLength.oneofKind === "auto")
            writer.tag(6, WireType.Varint).int32(message.saltLength.auto);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.hardwarekeyagent.v1.SignRequest
 */
export const SignRequest = new SignRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Signature$Type extends MessageType<Signature> {
    constructor() {
        super("teleport.lib.teleterm.hardwarekeyagent.v1.Signature", [
            { no: 1, name: "signature", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Signature>): Signature {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.signature = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<Signature>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Signature): Signature {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes signature */ 1:
                    message.signature = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Signature, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes signature = 1; */
        if (message.signature.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.signature);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.hardwarekeyagent.v1.Signature
 */
export const Signature = new Signature$Type();
// @generated message type with reflection information, may provide speed optimized methods
class KeyRef$Type extends MessageType<KeyRef> {
    constructor() {
        super("teleport.lib.teleterm.hardwarekeyagent.v1.KeyRef", [
            { no: 1, name: "serial_number", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "piv_slot", kind: "enum", T: () => ["teleport.lib.teleterm.hardwarekeyagent.v1.PIVSlot", PIVSlot] }
        ]);
    }
    create(value?: PartialMessage<KeyRef>): KeyRef {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.serialNumber = 0;
        message.pivSlot = 0;
        if (value !== undefined)
            reflectionMergePartial<KeyRef>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KeyRef): KeyRef {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 serial_number */ 1:
                    message.serialNumber = reader.uint32();
                    break;
                case /* teleport.lib.teleterm.hardwarekeyagent.v1.PIVSlot piv_slot */ 2:
                    message.pivSlot = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: KeyRef, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 serial_number = 1; */
        if (message.serialNumber !== 0)
            writer.tag(1, WireType.Varint).uint32(message.serialNumber);
        /* teleport.lib.teleterm.hardwarekeyagent.v1.PIVSlot piv_slot = 2; */
        if (message.pivSlot !== 0)
            writer.tag(2, WireType.Varint).int32(message.pivSlot);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.hardwarekeyagent.v1.KeyRef
 */
export const KeyRef = new KeyRef$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAttestationRequest$Type extends MessageType<GetAttestationRequest> {
    constructor() {
        super("teleport.lib.teleterm.hardwarekeyagent.v1.GetAttestationRequest", [
            { no: 1, name: "key_ref", kind: "message", T: () => KeyRef }
        ]);
    }
    create(value?: PartialMessage<GetAttestationRequest>): GetAttestationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetAttestationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAttestationRequest): GetAttestationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.lib.teleterm.hardwarekeyagent.v1.KeyRef key_ref */ 1:
                    message.keyRef = KeyRef.internalBinaryRead(reader, reader.uint32(), options, message.keyRef);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAttestationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.lib.teleterm.hardwarekeyagent.v1.KeyRef key_ref = 1; */
        if (message.keyRef)
            KeyRef.internalBinaryWrite(message.keyRef, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.hardwarekeyagent.v1.GetAttestationRequest
 */
export const GetAttestationRequest = new GetAttestationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAttestationResponse$Type extends MessageType<GetAttestationResponse> {
    constructor() {
        super("teleport.lib.teleterm.hardwarekeyagent.v1.GetAttestationResponse", [
            { no: 1, name: "attestation_statement", kind: "message", T: () => AttestationStatement }
        ]);
    }
    create(value?: PartialMessage<GetAttestationResponse>): GetAttestationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetAttestationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAttestationResponse): GetAttestationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* teleport.attestation.v1.AttestationStatement attestation_statement */ 1:
                    message.attestationStatement = AttestationStatement.internalBinaryRead(reader, reader.uint32(), options, message.attestationStatement);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAttestationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* teleport.attestation.v1.AttestationStatement attestation_statement = 1; */
        if (message.attestationStatement)
            AttestationStatement.internalBinaryWrite(message.attestationStatement, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.lib.teleterm.hardwarekeyagent.v1.GetAttestationResponse
 */
export const GetAttestationResponse = new GetAttestationResponse$Type();
/**
 * @generated ServiceType for protobuf service teleport.lib.teleterm.hardwarekeyagent.v1.HardwareKeyAgentService
 */
export const HardwareKeyAgentService = new ServiceType("teleport.lib.teleterm.hardwarekeyagent.v1.HardwareKeyAgentService", [
    { name: "Sign", options: {}, I: SignRequest, O: Signature },
    { name: "GetAttestation", options: {}, I: GetAttestationRequest, O: GetAttestationResponse }
]);
