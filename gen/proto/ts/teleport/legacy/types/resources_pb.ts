/* eslint-disable */
// @generated by protobuf-ts 2.9.3 with parameter add_pb_suffix,eslint_disable,generate_dependencies,server_grpc1,ts_nocheck
// @generated from protobuf file "teleport/legacy/types/resources.proto" (package "types", syntax proto3)
// tslint:disable
// @ts-nocheck
//
// Copyright 2025 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * ResourceID is a unique identifier for a teleport resource.
 * Must be kept in sync with teleport.decision.v1alpha1.ResourceId.
 *
 * @generated from protobuf message types.ResourceID
 */
export interface ResourceID {
    /**
     * ClusterName is the name of the cluster the resource is in.
     *
     * @generated from protobuf field: string ClusterName = 1 [json_name = "ClusterName"];
     */
    clusterName: string;
    /**
     * Kind is the resource kind.
     *
     * @generated from protobuf field: string Kind = 2 [json_name = "Kind"];
     */
    kind: string;
    /**
     * Name is the name of the specific resource.
     *
     * @generated from protobuf field: string Name = 3 [json_name = "Name"];
     */
    name: string;
    /**
     * SubResourceName is the resource belonging to resource identified by "Name"
     * that the user is allowed to access to.
     * When granting access to a subresource, access to other resources is limited.
     * Currently it just supports resources of Kind=pod and the format is the following
     * "<kube_namespace>/<kube_pod>".
     *
     * @generated from protobuf field: string SubResourceName = 4 [json_name = "SubResourceName"];
     */
    subResourceName: string;
}
/**
 * ResourceIDList represents a list of ResourceID objects.
 *
 * @generated from protobuf message types.ResourceIDList
 */
export interface ResourceIDList {
    /**
     * @generated from protobuf field: repeated types.ResourceID resource_ids = 1;
     */
    resourceIds: ResourceID[];
}
/**
 * ResourceConstraints is a domain-specific payload that narrows what principals
 * or options are allowed on the associated ResourceID. Exactly one detail is set.
 *
 * @generated from protobuf message types.ResourceConstraints
 */
export interface ResourceConstraints {
    /**
     * version is version; supported values are: `v1`.
     *
     * @generated from protobuf field: string version = 1;
     */
    version: string;
    /**
     * @generated from protobuf oneof: details
     */
    details: {
        oneofKind: "awsConsole";
        /**
         * aws_console scopes an AWS Console app to a subset of role ARNs
         * the requester is allowed to use.
         *
         * @generated from protobuf field: types.AWSConsoleResourceConstraints aws_console = 10;
         */
        awsConsole: AWSConsoleResourceConstraints;
    } | {
        oneofKind: undefined;
    };
}
/**
 * AwsConsoleResourceConstraints scopes an AWS Console app to a subset of role ARNs
 * the requester is allowed to use.
 *
 * @generated from protobuf message types.AWSConsoleResourceConstraints
 */
export interface AWSConsoleResourceConstraints {
    /**
     * @generated from protobuf field: repeated string role_arns = 1;
     */
    roleArns: string[];
}
/**
 * ResourceAccessID represents a ResourceID in an Access Request-related context,
 * where additional information such as ResourceConstraints may be provided.
 *
 * @generated from protobuf message types.ResourceAccessID
 */
export interface ResourceAccessID {
    /**
     * @generated from protobuf field: types.ResourceID id = 1;
     */
    id?: ResourceID;
    /**
     * @generated from protobuf field: types.ResourceConstraints constraints = 2;
     */
    constraints?: ResourceConstraints;
}
/**
 * ResourceAccessIDList represents a list of ResourceAccessIDs
 *
 * @generated from protobuf message types.ResourceAccessIDList
 */
export interface ResourceAccessIDList {
    /**
     * @generated from protobuf field: repeated types.ResourceAccessID resources = 1;
     */
    resources: ResourceAccessID[];
}
// @generated message type with reflection information, may provide speed optimized methods
class ResourceID$Type extends MessageType<ResourceID> {
    constructor() {
        super("types.ResourceID", [
            { no: 1, name: "ClusterName", kind: "scalar", jsonName: "ClusterName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "cluster" } },
            { no: 2, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 3, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "name" } },
            { no: 4, name: "SubResourceName", kind: "scalar", jsonName: "SubResourceName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub_resource,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ResourceID>): ResourceID {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterName = "";
        message.kind = "";
        message.name = "";
        message.subResourceName = "";
        if (value !== undefined)
            reflectionMergePartial<ResourceID>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResourceID): ResourceID {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ClusterName = 1 [json_name = "ClusterName"];*/ 1:
                    message.clusterName = reader.string();
                    break;
                case /* string Kind = 2 [json_name = "Kind"];*/ 2:
                    message.kind = reader.string();
                    break;
                case /* string Name = 3 [json_name = "Name"];*/ 3:
                    message.name = reader.string();
                    break;
                case /* string SubResourceName = 4 [json_name = "SubResourceName"];*/ 4:
                    message.subResourceName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResourceID, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ClusterName = 1 [json_name = "ClusterName"]; */
        if (message.clusterName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterName);
        /* string Kind = 2 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.kind);
        /* string Name = 3 [json_name = "Name"]; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string SubResourceName = 4 [json_name = "SubResourceName"]; */
        if (message.subResourceName !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.subResourceName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ResourceID
 */
export const ResourceID = new ResourceID$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResourceIDList$Type extends MessageType<ResourceIDList> {
    constructor() {
        super("types.ResourceIDList", [
            { no: 1, name: "resource_ids", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ResourceID, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<ResourceIDList>): ResourceIDList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.resourceIds = [];
        if (value !== undefined)
            reflectionMergePartial<ResourceIDList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResourceIDList): ResourceIDList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.ResourceID resource_ids */ 1:
                    message.resourceIds.push(ResourceID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResourceIDList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.ResourceID resource_ids = 1; */
        for (let i = 0; i < message.resourceIds.length; i++)
            ResourceID.internalBinaryWrite(message.resourceIds[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ResourceIDList
 */
export const ResourceIDList = new ResourceIDList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResourceConstraints$Type extends MessageType<ResourceConstraints> {
    constructor() {
        super("types.ResourceConstraints", [
            { no: 1, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "aws_console", kind: "message", oneof: "details", T: () => AWSConsoleResourceConstraints }
        ]);
    }
    create(value?: PartialMessage<ResourceConstraints>): ResourceConstraints {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.version = "";
        message.details = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ResourceConstraints>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResourceConstraints): ResourceConstraints {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string version */ 1:
                    message.version = reader.string();
                    break;
                case /* types.AWSConsoleResourceConstraints aws_console */ 10:
                    message.details = {
                        oneofKind: "awsConsole",
                        awsConsole: AWSConsoleResourceConstraints.internalBinaryRead(reader, reader.uint32(), options, (message.details as any).awsConsole)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResourceConstraints, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string version = 1; */
        if (message.version !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.version);
        /* types.AWSConsoleResourceConstraints aws_console = 10; */
        if (message.details.oneofKind === "awsConsole")
            AWSConsoleResourceConstraints.internalBinaryWrite(message.details.awsConsole, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ResourceConstraints
 */
export const ResourceConstraints = new ResourceConstraints$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AWSConsoleResourceConstraints$Type extends MessageType<AWSConsoleResourceConstraints> {
    constructor() {
        super("types.AWSConsoleResourceConstraints", [
            { no: 1, name: "role_arns", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AWSConsoleResourceConstraints>): AWSConsoleResourceConstraints {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.roleArns = [];
        if (value !== undefined)
            reflectionMergePartial<AWSConsoleResourceConstraints>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AWSConsoleResourceConstraints): AWSConsoleResourceConstraints {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string role_arns */ 1:
                    message.roleArns.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AWSConsoleResourceConstraints, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string role_arns = 1; */
        for (let i = 0; i < message.roleArns.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.roleArns[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AWSConsoleResourceConstraints
 */
export const AWSConsoleResourceConstraints = new AWSConsoleResourceConstraints$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResourceAccessID$Type extends MessageType<ResourceAccessID> {
    constructor() {
        super("types.ResourceAccessID", [
            { no: 1, name: "id", kind: "message", T: () => ResourceID, options: { "gogoproto.nullable": false } },
            { no: 2, name: "constraints", kind: "message", T: () => ResourceConstraints, options: { "gogoproto.nullable": true } }
        ]);
    }
    create(value?: PartialMessage<ResourceAccessID>): ResourceAccessID {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ResourceAccessID>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResourceAccessID): ResourceAccessID {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.ResourceID id */ 1:
                    message.id = ResourceID.internalBinaryRead(reader, reader.uint32(), options, message.id);
                    break;
                case /* types.ResourceConstraints constraints */ 2:
                    message.constraints = ResourceConstraints.internalBinaryRead(reader, reader.uint32(), options, message.constraints);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResourceAccessID, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.ResourceID id = 1; */
        if (message.id)
            ResourceID.internalBinaryWrite(message.id, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* types.ResourceConstraints constraints = 2; */
        if (message.constraints)
            ResourceConstraints.internalBinaryWrite(message.constraints, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ResourceAccessID
 */
export const ResourceAccessID = new ResourceAccessID$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResourceAccessIDList$Type extends MessageType<ResourceAccessIDList> {
    constructor() {
        super("types.ResourceAccessIDList", [
            { no: 1, name: "resources", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ResourceAccessID, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<ResourceAccessIDList>): ResourceAccessIDList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.resources = [];
        if (value !== undefined)
            reflectionMergePartial<ResourceAccessIDList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResourceAccessIDList): ResourceAccessIDList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.ResourceAccessID resources */ 1:
                    message.resources.push(ResourceAccessID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResourceAccessIDList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.ResourceAccessID resources = 1; */
        for (let i = 0; i < message.resources.length; i++)
            ResourceAccessID.internalBinaryWrite(message.resources[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ResourceAccessIDList
 */
export const ResourceAccessIDList = new ResourceAccessIDList$Type();
