/* eslint-disable */
// @generated by protobuf-ts 2.9.3 with parameter eslint_disable,add_pb_suffix,server_grpc1,ts_nocheck
// @generated from protobuf file "teleport/legacy/types/events/events.proto" (package "events", syntax proto3)
// tslint:disable
// @ts-nocheck
//
// Copyright 2021 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { LabelValues } from "../wrappers/wrappers_pb";
import { SAMLConnectorV2 } from "../types_pb";
import { UInt32Value } from "../../../../google/protobuf/wrappers_pb";
import { UInt64Value } from "../../../../google/protobuf/wrappers_pb";
import { Struct } from "../../../../google/protobuf/struct_pb";
import { LockTarget } from "../types_pb";
import { MembershipKind } from "../../../accesslist/v1/accesslist_pb";
import { Timestamp } from "../../../../google/protobuf/timestamp_pb";
/**
 * Metadata is a common event metadata
 *
 * @generated from protobuf message events.Metadata
 */
export interface Metadata {
    /**
     * Index is a monotonically incremented index in the event sequence
     *
     * @generated from protobuf field: int64 Index = 1 [json_name = "Index"];
     */
    index: bigint;
    /**
     * Type is the event type
     *
     * @generated from protobuf field: string Type = 2 [json_name = "Type"];
     */
    type: string;
    /**
     * ID is a unique event identifier
     *
     * @generated from protobuf field: string ID = 3 [json_name = "ID"];
     */
    iD: string;
    /**
     * Code is a unique event code
     *
     * @generated from protobuf field: string Code = 4 [json_name = "Code"];
     */
    code: string;
    /**
     * Time is event time
     *
     * @generated from protobuf field: google.protobuf.Timestamp Time = 5 [json_name = "Time"];
     */
    time?: Timestamp;
    /**
     * ClusterName identifies the originating teleport cluster
     *
     * @generated from protobuf field: string ClusterName = 6 [json_name = "ClusterName"];
     */
    clusterName: string;
}
/**
 * SessionMetadata is a common session event metadata
 *
 * @generated from protobuf message events.SessionMetadata
 */
export interface SessionMetadata {
    /**
     * SessionID is a unique UUID of the session.
     *
     * @generated from protobuf field: string SessionID = 1 [json_name = "SessionID"];
     */
    sessionID: string;
    /**
     * WithMFA is a UUID of an MFA device used to start this session.
     *
     * @generated from protobuf field: string WithMFA = 2 [json_name = "WithMFA"];
     */
    withMFA: string;
    /**
     * PrivateKeyPolicy is the private key policy of the private key used to start this session.
     *
     * @generated from protobuf field: string PrivateKeyPolicy = 3 [json_name = "PrivateKeyPolicy"];
     */
    privateKeyPolicy: string;
}
/**
 * UserMetadata is a common user event metadata
 *
 * @generated from protobuf message events.UserMetadata
 */
export interface UserMetadata {
    /**
     * User is teleport user name
     *
     * @generated from protobuf field: string User = 1 [json_name = "User"];
     */
    user: string;
    /**
     * Login is OS login
     *
     * @generated from protobuf field: string Login = 2 [json_name = "Login"];
     */
    login: string;
    /**
     * Impersonator is a user acting on behalf of another user
     *
     * @generated from protobuf field: string Impersonator = 3 [json_name = "Impersonator"];
     */
    impersonator: string;
    /**
     * AWSRoleARN is AWS IAM role user assumes when accessing AWS console.
     *
     * @generated from protobuf field: string AWSRoleARN = 4 [json_name = "AWSRoleARN"];
     */
    aWSRoleARN: string;
    /**
     * AccessRequests are the IDs of access requests created by the user
     *
     * @generated from protobuf field: repeated string AccessRequests = 5 [json_name = "AccessRequests"];
     */
    accessRequests: string[];
    /**
     * AzureIdentity is the Azure identity user assumes when accessing Azure API.
     *
     * @generated from protobuf field: string AzureIdentity = 6 [json_name = "AzureIdentity"];
     */
    azureIdentity: string;
    /**
     * GCPServiceAccount is the GCP service account user assumes when accessing GCP API.
     *
     * @generated from protobuf field: string GCPServiceAccount = 7 [json_name = "GCPServiceAccount"];
     */
    gCPServiceAccount: string;
    /**
     * TrustedDevice contains information about the users' trusted device.
     * Requires a registered and enrolled device to be used during authentication.
     *
     * @generated from protobuf field: events.DeviceMetadata TrustedDevice = 8 [json_name = "TrustedDevice"];
     */
    trustedDevice?: DeviceMetadata;
    /**
     * RequiredPrivateKeyPolicy is the private key policy enforced for this login.
     *
     * @generated from protobuf field: string RequiredPrivateKeyPolicy = 9 [json_name = "RequiredPrivateKeyPolicy"];
     */
    requiredPrivateKeyPolicy: string;
    /**
     * UserKind indicates what type of user this is, e.g. a human or Machine ID
     * bot user.
     *
     * @generated from protobuf field: events.UserKind UserKind = 10 [json_name = "UserKind"];
     */
    userKind: UserKind;
    /**
     * BotName is the name of the Bot if this action is associated with one.
     *
     * @generated from protobuf field: string BotName = 11 [json_name = "BotName"];
     */
    botName: string;
    /**
     * BotInstanceID is the ID of the Bot Instance if this action is associated
     * with one.
     *
     * @generated from protobuf field: string BotInstanceID = 12 [json_name = "BotInstanceID"];
     */
    botInstanceID: string;
    /**
     * UserOrigin specifies the origin of this user account.
     *
     * @generated from protobuf field: events.UserOrigin UserOrigin = 13 [json_name = "UserOrigin"];
     */
    userOrigin: UserOrigin;
}
/**
 * Server is a server metadata
 *
 * @generated from protobuf message events.ServerMetadata
 */
export interface ServerMetadata {
    /**
     * ServerNamespace is a namespace of the server event
     *
     * @generated from protobuf field: string ServerNamespace = 1 [json_name = "ServerNamespace"];
     */
    serverNamespace: string;
    /**
     * ServerID is the UUID of the server the session occurred on.
     *
     * @generated from protobuf field: string ServerID = 2 [json_name = "ServerID"];
     */
    serverID: string;
    /**
     * ServerHostname is the hostname of the server the session occurred on.
     *
     * @generated from protobuf field: string ServerHostname = 3 [json_name = "ServerHostname"];
     */
    serverHostname: string;
    /**
     * ServerAddr is the address of the server the session occurred on.
     *
     * @generated from protobuf field: string ServerAddr = 4 [json_name = "ServerAddr"];
     */
    serverAddr: string;
    /**
     * ServerLabels are the labels (static and dynamic) of the server the
     * session occurred on.
     *
     * @generated from protobuf field: map<string, string> ServerLabels = 5 [json_name = "ServerLabels"];
     */
    serverLabels: {
        [key: string]: string;
    };
    /**
     * ForwardedBy tells us if the metadata was sent by the node itself or by another node in it's
     * place. We can't verify emit permissions fully for these events so care should be taken with
     * them.
     *
     * @generated from protobuf field: string ForwardedBy = 6 [json_name = "ForwardedBy"];
     */
    forwardedBy: string;
    /**
     * ServerSubKind is the sub kind of the server the session occurred on.
     *
     * @generated from protobuf field: string ServerSubKind = 7 [json_name = "ServerSubKind"];
     */
    serverSubKind: string;
    /**
     * ServerVersion is the component version the session occurred on.
     *
     * @generated from protobuf field: string ServerVersion = 8 [json_name = "ServerVersion"];
     */
    serverVersion: string;
}
/**
 * Connection contains connection info
 *
 * @generated from protobuf message events.ConnectionMetadata
 */
export interface ConnectionMetadata {
    /**
     * LocalAddr is a target address on the host
     *
     * @generated from protobuf field: string LocalAddr = 1 [json_name = "LocalAddr"];
     */
    localAddr: string;
    /**
     * RemoteAddr is a client (user's) address
     *
     * @generated from protobuf field: string RemoteAddr = 2 [json_name = "RemoteAddr"];
     */
    remoteAddr: string;
    /**
     * Protocol specifies protocol that was captured
     *
     * @generated from protobuf field: string Protocol = 3 [json_name = "Protocol"];
     */
    protocol: string;
}
/**
 * ClientMetadata identifies the originating client for an event.
 *
 * @generated from protobuf message events.ClientMetadata
 */
export interface ClientMetadata {
    /**
     * UserAgent identifies the type of client that attempted the event.
     *
     * @generated from protobuf field: string UserAgent = 1 [json_name = "UserAgent"];
     */
    userAgent: string;
}
/**
 * KubernetesClusterMetadata contains common metadata for kubernetes-related
 * events.
 *
 * @generated from protobuf message events.KubernetesClusterMetadata
 */
export interface KubernetesClusterMetadata {
    /**
     * KubernetesCluster is a kubernetes cluster name.
     *
     * @generated from protobuf field: string KubernetesCluster = 1 [json_name = "KubernetesCluster"];
     */
    kubernetesCluster: string;
    /**
     * KubernetesUsers is a list of kubernetes usernames for the user.
     *
     * @generated from protobuf field: repeated string KubernetesUsers = 2 [json_name = "KubernetesUsers"];
     */
    kubernetesUsers: string[];
    /**
     * KubernetesGroups is a list of kubernetes groups for the user.
     *
     * @generated from protobuf field: repeated string KubernetesGroups = 3 [json_name = "KubernetesGroups"];
     */
    kubernetesGroups: string[];
    /**
     * KubernetesLabels are the labels (static and dynamic) of the kubernetes cluster the
     * session occurred on.
     *
     * @generated from protobuf field: map<string, string> KubernetesLabels = 4 [json_name = "KubernetesLabels"];
     */
    kubernetesLabels: {
        [key: string]: string;
    };
}
/**
 * KubernetesPodMetadata contains common metadata for kubernetes pod-related
 * events.
 *
 * @generated from protobuf message events.KubernetesPodMetadata
 */
export interface KubernetesPodMetadata {
    /**
     * KubernetesPodName is the name of the pod.
     *
     * @generated from protobuf field: string KubernetesPodName = 1 [json_name = "KubernetesPodName"];
     */
    kubernetesPodName: string;
    /**
     * KubernetesPodNamespace is the namespace of the pod.
     *
     * @generated from protobuf field: string KubernetesPodNamespace = 2 [json_name = "KubernetesPodNamespace"];
     */
    kubernetesPodNamespace: string;
    /**
     * KubernetesContainerName is the name of the container within the pod.
     *
     * @generated from protobuf field: string KubernetesContainerName = 3 [json_name = "KubernetesContainerName"];
     */
    kubernetesContainerName: string;
    /**
     * KubernetesContainerImage is the image of the container within the pod.
     *
     * @generated from protobuf field: string KubernetesContainerImage = 4 [json_name = "KubernetesContainerImage"];
     */
    kubernetesContainerImage: string;
    /**
     * KubernetesNodeName is the node that runs the pod.
     *
     * @generated from protobuf field: string KubernetesNodeName = 5 [json_name = "KubernetesNodeName"];
     */
    kubernetesNodeName: string;
}
/**
 * SAMLIdPServiceProviderMetadata contains common metadata for SAML IdP service provider
 * events.
 *
 * @generated from protobuf message events.SAMLIdPServiceProviderMetadata
 */
export interface SAMLIdPServiceProviderMetadata {
    /**
     * ServiceProviderEntityID is the entity ID of the service provider.
     *
     * @generated from protobuf field: string ServiceProviderEntityID = 1 [json_name = "ServiceProviderEntityID"];
     */
    serviceProviderEntityID: string;
    /**
     * ServiceProviderShortcut is the shortcut name of a service provider.
     *
     * @generated from protobuf field: string ServiceProviderShortcut = 2 [json_name = "ServiceProviderShortcut"];
     */
    serviceProviderShortcut: string;
    /**
     * AttributeMapping is a map of attribute name and value which will be asserted in SAML response.
     *
     * @generated from protobuf field: map<string, string> AttributeMapping = 3 [json_name = "AttributeMapping"];
     */
    attributeMapping: {
        [key: string]: string;
    };
}
/**
 * OktaResourcesUpdatedMetadata contains common metadata for Okta resources updated events.
 *
 * @generated from protobuf message events.OktaResourcesUpdatedMetadata
 */
export interface OktaResourcesUpdatedMetadata {
    /**
     * Added is the number of resources added.
     *
     * @generated from protobuf field: int32 Added = 1 [json_name = "Added"];
     */
    added: number;
    /**
     * Updated is the number of resources updated.
     *
     * @generated from protobuf field: int32 Updated = 2 [json_name = "Updated"];
     */
    updated: number;
    /**
     * Deleted is the number of resources deleted.
     *
     * @generated from protobuf field: int32 Deleted = 3 [json_name = "Deleted"];
     */
    deleted: number;
    /**
     * AddedResources is a list of the actual resources that were added.
     *
     * @generated from protobuf field: repeated events.OktaResource AddedResources = 4 [json_name = "AddedResources"];
     */
    addedResources: OktaResource[];
    /**
     * UpdatedResources is a list of the actual resources that were updated.
     *
     * @generated from protobuf field: repeated events.OktaResource UpdatedResources = 5 [json_name = "UpdatedResources"];
     */
    updatedResources: OktaResource[];
    /**
     * DeletedResources is a list of the actual resources that were deleted.
     *
     * @generated from protobuf field: repeated events.OktaResource DeletedResources = 6 [json_name = "DeletedResources"];
     */
    deletedResources: OktaResource[];
}
/**
 * OktaResource is a descriptor of an Okta resource.
 *
 * @generated from protobuf message events.OktaResource
 */
export interface OktaResource {
    /**
     * ID is the identifier of the Okta resource.
     *
     * @generated from protobuf field: string ID = 1 [json_name = "ID"];
     */
    iD: string;
    /**
     * Description is the description of the Okta resource.
     *
     * @generated from protobuf field: string Description = 2 [json_name = "Description"];
     */
    description: string;
}
/**
 * OktaAssignmentMetadata contains common metadata for Okta assignment events.
 *
 * @generated from protobuf message events.OktaAssignmentMetadata
 */
export interface OktaAssignmentMetadata {
    /**
     * Source is the source of the Okta assignment.
     *
     * @generated from protobuf field: string Source = 1 [json_name = "Source"];
     */
    source: string;
    /**
     * User is the user the Okta assignment is for.
     *
     * @generated from protobuf field: string User = 2 [json_name = "User"];
     */
    user: string;
    /**
     * StartingStatus is the starting status of the assignment.
     *
     * @generated from protobuf field: string StartingStatus = 3 [json_name = "StartingStatus"];
     */
    startingStatus: string;
    /**
     * EndingStatus is the ending status of the assignment.
     *
     * @generated from protobuf field: string EndingStatus = 4 [json_name = "EndingStatus"];
     */
    endingStatus: string;
}
/**
 * AccessListMemberMetadata contains common metadata for access list member resource events.
 *
 * @generated from protobuf message events.AccessListMemberMetadata
 */
export interface AccessListMemberMetadata {
    /**
     * AccessListName is the name of the access list the members are being added to or removed from.
     *
     * @generated from protobuf field: string AccessListName = 1 [json_name = "AccessListName"];
     */
    accessListName: string;
    /**
     * Members are all members affected by the access list membership change.
     *
     * @generated from protobuf field: repeated events.AccessListMember Members = 2 [json_name = "Members"];
     */
    members: AccessListMember[];
    /**
     * AccessListTitle is the access list's title.
     *
     * @generated from protobuf field: string AccessListTitle = 4 [json_name = "AccessListTitle"];
     */
    accessListTitle: string;
}
/**
 * AccessListMember is metadata surrounding an individual access list member.
 *
 * @generated from protobuf message events.AccessListMember
 */
export interface AccessListMember {
    /**
     * JoinedOn is the date that the member joined.
     *
     * @generated from protobuf field: google.protobuf.Timestamp JoinedOn = 1 [json_name = "JoinedOn"];
     */
    joinedOn?: Timestamp;
    /**
     * RemovedOn is the date that the access list member was removed. Will only be populated for deletion.
     *
     * @generated from protobuf field: google.protobuf.Timestamp RemovedOn = 2 [json_name = "RemovedOn"];
     */
    removedOn?: Timestamp;
    /**
     * Reason is the reason that the member was added, modified, or removed.
     *
     * @generated from protobuf field: string Reason = 3 [json_name = "Reason"];
     */
    reason: string;
    /**
     * MemberName is the name of the member.
     *
     * @generated from protobuf field: string MemberName = 4 [json_name = "MemberName"];
     */
    memberName: string;
    /**
     * MembershipKind describes the kind of membership, either
     * `MEMBERSHIP_KIND_USER` or `MEMBERSHIP_KIND_LIST`.
     *
     * @generated from protobuf field: teleport.accesslist.v1.MembershipKind membership_kind = 5;
     */
    membershipKind: MembershipKind;
}
/**
 * AccessListReviewMembershipRequirementsChanged contains information for when membership requirements change as part of a review.
 *
 * @generated from protobuf message events.AccessListReviewMembershipRequirementsChanged
 */
export interface AccessListReviewMembershipRequirementsChanged {
    /**
     * Roles are the roles that changed as part of a review.
     *
     * @generated from protobuf field: repeated string Roles = 1 [json_name = "Roles"];
     */
    roles: string[];
    /**
     * Traits are the traits that changed as part of a review.
     *
     * @generated from protobuf field: map<string, string> Traits = 2 [json_name = "Traits"];
     */
    traits: {
        [key: string]: string;
    };
}
/**
 * AccessListReviewMetadata contains metadata for access list review events.
 *
 * @generated from protobuf message events.AccessListReviewMetadata
 */
export interface AccessListReviewMetadata {
    /**
     * Message is the message that was supplied during the review.
     *
     * @generated from protobuf field: string Message = 1 [json_name = "Message"];
     */
    message: string;
    /**
     * ReviewID is the ID of the review.
     *
     * @generated from protobuf field: string ReviewID = 2 [json_name = "ReviewID"];
     */
    reviewID: string;
    /**
     * MembershipRequirementsChanged is populated if the memrship requirements have changed..
     *
     * @generated from protobuf field: events.AccessListReviewMembershipRequirementsChanged MembershipRequirementsChanged = 3 [json_name = "MembershipRequirementsChanged"];
     */
    membershipRequirementsChanged?: AccessListReviewMembershipRequirementsChanged;
    /**
     * ReviewFrequencyChanged is populated if the review frequency has changed.
     *
     * @generated from protobuf field: string ReviewFrequencyChanged = 4 [json_name = "ReviewFrequencyChanged"];
     */
    reviewFrequencyChanged: string;
    /**
     * ReviewDayOfMonthChanged is populated if the review day of month has changed.
     *
     * @generated from protobuf field: string ReviewDayOfMonthChanged = 5 [json_name = "ReviewDayOfMonthChanged"];
     */
    reviewDayOfMonthChanged: string;
    /**
     * RemovedMembers are the members that were removed as part of the review.
     *
     * @generated from protobuf field: repeated string RemovedMembers = 6 [json_name = "RemovedMembers"];
     */
    removedMembers: string[];
    /**
     * AccessListTitle is the access list's title.
     *
     * @generated from protobuf field: string AccessListTitle = 7 [json_name = "AccessListTitle"];
     */
    accessListTitle: string;
}
/**
 * LockMetadata contains common metadata for lock resource events.
 *
 * @generated from protobuf message events.LockMetadata
 */
export interface LockMetadata {
    /**
     * Target describes the set of interactions that the lock applies to
     *
     * @generated from protobuf field: types.LockTarget Target = 4 [json_name = "Target"];
     */
    target?: LockTarget;
}
/**
 * SessionStart is a session start event
 *
 * @generated from protobuf message events.SessionStart
 */
export interface SessionStart {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * ServerMetadata is a common server metadata
     *
     * @generated from protobuf field: events.ServerMetadata Server = 4 [json_name = "Server"];
     */
    server?: ServerMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 5 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * TerminalSize is expressed as 'W:H'
     *
     * @generated from protobuf field: string TerminalSize = 6 [json_name = "TerminalSize"];
     */
    terminalSize: string;
    /**
     * KubernetesCluster has information about a kubernetes cluster, if
     * applicable.
     *
     * @generated from protobuf field: events.KubernetesClusterMetadata KubernetesCluster = 7 [json_name = "KubernetesCluster"];
     */
    kubernetesCluster?: KubernetesClusterMetadata;
    /**
     * KubernetesPod has information about a kubernetes pod, if applicable.
     *
     * @generated from protobuf field: events.KubernetesPodMetadata KubernetesPod = 8 [json_name = "KubernetesPod"];
     */
    kubernetesPod?: KubernetesPodMetadata;
    /**
     * InitialCommand is the command used to start this session.
     *
     * @generated from protobuf field: repeated string InitialCommand = 9 [json_name = "InitialCommand"];
     */
    initialCommand: string[];
    /**
     * SessionRecording is the type of session recording.
     *
     * @generated from protobuf field: string SessionRecording = 10 [json_name = "SessionRecording"];
     */
    sessionRecording: string;
    /**
     * Invited is a list of invited users to this session.
     *
     * @generated from protobuf field: repeated string Invited = 12 [json_name = "Invited"];
     */
    invited: string[];
    /**
     * Reason is the reason for starting this session.
     *
     * @generated from protobuf field: string Reason = 13 [json_name = "Reason"];
     */
    reason: string;
}
/**
 * SessionJoin emitted when another user joins a session
 *
 * @generated from protobuf message events.SessionJoin
 */
export interface SessionJoin {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * ServerMetadata is a common server metadata
     *
     * @generated from protobuf field: events.ServerMetadata Server = 4 [json_name = "Server"];
     */
    server?: ServerMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 5 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * KubernetesCluster has information about a kubernetes cluster, if
     * applicable.
     *
     * @generated from protobuf field: events.KubernetesClusterMetadata KubernetesCluster = 6 [json_name = "KubernetesCluster"];
     */
    kubernetesCluster?: KubernetesClusterMetadata;
}
/**
 * SessionPrint event happens every time a write occurs to
 * terminal I/O during a session
 *
 * @generated from protobuf message events.SessionPrint
 */
export interface SessionPrint {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ChunkIndex is a monotonically incremented index for ordering print events
     *
     * @generated from protobuf field: int64 ChunkIndex = 2 [json_name = "ChunkIndex"];
     */
    chunkIndex: bigint;
    /**
     * Data is data transferred, it is not marshaled to JSON format
     *
     * @generated from protobuf field: bytes Data = 3 [json_name = "Data"];
     */
    data: Uint8Array;
    /**
     * Bytes says how many bytes have been written into the session
     * during "print" event
     *
     * @generated from protobuf field: int64 Bytes = 4 [json_name = "Bytes"];
     */
    bytes: bigint;
    /**
     * DelayMilliseconds is the delay in milliseconds from the start of the session
     *
     * @generated from protobuf field: int64 DelayMilliseconds = 5 [json_name = "DelayMilliseconds"];
     */
    delayMilliseconds: bigint;
    /**
     * Offset is the offset in bytes in the session file
     *
     * @generated from protobuf field: int64 Offset = 6 [json_name = "Offset"];
     */
    offset: bigint;
}
/**
 * DesktopRecording happens when a Teleport Desktop Protocol message
 * is captured during a Desktop Access Session.
 *
 * @generated from protobuf message events.DesktopRecording
 */
export interface DesktopRecording {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Message is the encoded TDP message.
     *
     * @generated from protobuf field: bytes Message = 2 [json_name = "Message"];
     */
    message: Uint8Array;
    /**
     * DelayMilliseconds is the delay in milliseconds from the start of the session
     *
     * @generated from protobuf field: int64 DelayMilliseconds = 3 [json_name = "DelayMilliseconds"];
     */
    delayMilliseconds: bigint; // JSON tag intentionally matches SessionPrintEvent
}
/**
 * DesktopClipboardReceive is emitted when Teleport receives
 * clipboard data from a remote desktop.
 *
 * @generated from protobuf message events.DesktopClipboardReceive
 */
export interface DesktopClipboardReceive {
    /**
     * Metadata is common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * Session is common event session metadata.
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * Connection holds information about the connection.
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * DesktopAddr is the address of the desktop being accessed.
     *
     * @generated from protobuf field: string DesktopAddr = 5 [json_name = "DesktopAddr"];
     */
    desktopAddr: string;
    /**
     * Length is the number of bytes of data received from the remote clipboard.
     *
     * @generated from protobuf field: int32 Length = 6 [json_name = "Length"];
     */
    length: number;
}
/**
 * DesktopClipboardSend is emitted when clipboard data is
 * sent from a user's workstation to Teleport.
 *
 * @generated from protobuf message events.DesktopClipboardSend
 */
export interface DesktopClipboardSend {
    /**
     * Metadata is common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * Session is common event session metadata.
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * Connection holds information about the connection.
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * DesktopAddr is the address of the desktop being accessed.
     *
     * @generated from protobuf field: string DesktopAddr = 5 [json_name = "DesktopAddr"];
     */
    desktopAddr: string;
    /**
     * Length is the number of bytes of data sent.
     *
     * @generated from protobuf field: int32 Length = 6 [json_name = "Length"];
     */
    length: number;
}
/**
 * DesktopSharedDirectoryStart is emitted when Teleport
 * successfully begins sharing a new directory to a remote desktop.
 *
 * @generated from protobuf message events.DesktopSharedDirectoryStart
 */
export interface DesktopSharedDirectoryStart {
    /**
     * Metadata is common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * Session is common event session metadata.
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * Connection holds information about the connection.
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * Status indicates whether the directory sharing initialization was successful.
     *
     * @generated from protobuf field: events.Status Status = 5 [json_name = "Status"];
     */
    status?: Status;
    /**
     * DesktopAddr is the address of the desktop being accessed.
     *
     * @generated from protobuf field: string DesktopAddr = 6 [json_name = "DesktopAddr"];
     */
    desktopAddr: string;
    /**
     * DirectoryName is the name of the directory being shared.
     *
     * @generated from protobuf field: string DirectoryName = 7 [json_name = "DirectoryName"];
     */
    directoryName: string;
    /**
     * DirectoryID is the ID of the directory being shared (unique to the Windows Desktop Session).
     *
     * @generated from protobuf field: uint32 DirectoryID = 8 [json_name = "DirectoryID"];
     */
    directoryID: number;
}
/**
 * DesktopSharedDirectoryRead is emitted when Teleport
 * attempts to read from a file in a shared directory at
 * the behest of the remote desktop.
 *
 * @generated from protobuf message events.DesktopSharedDirectoryRead
 */
export interface DesktopSharedDirectoryRead {
    /**
     * Metadata is common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * Session is common event session metadata.
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * Connection holds information about the connection.
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * Status indicates whether the read was successful.
     *
     * @generated from protobuf field: events.Status Status = 5 [json_name = "Status"];
     */
    status?: Status;
    /**
     * DesktopAddr is the address of the desktop being accessed.
     *
     * @generated from protobuf field: string DesktopAddr = 6 [json_name = "DesktopAddr"];
     */
    desktopAddr: string;
    /**
     * DirectoryName is the name of the directory being shared.
     *
     * @generated from protobuf field: string DirectoryName = 7 [json_name = "DirectoryName"];
     */
    directoryName: string;
    /**
     * DirectoryID is the ID of the directory being shared (unique to the Windows Desktop Session).
     *
     * @generated from protobuf field: uint32 DirectoryID = 8 [json_name = "DirectoryID"];
     */
    directoryID: number;
    /**
     * Path is the path within the shared directory where the file is located.
     *
     * @generated from protobuf field: string Path = 9 [json_name = "Path"];
     */
    path: string;
    /**
     * Length is the number of bytes read.
     *
     * @generated from protobuf field: uint32 Length = 10 [json_name = "Length"];
     */
    length: number;
    /**
     * Offset is the offset the bytes were read from.
     *
     * @generated from protobuf field: uint64 Offset = 11 [json_name = "Offset"];
     */
    offset: bigint;
}
/**
 * DesktopSharedDirectoryWrite is emitted when Teleport
 * attempts to write to a file in a shared directory at
 * the behest of the remote desktop.
 *
 * @generated from protobuf message events.DesktopSharedDirectoryWrite
 */
export interface DesktopSharedDirectoryWrite {
    /**
     * Metadata is common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * Session is common event session metadata.
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * Connection holds information about the connection.
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * Status indicates whether the write was successful.
     *
     * @generated from protobuf field: events.Status Status = 5 [json_name = "Status"];
     */
    status?: Status;
    /**
     * DesktopAddr is the address of the desktop being accessed.
     *
     * @generated from protobuf field: string DesktopAddr = 6 [json_name = "DesktopAddr"];
     */
    desktopAddr: string;
    /**
     * DirectoryName is the name of the directory being shared.
     *
     * @generated from protobuf field: string DirectoryName = 7 [json_name = "DirectoryName"];
     */
    directoryName: string;
    /**
     * DirectoryID is the ID of the directory being shared (unique to the Windows Desktop Session).
     *
     * @generated from protobuf field: uint32 DirectoryID = 8 [json_name = "DirectoryID"];
     */
    directoryID: number;
    /**
     * Path is the path within the shared directory where the file is located.
     *
     * @generated from protobuf field: string Path = 9 [json_name = "Path"];
     */
    path: string;
    /**
     * Length is the number of bytes written.
     *
     * @generated from protobuf field: uint32 Length = 10 [json_name = "Length"];
     */
    length: number;
    /**
     * Offset is the offset the bytes were written to.
     *
     * @generated from protobuf field: uint64 Offset = 11 [json_name = "Offset"];
     */
    offset: bigint;
}
/**
 * SessionReject event happens when a user hits a session control restriction.
 *
 * @generated from protobuf message events.SessionReject
 */
export interface SessionReject {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ServerMetadata is a common server metadata
     *
     * @generated from protobuf field: events.ServerMetadata Server = 3 [json_name = "Server"];
     */
    server?: ServerMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * Reason is a field that specifies reason for event, e.g. in disconnect
     * event it explains why server disconnected the client
     *
     * @generated from protobuf field: string Reason = 5 [json_name = "Reason"];
     */
    reason: string;
    /**
     * Maximum is an event field specifying a maximal value (e.g. the value
     * of `max_connections` for a `session.rejected` event).
     *
     * @generated from protobuf field: int64 Maximum = 6 [json_name = "Maximum"];
     */
    maximum: bigint;
}
/**
 * SessionConnect is emitted when a non-Teleport connection is made over net.Dial.
 *
 * @generated from protobuf message events.SessionConnect
 */
export interface SessionConnect {
    /**
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * @generated from protobuf field: events.ServerMetadata Server = 2 [json_name = "Server"];
     */
    server?: ServerMetadata;
    /**
     * @generated from protobuf field: events.ConnectionMetadata Connection = 3 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
}
/**
 * FileTransferRequestEvent happens when a FileTransferRequest is created, updated, approved, or denied.
 *
 * @generated from protobuf message events.FileTransferRequestEvent
 */
export interface FileTransferRequestEvent {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * SessionMetadata is a common event session metadata
     *
     * @generated from protobuf field: events.SessionMetadata Session = 2 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * RequestID is the ID for the FileTransferRequest
     *
     * @generated from protobuf field: string RequestID = 3 [json_name = "RequestID"];
     */
    requestID: string;
    /**
     * Approvers is a slice containing the Teleport users who have approved the request
     *
     * @generated from protobuf field: repeated string Approvers = 4 [json_name = "Approvers"];
     */
    approvers: string[];
    /**
     * Requester is the Teleport user who requested the file transfer
     *
     * @generated from protobuf field: string Requester = 5 [json_name = "Requester"];
     */
    requester: string;
    /**
     * Location is the location of the file to be downloaded, or the directory of the upload
     *
     * @generated from protobuf field: string Location = 6 [json_name = "Location"];
     */
    location: string;
    /**
     * Download is true if the requested file transfer is a download, false if an upload
     *
     * @generated from protobuf field: bool Download = 7 [json_name = "Download"];
     */
    download: boolean;
    /**
     * Filename is the name of the file to be uploaded to the Location. Only present in uploads.
     *
     * @generated from protobuf field: string Filename = 8 [json_name = "Filename"];
     */
    filename: string;
}
/**
 * Resize means that some user resized PTY on the client
 *
 * @generated from protobuf message events.Resize
 */
export interface Resize {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * ServerMetadata is a common server metadata
     *
     * @generated from protobuf field: events.ServerMetadata Server = 5 [json_name = "Server"];
     */
    server?: ServerMetadata;
    /**
     * TerminalSize is expressed as 'W:H'
     *
     * @generated from protobuf field: string TerminalSize = 6 [json_name = "TerminalSize"];
     */
    terminalSize: string;
    /**
     * KubernetesCluster has information about a kubernetes cluster, if
     * applicable.
     *
     * @generated from protobuf field: events.KubernetesClusterMetadata KubernetesCluster = 7 [json_name = "KubernetesCluster"];
     */
    kubernetesCluster?: KubernetesClusterMetadata;
    /**
     * KubernetesPod has information about a kubernetes pod, if applicable.
     *
     * @generated from protobuf field: events.KubernetesPodMetadata KubernetesPod = 8 [json_name = "KubernetesPod"];
     */
    kubernetesPod?: KubernetesPodMetadata;
}
/**
 * SessionEnd is a session end event
 *
 * @generated from protobuf message events.SessionEnd
 */
export interface SessionEnd {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * ServerMetadata is a common server metadata
     *
     * @generated from protobuf field: events.ServerMetadata Server = 5 [json_name = "Server"];
     */
    server?: ServerMetadata;
    /**
     * EnhancedRecording is used to indicate if the recording was an
     * enhanced recording or not.
     *
     * @generated from protobuf field: bool EnhancedRecording = 6 [json_name = "EnhancedRecording"];
     */
    enhancedRecording: boolean;
    /**
     * Interactive is used to indicate if the session was interactive
     * (has PTY attached) or not (exec session).
     *
     * @generated from protobuf field: bool Interactive = 7 [json_name = "Interactive"];
     */
    interactive: boolean;
    /**
     * Participants is a list of participants in the session.
     *
     * @generated from protobuf field: repeated string Participants = 8 [json_name = "Participants"];
     */
    participants: string[];
    /**
     * StartTime is the timestamp at which the session began.
     *
     * @generated from protobuf field: google.protobuf.Timestamp StartTime = 9 [json_name = "StartTime"];
     */
    startTime?: Timestamp;
    /**
     * EndTime is the timestamp at which the session ended.
     *
     * @generated from protobuf field: google.protobuf.Timestamp EndTime = 10 [json_name = "EndTime"];
     */
    endTime?: Timestamp;
    /**
     * KubernetesCluster has information about a kubernetes cluster, if
     * applicable.
     *
     * @generated from protobuf field: events.KubernetesClusterMetadata KubernetesCluster = 11 [json_name = "KubernetesCluster"];
     */
    kubernetesCluster?: KubernetesClusterMetadata;
    /**
     * KubernetesPod has information about a kubernetes pod, if applicable.
     *
     * @generated from protobuf field: events.KubernetesPodMetadata KubernetesPod = 12 [json_name = "KubernetesPod"];
     */
    kubernetesPod?: KubernetesPodMetadata;
    /**
     * InitialCommand is the command used to start this session.
     *
     * @generated from protobuf field: repeated string InitialCommand = 13 [json_name = "InitialCommand"];
     */
    initialCommand: string[];
    /**
     * SessionRecording is the type of session recording.
     *
     * @generated from protobuf field: string SessionRecording = 14 [json_name = "SessionRecording"];
     */
    sessionRecording: string;
}
/**
 * BPFMetadata is a common BPF process metadata
 *
 * @generated from protobuf message events.BPFMetadata
 */
export interface BPFMetadata {
    /**
     * PID is the ID of the process.
     *
     * @generated from protobuf field: uint64 PID = 1 [json_name = "PID"];
     */
    pID: bigint;
    /**
     * CgroupID is the internal cgroupv2 ID of the event.
     *
     * @generated from protobuf field: uint64 CgroupID = 2 [json_name = "CgroupID"];
     */
    cgroupID: bigint;
    /**
     * Program is name of the executable.
     *
     * @generated from protobuf field: string Program = 3 [json_name = "Program"];
     */
    program: string;
}
/**
 * Status contains common command or operation status fields
 *
 * @generated from protobuf message events.Status
 */
export interface Status {
    /**
     * Success indicates the success or failure of the operation
     *
     * @generated from protobuf field: bool Success = 1 [json_name = "Success"];
     */
    success: boolean;
    /**
     * Error includes system error message for the failed attempt
     *
     * @generated from protobuf field: string Error = 2 [json_name = "Error"];
     */
    error: string;
    /**
     * UserMessage is a user-friendly message for successfull or unsuccessfull auth attempt
     *
     * @generated from protobuf field: string UserMessage = 3 [json_name = "UserMessage"];
     */
    userMessage: string;
}
/**
 * SessionCommand is a session command event
 *
 * @generated from protobuf message events.SessionCommand
 */
export interface SessionCommand {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * ServerMetadata is a common server metadata
     *
     * @generated from protobuf field: events.ServerMetadata Server = 4 [json_name = "Server"];
     */
    server?: ServerMetadata;
    /**
     * BPFMetadata is a common BPF subsystem metadata
     *
     * @generated from protobuf field: events.BPFMetadata BPF = 5 [json_name = "BPF"];
     */
    bPF?: BPFMetadata;
    /**
     * PPID is the PID of the parent process.
     *
     * @generated from protobuf field: uint64 PPID = 6 [json_name = "PPID"];
     */
    pPID: bigint;
    /**
     * Path is the full path to the executable.
     *
     * @generated from protobuf field: string Path = 7 [json_name = "Path"];
     */
    path: string;
    /**
     * Argv is the list of arguments to the program. Note, the first element does
     * not contain the name of the process.
     *
     * @generated from protobuf field: repeated string Argv = 8 [json_name = "Argv"];
     */
    argv: string[];
    /**
     * ReturnCode is the return code of execve.
     *
     * @generated from protobuf field: int32 ReturnCode = 9 [json_name = "ReturnCode"];
     */
    returnCode: number;
}
/**
 * SessionDisk is a session disk access event
 *
 * @generated from protobuf message events.SessionDisk
 */
export interface SessionDisk {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * ServerMetadata is a common server metadata
     *
     * @generated from protobuf field: events.ServerMetadata Server = 4 [json_name = "Server"];
     */
    server?: ServerMetadata;
    /**
     * BPFMetadata is a common BPF subsystem metadata
     *
     * @generated from protobuf field: events.BPFMetadata BPF = 5 [json_name = "BPF"];
     */
    bPF?: BPFMetadata;
    /**
     * Path is the full path to the executable.
     *
     * @generated from protobuf field: string Path = 6 [json_name = "Path"];
     */
    path: string;
    /**
     * Flags are the flags passed to open.
     *
     * @generated from protobuf field: int32 Flags = 7 [json_name = "Flags"];
     */
    flags: number;
    /**
     * ReturnCode is the return code of disk open
     *
     * @generated from protobuf field: int32 ReturnCode = 8 [json_name = "ReturnCode"];
     */
    returnCode: number;
}
/**
 * SessionNetwork is a network event
 *
 * @generated from protobuf message events.SessionNetwork
 */
export interface SessionNetwork {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * ServerMetadata is a common server metadata
     *
     * @generated from protobuf field: events.ServerMetadata Server = 4 [json_name = "Server"];
     */
    server?: ServerMetadata;
    /**
     * BPFMetadata is a common BPF subsystem metadata
     *
     * @generated from protobuf field: events.BPFMetadata BPF = 5 [json_name = "BPF"];
     */
    bPF?: BPFMetadata;
    /**
     * SrcAddr is the source IP address of the connection.
     *
     * @generated from protobuf field: string SrcAddr = 6 [json_name = "SrcAddr"];
     */
    srcAddr: string;
    /**
     * DstAddr is the destination IP address of the connection.
     *
     * @generated from protobuf field: string DstAddr = 7 [json_name = "DstAddr"];
     */
    dstAddr: string;
    /**
     * DstPort is the destination port of the connection.
     *
     * @generated from protobuf field: int32 DstPort = 8 [json_name = "DstPort"];
     */
    dstPort: number;
    /**
     * TCPVersion is the version of TCP (4 or 6).
     *
     * @generated from protobuf field: int32 TCPVersion = 9 [json_name = "TCPVersion"];
     */
    tCPVersion: number;
    /**
     * Operation denotes what network operation was performed (e.g. connect)
     *
     * @generated from protobuf field: events.SessionNetwork.NetworkOperation Operation = 10 [json_name = "Operation"];
     */
    operation: SessionNetwork_NetworkOperation;
    /**
     * Action denotes what happened in response to the event
     *
     * @generated from protobuf field: events.EventAction Action = 11 [json_name = "Action"];
     */
    action: EventAction;
}
/**
 * Operation is the network operation that was performed or attempted
 *
 * @generated from protobuf enum events.SessionNetwork.NetworkOperation
 */
export enum SessionNetwork_NetworkOperation {
    /**
     * TCP connection establishment or binding a UDP socket to a remote address
     *
     * @generated from protobuf enum value: CONNECT = 0;
     */
    CONNECT = 0,
    /**
     * Transmission of data to a remote endpoint
     *
     * @generated from protobuf enum value: SEND = 1;
     */
    SEND = 1
}
/**
 * SessionData is emitted to report session data usage.
 *
 * @generated from protobuf message events.SessionData
 */
export interface SessionData {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * ServerMetadata is a common server metadata
     *
     * @generated from protobuf field: events.ServerMetadata Server = 4 [json_name = "Server"];
     */
    server?: ServerMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 5 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * BytesTransmitted is the amount of bytes transmitted
     *
     * @generated from protobuf field: uint64 BytesTransmitted = 6 [json_name = "BytesTransmitted"];
     */
    bytesTransmitted: bigint;
    /**
     * BytesReceived is the amount of bytes received
     *
     * @generated from protobuf field: uint64 BytesReceived = 7 [json_name = "BytesReceived"];
     */
    bytesReceived: bigint;
}
/**
 * SessionLeave is emitted to report that a user left the session
 *
 * @generated from protobuf message events.SessionLeave
 */
export interface SessionLeave {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * ServerMetadata is a common server metadata
     *
     * @generated from protobuf field: events.ServerMetadata Server = 4 [json_name = "Server"];
     */
    server?: ServerMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 5 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
}
/**
 * UserLogin records a successfully or failed user login event
 *
 * @generated from protobuf message events.UserLogin
 */
export interface UserLogin {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * Status contains common command or operation status fields
     *
     * @generated from protobuf field: events.Status Status = 3 [json_name = "Status"];
     */
    status?: Status;
    /**
     * Method is the event field indicating how the login was performed
     *
     * @generated from protobuf field: string Method = 4 [json_name = "Method"];
     */
    method: string;
    /**
     * IdentityAttributes is a map of user attributes received from identity provider
     *
     * @generated from protobuf field: google.protobuf.Struct IdentityAttributes = 5 [json_name = "IdentityAttributes"];
     */
    identityAttributes?: Struct;
    /**
     * MFA is the MFA device used during the login.
     *
     * @generated from protobuf field: events.MFADeviceMetadata MFADevice = 6 [json_name = "MFADevice"];
     */
    mFADevice?: MFADeviceMetadata;
    /**
     * Client is the common client event metadata
     *
     * @generated from protobuf field: events.ClientMetadata Client = 7 [json_name = "Client"];
     */
    client?: ClientMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 8 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * AppliedLoginRules stores the name of each login rule that was applied
     * during the login.
     *
     * @generated from protobuf field: repeated string AppliedLoginRules = 9 [json_name = "AppliedLoginRules"];
     */
    appliedLoginRules: string[];
    /**
     * ConnectorID is the ID of the connector used
     *
     * @generated from protobuf field: string ConnectorID = 10 [json_name = "ConnectorID"];
     */
    connectorID: string;
}
/**
 * CreateMFAAuthChallenge records the creation of an MFA auth challenge.
 *
 * @generated from protobuf message events.CreateMFAAuthChallenge
 */
export interface CreateMFAAuthChallenge {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * Scope is the authorization scope for this MFA challenge.
     * Only applies to WebAuthn challenges.
     *
     * @generated from protobuf field: string ChallengeScope = 3 [json_name = "ChallengeScope"];
     */
    challengeScope: string;
    /**
     * ChallengeAllowReuse defines whether the MFA challenge allows reuse.
     *
     * @generated from protobuf field: bool ChallengeAllowReuse = 4 [json_name = "ChallengeAllowReuse"];
     */
    challengeAllowReuse: boolean;
}
/**
 * ValidateMFAAuthResponse records the validation of an MFA auth callenge response.
 *
 * @generated from protobuf message events.ValidateMFAAuthResponse
 */
export interface ValidateMFAAuthResponse {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * Status contains common command or operation status fields
     *
     * @generated from protobuf field: events.Status Status = 3 [json_name = "Status"];
     */
    status?: Status;
    /**
     * MFADevice is the MFA device used.
     *
     * @generated from protobuf field: events.MFADeviceMetadata MFADevice = 4 [json_name = "MFADevice"];
     */
    mFADevice?: MFADeviceMetadata;
    /**
     * ChallengeScope is the authorization scope of the MFA challenge used for authentication.
     * Only applies to WebAuthn challenges.
     *
     * @generated from protobuf field: string ChallengeScope = 5 [json_name = "ChallengeScope"];
     */
    challengeScope: string;
    /**
     * ChallengeAllowReuse defines whether the MFA challenge used for authentication can be reused.
     *
     * @generated from protobuf field: bool ChallengeAllowReuse = 6 [json_name = "ChallengeAllowReuse"];
     */
    challengeAllowReuse: boolean;
}
/**
 * ResourceMetadata is a common resource metadata
 *
 * @generated from protobuf message events.ResourceMetadata
 */
export interface ResourceMetadata {
    /**
     * ResourceName is a resource name
     *
     * @generated from protobuf field: string Name = 1 [json_name = "Name"];
     */
    name: string;
    /**
     * Expires is set if resource expires
     *
     * @generated from protobuf field: google.protobuf.Timestamp Expires = 2 [json_name = "Expires"];
     */
    expires?: Timestamp;
    /**
     * UpdatedBy if set indicates the user who modified the resource
     *
     * @generated from protobuf field: string UpdatedBy = 3 [json_name = "UpdatedBy"];
     */
    updatedBy: string;
    /**
     * TTL is a TTL of reset password token represented as duration, e.g. "10m"
     * used for compatibility purposes for some events, Expires should be used instead
     * as it's more useful (contains exact expiration date/time)
     *
     * @generated from protobuf field: string TTL = 4 [json_name = "TTL"];
     */
    tTL: string;
}
/**
 * UserCreate is emitted when the user is created or upserted.
 *
 * @generated from protobuf message events.UserCreate
 */
export interface UserCreate {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 3 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * Roles is a list of roles for the user.
     *
     * @generated from protobuf field: repeated string Roles = 4 [json_name = "Roles"];
     */
    roles: string[];
    /**
     * Connector is the connector used to create the user.
     *
     * @generated from protobuf field: string Connector = 5 [json_name = "Connector"];
     */
    connector: string;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 6 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
}
/**
 * UserUpdate is emitted when the user is updated.
 *
 * @generated from protobuf message events.UserUpdate
 */
export interface UserUpdate {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 3 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * Roles is a list of roles for the user.
     *
     * @generated from protobuf field: repeated string Roles = 4 [json_name = "Roles"];
     */
    roles: string[];
    /**
     * Connector is the connector used to create the user.
     *
     * @generated from protobuf field: string Connector = 5 [json_name = "Connector"];
     */
    connector: string;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 6 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
}
/**
 * UserDelete is emitted when a user gets deleted
 *
 * @generated from protobuf message events.UserDelete
 */
export interface UserDelete {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 3 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
}
/**
 * UserPasswordChange is emitted when the user changes their own password.
 *
 * @generated from protobuf message events.UserPasswordChange
 */
export interface UserPasswordChange {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 3 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
}
/**
 * AccessRequestCreate is emitted when access request has been created or updated
 *
 * @generated from protobuf message events.AccessRequestCreate
 */
export interface AccessRequestCreate {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 3 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * Roles is a list of roles for the user.
     *
     * @generated from protobuf field: repeated string Roles = 4 [json_name = "Roles"];
     */
    roles: string[];
    /**
     * RequestID is access request ID
     *
     * @generated from protobuf field: string RequestID = 5 [json_name = "RequestID"];
     */
    requestID: string;
    /**
     * RequestState is access request state (in the access_request.review variant of
     * the event this represents the post-review state of the request).
     *
     * @generated from protobuf field: string RequestState = 6 [json_name = "RequestState"];
     */
    requestState: string;
    /**
     * Delegator is used by teleport plugins to indicate the identity
     * which caused them to update state.
     *
     * @generated from protobuf field: string Delegator = 7 [json_name = "Delegator"];
     */
    delegator: string;
    /**
     * Reason is an optional description of why the request is being
     * created or updated.
     *
     * @generated from protobuf field: string Reason = 8 [json_name = "Reason"];
     */
    reason: string;
    /**
     * Annotations is an optional set of attributes supplied by a plugin during
     * approval/denial of the request.
     *
     * @generated from protobuf field: google.protobuf.Struct Annotations = 9 [json_name = "Annotations"];
     */
    annotations?: Struct;
    /**
     * Reviewer is the author of the review (only used in the access_request.review event variant).
     *
     * @generated from protobuf field: string Reviewer = 10 [json_name = "Reviewer"];
     */
    reviewer: string;
    /**
     * ProposedState is the state proposed by a review (only used in the access_request.review event
     * variant).
     *
     * @generated from protobuf field: string ProposedState = 11 [json_name = "ProposedState"];
     */
    proposedState: string;
    /**
     * RequestedResourceIDs is the set of resources to which access is being requested.
     *
     * @generated from protobuf field: repeated events.ResourceID RequestedResourceIDs = 12 [json_name = "RequestedResourceIDs"];
     */
    requestedResourceIDs: ResourceID[];
    /**
     * MaxDuration indicates how long the access should be granted for.
     *
     * @generated from protobuf field: google.protobuf.Timestamp MaxDuration = 13 [json_name = "MaxDuration"];
     */
    maxDuration?: Timestamp;
    /**
     * PromotedAccessListName is the name of the access list that this request
     * was promoted to.
     * This field is only populated when the request is in the PROMOTED state.
     *
     * @generated from protobuf field: string PromotedAccessListName = 15 [json_name = "PromotedAccessListName"];
     */
    promotedAccessListName: string;
    /**
     * AssumeStartTime is the time the requested roles can be assumed.
     *
     * @generated from protobuf field: google.protobuf.Timestamp AssumeStartTime = 16 [json_name = "AssumeStartTime"];
     */
    assumeStartTime?: Timestamp;
}
/**
 * AccessRequestExpire is emitted when access request has expired.
 *
 * @generated from protobuf message events.AccessRequestExpire
 */
export interface AccessRequestExpire {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * RequestID is access request ID
     *
     * @generated from protobuf field: string RequestID = 3 [json_name = "RequestID"];
     */
    requestID: string;
    /**
     * ResourceExpiry is the time at which the access request resource will expire.
     *
     * @generated from protobuf field: google.protobuf.Timestamp ResourceExpiry = 4 [json_name = "ResourceExpiry"];
     */
    resourceExpiry?: Timestamp;
}
/**
 * ResourceID is a unique identifier for a teleport resource. This is duplicated
 * from api/types/types.proto to decouple the api and events types and because
 * neither file currently imports the other.
 *
 * @generated from protobuf message events.ResourceID
 */
export interface ResourceID {
    /**
     * ClusterName is the name of the cluster the resource is in.
     *
     * @generated from protobuf field: string ClusterName = 1 [json_name = "ClusterName"];
     */
    clusterName: string;
    /**
     * Kind is the resource kind.
     *
     * @generated from protobuf field: string Kind = 2 [json_name = "Kind"];
     */
    kind: string;
    /**
     * Name is the name of the specific resource.
     *
     * @generated from protobuf field: string Name = 3 [json_name = "Name"];
     */
    name: string;
    /**
     * SubResourceName is the resource belonging to resource identified by "Name"
     * that the user is allowed to access to.
     * When granting access to a subresource, access to other resources is limited.
     * Currently it just supports resources of Kind=pod and the format is the following
     * "<kube_namespace>/<kube_pod>".
     *
     * @generated from protobuf field: string SubResourceName = 4 [json_name = "SubResourceName"];
     */
    subResourceName: string;
}
/**
 * AccessRequestDelete is emitted when an access request has been deleted.
 *
 * @generated from protobuf message events.AccessRequestDelete
 */
export interface AccessRequestDelete {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * RequestID is access request ID
     *
     * @generated from protobuf field: string RequestID = 3 [json_name = "RequestID"];
     */
    requestID: string;
}
/**
 * PortForward is emitted when a user requests port forwarding.
 *
 * @generated from protobuf message events.PortForward
 */
export interface PortForward {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 3 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * Status contains operation success or failure status
     *
     * @generated from protobuf field: events.Status Status = 4 [json_name = "Status"];
     */
    status?: Status;
    /**
     * Addr is a target port forwarding address
     *
     * @generated from protobuf field: string Addr = 5 [json_name = "Addr"];
     */
    addr: string;
    /**
     * KubernetesCluster has information about a kubernetes cluster, if
     * applicable.
     *
     * @generated from protobuf field: events.KubernetesClusterMetadata KubernetesCluster = 6 [json_name = "KubernetesCluster"];
     */
    kubernetesCluster?: KubernetesClusterMetadata;
    /**
     * KubernetesPod has information about a kubernetes pod, if applicable.
     *
     * @generated from protobuf field: events.KubernetesPodMetadata KubernetesPod = 7 [json_name = "KubernetesPod"];
     */
    kubernetesPod?: KubernetesPodMetadata;
}
/**
 * X11Forward is emitted when a user requests X11 protocol forwarding
 *
 * @generated from protobuf message events.X11Forward
 */
export interface X11Forward {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 3 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * Status contains operation success or failure status
     *
     * @generated from protobuf field: events.Status Status = 4 [json_name = "Status"];
     */
    status?: Status;
}
/**
 * CommandMetadata specifies common command fields
 *
 * @generated from protobuf message events.CommandMetadata
 */
export interface CommandMetadata {
    /**
     * Command is the executed command name
     *
     * @generated from protobuf field: string Command = 1 [json_name = "Command"];
     */
    command: string;
    /**
     * ExitCode specifies command exit code
     *
     * @generated from protobuf field: string ExitCode = 2 [json_name = "ExitCode"];
     */
    exitCode: string;
    /**
     * Error is an optional exit error, set if command has failed
     *
     * @generated from protobuf field: string Error = 3 [json_name = "Error"];
     */
    error: string;
}
/**
 * Exec specifies command exec event
 *
 * @generated from protobuf message events.Exec
 */
export interface Exec {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 3 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * SessionMetadata is a common event session metadata
     *
     * @generated from protobuf field: events.SessionMetadata Session = 4 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * ServerMetadata is a common server metadata
     *
     * @generated from protobuf field: events.ServerMetadata Server = 5 [json_name = "Server"];
     */
    server?: ServerMetadata;
    /**
     * CommandMetadata is a common command metadata
     *
     * @generated from protobuf field: events.CommandMetadata Command = 6 [json_name = "Command"];
     */
    command?: CommandMetadata;
    /**
     * KubernetesCluster has information about a kubernetes cluster, if
     * applicable.
     *
     * @generated from protobuf field: events.KubernetesClusterMetadata KubernetesCluster = 7 [json_name = "KubernetesCluster"];
     */
    kubernetesCluster?: KubernetesClusterMetadata;
    /**
     * KubernetesPod has information about a kubernetes pod, if applicable.
     *
     * @generated from protobuf field: events.KubernetesPodMetadata KubernetesPod = 8 [json_name = "KubernetesPod"];
     */
    kubernetesPod?: KubernetesPodMetadata;
}
/**
 * SCP is emitted when data transfer has occurred between server and client
 *
 * @generated from protobuf message events.SCP
 */
export interface SCP {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 3 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * SessionMetadata is a common event session metadata
     *
     * @generated from protobuf field: events.SessionMetadata Session = 4 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * ServerMetadata is a common server metadata
     *
     * @generated from protobuf field: events.ServerMetadata Server = 5 [json_name = "Server"];
     */
    server?: ServerMetadata;
    /**
     * CommandMetadata is a common command metadata
     *
     * @generated from protobuf field: events.CommandMetadata Command = 6 [json_name = "Command"];
     */
    command?: CommandMetadata;
    /**
     * Path is a copy path
     *
     * @generated from protobuf field: string Path = 7 [json_name = "Path"];
     */
    path: string;
    /**
     * Action is upload or download
     *
     * @generated from protobuf field: string Action = 8 [json_name = "Action"];
     */
    action: string;
}
/**
 * SFTPAttributes are file metadata sent over SFTP
 *
 * @generated from protobuf message events.SFTPAttributes
 */
export interface SFTPAttributes {
    /**
     * FileSize is file size
     *
     * @generated from protobuf field: google.protobuf.UInt64Value FileSize = 1 [json_name = "FileSize"];
     */
    fileSize?: UInt64Value;
    /**
     * UID is the user owner of a file
     *
     * @generated from protobuf field: google.protobuf.UInt32Value UID = 2 [json_name = "UID"];
     */
    uID?: UInt32Value;
    /**
     * GID is the group owner of the file
     *
     * @generated from protobuf field: google.protobuf.UInt32Value GID = 3 [json_name = "GID"];
     */
    gID?: UInt32Value;
    /**
     * Permissions is the file permissions
     *
     * @generated from protobuf field: google.protobuf.UInt32Value Permissions = 4 [json_name = "Permissions"];
     */
    permissions?: UInt32Value;
    /**
     * AccessTime is when the file was last read
     *
     * @generated from protobuf field: google.protobuf.Timestamp AccessTime = 5 [json_name = "AccessTime"];
     */
    accessTime?: Timestamp;
    /**
     * ModificationTime was when the file was last changed
     *
     * @generated from protobuf field: google.protobuf.Timestamp ModificationTime = 6 [json_name = "ModificationTime"];
     */
    modificationTime?: Timestamp;
}
/**
 * SFTP is emitted when file operations have occurred between server and client
 *
 * @generated from protobuf message events.SFTP
 */
export interface SFTP {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 3 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * SessionMetadata is a common event session metadata
     *
     * @generated from protobuf field: events.SessionMetadata Session = 4 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * ServerMetadata is a common server metadata
     *
     * @generated from protobuf field: events.ServerMetadata Server = 5 [json_name = "Server"];
     */
    server?: ServerMetadata;
    /**
     * WorkingDirectory is the current directory the SFTP server is in
     *
     * @generated from protobuf field: string WorkingDirectory = 6 [json_name = "WorkingDirectory"];
     */
    workingDirectory: string;
    /**
     * Path is the filepath that was operated on. It is the exact path that
     * was sent by the client, so it may be relative or absolute.
     *
     * @generated from protobuf field: string Path = 7 [json_name = "Path"];
     */
    path: string;
    /**
     * TargetPath is the new path in file renames, or the path of the symlink
     * when creating symlinks. It is the exact path that wassent by the client,
     * so it may be relative or absolute.
     *
     * @generated from protobuf field: string TargetPath = 8 [json_name = "TargetPath"];
     */
    targetPath: string;
    /**
     * Flags is options that were passed that affect file creation events
     *
     * @generated from protobuf field: uint32 Flags = 9 [json_name = "Flags"];
     */
    flags: number;
    /**
     * Attributes is file metadata that the user requested to be changed
     *
     * @generated from protobuf field: events.SFTPAttributes Attributes = 10 [json_name = "Attributes"];
     */
    attributes?: SFTPAttributes;
    /**
     * Action is what kind of file operation
     *
     * @generated from protobuf field: events.SFTPAction Action = 11 [json_name = "Action"];
     */
    action: SFTPAction;
    /**
     * Error is the optional error that may have occurred
     *
     * @generated from protobuf field: string Error = 12 [json_name = "Error"];
     */
    error: string;
}
/**
 * SFTPSummary is emitted at the end of an SFTP transfer
 *
 * @generated from protobuf message events.SFTPSummary
 */
export interface SFTPSummary {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 3 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * SessionMetadata is a common event session metadata
     *
     * @generated from protobuf field: events.SessionMetadata Session = 4 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * ServerMetadata is a common server metadata
     *
     * @generated from protobuf field: events.ServerMetadata Server = 5 [json_name = "Server"];
     */
    server?: ServerMetadata;
    /**
     * FileTransferStats contains statistics about transferred files
     *
     * @generated from protobuf field: repeated events.FileTransferStat FileTransferStats = 6 [json_name = "FileTransferStats"];
     */
    fileTransferStats: FileTransferStat[];
}
/**
 * FileTransferStat is statistics about a transferred file
 *
 * @generated from protobuf message events.FileTransferStat
 */
export interface FileTransferStat {
    /**
     * @generated from protobuf field: string Path = 1 [json_name = "Path"];
     */
    path: string;
    /**
     * @generated from protobuf field: uint64 BytesRead = 2 [json_name = "BytesRead"];
     */
    bytesRead: bigint;
    /**
     * @generated from protobuf field: uint64 BytesWritten = 3 [json_name = "BytesWritten"];
     */
    bytesWritten: bigint;
}
/**
 * Subsystem is emitted when a user requests a new subsystem.
 *
 * @generated from protobuf message events.Subsystem
 */
export interface Subsystem {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 3 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * Name is a subsystem name
     *
     * @generated from protobuf field: string Name = 4 [json_name = "Name"];
     */
    name: string;
    /**
     * Error contains error in case of unsucessfull attempt
     *
     * @generated from protobuf field: string Error = 5 [json_name = "Error"];
     */
    error: string;
    /**
     * ServerMetadata is a common server metadata
     *
     * @generated from protobuf field: events.ServerMetadata Server = 6 [json_name = "Server"];
     */
    server?: ServerMetadata;
}
/**
 * ClientDisconnect is emitted when client is disconnected
 * by the server due to inactivity or any other reason
 *
 * @generated from protobuf message events.ClientDisconnect
 */
export interface ClientDisconnect {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 3 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * ServerMetadata is a common server metadata
     *
     * @generated from protobuf field: events.ServerMetadata Server = 4 [json_name = "Server"];
     */
    server?: ServerMetadata;
    /**
     * Reason is a field that specifies reason for event, e.g. in disconnect
     * event it explains why server disconnected the client
     *
     * @generated from protobuf field: string Reason = 5 [json_name = "Reason"];
     */
    reason: string;
}
/**
 * AuthAttempt is emitted upon a failed or successfull authentication attempt.
 *
 * @generated from protobuf message events.AuthAttempt
 */
export interface AuthAttempt {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 3 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * Status contains common command or operation status fields
     *
     * @generated from protobuf field: events.Status Status = 4 [json_name = "Status"];
     */
    status?: Status;
}
/**
 * UserTokenCreate is emitted when a user token is created.
 *
 * @generated from protobuf message events.UserTokenCreate
 */
export interface UserTokenCreate {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
}
/**
 * RoleCreate is emitted when a role is created/updated.
 *
 * @generated from protobuf message events.RoleCreate
 */
export interface RoleCreate {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
}
/**
 * RoleUpdate is emitted when a role is updated.
 *
 * @generated from protobuf message events.RoleUpdate
 */
export interface RoleUpdate {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
}
/**
 * RoleDelete is emitted when a role is deleted
 *
 * @generated from protobuf message events.RoleDelete
 */
export interface RoleDelete {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
}
/**
 * BotCreate is emitted when a bot is created/upserted.
 *
 * @generated from protobuf message events.BotCreate
 */
export interface BotCreate {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
}
/**
 * BotCreate is emitted when a bot is created/updated.
 *
 * @generated from protobuf message events.BotUpdate
 */
export interface BotUpdate {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
}
/**
 * BotDelete is emitted when a bot is deleted.
 *
 * @generated from protobuf message events.BotDelete
 */
export interface BotDelete {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
}
/**
 * TrustedClusterCreate is the event for creating a trusted cluster.
 *
 * @generated from protobuf message events.TrustedClusterCreate
 */
export interface TrustedClusterCreate {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
}
/**
 * TrustedClusterDelete is the event for removing a trusted cluster.
 *
 * @generated from protobuf message events.TrustedClusterDelete
 */
export interface TrustedClusterDelete {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
}
/**
 * ProvisionTokenCreate event is emitted when a provisioning token (a.k.a. join
 * token) of any role is created.
 *
 * @generated from protobuf message events.ProvisionTokenCreate
 */
export interface ProvisionTokenCreate {
    /**
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * @generated from protobuf field: repeated string Roles = 4 [json_name = "Roles"];
     */
    roles: string[];
    /**
     * @generated from protobuf field: string JoinMethod = 5 [json_name = "JoinMethod"];
     */
    joinMethod: string;
}
/**
 * TrustedClusterTokenCreate event is emitted (in addition to
 * ProvisionTokenCreate) when a token of a "Trusted_cluster" role is created.
 *
 * Deprecated: redundant, since we also emit ProvisionTokenCreate.
 *
 * @generated from protobuf message events.TrustedClusterTokenCreate
 */
export interface TrustedClusterTokenCreate {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
}
/**
 * GithubConnectorCreate fires when a Github connector is created.
 *
 * @generated from protobuf message events.GithubConnectorCreate
 */
export interface GithubConnectorCreate {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
}
/**
 * GithubConnectorUpdate fires when a Github connector is updated.
 *
 * @generated from protobuf message events.GithubConnectorUpdate
 */
export interface GithubConnectorUpdate {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
}
/**
 * GithubConnectorDelete fires when a Github connector is deleted.
 *
 * @generated from protobuf message events.GithubConnectorDelete
 */
export interface GithubConnectorDelete {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
}
/**
 * OIDCConnectorCreate fires when OIDC connector is created.
 *
 * @generated from protobuf message events.OIDCConnectorCreate
 */
export interface OIDCConnectorCreate {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
}
/**
 * OIDCConnectorUpdate fires when OIDC connector is updated.
 *
 * @generated from protobuf message events.OIDCConnectorUpdate
 */
export interface OIDCConnectorUpdate {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
}
/**
 * OIDCConnectorDelete fires when OIDC connector is deleted.
 *
 * @generated from protobuf message events.OIDCConnectorDelete
 */
export interface OIDCConnectorDelete {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
}
/**
 * SAMLConnectorCreate fires when SAML connector is created/updated.
 *
 * @generated from protobuf message events.SAMLConnectorCreate
 */
export interface SAMLConnectorCreate {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * Connector is the new SAML connector
     *
     * @generated from protobuf field: types.SAMLConnectorV2 Connector = 4 [json_name = "Connector"];
     */
    connector?: SAMLConnectorV2;
}
/**
 * SAMLConnectorUpdate fires when SAML connector is updated.
 *
 * @generated from protobuf message events.SAMLConnectorUpdate
 */
export interface SAMLConnectorUpdate {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * Connector is the updated SAML connector
     *
     * @generated from protobuf field: types.SAMLConnectorV2 Connector = 4 [json_name = "Connector"];
     */
    connector?: SAMLConnectorV2;
}
/**
 * SAMLConnectorDelete fires when SAML connector is deleted.
 *
 * @generated from protobuf message events.SAMLConnectorDelete
 */
export interface SAMLConnectorDelete {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
}
/**
 * KubeRequest specifies a Kubernetes API request event.
 *
 * @generated from protobuf message events.KubeRequest
 */
export interface KubeRequest {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 3 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * ServerMetadata is a common server metadata
     *
     * @generated from protobuf field: events.ServerMetadata Server = 4 [json_name = "Server"];
     */
    server?: ServerMetadata;
    /**
     * RequestPath is the raw request URL path.
     *
     * @generated from protobuf field: string RequestPath = 5 [json_name = "RequestPath"];
     */
    requestPath: string;
    /**
     * Verb is the HTTP verb used for this request (e.g. GET, POST, etc)
     *
     * @generated from protobuf field: string Verb = 6 [json_name = "Verb"];
     */
    verb: string;
    /**
     * ResourceAPIGroup is the resource API group.
     *
     * @generated from protobuf field: string ResourceAPIGroup = 7 [json_name = "ResourceAPIGroup"];
     */
    resourceAPIGroup: string;
    /**
     * ResourceNamespace is the resource namespace.
     *
     * @generated from protobuf field: string ResourceNamespace = 8 [json_name = "ResourceNamespace"];
     */
    resourceNamespace: string;
    /**
     * ResourceKind is the API resource kind (e.g. "pod", "service", etc).
     *
     * @generated from protobuf field: string ResourceKind = 9 [json_name = "ResourceKind"];
     */
    resourceKind: string;
    /**
     * ResourceName is the API resource name.
     *
     * @generated from protobuf field: string ResourceName = 10 [json_name = "ResourceName"];
     */
    resourceName: string;
    /**
     * ResponseCode is the HTTP response code for this request.
     *
     * @generated from protobuf field: int32 ResponseCode = 11 [json_name = "ResponseCode"];
     */
    responseCode: number;
    /**
     * Kubernetes has information about a kubernetes cluster, if applicable.
     *
     * @generated from protobuf field: events.KubernetesClusterMetadata Kubernetes = 12 [json_name = "Kubernetes"];
     */
    kubernetes?: KubernetesClusterMetadata;
    /**
     * SessionMetadata is a common event session metadata.
     *
     * @generated from protobuf field: events.SessionMetadata Session = 13 [json_name = "Session"];
     */
    session?: SessionMetadata;
}
/**
 * AppMetadata contains common application information.
 *
 * @generated from protobuf message events.AppMetadata
 */
export interface AppMetadata {
    /**
     * AppURI is the application endpoint.
     *
     * @generated from protobuf field: string AppURI = 1 [json_name = "AppURI"];
     */
    appURI: string;
    /**
     * AppPublicAddr is the configured application public address.
     *
     * @generated from protobuf field: string AppPublicAddr = 2 [json_name = "AppPublicAddr"];
     */
    appPublicAddr: string;
    /**
     * AppLabels are the configured application labels.
     *
     * @generated from protobuf field: map<string, string> AppLabels = 3 [json_name = "AppLabels"];
     */
    appLabels: {
        [key: string]: string;
    };
    /**
     * AppName is the configured application name.
     *
     * @generated from protobuf field: string AppName = 4 [json_name = "AppName"];
     */
    appName: string;
    /**
     * AppTargetPort signifies that the app is a multi-port TCP app and says which port was used to
     * access the app. This field is not set for other types of apps, including single-port TCP apps.
     *
     * @generated from protobuf field: uint32 AppTargetPort = 5 [json_name = "AppTargetPort"];
     */
    appTargetPort: number;
}
/**
 * AppCreate is emitted when a new application resource is created.
 *
 * @generated from protobuf message events.AppCreate
 */
export interface AppCreate {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ResourceMetadata is a common resource event metadata.
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 3 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * AppMetadata is a common application resource metadata.
     *
     * @generated from protobuf field: events.AppMetadata App = 4 [json_name = "App"];
     */
    app?: AppMetadata;
}
/**
 * AppUpdate is emitted when an existing application resource is updated.
 *
 * @generated from protobuf message events.AppUpdate
 */
export interface AppUpdate {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ResourceMetadata is a common resource event metadata.
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 3 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * AppMetadata is a common application resource metadata.
     *
     * @generated from protobuf field: events.AppMetadata App = 4 [json_name = "App"];
     */
    app?: AppMetadata;
}
/**
 * AppDelete is emitted when an application resource is deleted.
 *
 * @generated from protobuf message events.AppDelete
 */
export interface AppDelete {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ResourceMetadata is a common resource event metadata.
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 3 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
}
/**
 * AppSessionStart is emitted when a user is issued an application certificate.
 *
 * @generated from protobuf message events.AppSessionStart
 */
export interface AppSessionStart {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * ServerMetadata is a common server metadata
     *
     * @generated from protobuf field: events.ServerMetadata Server = 4 [json_name = "Server"];
     */
    server?: ServerMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 5 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * PublicAddr is the public address of the application being requested.
     * DELETE IN 10.0: this information is also present on the AppMetadata.
     *
     * @deprecated
     * @generated from protobuf field: string PublicAddr = 7 [deprecated = true, json_name = "PublicAddr"];
     */
    publicAddr: string;
    /**
     * App is a common application resource metadata.
     *
     * @generated from protobuf field: events.AppMetadata App = 8 [json_name = "App"];
     */
    app?: AppMetadata;
}
/**
 * AppSessionEnd is emitted when an application session ends.
 *
 * @generated from protobuf message events.AppSessionEnd
 */
export interface AppSessionEnd {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * ServerMetadata is a common server metadata
     *
     * @generated from protobuf field: events.ServerMetadata Server = 4 [json_name = "Server"];
     */
    server?: ServerMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 5 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * App is a common application resource metadata.
     *
     * @generated from protobuf field: events.AppMetadata App = 6 [json_name = "App"];
     */
    app?: AppMetadata;
}
/**
 * AppSessionChunk is emitted at the start of a 5 minute chunk on each
 * proxy. This chunk is used to buffer 5 minutes of audit events at a time
 * for applications.
 *
 * @generated from protobuf message events.AppSessionChunk
 */
export interface AppSessionChunk {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * ServerMetadata is a common server metadata
     *
     * @generated from protobuf field: events.ServerMetadata Server = 4 [json_name = "Server"];
     */
    server?: ServerMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 5 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * SessionChunkID is the ID of the session that was created for this 5 minute
     * application log chunk.
     *
     * @generated from protobuf field: string SessionChunkID = 6 [json_name = "SessionChunkID"];
     */
    sessionChunkID: string;
    /**
     * App is a common application resource metadata.
     *
     * @generated from protobuf field: events.AppMetadata App = 7 [json_name = "App"];
     */
    app?: AppMetadata;
}
/**
 * AppSessionRequest is an HTTP request and response.
 *
 * @generated from protobuf message events.AppSessionRequest
 */
export interface AppSessionRequest {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * StatusCode the HTTP response code for the request.
     *
     * @generated from protobuf field: uint32 StatusCode = 2 [json_name = "StatusCode"];
     */
    statusCode: number;
    /**
     * Path is relative path in the URL.
     *
     * @generated from protobuf field: string Path = 3 [json_name = "Path"];
     */
    path: string;
    /**
     * RawQuery are the encoded query values.
     *
     * @generated from protobuf field: string RawQuery = 4 [json_name = "RawQuery"];
     */
    rawQuery: string;
    /**
     * Method is the request HTTP method, like GET/POST/DELETE/etc.
     *
     * @generated from protobuf field: string Method = 5 [json_name = "Method"];
     */
    method: string;
    /**
     * App is a common application resource metadata.
     *
     * @generated from protobuf field: events.AppMetadata App = 6 [json_name = "App"];
     */
    app?: AppMetadata;
    /**
     * AWS contains extra AWS metadata of the request.
     *
     * @generated from protobuf field: events.AWSRequestMetadata AWS = 7 [json_name = "AWS"];
     */
    aWS?: AWSRequestMetadata;
}
/**
 * AWSRequestMetadata contains extra AWS metadata of an AppSessionRequest.
 *
 * @generated from protobuf message events.AWSRequestMetadata
 */
export interface AWSRequestMetadata {
    /**
     * AWSRegion is the requested AWS region.
     *
     * @generated from protobuf field: string AWSRegion = 1 [json_name = "AWSRegion"];
     */
    aWSRegion: string;
    /**
     * AWSService is the requested AWS service name.
     *
     * @generated from protobuf field: string AWSService = 2 [json_name = "AWSService"];
     */
    aWSService: string;
    /**
     * AWSHost is the requested host of the AWS service.
     *
     * @generated from protobuf field: string AWSHost = 3 [json_name = "AWSHost"];
     */
    aWSHost: string;
    /**
     * AWSAssumedRole is the assumed role that signed this request.
     *
     * @generated from protobuf field: string AWSAssumedRole = 4 [json_name = "AWSAssumedRole"];
     */
    aWSAssumedRole: string;
}
/**
 * DatabaseMetadata contains common database information.
 *
 * @generated from protobuf message events.DatabaseMetadata
 */
export interface DatabaseMetadata {
    /**
     * DatabaseService is the name of the database service proxying the database.
     *
     * @generated from protobuf field: string DatabaseService = 1 [json_name = "DatabaseService"];
     */
    databaseService: string;
    /**
     * DatabaseProtocol is the database type, e.g. postgres or mysql.
     *
     * @generated from protobuf field: string DatabaseProtocol = 2 [json_name = "DatabaseProtocol"];
     */
    databaseProtocol: string;
    /**
     * DatabaseURI is the database URI to connect to.
     *
     * @generated from protobuf field: string DatabaseURI = 3 [json_name = "DatabaseURI"];
     */
    databaseURI: string;
    /**
     * DatabaseName is the name of the database a user is connecting to.
     *
     * @generated from protobuf field: string DatabaseName = 4 [json_name = "DatabaseName"];
     */
    databaseName: string;
    /**
     * DatabaseUser is the database username used to connect.
     *
     * @generated from protobuf field: string DatabaseUser = 5 [json_name = "DatabaseUser"];
     */
    databaseUser: string;
    /**
     * DatabaseLabels is the database resource labels.
     *
     * @generated from protobuf field: map<string, string> DatabaseLabels = 6 [json_name = "DatabaseLabels"];
     */
    databaseLabels: {
        [key: string]: string;
    };
    /**
     * DatabaseAWSRegion is AWS regions for AWS hosted databases.
     *
     * @generated from protobuf field: string DatabaseAWSRegion = 7 [json_name = "DatabaseAWSRegion"];
     */
    databaseAWSRegion: string;
    /**
     * DatabaseAWSRegion is cluster ID for Redshift databases.
     *
     * @generated from protobuf field: string DatabaseAWSRedshiftClusterID = 8 [json_name = "DatabaseAWSRedshiftClusterID"];
     */
    databaseAWSRedshiftClusterID: string;
    /**
     * DatabaseGCPProjectID is project ID for GCP hosted databases.
     *
     * @generated from protobuf field: string DatabaseGCPProjectID = 9 [json_name = "DatabaseGCPProjectID"];
     */
    databaseGCPProjectID: string;
    /**
     * DatabaseGCPInstanceID is instance ID for GCP hosted databases.
     *
     * @generated from protobuf field: string DatabaseGCPInstanceID = 10 [json_name = "DatabaseGCPInstanceID"];
     */
    databaseGCPInstanceID: string;
    /**
     * DatabaseRoles is a list of database roles for auto-provisioned users.
     *
     * @generated from protobuf field: repeated string DatabaseRoles = 11 [json_name = "DatabaseRoles"];
     */
    databaseRoles: string[];
    /**
     * DatabaseType is the database type.
     *
     * @generated from protobuf field: string DatabaseType = 12 [json_name = "DatabaseType"];
     */
    databaseType: string;
    /**
     * DatabaseOrigin is the database origin source.
     *
     * @generated from protobuf field: string DatabaseOrigin = 13 [json_name = "DatabaseOrigin"];
     */
    databaseOrigin: string;
}
/**
 * DatabaseCreate is emitted when a new database resource is created.
 *
 * @generated from protobuf message events.DatabaseCreate
 */
export interface DatabaseCreate {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ResourceMetadata is a common resource event metadata.
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 3 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * DatabaseMetadata is a common database resource metadata.
     *
     * @generated from protobuf field: events.DatabaseMetadata Database = 4 [json_name = "Database"];
     */
    database?: DatabaseMetadata;
}
/**
 * DatabaseUpdate is emitted when an existing database resource is updated.
 *
 * @generated from protobuf message events.DatabaseUpdate
 */
export interface DatabaseUpdate {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ResourceMetadata is a common resource event metadata.
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 3 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * DatabaseMetadata is a common database resource metadata.
     *
     * @generated from protobuf field: events.DatabaseMetadata Database = 4 [json_name = "Database"];
     */
    database?: DatabaseMetadata;
}
/**
 * DatabaseDelete is emitted when a database resource is deleted.
 *
 * @generated from protobuf message events.DatabaseDelete
 */
export interface DatabaseDelete {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ResourceMetadata is a common resource event metadata.
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 3 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
}
/**
 * DatabaseSessionStart is emitted when a user connects to a database.
 *
 * @generated from protobuf message events.DatabaseSessionStart
 */
export interface DatabaseSessionStart {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * Session is a common event session metadata.
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * Server is a common server metadata.
     *
     * @generated from protobuf field: events.ServerMetadata Server = 4 [json_name = "Server"];
     */
    server?: ServerMetadata;
    /**
     * Connection holds information about the connection.
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 5 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * Status indicates whether the connection was successful or denied.
     *
     * @generated from protobuf field: events.Status Status = 6 [json_name = "Status"];
     */
    status?: Status;
    /**
     * Database contains database related metadata.
     *
     * @generated from protobuf field: events.DatabaseMetadata Database = 7 [json_name = "Database"];
     */
    database?: DatabaseMetadata;
    /**
     * PostgresPID is the Postgres backend PID that was created for a Postgres
     * connection. This can be useful for backend process cancellation or
     * termination and it is not a sensitive or secret value.
     *
     * @generated from protobuf field: uint32 PostgresPID = 8 [json_name = "PostgresPID"];
     */
    postgresPID: number;
    /**
     * Client is the common client event metadata.
     *
     * @generated from protobuf field: events.ClientMetadata Client = 9 [json_name = "Client"];
     */
    client?: ClientMetadata;
}
/**
 * DatabaseSessionQuery is emitted when a user executes a database query.
 *
 * @generated from protobuf message events.DatabaseSessionQuery
 */
export interface DatabaseSessionQuery {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata.
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * Database contains database related metadata.
     *
     * @generated from protobuf field: events.DatabaseMetadata Database = 4 [json_name = "Database"];
     */
    database?: DatabaseMetadata;
    /**
     * DatabaseQuery is the executed query string.
     *
     * @generated from protobuf field: string DatabaseQuery = 5 [json_name = "DatabaseQuery"];
     */
    databaseQuery: string;
    /**
     * DatabaseQueryParameters are the query parameters for prepared statements.
     *
     * @generated from protobuf field: repeated string DatabaseQueryParameters = 6 [json_name = "DatabaseQueryParameters"];
     */
    databaseQueryParameters: string[];
    /**
     * Status indicates whether the query was successfully sent to the database.
     *
     * @generated from protobuf field: events.Status Status = 7 [json_name = "Status"];
     */
    status?: Status;
}
/**
 * DatabaseSessionCommandResult represents the result of a user command. It is
 * expected that for each user command/query there will be a corresponding
 * result.
 *
 * @generated from protobuf message events.DatabaseSessionCommandResult
 */
export interface DatabaseSessionCommandResult {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata.
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * Database contains database related metadata.
     *
     * @generated from protobuf field: events.DatabaseMetadata Database = 4 [json_name = "Database"];
     */
    database?: DatabaseMetadata;
    /**
     * Status indicates if the command was successful or not.
     *
     * @generated from protobuf field: events.Status Status = 5 [json_name = "Status"];
     */
    status?: Status;
    /**
     * AfftectedRecords represents the number of records that were affected by the
     * command.
     *
     * @generated from protobuf field: uint64 AffectedRecords = 6 [json_name = "AffectedRecords"];
     */
    affectedRecords: bigint;
}
/**
 * DatabasePermissionUpdate is emitted when a user database permissions are updated.
 *
 * @generated from protobuf message events.DatabasePermissionUpdate
 */
export interface DatabasePermissionUpdate {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata.
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * Database contains database related metadata.
     *
     * @generated from protobuf field: events.DatabaseMetadata Database = 4 [json_name = "Database"];
     */
    database?: DatabaseMetadata;
    /**
     * PermissionSummary is a summary of applied permissions.
     *
     * @generated from protobuf field: repeated events.DatabasePermissionEntry PermissionSummary = 5 [json_name = "PermissionSummary"];
     */
    permissionSummary: DatabasePermissionEntry[];
    /**
     * AffectedObjectCounts counts how many distinct objects of each kind were affected.
     *
     * @generated from protobuf field: map<string, int32> AffectedObjectCounts = 6 [json_name = "AffectedObjectCounts"];
     */
    affectedObjectCounts: {
        [key: string]: number;
    };
}
/**
 * DatabasePermissionEntry is a summary of permissions, scoped to a particular permission.
 *
 * @generated from protobuf message events.DatabasePermissionEntry
 */
export interface DatabasePermissionEntry {
    /**
     * Permission is a particular database-level permission, e.g. "SELECT".
     *
     * @generated from protobuf field: string Permission = 1 [json_name = "Permission"];
     */
    permission: string;
    /**
     * Counts stores information how many objects of particular kind (e.g. "table") were affected.
     *
     * @generated from protobuf field: map<string, int32> Counts = 2 [json_name = "Counts"];
     */
    counts: {
        [key: string]: number;
    };
}
/**
 * DatabaseUserCreate is emitted when a database user is provisioned.
 *
 * @generated from protobuf message events.DatabaseUserCreate
 */
export interface DatabaseUserCreate {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata.
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * Database contains database related metadata.
     *
     * @generated from protobuf field: events.DatabaseMetadata Database = 4 [json_name = "Database"];
     */
    database?: DatabaseMetadata;
    /**
     * Status indicates whether the operation was successful.
     *
     * @generated from protobuf field: events.Status Status = 5 [json_name = "Status"];
     */
    status?: Status;
    /**
     * Username is the username chosen for the database user. Due to database limitations (e.g. username length, allowed charset)
     * it may differ from Teleport username.
     *
     * @generated from protobuf field: string Username = 6 [json_name = "Username"];
     */
    username: string;
    /**
     * Roles is an optional list of granted database roles.
     *
     * @generated from protobuf field: repeated string Roles = 7 [json_name = "Roles"];
     */
    roles: string[];
}
/**
 * DatabaseUserDeactivate is emitted when a database user is disabled or deleted.
 *
 * @generated from protobuf message events.DatabaseUserDeactivate
 */
export interface DatabaseUserDeactivate {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata.
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * Database contains database related metadata.
     *
     * @generated from protobuf field: events.DatabaseMetadata Database = 4 [json_name = "Database"];
     */
    database?: DatabaseMetadata;
    /**
     * Status indicates whether the operation was successful.
     *
     * @generated from protobuf field: events.Status Status = 5 [json_name = "Status"];
     */
    status?: Status;
    /**
     * Username is the username chosen for the database user. Due to database limitations (e.g. username length, allowed charset)
     * it may differ from Teleport username.
     *
     * @generated from protobuf field: string Username = 6 [json_name = "Username"];
     */
    username: string;
    /**
     * Delete indicates if the user was deleted entirely or merely disabled.
     *
     * @generated from protobuf field: bool Delete = 7 [json_name = "Delete"];
     */
    delete: boolean;
}
/**
 * PostgresParse is emitted when a Postgres client creates a prepared statement
 * using extended query protocol.
 *
 * @generated from protobuf message events.PostgresParse
 */
export interface PostgresParse {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata.
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * Database contains database related metadata.
     *
     * @generated from protobuf field: events.DatabaseMetadata Database = 4 [json_name = "Database"];
     */
    database?: DatabaseMetadata;
    /**
     * StatementName is the prepared statement name.
     *
     * @generated from protobuf field: string StatementName = 5 [json_name = "StatementName"];
     */
    statementName: string;
    /**
     * Query is the prepared statement query.
     *
     * @generated from protobuf field: string Query = 6 [json_name = "Query"];
     */
    query: string;
}
/**
 * PostgresBind is emitted when a Postgres client readies a prepared statement
 * for execution and binds it to parameters.
 *
 * @generated from protobuf message events.PostgresBind
 */
export interface PostgresBind {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata.
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * Database contains database related metadata.
     *
     * @generated from protobuf field: events.DatabaseMetadata Database = 4 [json_name = "Database"];
     */
    database?: DatabaseMetadata;
    /**
     * StatementName is the name of prepared statement that's being bound to parameters.
     *
     * @generated from protobuf field: string StatementName = 5 [json_name = "StatementName"];
     */
    statementName: string;
    /**
     * PortalName is the destination portal name that binds statement to parameters.
     *
     * @generated from protobuf field: string PortalName = 6 [json_name = "PortalName"];
     */
    portalName: string;
    /**
     * Parameters are the query bind parameters.
     *
     * @generated from protobuf field: repeated string Parameters = 7 [json_name = "Parameters"];
     */
    parameters: string[];
}
/**
 * PostgresExecute is emitted when a Postgres client executes a previously
 * bound prepared statement.
 *
 * @generated from protobuf message events.PostgresExecute
 */
export interface PostgresExecute {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata.
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * Database contains database related metadata.
     *
     * @generated from protobuf field: events.DatabaseMetadata Database = 4 [json_name = "Database"];
     */
    database?: DatabaseMetadata;
    /**
     * PortalName is the name of destination portal that's being executed.
     *
     * @generated from protobuf field: string PortalName = 5 [json_name = "PortalName"];
     */
    portalName: string;
}
/**
 * PostgresClose is emitted when a Postgres client closes an existing prepared
 * statement.
 *
 * @generated from protobuf message events.PostgresClose
 */
export interface PostgresClose {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata.
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * Database contains database related metadata.
     *
     * @generated from protobuf field: events.DatabaseMetadata Database = 4 [json_name = "Database"];
     */
    database?: DatabaseMetadata;
    /**
     * StatementName is the name of prepared statement that's being closed.
     *
     * @generated from protobuf field: string StatementName = 5 [json_name = "StatementName"];
     */
    statementName: string;
    /**
     * PortalName is the name of destination portal that's being closed.
     *
     * @generated from protobuf field: string PortalName = 6 [json_name = "PortalName"];
     */
    portalName: string;
}
/**
 * PostgresFunctionCall is emitted when a Postgres client calls internal
 * database function.
 *
 * @generated from protobuf message events.PostgresFunctionCall
 */
export interface PostgresFunctionCall {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata.
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * Database contains database related metadata.
     *
     * @generated from protobuf field: events.DatabaseMetadata Database = 4 [json_name = "Database"];
     */
    database?: DatabaseMetadata;
    /**
     * FunctionOID is the Postgres object ID of the called function.
     *
     * @generated from protobuf field: uint32 FunctionOID = 5 [json_name = "FunctionOID"];
     */
    functionOID: number;
    /**
     * FunctionArgs contains formatted function arguments.
     *
     * @generated from protobuf field: repeated string FunctionArgs = 6 [json_name = "FunctionArgs"];
     */
    functionArgs: string[];
}
/**
 * WindowsDesktopSessionStart is emitted when a user connects to a desktop.
 *
 * @generated from protobuf message events.WindowsDesktopSessionStart
 */
export interface WindowsDesktopSessionStart {
    /**
     * Metadata is common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * Session is common event session metadata.
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * Connection holds information about the connection.
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * Status indicates whether the connection was successful or denied.
     *
     * @generated from protobuf field: events.Status Status = 5 [json_name = "Status"];
     */
    status?: Status;
    /**
     * WindowsDesktopService is the name of the service proxying the RDP session.
     *
     * @generated from protobuf field: string WindowsDesktopService = 6 [json_name = "WindowsDesktopService"];
     */
    windowsDesktopService: string;
    /**
     * DesktopAddr is the address of the desktop being accessed.
     *
     * @generated from protobuf field: string DesktopAddr = 7 [json_name = "DesktopAddr"];
     */
    desktopAddr: string;
    /**
     * Domain is the Active Directory domain of the desktop being accessed.
     *
     * @generated from protobuf field: string Domain = 8 [json_name = "Domain"];
     */
    domain: string;
    /**
     * WindowsUser is the Windows username used to connect.
     *
     * @generated from protobuf field: string WindowsUser = 9 [json_name = "WindowsUser"];
     */
    windowsUser: string;
    /**
     * DesktopLabels are the labels on the desktop resource.
     *
     * @generated from protobuf field: map<string, string> DesktopLabels = 10 [json_name = "DesktopLabels"];
     */
    desktopLabels: {
        [key: string]: string;
    };
    /**
     * DesktopName is the name of the desktop resource.
     *
     * @generated from protobuf field: string DesktopName = 11 [json_name = "DesktopName"];
     */
    desktopName: string;
    /**
     * AllowUserCreation indicates whether automatic local user creation
     * is allowed for this session.
     *
     * @generated from protobuf field: bool AllowUserCreation = 12 [json_name = "AllowUserCreation"];
     */
    allowUserCreation: boolean;
    /**
     * NLA indicates whether Teleport performed Network Level Authentication (NLA)
     * when initiating this session.
     *
     * @generated from protobuf field: bool NLA = 13 [json_name = "NLA"];
     */
    nLA: boolean;
}
/**
 * DatabaseSessionEnd is emitted when a user ends the database session.
 *
 * @generated from protobuf message events.DatabaseSessionEnd
 */
export interface DatabaseSessionEnd {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * Session is a common event session metadata.
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * Database contains database related metadata.
     *
     * @generated from protobuf field: events.DatabaseMetadata Database = 4 [json_name = "Database"];
     */
    database?: DatabaseMetadata;
    /**
     * StartTime is the timestamp at which the session began.
     *
     * @generated from protobuf field: google.protobuf.Timestamp StartTime = 5 [json_name = "StartTime"];
     */
    startTime?: Timestamp;
    /**
     * EndTime is the timestamp at which the session ended.
     *
     * @generated from protobuf field: google.protobuf.Timestamp EndTime = 6 [json_name = "EndTime"];
     */
    endTime?: Timestamp;
}
/**
 * MFADeviceMetadata is a common MFA device metadata.
 *
 * @generated from protobuf message events.MFADeviceMetadata
 */
export interface MFADeviceMetadata {
    /**
     * Name is the user-specified name of the MFA device.
     *
     * @generated from protobuf field: string DeviceName = 1 [json_name = "DeviceName"];
     */
    deviceName: string;
    /**
     * ID is the UUID of the MFA device generated by Teleport.
     *
     * @generated from protobuf field: string DeviceID = 2 [json_name = "DeviceID"];
     */
    deviceID: string;
    /**
     * Type is the type of this MFA device.
     *
     * @generated from protobuf field: string DeviceType = 3 [json_name = "DeviceType"];
     */
    deviceType: string;
}
/**
 * MFADeviceAdd is emitted when a user adds an MFA device.
 *
 * @generated from protobuf message events.MFADeviceAdd
 */
export interface MFADeviceAdd {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * Device is the new MFA device added by the user.
     *
     * @generated from protobuf field: events.MFADeviceMetadata Device = 3 [json_name = "Device"];
     */
    device?: MFADeviceMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
}
/**
 * MFADeviceDelete is emitted when a user deletes an MFA device.
 *
 * @generated from protobuf message events.MFADeviceDelete
 */
export interface MFADeviceDelete {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * Device is the MFA device deleted by the user.
     *
     * @generated from protobuf field: events.MFADeviceMetadata Device = 3 [json_name = "Device"];
     */
    device?: MFADeviceMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
}
/**
 * BillingInformationUpdate is emitted when a user updates the billing information.
 *
 * @generated from protobuf message events.BillingInformationUpdate
 */
export interface BillingInformationUpdate {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
}
/**
 * BillingCardCreate is emitted when a user creates or updates a credit card.
 *
 * @generated from protobuf message events.BillingCardCreate
 */
export interface BillingCardCreate {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
}
/**
 * BillingCardDelete is emitted when a user deletes a credit card.
 *
 * @generated from protobuf message events.BillingCardDelete
 */
export interface BillingCardDelete {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
}
/**
 * LockCreate is emitted when a lock is created/updated.
 * Locks are used to restrict access to a Teleport environment by disabling
 * interactions involving a user, an RBAC role, a node, etc.
 * See rfd/0009-locking.md for more details.
 *
 * @generated from protobuf message events.LockCreate
 */
export interface LockCreate {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * Target describes the set of interactions that the lock applies to
     * Deprecated: use Lock instead.
     *
     * @deprecated
     * @generated from protobuf field: types.LockTarget Target = 4 [deprecated = true, json_name = "Target"];
     */
    target?: LockTarget;
    /**
     * Lock is a common lock event metadata
     *
     * @generated from protobuf field: events.LockMetadata Lock = 5 [json_name = "Lock"];
     */
    lock?: LockMetadata;
}
/**
 * LockDelete is emitted when a lock is deleted
 *
 * @generated from protobuf message events.LockDelete
 */
export interface LockDelete {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * Lock is a common lock event metadata
     *
     * @generated from protobuf field: events.LockMetadata Lock = 4 [json_name = "Lock"];
     */
    lock?: LockMetadata;
}
/**
 * RecoveryCodeGenerate is emitted when a user's new recovery codes are generated and updated.
 *
 * @generated from protobuf message events.RecoveryCodeGenerate
 */
export interface RecoveryCodeGenerate {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
}
/**
 * RecoveryCodeUsed is emitted when a user's recovery code was used successfully or
 * unsuccessfully.
 *
 * @generated from protobuf message events.RecoveryCodeUsed
 */
export interface RecoveryCodeUsed {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * Status contains fields to indicate whether attempt was successful or not.
     *
     * @generated from protobuf field: events.Status Status = 3 [json_name = "Status"];
     */
    status?: Status;
}
/**
 * WindowsDesktopSessionEnd is emitted when a user ends a Windows desktop session.
 *
 * @generated from protobuf message events.WindowsDesktopSessionEnd
 */
export interface WindowsDesktopSessionEnd {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * Session is a common event session metadata.
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * WindowsDesktopService is the name of the service proxying the RDP session.
     *
     * @generated from protobuf field: string WindowsDesktopService = 4 [json_name = "WindowsDesktopService"];
     */
    windowsDesktopService: string;
    /**
     * DesktopAddr is the address of the desktop being accessed.
     *
     * @generated from protobuf field: string DesktopAddr = 5 [json_name = "DesktopAddr"];
     */
    desktopAddr: string;
    /**
     * Domain is the Active Directory domain of the desktop being accessed.
     *
     * @generated from protobuf field: string Domain = 6 [json_name = "Domain"];
     */
    domain: string;
    /**
     * WindowsUser is the Windows username used to connect.
     *
     * @generated from protobuf field: string WindowsUser = 7 [json_name = "WindowsUser"];
     */
    windowsUser: string;
    /**
     * DesktopLabels are the labels on the desktop resource.
     *
     * @generated from protobuf field: map<string, string> DesktopLabels = 8 [json_name = "DesktopLabels"];
     */
    desktopLabels: {
        [key: string]: string;
    };
    /**
     * StartTime is the timestamp at which the session began.
     *
     * @generated from protobuf field: google.protobuf.Timestamp StartTime = 9 [json_name = "StartTime"];
     */
    startTime?: Timestamp;
    /**
     * EndTime is the timestamp at which the session ended.
     *
     * @generated from protobuf field: google.protobuf.Timestamp EndTime = 10 [json_name = "EndTime"];
     */
    endTime?: Timestamp;
    /**
     * DesktopName is the name of the desktop resource.
     *
     * @generated from protobuf field: string DesktopName = 11 [json_name = "DesktopName"];
     */
    desktopName: string;
    /**
     * Recorded is true if the session was recorded, false otherwise.
     *
     * @generated from protobuf field: bool Recorded = 12 [json_name = "Recorded"];
     */
    recorded: boolean;
    /**
     * Participants is a list of participants in the session.
     *
     * @generated from protobuf field: repeated string Participants = 13 [json_name = "Participants"];
     */
    participants: string[];
}
/**
 * CertificateCreate is emitted when a certificate is issued.
 *
 * @generated from protobuf message events.CertificateCreate
 */
export interface CertificateCreate {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * CertificateType is the type of certificate that was just issued.
     *
     * @generated from protobuf field: string CertificateType = 2 [json_name = "CertificateType"];
     */
    certificateType: string;
    /**
     * Identity is the identity associated with the certificate, as interpreted by Teleport.
     *
     * @generated from protobuf field: events.Identity Identity = 3 [json_name = "Identity"];
     */
    identity?: Identity;
    /**
     * Client is the common client event metadata
     *
     * @generated from protobuf field: events.ClientMetadata Client = 4 [json_name = "Client"];
     */
    client?: ClientMetadata;
}
/**
 * RenewableCertificateGenerationMismatch is emitted when a renewable
 * certificate's generation counter fails to validate, possibly indicating a
 * stolen certificate and an invalid renewal attempt.
 *
 * @generated from protobuf message events.RenewableCertificateGenerationMismatch
 */
export interface RenewableCertificateGenerationMismatch {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * UserMetadata is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata UserMetadata = 2 [json_name = "UserMetadata"];
     */
    userMetadata?: UserMetadata;
}
/**
 * BotJoin records a bot join event.
 *
 * @generated from protobuf message events.BotJoin
 */
export interface BotJoin {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Status contains common command or operation status fields.
     *
     * @generated from protobuf field: events.Status Status = 2 [json_name = "Status"];
     */
    status?: Status;
    /**
     * BotName is the name of the bot which has joined.
     *
     * @generated from protobuf field: string BotName = 3 [json_name = "BotName"];
     */
    botName: string;
    /**
     * Method is the event field indicating what join method was used.
     *
     * @generated from protobuf field: string Method = 4 [json_name = "Method"];
     */
    method: string;
    /**
     * TokenName is the name of the provision token used to join.
     *
     * @generated from protobuf field: string TokenName = 5 [json_name = "TokenName"];
     */
    tokenName: string;
    /**
     * Attributes is a map of attributes received from the join method provider.
     *
     * @generated from protobuf field: google.protobuf.Struct Attributes = 6 [json_name = "Attributes"];
     */
    attributes?: Struct;
    /**
     * UserName is the name of the user associated with the bot which has joined.
     *
     * @generated from protobuf field: string UserName = 7 [json_name = "UserName"];
     */
    userName: string;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 8 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * BotInstanceID is the ID of the bot instance which has joined or renewed.
     *
     * @generated from protobuf field: string BotInstanceID = 9 [json_name = "BotInstanceID"];
     */
    botInstanceID: string;
}
/**
 * InstanceJoin records an instance join event.
 *
 * @generated from protobuf message events.InstanceJoin
 */
export interface InstanceJoin {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Status contains common command or operation status fields.
     *
     * @generated from protobuf field: events.Status Status = 2 [json_name = "Status"];
     */
    status?: Status;
    /**
     * HostID is the unique host ID of the instance which attempted to join.
     *
     * @generated from protobuf field: string HostID = 3 [json_name = "HostID"];
     */
    hostID: string;
    /**
     * NodeName is the name of the instance which attempted to join.
     *
     * @generated from protobuf field: string NodeName = 4 [json_name = "NodeName"];
     */
    nodeName: string;
    /**
     * Role is the role that the node requested when attempting to join.
     *
     * @generated from protobuf field: string Role = 5 [json_name = "Role"];
     */
    role: string;
    /**
     * Method is the event field indicating what join method was used.
     *
     * @generated from protobuf field: string Method = 6 [json_name = "Method"];
     */
    method: string;
    /**
     * TokenName is the name of the token used to join. This will be omitted
     * for the 'token' join method where the token name is a secret value.
     *
     * @generated from protobuf field: string TokenName = 7 [json_name = "TokenName"];
     */
    tokenName: string;
    /**
     * Attributes is a map of attributes received from the join method provider.
     *
     * @generated from protobuf field: google.protobuf.Struct Attributes = 8 [json_name = "Attributes"];
     */
    attributes?: Struct;
    /**
     * TokenExpires contain information about token expiration time.
     * In case of static token the TokenExpiration time is to the Unix epoch start time.
     *
     * @generated from protobuf field: google.protobuf.Timestamp TokenExpires = 9 [json_name = "TokenExpires"];
     */
    tokenExpires?: Timestamp;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 10 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
}
/**
 * Unknown is a fallback event used when we don't recognize an event from the backend.
 *
 * @generated from protobuf message events.Unknown
 */
export interface Unknown {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * UnknownType is the event type extracted from the unknown event.
     *
     * @generated from protobuf field: string UnknownType = 2 [json_name = "UnknownType"];
     */
    unknownType: string;
    /**
     * UnknownCode is the event code extracted from the unknown event.
     *
     * @generated from protobuf field: string UnknownCode = 3 [json_name = "UnknownCode"];
     */
    unknownCode: string;
    /**
     * Data is the serialized JSON data of the unknown event.
     *
     * @generated from protobuf field: string Data = 4 [json_name = "Data"];
     */
    data: string;
}
/**
 * DeviceMetadata groups device information for events.
 *
 * @generated from protobuf message events.DeviceMetadata
 */
export interface DeviceMetadata {
    /**
     * ID of the device.
     *
     * @generated from protobuf field: string device_id = 1;
     */
    deviceId: string;
    /**
     * OS of the device.
     *
     * @generated from protobuf field: events.OSType os_type = 2;
     */
    osType: OSType;
    /**
     * Device inventory identifier.
     *
     * @generated from protobuf field: string asset_tag = 3;
     */
    assetTag: string;
    /**
     * Device credential identifier.
     *
     * @generated from protobuf field: string credential_id = 4;
     */
    credentialId: string;
    /**
     * Device origin.
     *
     * @generated from protobuf field: events.DeviceOrigin device_origin = 5;
     */
    deviceOrigin: DeviceOrigin;
    /**
     * True if web authentication, aka on-behalf-of device authentication, was
     * performed.
     * Only present in "device.authenticate" type events.
     *
     * @generated from protobuf field: bool web_authentication = 6;
     */
    webAuthentication: boolean;
    /**
     * Device web authentication attempt ID.
     * Present in events related to device web authentication.
     *
     * @generated from protobuf field: string web_authentication_id = 8;
     */
    webAuthenticationId: string;
}
/**
 * DeviceEvent is a device-related event.
 * The event type (Metadata.Type) for device events is always "device". See the
 * event code (Metadata.Code) for its meaning.
 * Deprecated: Use DeviceEvent2 instead.
 *
 * @generated from protobuf message events.DeviceEvent
 */
export interface DeviceEvent {
    /**
     * Metadata holds common event metadata.
     *
     * @generated from protobuf field: events.Metadata metadata = 1;
     */
    metadata?: Metadata;
    /**
     * Status indicates the outcome of the event.
     *
     * @generated from protobuf field: events.Status status = 2;
     */
    status?: Status;
    /**
     * DeviceMetadata holds metadata about the user device.
     *
     * @generated from protobuf field: events.DeviceMetadata device = 3;
     */
    device?: DeviceMetadata;
    /**
     * UserMetadata holds metadata about the user behind the event.
     *
     * @generated from protobuf field: events.UserMetadata user = 4;
     */
    user?: UserMetadata;
}
/**
 * DeviceEvent2 is a device-related event.
 * See the "lib/events.Device*Event" and "lib/events.Device*Code" for the
 * various event types and codes, respectively.
 * Replaces the previous [DeviceEvent] proto, presenting a more standard event
 * interface with various embeds.
 *
 * @generated from protobuf message events.DeviceEvent2
 */
export interface DeviceEvent2 {
    /**
     * Metadata holds common event metadata.
     *
     * @generated from protobuf field: events.Metadata metadata = 1;
     */
    metadata?: Metadata;
    /**
     * DeviceMetadata holds metadata about the user device.
     *
     * @generated from protobuf field: events.DeviceMetadata device = 3;
     */
    device?: DeviceMetadata;
    /**
     * Status indicates the outcome of the event.
     *
     * @generated from protobuf field: events.Status status = 5;
     */
    status?: Status;
    /**
     * UserMetadata holds metadata about the user behind the event.
     *
     * @generated from protobuf field: events.UserMetadata user = 6;
     */
    user?: UserMetadata;
}
/**
 * DiscoveryConfigCreate is emitted when a discovery config is created.
 *
 * @generated from protobuf message events.DiscoveryConfigCreate
 */
export interface DiscoveryConfigCreate {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 3 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
}
/**
 * DiscoveryConfigUpdate is emitted when a discovery config is updated.
 *
 * @generated from protobuf message events.DiscoveryConfigUpdate
 */
export interface DiscoveryConfigUpdate {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 3 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
}
/**
 * DiscoveryConfigDelete is emitted when a discovery config is deleted.
 *
 * @generated from protobuf message events.DiscoveryConfigDelete
 */
export interface DiscoveryConfigDelete {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 3 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
}
/**
 * DiscoveryConfigDeleteAll is emitted when all discovery configs are deleted.
 *
 * @generated from protobuf message events.DiscoveryConfigDeleteAll
 */
export interface DiscoveryConfigDeleteAll {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 3 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
}
/**
 * IntegrationCreate is emitted when an integration resource is created.
 *
 * @generated from protobuf message events.IntegrationCreate
 */
export interface IntegrationCreate {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ResourceMetadata is a common resource event metadata.
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 3 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * @generated from protobuf field: events.IntegrationMetadata Integration = 4 [json_name = "Integration"];
     */
    integration?: IntegrationMetadata;
    /**
     * ConnectionMetadata holds information about the connection.
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 5 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
}
/**
 * IntegrationUpdate is emitted when an integration resource is updated.
 *
 * @generated from protobuf message events.IntegrationUpdate
 */
export interface IntegrationUpdate {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ResourceMetadata is a common resource event metadata.
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 3 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * @generated from protobuf field: events.IntegrationMetadata Integration = 4 [json_name = "Integration"];
     */
    integration?: IntegrationMetadata;
    /**
     * ConnectionMetadata holds information about the connection.
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 5 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
}
/**
 * IntegrationDelete is emitted when an integration is deleted.
 *
 * @generated from protobuf message events.IntegrationDelete
 */
export interface IntegrationDelete {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ResourceMetadata is a common resource event metadata.
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 3 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * @generated from protobuf field: events.IntegrationMetadata Integration = 4 [json_name = "Integration"];
     */
    integration?: IntegrationMetadata;
    /**
     * ConnectionMetadata holds information about the connection.
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 5 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
}
/**
 * IntegrationMetadata contains information about integration resources.
 *
 * @generated from protobuf message events.IntegrationMetadata
 */
export interface IntegrationMetadata {
    /**
     * SubKind is the sub kind of the integration resource.
     *
     * @generated from protobuf field: string SubKind = 1 [json_name = "SubKind"];
     */
    subKind: string;
    /**
     * AWSOIDC contains metadata for AWS OIDC integrations.
     *
     * @generated from protobuf field: events.AWSOIDCIntegrationMetadata AWSOIDC = 2 [json_name = "AWSOIDC"];
     */
    aWSOIDC?: AWSOIDCIntegrationMetadata;
    /**
     * AzureOIDC contains metadata for Azure OIDC integrations.
     *
     * @generated from protobuf field: events.AzureOIDCIntegrationMetadata AzureOIDC = 3 [json_name = "AzureOIDC"];
     */
    azureOIDC?: AzureOIDCIntegrationMetadata;
    /**
     * GitHub contains metadata for GitHub integrations.
     *
     * @generated from protobuf field: events.GitHubIntegrationMetadata GitHub = 4 [json_name = "GitHub"];
     */
    gitHub?: GitHubIntegrationMetadata;
    /**
     * AWSRA contains metadata for AWS IAM Roles Anywhere integrations.
     *
     * @generated from protobuf field: events.AWSRAIntegrationMetadata AWSRA = 5 [json_name = "AWSRA"];
     */
    aWSRA?: AWSRAIntegrationMetadata;
}
/**
 * AWSOIDCIntegrationMetadata contains metadata for AWS OIDC integrations.
 *
 * @generated from protobuf message events.AWSOIDCIntegrationMetadata
 */
export interface AWSOIDCIntegrationMetadata {
    /**
     * RoleARN contains the Role ARN used to set up the Integration.
     * This is the AWS Role that Teleport will use to issue tokens for API Calls.
     *
     * @generated from protobuf field: string RoleARN = 1 [json_name = "RoleARN"];
     */
    roleARN: string;
    /**
     * IssuerS3URI is the Identity Provider that was configured in AWS.
     *
     * @generated from protobuf field: string IssuerS3URI = 2 [json_name = "IssuerS3URI"];
     */
    issuerS3URI: string;
}
/**
 * AzureOIDCIntegrationMetadata contains metadata for Azure OIDC integrations.
 *
 * @generated from protobuf message events.AzureOIDCIntegrationMetadata
 */
export interface AzureOIDCIntegrationMetadata {
    /**
     * TenantID specifies the ID of Entra Tenant (Directory).
     *
     * @generated from protobuf field: string TenantID = 1 [json_name = "TenantID"];
     */
    tenantID: string;
    /**
     * ClientID specifies the ID of Azure enterprise application (client).
     *
     * @generated from protobuf field: string ClientID = 2 [json_name = "ClientID"];
     */
    clientID: string;
}
/**
 * GitHubIntegrationMetadata contains metadata for GitHub integrations.
 *
 * @generated from protobuf message events.GitHubIntegrationMetadata
 */
export interface GitHubIntegrationMetadata {
    /**
     * Organization specifies the name of the organization for the GitHub integration.
     *
     * @generated from protobuf field: string Organization = 1 [json_name = "Organization"];
     */
    organization: string;
}
/**
 * AWSRAIntegrationMetadata contains metadata for AWS IAM Roles Anywhere integrations.
 *
 * @generated from protobuf message events.AWSRAIntegrationMetadata
 */
export interface AWSRAIntegrationMetadata {
    /**
     * TrustAnchorARN contains the IAM Roles Anywhere Trust Anchor ARN used to set up the Integration.
     *
     * @generated from protobuf field: string TrustAnchorARN = 1 [json_name = "TrustAnchorARN"];
     */
    trustAnchorARN: string;
}
/**
 * PluginCreate is emitted when a plugin resource is created.
 *
 * @generated from protobuf message events.PluginCreate
 */
export interface PluginCreate {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata metadata = 1;
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata user = 2;
     */
    user?: UserMetadata;
    /**
     * ResourceMetadata is a common resource event metadata.
     *
     * @generated from protobuf field: events.ResourceMetadata resource = 3;
     */
    resource?: ResourceMetadata;
    /**
     * @generated from protobuf field: events.PluginMetadata plugin = 4;
     */
    plugin?: PluginMetadata;
    /**
     * ConnectionMetadata holds information about the connection.
     *
     * @generated from protobuf field: events.ConnectionMetadata connection = 5;
     */
    connection?: ConnectionMetadata;
}
/**
 * PluginUpdate is emitted when a plugin resource is updated.
 *
 * @generated from protobuf message events.PluginUpdate
 */
export interface PluginUpdate {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata metadata = 1;
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata user = 2;
     */
    user?: UserMetadata;
    /**
     * ResourceMetadata is a common resource event metadata.
     *
     * @generated from protobuf field: events.ResourceMetadata resource = 3;
     */
    resource?: ResourceMetadata;
    /**
     * @generated from protobuf field: events.PluginMetadata plugin = 4;
     */
    plugin?: PluginMetadata;
    /**
     * ConnectionMetadata holds information about the connection.
     *
     * @generated from protobuf field: events.ConnectionMetadata connection = 5;
     */
    connection?: ConnectionMetadata;
}
/**
 * PluginDelete is emitted when a plugin is deleted.
 *
 * @generated from protobuf message events.PluginDelete
 */
export interface PluginDelete {
    /**
     * metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata metadata = 1;
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata user = 2;
     */
    user?: UserMetadata;
    /**
     * ResourceMetadata is a common resource event metadata.
     *
     * @generated from protobuf field: events.ResourceMetadata resource = 3;
     */
    resource?: ResourceMetadata;
    /**
     * @generated from protobuf field: events.PluginMetadata plugin = 4;
     */
    plugin?: PluginMetadata;
    /**
     * ConnectionMetadata holds information about the connection.
     *
     * @generated from protobuf field: events.ConnectionMetadata connection = 5;
     */
    connection?: ConnectionMetadata;
}
/**
 * PluginMetadata contains information about plugin resources.
 *
 * @generated from protobuf message events.PluginMetadata
 */
export interface PluginMetadata {
    /**
     * plugin_type is the plugin type of the plugin resource.
     * The value matches the types.PluginV1.Spec.Type field.
     *
     * @generated from protobuf field: string plugin_type = 1;
     */
    pluginType: string;
    /**
     * has_credentials indicates whether the plugin has credentials.
     *
     * @generated from protobuf field: bool has_credentials = 3;
     */
    hasCredentials: boolean;
    /**
     * reuses_credentials indicates whether the plugin reuses credentials.
     *
     * @generated from protobuf field: bool reuses_credentials = 4;
     */
    reusesCredentials: boolean;
    /**
     * plugin_data is the plugin data of the plugin resource.
     *
     * @generated from protobuf field: google.protobuf.Struct plugin_data = 5;
     */
    pluginData?: Struct;
}
/**
 * OneOf is a union of one of audit events submitted to the auth service
 *
 * @generated from protobuf message events.OneOf
 */
export interface OneOf {
    /**
     * @generated from protobuf oneof: Event
     */
    event: {
        oneofKind: "userLogin";
        /**
         * @generated from protobuf field: events.UserLogin UserLogin = 1 [json_name = "UserLogin"];
         */
        userLogin: UserLogin;
    } | {
        oneofKind: "userCreate";
        /**
         * @generated from protobuf field: events.UserCreate UserCreate = 2 [json_name = "UserCreate"];
         */
        userCreate: UserCreate;
    } | {
        oneofKind: "userDelete";
        /**
         * @generated from protobuf field: events.UserDelete UserDelete = 3 [json_name = "UserDelete"];
         */
        userDelete: UserDelete;
    } | {
        oneofKind: "userPasswordChange";
        /**
         * @generated from protobuf field: events.UserPasswordChange UserPasswordChange = 4 [json_name = "UserPasswordChange"];
         */
        userPasswordChange: UserPasswordChange;
    } | {
        oneofKind: "sessionStart";
        /**
         * @generated from protobuf field: events.SessionStart SessionStart = 5 [json_name = "SessionStart"];
         */
        sessionStart: SessionStart;
    } | {
        oneofKind: "sessionJoin";
        /**
         * @generated from protobuf field: events.SessionJoin SessionJoin = 6 [json_name = "SessionJoin"];
         */
        sessionJoin: SessionJoin;
    } | {
        oneofKind: "sessionPrint";
        /**
         * @generated from protobuf field: events.SessionPrint SessionPrint = 7 [json_name = "SessionPrint"];
         */
        sessionPrint: SessionPrint;
    } | {
        oneofKind: "sessionReject";
        /**
         * @generated from protobuf field: events.SessionReject SessionReject = 8 [json_name = "SessionReject"];
         */
        sessionReject: SessionReject;
    } | {
        oneofKind: "resize";
        /**
         * @generated from protobuf field: events.Resize Resize = 9 [json_name = "Resize"];
         */
        resize: Resize;
    } | {
        oneofKind: "sessionEnd";
        /**
         * @generated from protobuf field: events.SessionEnd SessionEnd = 10 [json_name = "SessionEnd"];
         */
        sessionEnd: SessionEnd;
    } | {
        oneofKind: "sessionCommand";
        /**
         * @generated from protobuf field: events.SessionCommand SessionCommand = 11 [json_name = "SessionCommand"];
         */
        sessionCommand: SessionCommand;
    } | {
        oneofKind: "sessionDisk";
        /**
         * @generated from protobuf field: events.SessionDisk SessionDisk = 12 [json_name = "SessionDisk"];
         */
        sessionDisk: SessionDisk;
    } | {
        oneofKind: "sessionNetwork";
        /**
         * @generated from protobuf field: events.SessionNetwork SessionNetwork = 13 [json_name = "SessionNetwork"];
         */
        sessionNetwork: SessionNetwork;
    } | {
        oneofKind: "sessionData";
        /**
         * @generated from protobuf field: events.SessionData SessionData = 14 [json_name = "SessionData"];
         */
        sessionData: SessionData;
    } | {
        oneofKind: "sessionLeave";
        /**
         * @generated from protobuf field: events.SessionLeave SessionLeave = 15 [json_name = "SessionLeave"];
         */
        sessionLeave: SessionLeave;
    } | {
        oneofKind: "portForward";
        /**
         * @generated from protobuf field: events.PortForward PortForward = 16 [json_name = "PortForward"];
         */
        portForward: PortForward;
    } | {
        oneofKind: "x11Forward";
        /**
         * @generated from protobuf field: events.X11Forward X11Forward = 17 [json_name = "X11Forward"];
         */
        x11Forward: X11Forward;
    } | {
        oneofKind: "sCP";
        /**
         * @generated from protobuf field: events.SCP SCP = 18 [json_name = "SCP"];
         */
        sCP: SCP;
    } | {
        oneofKind: "exec";
        /**
         * @generated from protobuf field: events.Exec Exec = 19 [json_name = "Exec"];
         */
        exec: Exec;
    } | {
        oneofKind: "subsystem";
        /**
         * @generated from protobuf field: events.Subsystem Subsystem = 20 [json_name = "Subsystem"];
         */
        subsystem: Subsystem;
    } | {
        oneofKind: "clientDisconnect";
        /**
         * @generated from protobuf field: events.ClientDisconnect ClientDisconnect = 21 [json_name = "ClientDisconnect"];
         */
        clientDisconnect: ClientDisconnect;
    } | {
        oneofKind: "authAttempt";
        /**
         * @generated from protobuf field: events.AuthAttempt AuthAttempt = 22 [json_name = "AuthAttempt"];
         */
        authAttempt: AuthAttempt;
    } | {
        oneofKind: "accessRequestCreate";
        /**
         * @generated from protobuf field: events.AccessRequestCreate AccessRequestCreate = 23 [json_name = "AccessRequestCreate"];
         */
        accessRequestCreate: AccessRequestCreate;
    } | {
        oneofKind: "userTokenCreate";
        /**
         * @generated from protobuf field: events.UserTokenCreate UserTokenCreate = 24 [json_name = "UserTokenCreate"];
         */
        userTokenCreate: UserTokenCreate;
    } | {
        oneofKind: "roleCreate";
        /**
         * @generated from protobuf field: events.RoleCreate RoleCreate = 25 [json_name = "RoleCreate"];
         */
        roleCreate: RoleCreate;
    } | {
        oneofKind: "roleDelete";
        /**
         * @generated from protobuf field: events.RoleDelete RoleDelete = 26 [json_name = "RoleDelete"];
         */
        roleDelete: RoleDelete;
    } | {
        oneofKind: "trustedClusterCreate";
        /**
         * @generated from protobuf field: events.TrustedClusterCreate TrustedClusterCreate = 27 [json_name = "TrustedClusterCreate"];
         */
        trustedClusterCreate: TrustedClusterCreate;
    } | {
        oneofKind: "trustedClusterDelete";
        /**
         * @generated from protobuf field: events.TrustedClusterDelete TrustedClusterDelete = 28 [json_name = "TrustedClusterDelete"];
         */
        trustedClusterDelete: TrustedClusterDelete;
    } | {
        oneofKind: "trustedClusterTokenCreate";
        /**
         * @generated from protobuf field: events.TrustedClusterTokenCreate TrustedClusterTokenCreate = 29 [json_name = "TrustedClusterTokenCreate"];
         */
        trustedClusterTokenCreate: TrustedClusterTokenCreate;
    } | {
        oneofKind: "githubConnectorCreate";
        /**
         * @generated from protobuf field: events.GithubConnectorCreate GithubConnectorCreate = 30 [json_name = "GithubConnectorCreate"];
         */
        githubConnectorCreate: GithubConnectorCreate;
    } | {
        oneofKind: "githubConnectorDelete";
        /**
         * @generated from protobuf field: events.GithubConnectorDelete GithubConnectorDelete = 31 [json_name = "GithubConnectorDelete"];
         */
        githubConnectorDelete: GithubConnectorDelete;
    } | {
        oneofKind: "oIDCConnectorCreate";
        /**
         * @generated from protobuf field: events.OIDCConnectorCreate OIDCConnectorCreate = 32 [json_name = "OIDCConnectorCreate"];
         */
        oIDCConnectorCreate: OIDCConnectorCreate;
    } | {
        oneofKind: "oIDCConnectorDelete";
        /**
         * @generated from protobuf field: events.OIDCConnectorDelete OIDCConnectorDelete = 33 [json_name = "OIDCConnectorDelete"];
         */
        oIDCConnectorDelete: OIDCConnectorDelete;
    } | {
        oneofKind: "sAMLConnectorCreate";
        /**
         * @generated from protobuf field: events.SAMLConnectorCreate SAMLConnectorCreate = 34 [json_name = "SAMLConnectorCreate"];
         */
        sAMLConnectorCreate: SAMLConnectorCreate;
    } | {
        oneofKind: "sAMLConnectorDelete";
        /**
         * @generated from protobuf field: events.SAMLConnectorDelete SAMLConnectorDelete = 35 [json_name = "SAMLConnectorDelete"];
         */
        sAMLConnectorDelete: SAMLConnectorDelete;
    } | {
        oneofKind: "kubeRequest";
        /**
         * @generated from protobuf field: events.KubeRequest KubeRequest = 36 [json_name = "KubeRequest"];
         */
        kubeRequest: KubeRequest;
    } | {
        oneofKind: "appSessionStart";
        /**
         * @generated from protobuf field: events.AppSessionStart AppSessionStart = 37 [json_name = "AppSessionStart"];
         */
        appSessionStart: AppSessionStart;
    } | {
        oneofKind: "appSessionChunk";
        /**
         * @generated from protobuf field: events.AppSessionChunk AppSessionChunk = 38 [json_name = "AppSessionChunk"];
         */
        appSessionChunk: AppSessionChunk;
    } | {
        oneofKind: "appSessionRequest";
        /**
         * @generated from protobuf field: events.AppSessionRequest AppSessionRequest = 39 [json_name = "AppSessionRequest"];
         */
        appSessionRequest: AppSessionRequest;
    } | {
        oneofKind: "databaseSessionStart";
        /**
         * @generated from protobuf field: events.DatabaseSessionStart DatabaseSessionStart = 40 [json_name = "DatabaseSessionStart"];
         */
        databaseSessionStart: DatabaseSessionStart;
    } | {
        oneofKind: "databaseSessionEnd";
        /**
         * @generated from protobuf field: events.DatabaseSessionEnd DatabaseSessionEnd = 41 [json_name = "DatabaseSessionEnd"];
         */
        databaseSessionEnd: DatabaseSessionEnd;
    } | {
        oneofKind: "databaseSessionQuery";
        /**
         * @generated from protobuf field: events.DatabaseSessionQuery DatabaseSessionQuery = 42 [json_name = "DatabaseSessionQuery"];
         */
        databaseSessionQuery: DatabaseSessionQuery;
    } | {
        oneofKind: "sessionUpload";
        /**
         * @generated from protobuf field: events.SessionUpload SessionUpload = 43 [json_name = "SessionUpload"];
         */
        sessionUpload: SessionUpload;
    } | {
        oneofKind: "mFADeviceAdd";
        /**
         * @generated from protobuf field: events.MFADeviceAdd MFADeviceAdd = 44 [json_name = "MFADeviceAdd"];
         */
        mFADeviceAdd: MFADeviceAdd;
    } | {
        oneofKind: "mFADeviceDelete";
        /**
         * @generated from protobuf field: events.MFADeviceDelete MFADeviceDelete = 45 [json_name = "MFADeviceDelete"];
         */
        mFADeviceDelete: MFADeviceDelete;
    } | {
        oneofKind: "billingInformationUpdate";
        /**
         * @generated from protobuf field: events.BillingInformationUpdate BillingInformationUpdate = 46 [json_name = "BillingInformationUpdate"];
         */
        billingInformationUpdate: BillingInformationUpdate;
    } | {
        oneofKind: "billingCardCreate";
        /**
         * @generated from protobuf field: events.BillingCardCreate BillingCardCreate = 47 [json_name = "BillingCardCreate"];
         */
        billingCardCreate: BillingCardCreate;
    } | {
        oneofKind: "billingCardDelete";
        /**
         * @generated from protobuf field: events.BillingCardDelete BillingCardDelete = 48 [json_name = "BillingCardDelete"];
         */
        billingCardDelete: BillingCardDelete;
    } | {
        oneofKind: "lockCreate";
        /**
         * @generated from protobuf field: events.LockCreate LockCreate = 49 [json_name = "LockCreate"];
         */
        lockCreate: LockCreate;
    } | {
        oneofKind: "lockDelete";
        /**
         * @generated from protobuf field: events.LockDelete LockDelete = 50 [json_name = "LockDelete"];
         */
        lockDelete: LockDelete;
    } | {
        oneofKind: "recoveryCodeGenerate";
        /**
         * @generated from protobuf field: events.RecoveryCodeGenerate RecoveryCodeGenerate = 51 [json_name = "RecoveryCodeGenerate"];
         */
        recoveryCodeGenerate: RecoveryCodeGenerate;
    } | {
        oneofKind: "recoveryCodeUsed";
        /**
         * @generated from protobuf field: events.RecoveryCodeUsed RecoveryCodeUsed = 52 [json_name = "RecoveryCodeUsed"];
         */
        recoveryCodeUsed: RecoveryCodeUsed;
    } | {
        oneofKind: "databaseCreate";
        /**
         * @generated from protobuf field: events.DatabaseCreate DatabaseCreate = 53 [json_name = "DatabaseCreate"];
         */
        databaseCreate: DatabaseCreate;
    } | {
        oneofKind: "databaseUpdate";
        /**
         * @generated from protobuf field: events.DatabaseUpdate DatabaseUpdate = 54 [json_name = "DatabaseUpdate"];
         */
        databaseUpdate: DatabaseUpdate;
    } | {
        oneofKind: "databaseDelete";
        /**
         * @generated from protobuf field: events.DatabaseDelete DatabaseDelete = 55 [json_name = "DatabaseDelete"];
         */
        databaseDelete: DatabaseDelete;
    } | {
        oneofKind: "appCreate";
        /**
         * @generated from protobuf field: events.AppCreate AppCreate = 56 [json_name = "AppCreate"];
         */
        appCreate: AppCreate;
    } | {
        oneofKind: "appUpdate";
        /**
         * @generated from protobuf field: events.AppUpdate AppUpdate = 57 [json_name = "AppUpdate"];
         */
        appUpdate: AppUpdate;
    } | {
        oneofKind: "appDelete";
        /**
         * @generated from protobuf field: events.AppDelete AppDelete = 58 [json_name = "AppDelete"];
         */
        appDelete: AppDelete;
    } | {
        oneofKind: "windowsDesktopSessionStart";
        /**
         * @generated from protobuf field: events.WindowsDesktopSessionStart WindowsDesktopSessionStart = 59 [json_name = "WindowsDesktopSessionStart"];
         */
        windowsDesktopSessionStart: WindowsDesktopSessionStart;
    } | {
        oneofKind: "windowsDesktopSessionEnd";
        /**
         * @generated from protobuf field: events.WindowsDesktopSessionEnd WindowsDesktopSessionEnd = 60 [json_name = "WindowsDesktopSessionEnd"];
         */
        windowsDesktopSessionEnd: WindowsDesktopSessionEnd;
    } | {
        oneofKind: "postgresParse";
        /**
         * @generated from protobuf field: events.PostgresParse PostgresParse = 61 [json_name = "PostgresParse"];
         */
        postgresParse: PostgresParse;
    } | {
        oneofKind: "postgresBind";
        /**
         * @generated from protobuf field: events.PostgresBind PostgresBind = 62 [json_name = "PostgresBind"];
         */
        postgresBind: PostgresBind;
    } | {
        oneofKind: "postgresExecute";
        /**
         * @generated from protobuf field: events.PostgresExecute PostgresExecute = 63 [json_name = "PostgresExecute"];
         */
        postgresExecute: PostgresExecute;
    } | {
        oneofKind: "postgresClose";
        /**
         * @generated from protobuf field: events.PostgresClose PostgresClose = 64 [json_name = "PostgresClose"];
         */
        postgresClose: PostgresClose;
    } | {
        oneofKind: "postgresFunctionCall";
        /**
         * @generated from protobuf field: events.PostgresFunctionCall PostgresFunctionCall = 65 [json_name = "PostgresFunctionCall"];
         */
        postgresFunctionCall: PostgresFunctionCall;
    } | {
        oneofKind: "accessRequestDelete";
        /**
         * @generated from protobuf field: events.AccessRequestDelete AccessRequestDelete = 66 [json_name = "AccessRequestDelete"];
         */
        accessRequestDelete: AccessRequestDelete;
    } | {
        oneofKind: "sessionConnect";
        /**
         * @generated from protobuf field: events.SessionConnect SessionConnect = 67 [json_name = "SessionConnect"];
         */
        sessionConnect: SessionConnect;
    } | {
        oneofKind: "certificateCreate";
        /**
         * @generated from protobuf field: events.CertificateCreate CertificateCreate = 68 [json_name = "CertificateCreate"];
         */
        certificateCreate: CertificateCreate;
    } | {
        oneofKind: "desktopRecording";
        /**
         * @generated from protobuf field: events.DesktopRecording DesktopRecording = 69 [json_name = "DesktopRecording"];
         */
        desktopRecording: DesktopRecording;
    } | {
        oneofKind: "desktopClipboardSend";
        /**
         * @generated from protobuf field: events.DesktopClipboardSend DesktopClipboardSend = 70 [json_name = "DesktopClipboardSend"];
         */
        desktopClipboardSend: DesktopClipboardSend;
    } | {
        oneofKind: "desktopClipboardReceive";
        /**
         * @generated from protobuf field: events.DesktopClipboardReceive DesktopClipboardReceive = 71 [json_name = "DesktopClipboardReceive"];
         */
        desktopClipboardReceive: DesktopClipboardReceive;
    } | {
        oneofKind: "mySQLStatementPrepare";
        /**
         * @generated from protobuf field: events.MySQLStatementPrepare MySQLStatementPrepare = 72 [json_name = "MySQLStatementPrepare"];
         */
        mySQLStatementPrepare: MySQLStatementPrepare;
    } | {
        oneofKind: "mySQLStatementExecute";
        /**
         * @generated from protobuf field: events.MySQLStatementExecute MySQLStatementExecute = 73 [json_name = "MySQLStatementExecute"];
         */
        mySQLStatementExecute: MySQLStatementExecute;
    } | {
        oneofKind: "mySQLStatementSendLongData";
        /**
         * @generated from protobuf field: events.MySQLStatementSendLongData MySQLStatementSendLongData = 74 [json_name = "MySQLStatementSendLongData"];
         */
        mySQLStatementSendLongData: MySQLStatementSendLongData;
    } | {
        oneofKind: "mySQLStatementClose";
        /**
         * @generated from protobuf field: events.MySQLStatementClose MySQLStatementClose = 75 [json_name = "MySQLStatementClose"];
         */
        mySQLStatementClose: MySQLStatementClose;
    } | {
        oneofKind: "mySQLStatementReset";
        /**
         * @generated from protobuf field: events.MySQLStatementReset MySQLStatementReset = 76 [json_name = "MySQLStatementReset"];
         */
        mySQLStatementReset: MySQLStatementReset;
    } | {
        oneofKind: "mySQLStatementFetch";
        /**
         * @generated from protobuf field: events.MySQLStatementFetch MySQLStatementFetch = 77 [json_name = "MySQLStatementFetch"];
         */
        mySQLStatementFetch: MySQLStatementFetch;
    } | {
        oneofKind: "mySQLStatementBulkExecute";
        /**
         * @generated from protobuf field: events.MySQLStatementBulkExecute MySQLStatementBulkExecute = 78 [json_name = "MySQLStatementBulkExecute"];
         */
        mySQLStatementBulkExecute: MySQLStatementBulkExecute;
    } | {
        oneofKind: "renewableCertificateGenerationMismatch";
        /**
         * @generated from protobuf field: events.RenewableCertificateGenerationMismatch RenewableCertificateGenerationMismatch = 79 [json_name = "RenewableCertificateGenerationMismatch"];
         */
        renewableCertificateGenerationMismatch: RenewableCertificateGenerationMismatch;
    } | {
        oneofKind: "unknown";
        /**
         * @generated from protobuf field: events.Unknown Unknown = 80 [json_name = "Unknown"];
         */
        unknown: Unknown;
    } | {
        oneofKind: "mySQLInitDB";
        /**
         * @generated from protobuf field: events.MySQLInitDB MySQLInitDB = 81 [json_name = "MySQLInitDB"];
         */
        mySQLInitDB: MySQLInitDB;
    } | {
        oneofKind: "mySQLCreateDB";
        /**
         * @generated from protobuf field: events.MySQLCreateDB MySQLCreateDB = 82 [json_name = "MySQLCreateDB"];
         */
        mySQLCreateDB: MySQLCreateDB;
    } | {
        oneofKind: "mySQLDropDB";
        /**
         * @generated from protobuf field: events.MySQLDropDB MySQLDropDB = 83 [json_name = "MySQLDropDB"];
         */
        mySQLDropDB: MySQLDropDB;
    } | {
        oneofKind: "mySQLShutDown";
        /**
         * @generated from protobuf field: events.MySQLShutDown MySQLShutDown = 84 [json_name = "MySQLShutDown"];
         */
        mySQLShutDown: MySQLShutDown;
    } | {
        oneofKind: "mySQLProcessKill";
        /**
         * @generated from protobuf field: events.MySQLProcessKill MySQLProcessKill = 85 [json_name = "MySQLProcessKill"];
         */
        mySQLProcessKill: MySQLProcessKill;
    } | {
        oneofKind: "mySQLDebug";
        /**
         * @generated from protobuf field: events.MySQLDebug MySQLDebug = 86 [json_name = "MySQLDebug"];
         */
        mySQLDebug: MySQLDebug;
    } | {
        oneofKind: "mySQLRefresh";
        /**
         * @generated from protobuf field: events.MySQLRefresh MySQLRefresh = 87 [json_name = "MySQLRefresh"];
         */
        mySQLRefresh: MySQLRefresh;
    } | {
        oneofKind: "accessRequestResourceSearch";
        /**
         * @generated from protobuf field: events.AccessRequestResourceSearch AccessRequestResourceSearch = 88 [json_name = "AccessRequestResourceSearch"];
         */
        accessRequestResourceSearch: AccessRequestResourceSearch;
    } | {
        oneofKind: "sQLServerRPCRequest";
        /**
         * @generated from protobuf field: events.SQLServerRPCRequest SQLServerRPCRequest = 89 [json_name = "SQLServerRPCRequest"];
         */
        sQLServerRPCRequest: SQLServerRPCRequest;
    } | {
        oneofKind: "databaseSessionMalformedPacket";
        /**
         * @generated from protobuf field: events.DatabaseSessionMalformedPacket DatabaseSessionMalformedPacket = 90 [json_name = "DatabaseSessionMalformedPacket"];
         */
        databaseSessionMalformedPacket: DatabaseSessionMalformedPacket;
    } | {
        oneofKind: "sFTP";
        /**
         * @generated from protobuf field: events.SFTP SFTP = 91 [json_name = "SFTP"];
         */
        sFTP: SFTP;
    } | {
        oneofKind: "upgradeWindowStartUpdate";
        /**
         * @generated from protobuf field: events.UpgradeWindowStartUpdate UpgradeWindowStartUpdate = 92 [json_name = "UpgradeWindowStartUpdate"];
         */
        upgradeWindowStartUpdate: UpgradeWindowStartUpdate;
    } | {
        oneofKind: "appSessionEnd";
        /**
         * @generated from protobuf field: events.AppSessionEnd AppSessionEnd = 93 [json_name = "AppSessionEnd"];
         */
        appSessionEnd: AppSessionEnd;
    } | {
        oneofKind: "sessionRecordingAccess";
        /**
         * @generated from protobuf field: events.SessionRecordingAccess SessionRecordingAccess = 94 [json_name = "SessionRecordingAccess"];
         */
        sessionRecordingAccess: SessionRecordingAccess;
    } | {
        oneofKind: "kubernetesClusterCreate";
        /**
         * @generated from protobuf field: events.KubernetesClusterCreate KubernetesClusterCreate = 96 [json_name = "KubernetesClusterCreate"];
         */
        kubernetesClusterCreate: KubernetesClusterCreate;
    } | {
        oneofKind: "kubernetesClusterUpdate";
        /**
         * @generated from protobuf field: events.KubernetesClusterUpdate KubernetesClusterUpdate = 97 [json_name = "KubernetesClusterUpdate"];
         */
        kubernetesClusterUpdate: KubernetesClusterUpdate;
    } | {
        oneofKind: "kubernetesClusterDelete";
        /**
         * @generated from protobuf field: events.KubernetesClusterDelete KubernetesClusterDelete = 98 [json_name = "KubernetesClusterDelete"];
         */
        kubernetesClusterDelete: KubernetesClusterDelete;
    } | {
        oneofKind: "sSMRun";
        /**
         * @generated from protobuf field: events.SSMRun SSMRun = 99 [json_name = "SSMRun"];
         */
        sSMRun: SSMRun;
    } | {
        oneofKind: "elasticsearchRequest";
        /**
         * @generated from protobuf field: events.ElasticsearchRequest ElasticsearchRequest = 100 [json_name = "ElasticsearchRequest"];
         */
        elasticsearchRequest: ElasticsearchRequest;
    } | {
        oneofKind: "cassandraBatch";
        /**
         * @generated from protobuf field: events.CassandraBatch CassandraBatch = 101 [json_name = "CassandraBatch"];
         */
        cassandraBatch: CassandraBatch;
    } | {
        oneofKind: "cassandraPrepare";
        /**
         * @generated from protobuf field: events.CassandraPrepare CassandraPrepare = 102 [json_name = "CassandraPrepare"];
         */
        cassandraPrepare: CassandraPrepare;
    } | {
        oneofKind: "cassandraRegister";
        /**
         * @generated from protobuf field: events.CassandraRegister CassandraRegister = 103 [json_name = "CassandraRegister"];
         */
        cassandraRegister: CassandraRegister;
    } | {
        oneofKind: "cassandraExecute";
        /**
         * @generated from protobuf field: events.CassandraExecute CassandraExecute = 104 [json_name = "CassandraExecute"];
         */
        cassandraExecute: CassandraExecute;
    } | {
        oneofKind: "appSessionDynamoDBRequest";
        /**
         * @generated from protobuf field: events.AppSessionDynamoDBRequest AppSessionDynamoDBRequest = 105 [json_name = "AppSessionDynamoDBRequest"];
         */
        appSessionDynamoDBRequest: AppSessionDynamoDBRequest;
    } | {
        oneofKind: "desktopSharedDirectoryStart";
        /**
         * @generated from protobuf field: events.DesktopSharedDirectoryStart DesktopSharedDirectoryStart = 106 [json_name = "DesktopSharedDirectoryStart"];
         */
        desktopSharedDirectoryStart: DesktopSharedDirectoryStart;
    } | {
        oneofKind: "desktopSharedDirectoryRead";
        /**
         * @generated from protobuf field: events.DesktopSharedDirectoryRead DesktopSharedDirectoryRead = 107 [json_name = "DesktopSharedDirectoryRead"];
         */
        desktopSharedDirectoryRead: DesktopSharedDirectoryRead;
    } | {
        oneofKind: "desktopSharedDirectoryWrite";
        /**
         * @generated from protobuf field: events.DesktopSharedDirectoryWrite DesktopSharedDirectoryWrite = 108 [json_name = "DesktopSharedDirectoryWrite"];
         */
        desktopSharedDirectoryWrite: DesktopSharedDirectoryWrite;
    } | {
        oneofKind: "dynamoDBRequest";
        /**
         * @generated from protobuf field: events.DynamoDBRequest DynamoDBRequest = 109 [json_name = "DynamoDBRequest"];
         */
        dynamoDBRequest: DynamoDBRequest;
    } | {
        oneofKind: "botJoin";
        /**
         * @generated from protobuf field: events.BotJoin BotJoin = 110 [json_name = "BotJoin"];
         */
        botJoin: BotJoin;
    } | {
        oneofKind: "instanceJoin";
        /**
         * @generated from protobuf field: events.InstanceJoin InstanceJoin = 111 [json_name = "InstanceJoin"];
         */
        instanceJoin: InstanceJoin;
    } | {
        oneofKind: "deviceEvent";
        /**
         * @generated from protobuf field: events.DeviceEvent DeviceEvent = 112 [json_name = "DeviceEvent"];
         */
        deviceEvent: DeviceEvent;
    } | {
        oneofKind: "loginRuleCreate";
        /**
         * @generated from protobuf field: events.LoginRuleCreate LoginRuleCreate = 113 [json_name = "LoginRuleCreate"];
         */
        loginRuleCreate: LoginRuleCreate;
    } | {
        oneofKind: "loginRuleDelete";
        /**
         * @generated from protobuf field: events.LoginRuleDelete LoginRuleDelete = 114 [json_name = "LoginRuleDelete"];
         */
        loginRuleDelete: LoginRuleDelete;
    } | {
        oneofKind: "sAMLIdPAuthAttempt";
        /**
         * @generated from protobuf field: events.SAMLIdPAuthAttempt SAMLIdPAuthAttempt = 115 [json_name = "SAMLIdPAuthAttempt"];
         */
        sAMLIdPAuthAttempt: SAMLIdPAuthAttempt;
    } | {
        oneofKind: "sAMLIdPServiceProviderCreate";
        /**
         * @generated from protobuf field: events.SAMLIdPServiceProviderCreate SAMLIdPServiceProviderCreate = 116 [json_name = "SAMLIdPServiceProviderCreate"];
         */
        sAMLIdPServiceProviderCreate: SAMLIdPServiceProviderCreate;
    } | {
        oneofKind: "sAMLIdPServiceProviderUpdate";
        /**
         * @generated from protobuf field: events.SAMLIdPServiceProviderUpdate SAMLIdPServiceProviderUpdate = 117 [json_name = "SAMLIdPServiceProviderUpdate"];
         */
        sAMLIdPServiceProviderUpdate: SAMLIdPServiceProviderUpdate;
    } | {
        oneofKind: "sAMLIdPServiceProviderDelete";
        /**
         * @generated from protobuf field: events.SAMLIdPServiceProviderDelete SAMLIdPServiceProviderDelete = 118 [json_name = "SAMLIdPServiceProviderDelete"];
         */
        sAMLIdPServiceProviderDelete: SAMLIdPServiceProviderDelete;
    } | {
        oneofKind: "sAMLIdPServiceProviderDeleteAll";
        /**
         * @generated from protobuf field: events.SAMLIdPServiceProviderDeleteAll SAMLIdPServiceProviderDeleteAll = 119 [json_name = "SAMLIdPServiceProviderDeleteAll"];
         */
        sAMLIdPServiceProviderDeleteAll: SAMLIdPServiceProviderDeleteAll;
    } | {
        oneofKind: "openSearchRequest";
        /**
         * @generated from protobuf field: events.OpenSearchRequest OpenSearchRequest = 120 [json_name = "OpenSearchRequest"];
         */
        openSearchRequest: OpenSearchRequest;
    } | {
        oneofKind: "deviceEvent2";
        /**
         * @generated from protobuf field: events.DeviceEvent2 DeviceEvent2 = 121 [json_name = "DeviceEvent2"];
         */
        deviceEvent2: DeviceEvent2;
    } | {
        oneofKind: "oktaResourcesUpdate";
        /**
         * @generated from protobuf field: events.OktaResourcesUpdate OktaResourcesUpdate = 122 [json_name = "OktaResourcesUpdate"];
         */
        oktaResourcesUpdate: OktaResourcesUpdate;
    } | {
        oneofKind: "oktaSyncFailure";
        /**
         * @generated from protobuf field: events.OktaSyncFailure OktaSyncFailure = 123 [json_name = "OktaSyncFailure"];
         */
        oktaSyncFailure: OktaSyncFailure;
    } | {
        oneofKind: "oktaAssignmentResult";
        /**
         * @generated from protobuf field: events.OktaAssignmentResult OktaAssignmentResult = 124 [json_name = "OktaAssignmentResult"];
         */
        oktaAssignmentResult: OktaAssignmentResult;
    } | {
        oneofKind: "provisionTokenCreate";
        /**
         * @generated from protobuf field: events.ProvisionTokenCreate ProvisionTokenCreate = 125 [json_name = "ProvisionTokenCreate"];
         */
        provisionTokenCreate: ProvisionTokenCreate;
    } | {
        oneofKind: "accessListCreate";
        /**
         * @generated from protobuf field: events.AccessListCreate AccessListCreate = 126 [json_name = "AccessListCreate"];
         */
        accessListCreate: AccessListCreate;
    } | {
        oneofKind: "accessListUpdate";
        /**
         * @generated from protobuf field: events.AccessListUpdate AccessListUpdate = 127 [json_name = "AccessListUpdate"];
         */
        accessListUpdate: AccessListUpdate;
    } | {
        oneofKind: "accessListDelete";
        /**
         * @generated from protobuf field: events.AccessListDelete AccessListDelete = 128 [json_name = "AccessListDelete"];
         */
        accessListDelete: AccessListDelete;
    } | {
        oneofKind: "accessListReview";
        /**
         * @generated from protobuf field: events.AccessListReview AccessListReview = 129 [json_name = "AccessListReview"];
         */
        accessListReview: AccessListReview;
    } | {
        oneofKind: "accessListMemberCreate";
        /**
         * @generated from protobuf field: events.AccessListMemberCreate AccessListMemberCreate = 130 [json_name = "AccessListMemberCreate"];
         */
        accessListMemberCreate: AccessListMemberCreate;
    } | {
        oneofKind: "accessListMemberUpdate";
        /**
         * @generated from protobuf field: events.AccessListMemberUpdate AccessListMemberUpdate = 131 [json_name = "AccessListMemberUpdate"];
         */
        accessListMemberUpdate: AccessListMemberUpdate;
    } | {
        oneofKind: "accessListMemberDelete";
        /**
         * @generated from protobuf field: events.AccessListMemberDelete AccessListMemberDelete = 132 [json_name = "AccessListMemberDelete"];
         */
        accessListMemberDelete: AccessListMemberDelete;
    } | {
        oneofKind: "accessListMemberDeleteAllForAccessList";
        /**
         * @generated from protobuf field: events.AccessListMemberDeleteAllForAccessList AccessListMemberDeleteAllForAccessList = 133 [json_name = "AccessListMemberDeleteAllForAccessList"];
         */
        accessListMemberDeleteAllForAccessList: AccessListMemberDeleteAllForAccessList;
    } | {
        oneofKind: "auditQueryRun";
        /**
         * @generated from protobuf field: events.AuditQueryRun AuditQueryRun = 134 [json_name = "AuditQueryRun"];
         */
        auditQueryRun: AuditQueryRun;
    } | {
        oneofKind: "securityReportRun";
        /**
         * @generated from protobuf field: events.SecurityReportRun SecurityReportRun = 135 [json_name = "SecurityReportRun"];
         */
        securityReportRun: SecurityReportRun;
    } | {
        oneofKind: "githubConnectorUpdate";
        /**
         * @generated from protobuf field: events.GithubConnectorUpdate GithubConnectorUpdate = 136 [json_name = "GithubConnectorUpdate"];
         */
        githubConnectorUpdate: GithubConnectorUpdate;
    } | {
        oneofKind: "oIDCConnectorUpdate";
        /**
         * @generated from protobuf field: events.OIDCConnectorUpdate OIDCConnectorUpdate = 137 [json_name = "OIDCConnectorUpdate"];
         */
        oIDCConnectorUpdate: OIDCConnectorUpdate;
    } | {
        oneofKind: "sAMLConnectorUpdate";
        /**
         * @generated from protobuf field: events.SAMLConnectorUpdate SAMLConnectorUpdate = 138 [json_name = "SAMLConnectorUpdate"];
         */
        sAMLConnectorUpdate: SAMLConnectorUpdate;
    } | {
        oneofKind: "roleUpdate";
        /**
         * @generated from protobuf field: events.RoleUpdate RoleUpdate = 139 [json_name = "RoleUpdate"];
         */
        roleUpdate: RoleUpdate;
    } | {
        oneofKind: "userUpdate";
        /**
         * @generated from protobuf field: events.UserUpdate UserUpdate = 140 [json_name = "UserUpdate"];
         */
        userUpdate: UserUpdate;
    } | {
        oneofKind: "externalAuditStorageEnable";
        /**
         * @generated from protobuf field: events.ExternalAuditStorageEnable ExternalAuditStorageEnable = 141 [json_name = "ExternalAuditStorageEnable"];
         */
        externalAuditStorageEnable: ExternalAuditStorageEnable;
    } | {
        oneofKind: "externalAuditStorageDisable";
        /**
         * @generated from protobuf field: events.ExternalAuditStorageDisable ExternalAuditStorageDisable = 142 [json_name = "ExternalAuditStorageDisable"];
         */
        externalAuditStorageDisable: ExternalAuditStorageDisable;
    } | {
        oneofKind: "botCreate";
        /**
         * @generated from protobuf field: events.BotCreate BotCreate = 143 [json_name = "BotCreate"];
         */
        botCreate: BotCreate;
    } | {
        oneofKind: "botDelete";
        /**
         * @generated from protobuf field: events.BotDelete BotDelete = 144 [json_name = "BotDelete"];
         */
        botDelete: BotDelete;
    } | {
        oneofKind: "botUpdate";
        /**
         * @generated from protobuf field: events.BotUpdate BotUpdate = 145 [json_name = "BotUpdate"];
         */
        botUpdate: BotUpdate;
    } | {
        oneofKind: "createMFAAuthChallenge";
        /**
         * @generated from protobuf field: events.CreateMFAAuthChallenge CreateMFAAuthChallenge = 146 [json_name = "CreateMFAAuthChallenge"];
         */
        createMFAAuthChallenge: CreateMFAAuthChallenge;
    } | {
        oneofKind: "validateMFAAuthResponse";
        /**
         * @generated from protobuf field: events.ValidateMFAAuthResponse ValidateMFAAuthResponse = 147 [json_name = "ValidateMFAAuthResponse"];
         */
        validateMFAAuthResponse: ValidateMFAAuthResponse;
    } | {
        oneofKind: "oktaAccessListSync";
        /**
         * @generated from protobuf field: events.OktaAccessListSync OktaAccessListSync = 148 [json_name = "OktaAccessListSync"];
         */
        oktaAccessListSync: OktaAccessListSync;
    } | {
        oneofKind: "databasePermissionUpdate";
        /**
         * @generated from protobuf field: events.DatabasePermissionUpdate DatabasePermissionUpdate = 149 [json_name = "DatabasePermissionUpdate"];
         */
        databasePermissionUpdate: DatabasePermissionUpdate;
    } | {
        oneofKind: "sPIFFESVIDIssued";
        /**
         * @generated from protobuf field: events.SPIFFESVIDIssued SPIFFESVIDIssued = 150 [json_name = "SPIFFESVIDIssued"];
         */
        sPIFFESVIDIssued: SPIFFESVIDIssued;
    } | {
        oneofKind: "oktaUserSync";
        /**
         * @generated from protobuf field: events.OktaUserSync OktaUserSync = 151 [json_name = "OktaUserSync"];
         */
        oktaUserSync: OktaUserSync;
    } | {
        oneofKind: "authPreferenceUpdate";
        /**
         * @generated from protobuf field: events.AuthPreferenceUpdate AuthPreferenceUpdate = 152 [json_name = "AuthPreferenceUpdate"];
         */
        authPreferenceUpdate: AuthPreferenceUpdate;
    } | {
        oneofKind: "sessionRecordingConfigUpdate";
        /**
         * @generated from protobuf field: events.SessionRecordingConfigUpdate SessionRecordingConfigUpdate = 153 [json_name = "SessionRecordingConfigUpdate"];
         */
        sessionRecordingConfigUpdate: SessionRecordingConfigUpdate;
    } | {
        oneofKind: "clusterNetworkingConfigUpdate";
        /**
         * @generated from protobuf field: events.ClusterNetworkingConfigUpdate ClusterNetworkingConfigUpdate = 154 [json_name = "ClusterNetworkingConfigUpdate"];
         */
        clusterNetworkingConfigUpdate: ClusterNetworkingConfigUpdate;
    } | {
        oneofKind: "databaseUserCreate";
        /**
         * @generated from protobuf field: events.DatabaseUserCreate DatabaseUserCreate = 155 [json_name = "DatabaseUserCreate"];
         */
        databaseUserCreate: DatabaseUserCreate;
    } | {
        oneofKind: "databaseUserDeactivate";
        /**
         * @generated from protobuf field: events.DatabaseUserDeactivate DatabaseUserDeactivate = 156 [json_name = "DatabaseUserDeactivate"];
         */
        databaseUserDeactivate: DatabaseUserDeactivate;
    } | {
        oneofKind: "accessPathChanged";
        /**
         * @generated from protobuf field: events.AccessPathChanged AccessPathChanged = 157 [json_name = "AccessPathChanged"];
         */
        accessPathChanged: AccessPathChanged;
    } | {
        oneofKind: "spannerRPC";
        /**
         * @generated from protobuf field: events.SpannerRPC SpannerRPC = 158 [json_name = "SpannerRPC"];
         */
        spannerRPC: SpannerRPC;
    } | {
        oneofKind: "databaseSessionCommandResult";
        /**
         * @generated from protobuf field: events.DatabaseSessionCommandResult DatabaseSessionCommandResult = 159 [json_name = "DatabaseSessionCommandResult"];
         */
        databaseSessionCommandResult: DatabaseSessionCommandResult;
    } | {
        oneofKind: "discoveryConfigCreate";
        /**
         * @generated from protobuf field: events.DiscoveryConfigCreate DiscoveryConfigCreate = 160 [json_name = "DiscoveryConfigCreate"];
         */
        discoveryConfigCreate: DiscoveryConfigCreate;
    } | {
        oneofKind: "discoveryConfigUpdate";
        /**
         * @generated from protobuf field: events.DiscoveryConfigUpdate DiscoveryConfigUpdate = 161 [json_name = "DiscoveryConfigUpdate"];
         */
        discoveryConfigUpdate: DiscoveryConfigUpdate;
    } | {
        oneofKind: "discoveryConfigDelete";
        /**
         * @generated from protobuf field: events.DiscoveryConfigDelete DiscoveryConfigDelete = 162 [json_name = "DiscoveryConfigDelete"];
         */
        discoveryConfigDelete: DiscoveryConfigDelete;
    } | {
        oneofKind: "discoveryConfigDeleteAll";
        /**
         * @generated from protobuf field: events.DiscoveryConfigDeleteAll DiscoveryConfigDeleteAll = 163 [json_name = "DiscoveryConfigDeleteAll"];
         */
        discoveryConfigDeleteAll: DiscoveryConfigDeleteAll;
    } | {
        oneofKind: "accessGraphSettingsUpdate";
        /**
         * @generated from protobuf field: events.AccessGraphSettingsUpdate AccessGraphSettingsUpdate = 164 [json_name = "AccessGraphSettingsUpdate"];
         */
        accessGraphSettingsUpdate: AccessGraphSettingsUpdate;
    } | {
        oneofKind: "integrationCreate";
        /**
         * @generated from protobuf field: events.IntegrationCreate IntegrationCreate = 165 [json_name = "IntegrationCreate"];
         */
        integrationCreate: IntegrationCreate;
    } | {
        oneofKind: "integrationUpdate";
        /**
         * @generated from protobuf field: events.IntegrationUpdate IntegrationUpdate = 166 [json_name = "IntegrationUpdate"];
         */
        integrationUpdate: IntegrationUpdate;
    } | {
        oneofKind: "integrationDelete";
        /**
         * @generated from protobuf field: events.IntegrationDelete IntegrationDelete = 167 [json_name = "IntegrationDelete"];
         */
        integrationDelete: IntegrationDelete;
    } | {
        oneofKind: "sPIFFEFederationCreate";
        /**
         * @generated from protobuf field: events.SPIFFEFederationCreate SPIFFEFederationCreate = 168 [json_name = "SPIFFEFederationCreate"];
         */
        sPIFFEFederationCreate: SPIFFEFederationCreate;
    } | {
        oneofKind: "sPIFFEFederationDelete";
        /**
         * @generated from protobuf field: events.SPIFFEFederationDelete SPIFFEFederationDelete = 169 [json_name = "SPIFFEFederationDelete"];
         */
        sPIFFEFederationDelete: SPIFFEFederationDelete;
    } | {
        oneofKind: "pluginCreate";
        /**
         * @generated from protobuf field: events.PluginCreate PluginCreate = 170 [json_name = "PluginCreate"];
         */
        pluginCreate: PluginCreate;
    } | {
        oneofKind: "pluginUpdate";
        /**
         * @generated from protobuf field: events.PluginUpdate PluginUpdate = 171 [json_name = "PluginUpdate"];
         */
        pluginUpdate: PluginUpdate;
    } | {
        oneofKind: "pluginDelete";
        /**
         * @generated from protobuf field: events.PluginDelete PluginDelete = 172 [json_name = "PluginDelete"];
         */
        pluginDelete: PluginDelete;
    } | {
        oneofKind: "autoUpdateConfigCreate";
        /**
         * @generated from protobuf field: events.AutoUpdateConfigCreate AutoUpdateConfigCreate = 173 [json_name = "AutoUpdateConfigCreate"];
         */
        autoUpdateConfigCreate: AutoUpdateConfigCreate;
    } | {
        oneofKind: "autoUpdateConfigUpdate";
        /**
         * @generated from protobuf field: events.AutoUpdateConfigUpdate AutoUpdateConfigUpdate = 174 [json_name = "AutoUpdateConfigUpdate"];
         */
        autoUpdateConfigUpdate: AutoUpdateConfigUpdate;
    } | {
        oneofKind: "autoUpdateConfigDelete";
        /**
         * @generated from protobuf field: events.AutoUpdateConfigDelete AutoUpdateConfigDelete = 175 [json_name = "AutoUpdateConfigDelete"];
         */
        autoUpdateConfigDelete: AutoUpdateConfigDelete;
    } | {
        oneofKind: "autoUpdateVersionCreate";
        /**
         * @generated from protobuf field: events.AutoUpdateVersionCreate AutoUpdateVersionCreate = 176 [json_name = "AutoUpdateVersionCreate"];
         */
        autoUpdateVersionCreate: AutoUpdateVersionCreate;
    } | {
        oneofKind: "autoUpdateVersionUpdate";
        /**
         * @generated from protobuf field: events.AutoUpdateVersionUpdate AutoUpdateVersionUpdate = 177 [json_name = "AutoUpdateVersionUpdate"];
         */
        autoUpdateVersionUpdate: AutoUpdateVersionUpdate;
    } | {
        oneofKind: "autoUpdateVersionDelete";
        /**
         * @generated from protobuf field: events.AutoUpdateVersionDelete AutoUpdateVersionDelete = 178 [json_name = "AutoUpdateVersionDelete"];
         */
        autoUpdateVersionDelete: AutoUpdateVersionDelete;
    } | {
        oneofKind: "staticHostUserCreate";
        /**
         * @generated from protobuf field: events.StaticHostUserCreate StaticHostUserCreate = 179 [json_name = "StaticHostUserCreate"];
         */
        staticHostUserCreate: StaticHostUserCreate;
    } | {
        oneofKind: "staticHostUserUpdate";
        /**
         * @generated from protobuf field: events.StaticHostUserUpdate StaticHostUserUpdate = 180 [json_name = "StaticHostUserUpdate"];
         */
        staticHostUserUpdate: StaticHostUserUpdate;
    } | {
        oneofKind: "staticHostUserDelete";
        /**
         * @generated from protobuf field: events.StaticHostUserDelete StaticHostUserDelete = 181 [json_name = "StaticHostUserDelete"];
         */
        staticHostUserDelete: StaticHostUserDelete;
    } | {
        oneofKind: "crownJewelCreate";
        /**
         * @generated from protobuf field: events.CrownJewelCreate CrownJewelCreate = 182 [json_name = "CrownJewelCreate"];
         */
        crownJewelCreate: CrownJewelCreate;
    } | {
        oneofKind: "crownJewelUpdate";
        /**
         * @generated from protobuf field: events.CrownJewelUpdate CrownJewelUpdate = 183 [json_name = "CrownJewelUpdate"];
         */
        crownJewelUpdate: CrownJewelUpdate;
    } | {
        oneofKind: "crownJewelDelete";
        /**
         * @generated from protobuf field: events.CrownJewelDelete CrownJewelDelete = 184 [json_name = "CrownJewelDelete"];
         */
        crownJewelDelete: CrownJewelDelete;
    } | {
        oneofKind: "userTaskCreate";
        /**
         * @generated from protobuf field: events.UserTaskCreate UserTaskCreate = 188 [json_name = "UserTaskCreate"];
         */
        userTaskCreate: UserTaskCreate;
    } | {
        oneofKind: "userTaskUpdate";
        /**
         * @generated from protobuf field: events.UserTaskUpdate UserTaskUpdate = 189 [json_name = "UserTaskUpdate"];
         */
        userTaskUpdate: UserTaskUpdate;
    } | {
        oneofKind: "userTaskDelete";
        /**
         * @generated from protobuf field: events.UserTaskDelete UserTaskDelete = 190 [json_name = "UserTaskDelete"];
         */
        userTaskDelete: UserTaskDelete;
    } | {
        oneofKind: "sFTPSummary";
        /**
         * @generated from protobuf field: events.SFTPSummary SFTPSummary = 191 [json_name = "SFTPSummary"];
         */
        sFTPSummary: SFTPSummary;
    } | {
        oneofKind: "contactCreate";
        /**
         * @generated from protobuf field: events.ContactCreate ContactCreate = 192 [json_name = "ContactCreate"];
         */
        contactCreate: ContactCreate;
    } | {
        oneofKind: "contactDelete";
        /**
         * @generated from protobuf field: events.ContactDelete ContactDelete = 193 [json_name = "ContactDelete"];
         */
        contactDelete: ContactDelete;
    } | {
        oneofKind: "workloadIdentityCreate";
        /**
         * @generated from protobuf field: events.WorkloadIdentityCreate WorkloadIdentityCreate = 194 [json_name = "WorkloadIdentityCreate"];
         */
        workloadIdentityCreate: WorkloadIdentityCreate;
    } | {
        oneofKind: "workloadIdentityUpdate";
        /**
         * @generated from protobuf field: events.WorkloadIdentityUpdate WorkloadIdentityUpdate = 195 [json_name = "WorkloadIdentityUpdate"];
         */
        workloadIdentityUpdate: WorkloadIdentityUpdate;
    } | {
        oneofKind: "workloadIdentityDelete";
        /**
         * @generated from protobuf field: events.WorkloadIdentityDelete WorkloadIdentityDelete = 196 [json_name = "WorkloadIdentityDelete"];
         */
        workloadIdentityDelete: WorkloadIdentityDelete;
    } | {
        oneofKind: "gitCommand";
        /**
         * @generated from protobuf field: events.GitCommand GitCommand = 197 [json_name = "GitCommand"];
         */
        gitCommand: GitCommand;
    } | {
        oneofKind: "userLoginAccessListInvalid";
        /**
         * @generated from protobuf field: events.UserLoginAccessListInvalid UserLoginAccessListInvalid = 198 [json_name = "UserLoginAccessListInvalid"];
         */
        userLoginAccessListInvalid: UserLoginAccessListInvalid;
    } | {
        oneofKind: "accessRequestExpire";
        /**
         * @generated from protobuf field: events.AccessRequestExpire AccessRequestExpire = 199 [json_name = "AccessRequestExpire"];
         */
        accessRequestExpire: AccessRequestExpire;
    } | {
        oneofKind: "stableUNIXUserCreate";
        /**
         * @generated from protobuf field: events.StableUNIXUserCreate StableUNIXUserCreate = 200 [json_name = "StableUNIXUserCreate"];
         */
        stableUNIXUserCreate: StableUNIXUserCreate;
    } | {
        oneofKind: "workloadIdentityX509RevocationCreate";
        /**
         * @generated from protobuf field: events.WorkloadIdentityX509RevocationCreate WorkloadIdentityX509RevocationCreate = 201 [json_name = "WorkloadIdentityX509RevocationCreate"];
         */
        workloadIdentityX509RevocationCreate: WorkloadIdentityX509RevocationCreate;
    } | {
        oneofKind: "workloadIdentityX509RevocationDelete";
        /**
         * @generated from protobuf field: events.WorkloadIdentityX509RevocationDelete WorkloadIdentityX509RevocationDelete = 202 [json_name = "WorkloadIdentityX509RevocationDelete"];
         */
        workloadIdentityX509RevocationDelete: WorkloadIdentityX509RevocationDelete;
    } | {
        oneofKind: "workloadIdentityX509RevocationUpdate";
        /**
         * @generated from protobuf field: events.WorkloadIdentityX509RevocationUpdate WorkloadIdentityX509RevocationUpdate = 203 [json_name = "WorkloadIdentityX509RevocationUpdate"];
         */
        workloadIdentityX509RevocationUpdate: WorkloadIdentityX509RevocationUpdate;
    } | {
        oneofKind: "aWSICResourceSync";
        /**
         * @generated from protobuf field: events.AWSICResourceSync AWSICResourceSync = 204 [json_name = "AWSICResourceSync"];
         */
        aWSICResourceSync: AWSICResourceSync;
    } | {
        oneofKind: "healthCheckConfigCreate";
        /**
         * @generated from protobuf field: events.HealthCheckConfigCreate HealthCheckConfigCreate = 205 [json_name = "HealthCheckConfigCreate"];
         */
        healthCheckConfigCreate: HealthCheckConfigCreate;
    } | {
        oneofKind: "healthCheckConfigUpdate";
        /**
         * @generated from protobuf field: events.HealthCheckConfigUpdate HealthCheckConfigUpdate = 206 [json_name = "HealthCheckConfigUpdate"];
         */
        healthCheckConfigUpdate: HealthCheckConfigUpdate;
    } | {
        oneofKind: "healthCheckConfigDelete";
        /**
         * @generated from protobuf field: events.HealthCheckConfigDelete HealthCheckConfigDelete = 207 [json_name = "HealthCheckConfigDelete"];
         */
        healthCheckConfigDelete: HealthCheckConfigDelete;
    } | {
        oneofKind: "workloadIdentityX509IssuerOverrideCreate";
        /**
         * @generated from protobuf field: events.WorkloadIdentityX509IssuerOverrideCreate WorkloadIdentityX509IssuerOverrideCreate = 208 [json_name = "WorkloadIdentityX509IssuerOverrideCreate"];
         */
        workloadIdentityX509IssuerOverrideCreate: WorkloadIdentityX509IssuerOverrideCreate;
    } | {
        oneofKind: "workloadIdentityX509IssuerOverrideDelete";
        /**
         * @generated from protobuf field: events.WorkloadIdentityX509IssuerOverrideDelete WorkloadIdentityX509IssuerOverrideDelete = 209 [json_name = "WorkloadIdentityX509IssuerOverrideDelete"];
         */
        workloadIdentityX509IssuerOverrideDelete: WorkloadIdentityX509IssuerOverrideDelete;
    } | {
        oneofKind: "sigstorePolicyCreate";
        /**
         * @generated from protobuf field: events.SigstorePolicyCreate SigstorePolicyCreate = 210 [json_name = "SigstorePolicyCreate"];
         */
        sigstorePolicyCreate: SigstorePolicyCreate;
    } | {
        oneofKind: "sigstorePolicyUpdate";
        /**
         * @generated from protobuf field: events.SigstorePolicyUpdate SigstorePolicyUpdate = 211 [json_name = "SigstorePolicyUpdate"];
         */
        sigstorePolicyUpdate: SigstorePolicyUpdate;
    } | {
        oneofKind: "sigstorePolicyDelete";
        /**
         * @generated from protobuf field: events.SigstorePolicyDelete SigstorePolicyDelete = 212 [json_name = "SigstorePolicyDelete"];
         */
        sigstorePolicyDelete: SigstorePolicyDelete;
    } | {
        oneofKind: "autoUpdateAgentRolloutTrigger";
        /**
         * @generated from protobuf field: events.AutoUpdateAgentRolloutTrigger AutoUpdateAgentRolloutTrigger = 213 [json_name = "AutoUpdateAgentRolloutTrigger"];
         */
        autoUpdateAgentRolloutTrigger: AutoUpdateAgentRolloutTrigger;
    } | {
        oneofKind: "autoUpdateAgentRolloutForceDone";
        /**
         * @generated from protobuf field: events.AutoUpdateAgentRolloutForceDone AutoUpdateAgentRolloutForceDone = 214 [json_name = "AutoUpdateAgentRolloutForceDone"];
         */
        autoUpdateAgentRolloutForceDone: AutoUpdateAgentRolloutForceDone;
    } | {
        oneofKind: "autoUpdateAgentRolloutRollback";
        /**
         * @generated from protobuf field: events.AutoUpdateAgentRolloutRollback AutoUpdateAgentRolloutRollback = 215 [json_name = "AutoUpdateAgentRolloutRollback"];
         */
        autoUpdateAgentRolloutRollback: AutoUpdateAgentRolloutRollback;
    } | {
        oneofKind: undefined;
    };
}
/**
 * StreamStatus reflects stream status
 *
 * @generated from protobuf message events.StreamStatus
 */
export interface StreamStatus {
    /**
     * UploadID represents upload ID
     *
     * @generated from protobuf field: string UploadID = 1 [json_name = "UploadID"];
     */
    uploadID: string;
    /**
     * LastEventIndex updates last event index
     *
     * @generated from protobuf field: int64 LastEventIndex = 2 [json_name = "LastEventIndex"];
     */
    lastEventIndex: bigint;
    /**
     * LastUploadTime is the time of the last upload
     *
     * @generated from protobuf field: google.protobuf.Timestamp LastUploadTime = 3 [json_name = "LastUploadTime"];
     */
    lastUploadTime?: Timestamp;
}
/**
 * SessionUpload is a session upload
 *
 * @generated from protobuf message events.SessionUpload
 */
export interface SessionUpload {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * SessionMetadata is a common event session metadata
     *
     * @generated from protobuf field: events.SessionMetadata SessionMetadata = 2 [json_name = "SessionMetadata"];
     */
    sessionMetadata?: SessionMetadata;
    /**
     * URL is where the url the session event data upload is at
     *
     * @generated from protobuf field: string SessionURL = 5 [json_name = "SessionURL"];
     */
    sessionURL: string;
}
/**
 * Identity matches github.com/gravitational/teleport/lib/tlsca.Identity except
 * for RouteToApp and RouteToDatabase which are nullable and Traits which is
 * represented as a google.protobuf.Struct (still containing a map from string
 * to strings). Field names match other names already used in other events
 * rather than the field names in tlsca.Identity.
 *
 * @generated from protobuf message events.Identity
 */
export interface Identity {
    /**
     * User is a username or name of the node connection
     *
     * @generated from protobuf field: string User = 1 [json_name = "User"];
     */
    user: string;
    /**
     * Impersonator is a username of a user impersonating this user
     *
     * @generated from protobuf field: string Impersonator = 2 [json_name = "Impersonator"];
     */
    impersonator: string;
    /**
     * Roles is a list of groups (Teleport roles) encoded in the identity
     *
     * @generated from protobuf field: repeated string Roles = 3 [json_name = "Roles"];
     */
    roles: string[];
    /**
     * Usage is a list of usage restrictions encoded in the identity
     *
     * @generated from protobuf field: repeated string Usage = 4 [json_name = "Usage"];
     */
    usage: string[];
    /**
     * Logins is a list of Unix logins allowed.
     *
     * @generated from protobuf field: repeated string Logins = 5 [json_name = "Logins"];
     */
    logins: string[];
    /**
     * KubernetesGroups is a list of Kubernetes groups allowed
     *
     * @generated from protobuf field: repeated string KubernetesGroups = 6 [json_name = "KubernetesGroups"];
     */
    kubernetesGroups: string[];
    /**
     * KubernetesUsers is a list of Kubernetes users allowed
     *
     * @generated from protobuf field: repeated string KubernetesUsers = 7 [json_name = "KubernetesUsers"];
     */
    kubernetesUsers: string[];
    /**
     * Expires specifies whenever the session will expire
     *
     * @generated from protobuf field: google.protobuf.Timestamp Expires = 8 [json_name = "Expires"];
     */
    expires?: Timestamp;
    /**
     * RouteToCluster specifies the target cluster
     * if present in the session
     *
     * @generated from protobuf field: string RouteToCluster = 9 [json_name = "RouteToCluster"];
     */
    routeToCluster: string;
    /**
     * KubernetesCluster specifies the target kubernetes cluster for TLS
     * identities. This can be empty on older Teleport clients.
     *
     * @generated from protobuf field: string KubernetesCluster = 10 [json_name = "KubernetesCluster"];
     */
    kubernetesCluster: string;
    /**
     * Traits hold claim data used to populate a role at runtime.
     *
     * @generated from protobuf field: wrappers.LabelValues Traits = 11 [json_name = "Traits"];
     */
    traits?: LabelValues;
    /**
     * RouteToApp holds routing information for applications. Routing metadata
     * allows Teleport web proxy to route HTTP requests to the appropriate
     * cluster and Teleport application proxy within the cluster.
     *
     * @generated from protobuf field: events.RouteToApp RouteToApp = 12 [json_name = "RouteToApp"];
     */
    routeToApp?: RouteToApp;
    /**
     * TeleportCluster is the name of the teleport cluster that this identity
     * originated from. For TLS certs this may not be the same as cert issuer,
     * in case of multi-hop requests that originate from a remote cluster.
     *
     * @generated from protobuf field: string TeleportCluster = 13 [json_name = "TeleportCluster"];
     */
    teleportCluster: string;
    /**
     * RouteToDatabase contains routing information for databases.
     *
     * @generated from protobuf field: events.RouteToDatabase RouteToDatabase = 14 [json_name = "RouteToDatabase"];
     */
    routeToDatabase?: RouteToDatabase;
    /**
     * DatabaseNames is a list of allowed database names.
     *
     * @generated from protobuf field: repeated string DatabaseNames = 15 [json_name = "DatabaseNames"];
     */
    databaseNames: string[];
    /**
     * DatabaseUsers is a list of allowed database users.
     *
     * @generated from protobuf field: repeated string DatabaseUsers = 16 [json_name = "DatabaseUsers"];
     */
    databaseUsers: string[];
    /**
     * MFADeviceUUID is the UUID of an MFA device when this Identity was
     * confirmed immediately after an MFA check.
     *
     * @generated from protobuf field: string MFADeviceUUID = 17 [json_name = "MFADeviceUUID"];
     */
    mFADeviceUUID: string;
    /**
     * ClientIP is an observed IP of the client that this Identity represents.
     *
     * @generated from protobuf field: string ClientIP = 18 [json_name = "ClientIP"];
     */
    clientIP: string;
    /**
     * AWSRoleARNs is a list of allowed AWS role ARNs user can assume.
     *
     * @generated from protobuf field: repeated string AWSRoleARNs = 19 [json_name = "AWSRoleARNs"];
     */
    aWSRoleARNs: string[];
    /**
     * AccessRequests is a list of UUIDs of active requests for this Identity.
     *
     * @generated from protobuf field: repeated string AccessRequests = 20 [json_name = "AccessRequests"];
     */
    accessRequests: string[];
    /**
     * DisallowReissue is a flag that, if set, instructs the auth server to
     * deny any attempts to reissue new certificates while authenticated with
     * this certificate.
     *
     * @generated from protobuf field: bool DisallowReissue = 21 [json_name = "DisallowReissue"];
     */
    disallowReissue: boolean;
    /**
     * AllowedResourceIds is the list of resources which the identity will be
     * allowed to access. An empty list indicates that no resource-specific
     * restrictions will be applied.
     *
     * @generated from protobuf field: repeated events.ResourceID AllowedResourceIDs = 22 [json_name = "AllowedResourceIDs"];
     */
    allowedResourceIDs: ResourceID[];
    /**
     * PreviousIdentityExpires is the expiry time of the identity/cert that this
     * identity/cert was derived from. It is used to determine a session's hard
     * deadline in cases where both require_session_mfa and disconnect_expired_cert
     * are enabled. See https://github.com/gravitational/teleport/issues/18544.
     *
     * @generated from protobuf field: google.protobuf.Timestamp PreviousIdentityExpires = 23 [json_name = "PreviousIdentityExpires"];
     */
    previousIdentityExpires?: Timestamp;
    /**
     * AzureIdentities is a list of allowed Azure identities user can assume.
     *
     * @generated from protobuf field: repeated string AzureIdentities = 24 [json_name = "AzureIdentities"];
     */
    azureIdentities: string[];
    /**
     * GCPServiceAccounts is a list of allowed GCP service accounts user can assume.
     *
     * @generated from protobuf field: repeated string GCPServiceAccounts = 25 [json_name = "GCPServiceAccounts"];
     */
    gCPServiceAccounts: string[];
    /**
     * PrivateKeyPolicy is the private key policy of the user's private key.
     *
     * @generated from protobuf field: string PrivateKeyPolicy = 26 [json_name = "PrivateKeyPolicy"];
     */
    privateKeyPolicy: string;
    /**
     * BotName indicates the name of the Machine ID bot this identity was issued
     * to, if any.
     *
     * @generated from protobuf field: string BotName = 27 [json_name = "BotName"];
     */
    botName: string;
    /**
     * DeviceExtensions holds the device trust device extensions for the identity,
     * if any.
     *
     * @generated from protobuf field: events.DeviceExtensions DeviceExtensions = 28 [json_name = "DeviceExtensions"];
     */
    deviceExtensions?: DeviceExtensions;
    /**
     * BotInstanceID indicates the name of the Machine ID bot instance this
     * identity was issued to, if any.
     *
     * @generated from protobuf field: string BotInstanceID = 29 [json_name = "BotInstanceID"];
     */
    botInstanceID: string;
}
/**
 * RouteToApp contains parameters for application access certificate requests.
 *
 * @generated from protobuf message events.RouteToApp
 */
export interface RouteToApp {
    /**
     * Name is the application name certificate is being requested for.
     *
     * @generated from protobuf field: string Name = 1 [json_name = "Name"];
     */
    name: string;
    /**
     * SessionID is the ID of the application session.
     *
     * @generated from protobuf field: string SessionID = 2 [json_name = "SessionID"];
     */
    sessionID: string;
    /**
     * PublicAddr is the application public address.
     *
     * @generated from protobuf field: string PublicAddr = 3 [json_name = "PublicAddr"];
     */
    publicAddr: string;
    /**
     * ClusterName is the cluster where the application resides.
     *
     * @generated from protobuf field: string ClusterName = 4 [json_name = "ClusterName"];
     */
    clusterName: string;
    /**
     * AWSRoleARN is the AWS role to assume when accessing AWS API.
     *
     * @generated from protobuf field: string AWSRoleARN = 5 [json_name = "AWSRoleARN"];
     */
    aWSRoleARN: string;
    /**
     * AzureIdentity is the Azure identity ot assume when accessing Azure API.
     *
     * @generated from protobuf field: string AzureIdentity = 6 [json_name = "AzureIdentity"];
     */
    azureIdentity: string;
    /**
     * GCPServiceAccount is the GCP service account to assume when accessing GCP API.
     *
     * @generated from protobuf field: string GCPServiceAccount = 7 [json_name = "GCPServiceAccount"];
     */
    gCPServiceAccount: string;
    /**
     * URI is the application URI.
     *
     * @generated from protobuf field: string URI = 8 [json_name = "URI"];
     */
    uRI: string;
    /**
     * TargetPort signifies that the user accessed a specific port in a multi-port TCP app. The value
     * must be between 1 and 65535.
     *
     * @generated from protobuf field: uint32 TargetPort = 9 [json_name = "TargetPort"];
     */
    targetPort: number;
}
/**
 * RouteToDatabase combines parameters for database service routing information.
 *
 * @generated from protobuf message events.RouteToDatabase
 */
export interface RouteToDatabase {
    /**
     * ServiceName is the Teleport database proxy service name the cert is for.
     *
     * @generated from protobuf field: string ServiceName = 1 [json_name = "ServiceName"];
     */
    serviceName: string;
    /**
     * Protocol is the type of the database the cert is for.
     *
     * @generated from protobuf field: string Protocol = 2 [json_name = "Protocol"];
     */
    protocol: string;
    /**
     * Username is an optional database username to embed.
     *
     * @generated from protobuf field: string Username = 3 [json_name = "Username"];
     */
    username: string;
    /**
     * Database is an optional database name to embed.
     *
     * @generated from protobuf field: string Database = 4 [json_name = "Database"];
     */
    database: string;
    /**
     * Roles is an optional list of database roles to embed.
     *
     * @generated from protobuf field: repeated string Roles = 5 [json_name = "Roles"];
     */
    roles: string[];
}
/**
 * DeviceExtensions holds certificate extensions (X.509 and SSH) for device
 * trust.
 *
 * Mimics tlsca.DeviceExtensions.
 *
 * @generated from protobuf message events.DeviceExtensions
 */
export interface DeviceExtensions {
    /**
     * DeviceID is the trusted device identifier.
     *
     * @generated from protobuf field: string device_id = 1;
     */
    deviceId: string;
    /**
     * AssetTag is the device inventory identifier.
     *
     * @generated from protobuf field: string asset_tag = 2;
     */
    assetTag: string;
    /**
     * CredentialID is the identifier for the credential used by the device to
     * authenticate itself.
     *
     * @generated from protobuf field: string credential_id = 3;
     */
    credentialId: string;
}
/**
 * AccessRequestResourceSearch is emitted when a user searches for resources as
 * part of a search-based access request
 *
 * @generated from protobuf message events.AccessRequestResourceSearch
 */
export interface AccessRequestResourceSearch {
    /**
     * Metadata is common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is common user metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SearchAsRoles is the list of roles the search was performed as.
     *
     * @generated from protobuf field: repeated string SearchAsRoles = 3 [json_name = "SearchAsRoles"];
     */
    searchAsRoles: string[];
    /**
     * ResourceType is the type of resource being searched for.
     *
     * @generated from protobuf field: string ResourceType = 4 [json_name = "ResourceType"];
     */
    resourceType: string;
    /**
     * Namespace is the namespace of resources.
     *
     * @generated from protobuf field: string Namespace = 5 [json_name = "Namespace"];
     */
    namespace: string;
    /**
     * Labels is the label-based matcher used for the search.
     *
     * @generated from protobuf field: map<string, string> Labels = 6 [json_name = "Labels"];
     */
    labels: {
        [key: string]: string;
    };
    /**
     * PredicateExpression is the list of boolean conditions that were used for the search.
     *
     * @generated from protobuf field: string PredicateExpression = 7 [json_name = "PredicateExpression"];
     */
    predicateExpression: string;
    /**
     * SearchKeywords is the list of search keywords used to match against resource field values.
     *
     * @generated from protobuf field: repeated string SearchKeywords = 8 [json_name = "SearchKeywords"];
     */
    searchKeywords: string[];
}
/**
 * MySQLStatementPrepare is emitted when a MySQL client creates a prepared
 * statement using the prepared statement protocol.
 *
 * @generated from protobuf message events.MySQLStatementPrepare
 */
export interface MySQLStatementPrepare {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata.
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * Database contains database related metadata.
     *
     * @generated from protobuf field: events.DatabaseMetadata Database = 4 [json_name = "Database"];
     */
    database?: DatabaseMetadata;
    /**
     * Query is the prepared statement query.
     *
     * @generated from protobuf field: string Query = 5 [json_name = "Query"];
     */
    query: string;
}
/**
 * MySQLStatementExecute is emitted when a MySQL client executes a prepared
 * statement using the prepared statement protocol.
 *
 * @generated from protobuf message events.MySQLStatementExecute
 */
export interface MySQLStatementExecute {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata.
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * Database contains database related metadata.
     *
     * @generated from protobuf field: events.DatabaseMetadata Database = 4 [json_name = "Database"];
     */
    database?: DatabaseMetadata;
    /**
     * StatementID is the identifier of the prepared statement.
     *
     * @generated from protobuf field: uint32 StatementID = 5 [json_name = "StatementID"];
     */
    statementID: number;
    /**
     * Parameters are the parameters used to execute the prepared statement.
     *
     * @generated from protobuf field: repeated string Parameters = 6 [json_name = "Parameters"];
     */
    parameters: string[];
}
/**
 * MySQLStatementSendLongData is emitted when a MySQL client sends long bytes
 * stream using the prepared statement protocol.
 *
 * @generated from protobuf message events.MySQLStatementSendLongData
 */
export interface MySQLStatementSendLongData {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata.
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * Database contains database related metadata.
     *
     * @generated from protobuf field: events.DatabaseMetadata Database = 4 [json_name = "Database"];
     */
    database?: DatabaseMetadata;
    /**
     * StatementID is the identifier of the prepared statement.
     *
     * @generated from protobuf field: uint32 StatementID = 5 [json_name = "StatementID"];
     */
    statementID: number;
    /**
     * ParameterID is the identifier of the parameter.
     *
     * @generated from protobuf field: uint32 ParameterID = 6 [json_name = "ParameterID"];
     */
    parameterID: number;
    /**
     * DataSize is the size of the data.
     *
     * @generated from protobuf field: uint32 DataSize = 7 [json_name = "DataSize"];
     */
    dataSize: number;
}
/**
 * MySQLStatementClose is emitted when a MySQL client deallocates a prepared
 * statement using the prepared statement protocol.
 *
 * @generated from protobuf message events.MySQLStatementClose
 */
export interface MySQLStatementClose {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata.
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * Database contains database related metadata.
     *
     * @generated from protobuf field: events.DatabaseMetadata Database = 4 [json_name = "Database"];
     */
    database?: DatabaseMetadata;
    /**
     * StatementID is the identifier of the prepared statement.
     *
     * @generated from protobuf field: uint32 StatementID = 5 [json_name = "StatementID"];
     */
    statementID: number;
}
/**
 * MySQLStatementReset is emitted when a MySQL client resets the data of a
 * prepared statement using the prepared statement protocol.
 *
 * @generated from protobuf message events.MySQLStatementReset
 */
export interface MySQLStatementReset {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata.
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * Database contains database related metadata.
     *
     * @generated from protobuf field: events.DatabaseMetadata Database = 4 [json_name = "Database"];
     */
    database?: DatabaseMetadata;
    /**
     * StatementID is the identifier of the prepared statement.
     *
     * @generated from protobuf field: uint32 StatementID = 5 [json_name = "StatementID"];
     */
    statementID: number;
}
/**
 * MySQLStatementFetch is emitted when a MySQL client fetches rows from a
 * prepared statement using the prepared statement protocol.
 *
 * @generated from protobuf message events.MySQLStatementFetch
 */
export interface MySQLStatementFetch {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata.
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * Database contains database related metadata.
     *
     * @generated from protobuf field: events.DatabaseMetadata Database = 4 [json_name = "Database"];
     */
    database?: DatabaseMetadata;
    /**
     * StatementID is the identifier of the prepared statement.
     *
     * @generated from protobuf field: uint32 StatementID = 5 [json_name = "StatementID"];
     */
    statementID: number;
    /**
     * RowsCount is the number of rows to fetch.
     *
     * @generated from protobuf field: uint32 RowsCount = 6 [json_name = "RowsCount"];
     */
    rowsCount: number;
}
/**
 * MySQLStatementBulkExecute is emitted when a MySQL client executes a bulk
 * insert of a prepared statement using the prepared statement protocol.
 *
 * @generated from protobuf message events.MySQLStatementBulkExecute
 */
export interface MySQLStatementBulkExecute {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata.
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * Database contains database related metadata.
     *
     * @generated from protobuf field: events.DatabaseMetadata Database = 4 [json_name = "Database"];
     */
    database?: DatabaseMetadata;
    /**
     * StatementID is the identifier of the prepared statement.
     *
     * @generated from protobuf field: uint32 StatementID = 5 [json_name = "StatementID"];
     */
    statementID: number;
    /**
     * Parameters are the parameters used to execute the prepared statement.
     *
     * @generated from protobuf field: repeated string Parameters = 6 [json_name = "Parameters"];
     */
    parameters: string[];
}
/**
 * MySQLInitDB is emitted when a MySQL client changes the default schema for
 * the connection.
 *
 * @generated from protobuf message events.MySQLInitDB
 */
export interface MySQLInitDB {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata.
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * Database contains database related metadata.
     *
     * @generated from protobuf field: events.DatabaseMetadata Database = 4 [json_name = "Database"];
     */
    database?: DatabaseMetadata;
    /**
     * SchemaName is the name of the schema to use.
     *
     * @generated from protobuf field: string SchemaName = 5 [json_name = "SchemaName"];
     */
    schemaName: string;
}
/**
 * MySQLCreateDB is emitted when a MySQL client creates a schema.
 *
 * @generated from protobuf message events.MySQLCreateDB
 */
export interface MySQLCreateDB {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata.
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * Database contains database related metadata.
     *
     * @generated from protobuf field: events.DatabaseMetadata Database = 4 [json_name = "Database"];
     */
    database?: DatabaseMetadata;
    /**
     * SchemaName is the name of the schema to create.
     *
     * @generated from protobuf field: string SchemaName = 5 [json_name = "SchemaName"];
     */
    schemaName: string;
}
/**
 * MySQLDropDB is emitted when a MySQL client drops a schema.
 *
 * @generated from protobuf message events.MySQLDropDB
 */
export interface MySQLDropDB {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata.
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * Database contains database related metadata.
     *
     * @generated from protobuf field: events.DatabaseMetadata Database = 4 [json_name = "Database"];
     */
    database?: DatabaseMetadata;
    /**
     * SchemaName is the name of the schema to drop.
     *
     * @generated from protobuf field: string SchemaName = 5 [json_name = "SchemaName"];
     */
    schemaName: string;
}
/**
 * MySQLShutDown is emitted when a MySQL client asks the server to shut down.
 *
 * @generated from protobuf message events.MySQLShutDown
 */
export interface MySQLShutDown {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata.
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * Database contains database related metadata.
     *
     * @generated from protobuf field: events.DatabaseMetadata Database = 4 [json_name = "Database"];
     */
    database?: DatabaseMetadata;
}
/**
 * MySQLProcessKill is emitted when a MySQL client asks the server to terminate
 * a connection.
 *
 * @generated from protobuf message events.MySQLProcessKill
 */
export interface MySQLProcessKill {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata.
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * Database contains database related metadata.
     *
     * @generated from protobuf field: events.DatabaseMetadata Database = 4 [json_name = "Database"];
     */
    database?: DatabaseMetadata;
    /**
     * ProcessID is the process ID of a connection.
     *
     * @generated from protobuf field: uint32 ProcessID = 5 [json_name = "ProcessID"];
     */
    processID: number;
}
/**
 * MySQLDebug is emitted when a MySQL client asks the server to dump internal
 * debug info to stdout.
 *
 * @generated from protobuf message events.MySQLDebug
 */
export interface MySQLDebug {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata.
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * Database contains database related metadata.
     *
     * @generated from protobuf field: events.DatabaseMetadata Database = 4 [json_name = "Database"];
     */
    database?: DatabaseMetadata;
}
/**
 * MySQLRefresh is emitted when a MySQL client sends refresh commands.
 *
 * @generated from protobuf message events.MySQLRefresh
 */
export interface MySQLRefresh {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata.
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * Database contains database related metadata.
     *
     * @generated from protobuf field: events.DatabaseMetadata Database = 4 [json_name = "Database"];
     */
    database?: DatabaseMetadata;
    /**
     * Subcommand is the string representation of the subcommand.
     *
     * @generated from protobuf field: string Subcommand = 5 [json_name = "Subcommand"];
     */
    subcommand: string;
}
/**
 * SQLServerRPCRequest is emitted when a user executes a MSSQL Server RPC command.
 *
 * @generated from protobuf message events.SQLServerRPCRequest
 */
export interface SQLServerRPCRequest {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata.
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * Database contains database related metadata.
     *
     * @generated from protobuf field: events.DatabaseMetadata Database = 4 [json_name = "Database"];
     */
    database?: DatabaseMetadata;
    /**
     * Procname is the RPC SQL Server procedure name.
     *
     * @generated from protobuf field: string Procname = 5 [json_name = "Procname"];
     */
    procname: string;
    /**
     * Parameters are the RPC parameters used to execute RPC Procedure..
     *
     * @generated from protobuf field: repeated string Parameters = 6 [json_name = "Parameters"];
     */
    parameters: string[];
}
/**
 * DatabaseSessionMalformedPacket is emitted when a database sends a malformed packet.
 *
 * @generated from protobuf message events.DatabaseSessionMalformedPacket
 */
export interface DatabaseSessionMalformedPacket {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata.
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * Database contains database related metadata.
     *
     * @generated from protobuf field: events.DatabaseMetadata Database = 4 [json_name = "Database"];
     */
    database?: DatabaseMetadata;
    /**
     * Payload is the malformed packet payload.
     *
     * @generated from protobuf field: bytes Payload = 5 [json_name = "Payload"];
     */
    payload: Uint8Array;
}
/**
 * ElasticsearchRequest is emitted when user executes an Elasticsearch request, which isn't
 * covered by API-specific events.
 *
 * @generated from protobuf message events.ElasticsearchRequest
 */
export interface ElasticsearchRequest {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata.
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * Database contains database related metadata.
     *
     * @generated from protobuf field: events.DatabaseMetadata Database = 4 [json_name = "Database"];
     */
    database?: DatabaseMetadata;
    /**
     * Path is relative path in the URL.
     *
     * @generated from protobuf field: string Path = 5 [json_name = "Path"];
     */
    path: string;
    /**
     * RawQuery are the encoded query values.
     *
     * @generated from protobuf field: string RawQuery = 6 [json_name = "RawQuery"];
     */
    rawQuery: string;
    /**
     * Method is the request HTTP method, like GET/POST/DELETE/etc.
     *
     * @generated from protobuf field: string Method = 7 [json_name = "Method"];
     */
    method: string;
    /**
     * Body is the request HTTP body.
     *
     * @generated from protobuf field: bytes Body = 8 [json_name = "Body"];
     */
    body: Uint8Array;
    /**
     * Headers are the HTTP request headers.
     *
     * @generated from protobuf field: wrappers.LabelValues Headers = 9 [json_name = "Headers"];
     */
    headers?: LabelValues;
    /**
     * Category represents the category if API being accessed in a given request.
     *
     * @generated from protobuf field: events.ElasticsearchCategory Category = 10 [json_name = "Category"];
     */
    category: ElasticsearchCategory;
    /**
     * Target is an optional field indicating the target index or set of indices used as a subject of request.
     *
     * @generated from protobuf field: string Target = 11 [json_name = "Target"];
     */
    target: string;
    /**
     * Query is an optional text of query (e.g. an SQL select statement for _sql API), if a request includes it.
     *
     * @generated from protobuf field: string Query = 12 [json_name = "Query"];
     */
    query: string;
    /**
     * StatusCode is optional status code returned from the call to database.
     *
     * @generated from protobuf field: uint32 StatusCode = 13 [json_name = "StatusCode"];
     */
    statusCode: number;
}
/**
 * OpenSearchRequest is emitted when a user executes a OpenSearch request via database-access.
 *
 * @generated from protobuf message events.OpenSearchRequest
 */
export interface OpenSearchRequest {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata.
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * Database contains database related metadata.
     *
     * @generated from protobuf field: events.DatabaseMetadata Database = 4 [json_name = "Database"];
     */
    database?: DatabaseMetadata;
    /**
     * Path is relative path in the URL.
     *
     * @generated from protobuf field: string Path = 5 [json_name = "Path"];
     */
    path: string;
    /**
     * RawQuery are the encoded query values.
     *
     * @generated from protobuf field: string RawQuery = 6 [json_name = "RawQuery"];
     */
    rawQuery: string;
    /**
     * Method is the request HTTP method, like GET/POST/DELETE/etc.
     *
     * @generated from protobuf field: string Method = 7 [json_name = "Method"];
     */
    method: string;
    /**
     * Body is the request HTTP body.
     *
     * @generated from protobuf field: bytes Body = 8 [json_name = "Body"];
     */
    body: Uint8Array;
    /**
     * Headers are the HTTP request headers.
     *
     * @generated from protobuf field: wrappers.LabelValues Headers = 9 [json_name = "Headers"];
     */
    headers?: LabelValues;
    /**
     * Category represents the category if API being accessed in a given request.
     *
     * @generated from protobuf field: events.OpenSearchCategory Category = 10 [json_name = "Category"];
     */
    category: OpenSearchCategory;
    /**
     * Target is an optional field indicating the target index or set of indices used as a subject of request.
     *
     * @generated from protobuf field: string Target = 11 [json_name = "Target"];
     */
    target: string;
    /**
     * Query is an optional text of query (e.g. an SQL select statement for _sql API), if a request includes it.
     *
     * @generated from protobuf field: string Query = 12 [json_name = "Query"];
     */
    query: string;
    /**
     * StatusCode is optional status code returned from the call to database.
     *
     * @generated from protobuf field: uint32 StatusCode = 13 [json_name = "StatusCode"];
     */
    statusCode: number;
}
/**
 * DynamoDBRequest is emitted when a user executes a DynamoDB request via database-access.
 *
 * @generated from protobuf message events.DynamoDBRequest
 */
export interface DynamoDBRequest {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata.
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * Database contains database related metadata.
     *
     * @generated from protobuf field: events.DatabaseMetadata Database = 4 [json_name = "Database"];
     */
    database?: DatabaseMetadata;
    /**
     * @generated from protobuf field: uint32 StatusCode = 5 [json_name = "StatusCode"];
     */
    statusCode: number;
    /**
     * Path is relative path in the URL.
     *
     * @generated from protobuf field: string Path = 6 [json_name = "Path"];
     */
    path: string;
    /**
     * RawQuery are the encoded query values.
     *
     * @generated from protobuf field: string RawQuery = 7 [json_name = "RawQuery"];
     */
    rawQuery: string;
    /**
     * Method is the request HTTP method, like GET/POST/DELETE/etc.
     *
     * @generated from protobuf field: string Method = 8 [json_name = "Method"];
     */
    method: string;
    /**
     * Target is the API target in the X-Amz-Target header.
     *
     * @generated from protobuf field: string Target = 9 [json_name = "Target"];
     */
    target: string;
    /**
     * Body is the HTTP request json body.
     * The Struct type is a wrapper around protobuf/types.Struct and is used to marshal the JSON body correctly.
     *
     * @generated from protobuf field: google.protobuf.Struct Body = 10 [json_name = "Body"];
     */
    body?: Struct;
}
/**
 * AppSessionDynamoDBRequest is emitted when a user executes a DynamoDB request via app access.
 *
 * @generated from protobuf message events.AppSessionDynamoDBRequest
 */
export interface AppSessionDynamoDBRequest {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * App is a common application resource metadata.
     *
     * @generated from protobuf field: events.AppMetadata App = 3 [json_name = "App"];
     */
    app?: AppMetadata;
    /**
     * AWS contains extra AWS metadata of the request.
     *
     * @generated from protobuf field: events.AWSRequestMetadata AWS = 4 [json_name = "AWS"];
     */
    aWS?: AWSRequestMetadata;
    /**
     * SessionChunkID is the ID of the app session chunk that this request belongs to.
     * This is more appropriate to include than the app session id, since it is the chunk
     * id that is needed to play back the session chunk with tsh. The session chunk event
     * already includes the app session id.
     *
     * @generated from protobuf field: string SessionChunkID = 5 [json_name = "SessionChunkID"];
     */
    sessionChunkID: string;
    /**
     * StatusCode the HTTP response code for the request.
     *
     * @generated from protobuf field: uint32 StatusCode = 6 [json_name = "StatusCode"];
     */
    statusCode: number;
    /**
     * Path is relative path in the URL.
     *
     * @generated from protobuf field: string Path = 7 [json_name = "Path"];
     */
    path: string;
    /**
     * RawQuery are the encoded query values.
     *
     * @generated from protobuf field: string RawQuery = 8 [json_name = "RawQuery"];
     */
    rawQuery: string;
    /**
     * Method is the request HTTP method, like GET/POST/DELETE/etc.
     *
     * @generated from protobuf field: string Method = 9 [json_name = "Method"];
     */
    method: string;
    /**
     * Target is the API target in the X-Amz-Target header.
     *
     * @generated from protobuf field: string Target = 10 [json_name = "Target"];
     */
    target: string;
    /**
     * Body is the HTTP request json body.
     * The Struct type is a wrapper around protobuf/types.Struct and is used to marshal the JSON body correctly.
     *
     * @generated from protobuf field: google.protobuf.Struct Body = 11 [json_name = "Body"];
     */
    body?: Struct;
}
/**
 * UpgradeWindowStartMetadata contains common upgrade window information.
 *
 * @generated from protobuf message events.UpgradeWindowStartMetadata
 */
export interface UpgradeWindowStartMetadata {
    /**
     * UpgradeWindowStart is the upgrade window time.
     *
     * @generated from protobuf field: string UpgradeWindowStart = 1 [json_name = "UpgradeWindowStart"];
     */
    upgradeWindowStart: string;
}
/**
 * UpgradeWindowStartUpdate is emitted when a user updates the cloud upgrade window start time.
 *
 * @generated from protobuf message events.UpgradeWindowStartUpdate
 */
export interface UpgradeWindowStartUpdate {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata.
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * UpgradeWindowStartMetadata contains upgrade window related metadata.
     *
     * @generated from protobuf field: events.UpgradeWindowStartMetadata UpgradeWindowStart = 4 [json_name = "UpgradeWindowStart"];
     */
    upgradeWindowStart?: UpgradeWindowStartMetadata;
}
/**
 * SessionRecordingAccess is emitted when a session recording is accessed, allowing
 * session views to be included in the audit log
 *
 * @generated from protobuf message events.SessionRecordingAccess
 */
export interface SessionRecordingAccess {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * SessionID is the ID of the session.
     *
     * @generated from protobuf field: string SessionID = 2 [json_name = "SessionID"];
     */
    sessionID: string;
    /**
     * UserMetadata is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata UserMetadata = 3 [json_name = "UserMetadata"];
     */
    userMetadata?: UserMetadata;
    /**
     * SessionType is type of the session.
     *
     * @generated from protobuf field: string SessionType = 4 [json_name = "SessionType"];
     */
    sessionType: string;
    /**
     * Format is the format the session recording was accessed.
     *
     * @generated from protobuf field: string Format = 5 [json_name = "Format"];
     */
    format: string;
}
/**
 * KubeClusterMetadata contains common kubernetes cluster information.
 *
 * @generated from protobuf message events.KubeClusterMetadata
 */
export interface KubeClusterMetadata {
    /**
     * KubeLabels are the configured cluster labels.
     *
     * @generated from protobuf field: map<string, string> KubeLabels = 1 [json_name = "KubeLabels"];
     */
    kubeLabels: {
        [key: string]: string;
    };
}
/**
 * KubernetesClusterCreate is emitted when a new kubernetes cluster resource is created.
 *
 * @generated from protobuf message events.KubernetesClusterCreate
 */
export interface KubernetesClusterCreate {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ResourceMetadata is a common resource event metadata.
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 3 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * KubeClusterMetadata is a common kubernetes resource metadata.
     *
     * @generated from protobuf field: events.KubeClusterMetadata KubeClusterMetadata = 4 [json_name = "KubeClusterMetadata"];
     */
    kubeClusterMetadata?: KubeClusterMetadata;
}
/**
 * KubernetesClusterUpdate is emitted when an existing kubernetes cluster resource is updated.
 *
 * @generated from protobuf message events.KubernetesClusterUpdate
 */
export interface KubernetesClusterUpdate {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ResourceMetadata is a common resource event metadata.
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 3 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * KubeClusterMetadata is a common kubernetes resource metadata.
     *
     * @generated from protobuf field: events.KubeClusterMetadata KubeClusterMetadata = 4 [json_name = "KubeClusterMetadata"];
     */
    kubeClusterMetadata?: KubeClusterMetadata;
}
/**
 * KubernetesClusterDelete is emitted when a kubernetes cluster resource is deleted.
 *
 * @generated from protobuf message events.KubernetesClusterDelete
 */
export interface KubernetesClusterDelete {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ResourceMetadata is a common resource event metadata.
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 3 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
}
/**
 * SSMRun is emitted after an AWS SSM document completes execution.
 *
 * @generated from protobuf message events.SSMRun
 */
export interface SSMRun {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * CommandID is the id of the SSM command that was run.
     *
     * @generated from protobuf field: string CommandID = 2 [json_name = "CommandID"];
     */
    commandID: string;
    /**
     * InstanceID is the id of the EC2 instance the command was run on.
     *
     * @generated from protobuf field: string InstanceID = 3 [json_name = "InstanceID"];
     */
    instanceID: string;
    /**
     * ExitCode is the exit code resulting from the script run.
     *
     * @generated from protobuf field: int64 ExitCode = 4 [json_name = "ExitCode"];
     */
    exitCode: bigint;
    /**
     * Status represents the success or failure status of a script run.
     *
     * @generated from protobuf field: string Status = 5 [json_name = "Status"];
     */
    status: string;
    /**
     * AccountID is the id of the AWS account that ran the command.
     *
     * @generated from protobuf field: string AccountID = 6 [json_name = "AccountID"];
     */
    accountID: string;
    /**
     * Region is the AWS region the command was ran in.
     *
     * @generated from protobuf field: string Region = 7 [json_name = "Region"];
     */
    region: string;
    /**
     * StandardOutput contains the stdout of the executed command.
     * Only the first 24000 chars are returned.
     *
     * @generated from protobuf field: string StandardOutput = 8 [json_name = "StandardOutput"];
     */
    standardOutput: string;
    /**
     * StandardError contains the stderr of the executed command.
     * Only the first 24000 chars are returned.
     *
     * @generated from protobuf field: string StandardError = 9 [json_name = "StandardError"];
     */
    standardError: string;
    /**
     * InvocationURL is a link to AWS Web Console for this invocation.
     * An invocation is the execution of a Command in an Instance.
     *
     * @generated from protobuf field: string InvocationURL = 10 [json_name = "InvocationURL"];
     */
    invocationURL: string;
}
/**
 * CassandraSession is emitted when a Cassandra client sends
 * the prepare a CQL statement.
 *
 * @generated from protobuf message events.CassandraPrepare
 */
export interface CassandraPrepare {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata.
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * Database contains database related metadata.
     *
     * @generated from protobuf field: events.DatabaseMetadata Database = 4 [json_name = "Database"];
     */
    database?: DatabaseMetadata;
    /**
     * Query is the CQL statement.
     *
     * @generated from protobuf field: string Query = 5 [json_name = "Query"];
     */
    query: string;
    /**
     * Keyspace is the keyspace the statement is in.
     *
     * @generated from protobuf field: string Keyspace = 6 [json_name = "Keyspace"];
     */
    keyspace: string;
}
/**
 * CassandraExecute is emitted when a Cassandra client executes a CQL statement.
 *
 * @generated from protobuf message events.CassandraExecute
 */
export interface CassandraExecute {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata.
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * Database contains database related metadata.
     *
     * @generated from protobuf field: events.DatabaseMetadata Database = 4 [json_name = "Database"];
     */
    database?: DatabaseMetadata;
    /**
     * QueryId is the prepared query id to execute.
     *
     * @generated from protobuf field: string QueryId = 5 [json_name = "QueryId"];
     */
    queryId: string;
}
/**
 * CassandraBatch is emitted when a Cassandra client executes a batch of CQL statements.
 *
 * @generated from protobuf message events.CassandraBatch
 */
export interface CassandraBatch {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata.
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * Database contains database related metadata.
     *
     * @generated from protobuf field: events.DatabaseMetadata Database = 4 [json_name = "Database"];
     */
    database?: DatabaseMetadata;
    /**
     * Consistency is the consistency level to use.
     *
     * @generated from protobuf field: string Consistency = 5 [json_name = "Consistency"];
     */
    consistency: string;
    /**
     * Keyspace is the keyspace the statement is in.
     *
     * @generated from protobuf field: string Keyspace = 6 [json_name = "Keyspace"];
     */
    keyspace: string;
    /**
     * BatchType is the type of batch.
     *
     * @generated from protobuf field: string BatchType = 7 [json_name = "BatchType"];
     */
    batchType: string;
    /**
     * Children is batch children statements.
     *
     * @generated from protobuf field: repeated events.CassandraBatch.BatchChild Children = 8 [json_name = "Children"];
     */
    children: CassandraBatch_BatchChild[];
}
/**
 * BatchChild represents a single child batch statement.
 *
 * @generated from protobuf message events.CassandraBatch.BatchChild
 */
export interface CassandraBatch_BatchChild {
    /**
     * ID is the id of the statement.
     *
     * @generated from protobuf field: string ID = 1 [json_name = "ID"];
     */
    iD: string;
    /**
     * Query the CQL statement to execute.
     *
     * @generated from protobuf field: string Query = 2 [json_name = "Query"];
     */
    query: string;
    /**
     * Values is the values to bind to the query.
     *
     * @generated from protobuf field: repeated events.CassandraBatch.BatchChild.Value Values = 3 [json_name = "Values"];
     */
    values: CassandraBatch_BatchChild_Value[];
}
/**
 * Value is a single value to bind to the query.
 *
 * @generated from protobuf message events.CassandraBatch.BatchChild.Value
 */
export interface CassandraBatch_BatchChild_Value {
    /**
     * Type is the type of the value.
     *
     * @generated from protobuf field: uint32 Type = 1 [json_name = "Type"];
     */
    type: number;
    /**
     * Contents is the value contents.
     *
     * @generated from protobuf field: bytes Contents = 2 [json_name = "Contents"];
     */
    contents: Uint8Array;
}
/**
 * CassandraRegister is emitted when a Cassandra client
 * request to register for the specified event types.
 *
 * @generated from protobuf message events.CassandraRegister
 */
export interface CassandraRegister {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata.
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * Database contains database related metadata.
     *
     * @generated from protobuf field: events.DatabaseMetadata Database = 4 [json_name = "Database"];
     */
    database?: DatabaseMetadata;
    /**
     * EventTypes is the list of event types to register for.
     *
     * @generated from protobuf field: repeated string EventTypes = 5 [json_name = "EventTypes"];
     */
    eventTypes: string[];
}
/**
 * LoginRuleCreate is emitted when a login rule is created or updated.
 *
 * @generated from protobuf message events.LoginRuleCreate
 */
export interface LoginRuleCreate {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
}
/**
 * LoginRuleDelete is emitted when a login rule is deleted
 *
 * @generated from protobuf message events.LoginRuleDelete
 */
export interface LoginRuleDelete {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
}
/**
 * SAMLIdPAuthAttempt is emitted when a user has attempted to authorize against the SAML IdP.
 *
 * @generated from protobuf message events.SAMLIdPAuthAttempt
 */
export interface SAMLIdPAuthAttempt {
    /**
     * Metadata is common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is common event session metadata
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * Status indicates whether the SAML IdP authentication was successful.
     *
     * @generated from protobuf field: events.Status Status = 4 [json_name = "Status"];
     */
    status?: Status;
    /**
     * SAMLIdPServiceProviderMetadata is common SAML IdP service provider event metadata
     *
     * @generated from protobuf field: events.SAMLIdPServiceProviderMetadata ServiceProvider = 5 [json_name = "ServiceProvider"];
     */
    serviceProvider?: SAMLIdPServiceProviderMetadata;
}
/**
 * SAMLIdPServiceProviderCreate is emitted when a service provider has been added.
 *
 * @generated from protobuf message events.SAMLIdPServiceProviderCreate
 */
export interface SAMLIdPServiceProviderCreate {
    /**
     * Metadata is common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ResourceMetadata is common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * SAMLIdPServiceProviderMetadata is common SAML IdP service provider event metadata
     *
     * @generated from protobuf field: events.SAMLIdPServiceProviderMetadata ServiceProvider = 3 [json_name = "ServiceProvider"];
     */
    serviceProvider?: SAMLIdPServiceProviderMetadata;
}
/**
 * SAMLIdPServiceProviderUpdate is emitted when a service provider has been updated.
 *
 * @generated from protobuf message events.SAMLIdPServiceProviderUpdate
 */
export interface SAMLIdPServiceProviderUpdate {
    /**
     * Metadata is common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * SAMLIdPServiceProviderMetadata is common SAML IdP service provider event metadata
     *
     * @generated from protobuf field: events.SAMLIdPServiceProviderMetadata ServiceProvider = 3 [json_name = "ServiceProvider"];
     */
    serviceProvider?: SAMLIdPServiceProviderMetadata;
}
/**
 * SAMLIdPServiceProviderDelete is emitted when a service provider has been deleted.
 *
 * @generated from protobuf message events.SAMLIdPServiceProviderDelete
 */
export interface SAMLIdPServiceProviderDelete {
    /**
     * Metadata is common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ResourceMetadata is common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * SAMLIdPServiceProviderMetadata is common SAML IdP service provider event metadata
     *
     * @generated from protobuf field: events.SAMLIdPServiceProviderMetadata ServiceProvider = 3 [json_name = "ServiceProvider"];
     */
    serviceProvider?: SAMLIdPServiceProviderMetadata;
}
/**
 * SAMLIdPServiceProviderDeleteAll is emitted when all service providers have been deleted.
 *
 * @generated from protobuf message events.SAMLIdPServiceProviderDeleteAll
 */
export interface SAMLIdPServiceProviderDeleteAll {
    /**
     * Metadata is common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ResourceMetadata is common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
}
/**
 * OktaResourcesUpdate is emitted when Okta related resources have been updated.
 *
 * @generated from protobuf message events.OktaResourcesUpdate
 */
export interface OktaResourcesUpdate {
    /**
     * Metadata is common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Server is a common server metadata.
     *
     * @generated from protobuf field: events.ServerMetadata Server = 2 [json_name = "Server"];
     */
    server?: ServerMetadata;
    /**
     * Updated is common metadata related to Okta resources being updated.
     *
     * @generated from protobuf field: events.OktaResourcesUpdatedMetadata Updated = 3 [json_name = "Updated"];
     */
    updated?: OktaResourcesUpdatedMetadata;
}
/**
 * OktaSyncFailure is emitted when an Okta synchronization attempt has failed.
 *
 * @generated from protobuf message events.OktaSyncFailure
 */
export interface OktaSyncFailure {
    /**
     * Metadata is common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Server is a common server metadata.
     *
     * @generated from protobuf field: events.ServerMetadata Server = 2 [json_name = "Server"];
     */
    server?: ServerMetadata;
    /**
     * Status contains error information for the synchronization failure.
     *
     * @generated from protobuf field: events.Status Status = 3 [json_name = "Status"];
     */
    status?: Status;
}
/**
 * OktaAssignmentResult is emitted when an Okta assignment processing or cleanup was attempted.
 *
 * @generated from protobuf message events.OktaAssignmentResult
 */
export interface OktaAssignmentResult {
    /**
     * Metadata is common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Server is a common server metadata.
     *
     * @generated from protobuf field: events.ServerMetadata Server = 2 [json_name = "Server"];
     */
    server?: ServerMetadata;
    /**
     * ResourceMetadata is common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 3 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * Status indicates whether the assignment processing was successful.
     *
     * @generated from protobuf field: events.Status Status = 4 [json_name = "Status"];
     */
    status?: Status;
    /**
     * OktaAssignmentMetadata is common Okta assignment metadata.
     *
     * @generated from protobuf field: events.OktaAssignmentMetadata OktaAssignment = 5 [json_name = "OktaAssignment"];
     */
    oktaAssignment?: OktaAssignmentMetadata;
}
/**
 * AccessListCreate is emitted when an access list is created.
 *
 * @generated from protobuf message events.AccessListCreate
 */
export interface AccessListCreate {
    /**
     * Metadata is common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Resource is common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * Status indicates whether the resource operation was successful.
     *
     * @generated from protobuf field: events.Status Status = 3 [json_name = "Status"];
     */
    status?: Status;
    /**
     * AccessListTitle is the access list's title.
     *
     * @generated from protobuf field: string AccessListTitle = 4 [json_name = "AccessListTitle"];
     */
    accessListTitle: string;
}
/**
 * AccessListUpdate is emitted when an access list is updated.
 *
 * @generated from protobuf message events.AccessListUpdate
 */
export interface AccessListUpdate {
    /**
     * Metadata is common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Resource is common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * Status indicates whether the resource operation was successful.
     *
     * @generated from protobuf field: events.Status Status = 3 [json_name = "Status"];
     */
    status?: Status;
    /**
     * AccessListTitle is the access list's title.
     *
     * @generated from protobuf field: string AccessListTitle = 4 [json_name = "AccessListTitle"];
     */
    accessListTitle: string;
}
/**
 * AccessListDelete is emitted when an access list is deleted.
 *
 * @generated from protobuf message events.AccessListDelete
 */
export interface AccessListDelete {
    /**
     * Metadata is common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Resource is common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * Status indicates whether the resource operation was successful.
     *
     * @generated from protobuf field: events.Status Status = 3 [json_name = "Status"];
     */
    status?: Status;
    /**
     * AccessListTitle is the access list's title.
     *
     * @generated from protobuf field: string AccessListTitle = 4 [json_name = "AccessListTitle"];
     */
    accessListTitle: string;
}
/**
 * AccessListMemberCreate is emitted when an access list member is created.
 *
 * @generated from protobuf message events.AccessListMemberCreate
 */
export interface AccessListMemberCreate {
    /**
     * Metadata is common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Resource is common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * AccessListMember is common access list member metadata.
     *
     * @generated from protobuf field: events.AccessListMemberMetadata AccessListMember = 3 [json_name = "AccessListMember"];
     */
    accessListMember?: AccessListMemberMetadata;
    /**
     * Status indicates whether the resource operation was successful.
     *
     * @generated from protobuf field: events.Status Status = 4 [json_name = "Status"];
     */
    status?: Status;
}
/**
 * AccessListMemberUpdate is emitted when an access list member is updated.
 *
 * @generated from protobuf message events.AccessListMemberUpdate
 */
export interface AccessListMemberUpdate {
    /**
     * Metadata is common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Resource is common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * AccessListMember is common access list member metadata.
     *
     * @generated from protobuf field: events.AccessListMemberMetadata AccessListMember = 3 [json_name = "AccessListMember"];
     */
    accessListMember?: AccessListMemberMetadata;
    /**
     * Status indicates whether the resource operation was successful.
     *
     * @generated from protobuf field: events.Status Status = 4 [json_name = "Status"];
     */
    status?: Status;
}
/**
 * AccessListMemberDelete is emitted when an access list member is deleted.
 *
 * @generated from protobuf message events.AccessListMemberDelete
 */
export interface AccessListMemberDelete {
    /**
     * Metadata is common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Resource is common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * AccessListMember is common access list member metadata.
     *
     * @generated from protobuf field: events.AccessListMemberMetadata AccessListMember = 3 [json_name = "AccessListMember"];
     */
    accessListMember?: AccessListMemberMetadata;
    /**
     * Status indicates whether the resource operation was successful.
     *
     * @generated from protobuf field: events.Status Status = 4 [json_name = "Status"];
     */
    status?: Status;
}
/**
 * AccessListMemberDeleteAllForAccessList is emitted when all members are deleted for an access list.
 *
 * @generated from protobuf message events.AccessListMemberDeleteAllForAccessList
 */
export interface AccessListMemberDeleteAllForAccessList {
    /**
     * Metadata is common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Resource is common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * AccessListMember is common access list member metadata.
     *
     * @generated from protobuf field: events.AccessListMemberMetadata AccessListMember = 3 [json_name = "AccessListMember"];
     */
    accessListMember?: AccessListMemberMetadata;
    /**
     * Status indicates whether the resource operation was successful.
     *
     * @generated from protobuf field: events.Status Status = 4 [json_name = "Status"];
     */
    status?: Status;
}
/**
 * AccessListReview is emitted when an access list is reviewed.
 *
 * @generated from protobuf message events.AccessListReview
 */
export interface AccessListReview {
    /**
     * Metadata is common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Resource is common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * Review is metadata for the access list review.
     *
     * @generated from protobuf field: events.AccessListReviewMetadata Review = 3 [json_name = "Review"];
     */
    review?: AccessListReviewMetadata;
    /**
     * Status indicates whether the review operation was successful.
     *
     * @generated from protobuf field: events.Status status = 4;
     */
    status?: Status;
}
/**
 * AuditQueryRun is emitted when a user runs an audit query.
 *
 * @generated from protobuf message events.AuditQueryRun
 */
export interface AuditQueryRun {
    /**
     * Metadata is common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * Status indicates whether the read was successful.
     *
     * @generated from protobuf field: events.Status Status = 3 [json_name = "Status"];
     */
    status?: Status;
    /**
     * Query contains additional query information.
     *
     * @generated from protobuf field: events.AuditQueryDetails Query = 4 [json_name = "Query"];
     */
    query?: AuditQueryDetails;
}
/**
 * AuditQueryDetails contains additional query information.
 *
 * @generated from protobuf message events.AuditQueryDetails
 */
export interface AuditQueryDetails {
    /**
     * Name is the name of the query.
     *
     * @generated from protobuf field: string Name = 1 [json_name = "Name"];
     */
    name: string;
    /**
     * Query is the query that was run.
     *
     * @generated from protobuf field: string Query = 2 [json_name = "Query"];
     */
    query: string;
    /**
     * Days is the number of days time range for the query.
     *
     * @generated from protobuf field: int32 Days = 3 [json_name = "Days"];
     */
    days: number;
    /**
     * ExecutionTimeInMillis is the total execution time of the query.
     *
     * @generated from protobuf field: int64 ExecutionTimeInMillis = 4 [json_name = "ExecutionTimeInMillis"];
     */
    executionTimeInMillis: bigint;
    /**
     * DataScannedInBytes is the amount of data scanned by the query.
     *
     * @generated from protobuf field: int64 DataScannedInBytes = 5 [json_name = "DataScannedInBytes"];
     */
    dataScannedInBytes: bigint;
}
/**
 * SecurityReportRun is emitted when a user runs an audit query.
 *
 * @generated from protobuf message events.SecurityReportRun
 */
export interface SecurityReportRun {
    /**
     * Metadata is common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * Status indicates whether the read was successful.
     *
     * @generated from protobuf field: events.Status Status = 3 [json_name = "Status"];
     */
    status?: Status;
    /**
     * Query is the query that was run.
     *
     * @generated from protobuf field: string Name = 4 [json_name = "Name"];
     */
    name: string;
    /**
     * Version is the version of security report.
     *
     * @generated from protobuf field: string Version = 5 [json_name = "Version"];
     */
    version: string;
    /**
     * TotalExecutionTimeInMillis is the total execution time of the query.
     *
     * @generated from protobuf field: int64 TotalExecutionTimeInMillis = 6 [json_name = "TotalExecutionTimeInMillis"];
     */
    totalExecutionTimeInMillis: bigint;
    /**
     * TotalDataScannedInBytes is the amount of data scanned by the query.
     *
     * @generated from protobuf field: int64 TotalDataScannedInBytes = 7 [json_name = "TotalDataScannedInBytes"];
     */
    totalDataScannedInBytes: bigint;
    /**
     * AuditQueries is the list of audit queries that were run.
     *
     * @generated from protobuf field: repeated events.AuditQueryDetails AuditQueries = 8 [json_name = "AuditQueries"];
     */
    auditQueries: AuditQueryDetails[];
}
/**
 * ExternalAuditStorageEnableEvent is emitted when External Audit Storage is
 * enabled.
 *
 * @generated from protobuf message events.ExternalAuditStorageEnable
 */
export interface ExternalAuditStorageEnable {
    /**
     * Metadata is common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Resource is common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * Details holds details about the External Audit Storage configuration that
     * was enabled.
     *
     * @generated from protobuf field: events.ExternalAuditStorageDetails details = 3;
     */
    details?: ExternalAuditStorageDetails;
}
/**
 * ExternalAuditStorageDisableEvent is emitted when External Audit Storage is
 * disabled.
 *
 * @generated from protobuf message events.ExternalAuditStorageDisable
 */
export interface ExternalAuditStorageDisable {
    /**
     * Metadata is common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Resource is common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * Details holds details about the External Audit Storage configuration that
     * was disabled.
     *
     * @generated from protobuf field: events.ExternalAuditStorageDetails details = 3;
     */
    details?: ExternalAuditStorageDetails;
}
/**
 * Details holds details about the External Audit Storage configuration.
 *
 * @generated from protobuf message events.ExternalAuditStorageDetails
 */
export interface ExternalAuditStorageDetails {
    /**
     * IntegrationName is the name of the AWS OIDC integration used.
     *
     * @generated from protobuf field: string integration_name = 3;
     */
    integrationName: string;
    /**
     * SessionsRecordingsURI is the S3 path used to store session recordings.
     *
     * @generated from protobuf field: string session_recordings_uri = 4;
     */
    sessionRecordingsUri: string;
    /**
     * AthenaWorkgroup is the workgroup used for Athena audit log queries.
     *
     * @generated from protobuf field: string athena_workgroup = 5;
     */
    athenaWorkgroup: string;
    /**
     * GlueDatabase is the database used for Athena audit log queries.
     *
     * @generated from protobuf field: string glue_database = 6;
     */
    glueDatabase: string;
    /**
     * GlueTable is the table used for Athena audit log queries.
     *
     * @generated from protobuf field: string glue_table = 7;
     */
    glueTable: string;
    /**
     * AuditEventsLongTermURI is the S3 path used to store batched parquet files
     * with audit events, partitioned by event date.
     *
     * @generated from protobuf field: string audit_events_long_term_uri = 8;
     */
    auditEventsLongTermUri: string;
    /**
     * AthenaResultsURI is the S3 path used to store temporary results generated
     * by Athena.
     *
     * @generated from protobuf field: string athena_results_uri = 9;
     */
    athenaResultsUri: string;
    /**
     * PolicyName is the name of the IAM policy attached to the OIDC integration
     * role.
     *
     * @generated from protobuf field: string policy_name = 10;
     */
    policyName: string;
    /**
     * Region is the AWS region where the infrastructure is hosted.
     *
     * @generated from protobuf field: string region = 11;
     */
    region: string;
}
/**
 * OktaAccessListSync records an access list sync event.
 *
 * @generated from protobuf message events.OktaAccessListSync
 */
export interface OktaAccessListSync {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Status contains common command or operation status fields.
     *
     * @generated from protobuf field: events.Status Status = 2 [json_name = "Status"];
     */
    status?: Status;
    /**
     * NumAppFilters is the number of application filters used for this sync.
     *
     * @generated from protobuf field: int32 num_app_filters = 3;
     */
    numAppFilters: number;
    /**
     * NumGroupFilters is the number of group filters used for this sync.
     *
     * @generated from protobuf field: int32 num_group_filters = 4;
     */
    numGroupFilters: number;
    /**
     * NumApps is the number of apps that were synchronized from this sync event.
     *
     * @generated from protobuf field: int32 num_apps = 5;
     */
    numApps: number;
    /**
     * NumGroups is the number of groups that were synchronized from this sync event.
     *
     * @generated from protobuf field: int32 num_groups = 6;
     */
    numGroups: number;
    /**
     * NumRoles are the number of roles that were created/updated.
     *
     * @generated from protobuf field: int32 numRoles = 7;
     */
    numRoles: number;
    /**
     * NumAccessLists are the number of access lists that were created/updated.
     *
     * @generated from protobuf field: int32 numAccessLists = 8;
     */
    numAccessLists: number;
    /**
     * NumAccessListMembers are the number of access list members that were created/updated.
     *
     * @generated from protobuf field: int32 numAccessListMembers = 9;
     */
    numAccessListMembers: number;
}
/**
 * OktaUserSync records an Okta user sync event.
 *
 * @generated from protobuf message events.OktaUserSync
 */
export interface OktaUserSync {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Status contains common command or operation status fields.
     *
     * @generated from protobuf field: events.Status Status = 2 [json_name = "Status"];
     */
    status?: Status;
    /**
     * OrgUrl is the URL of the Okta organization being synced to
     *
     * @generated from protobuf field: string org_url = 3;
     */
    orgUrl: string;
    /**
     * AppId is the optional ID of an Okta Application that Teleport is using as
     * its gateway into Okta. The list of potential Teleport users are drawn from
     * the list of Okta users assigned to this app - either directly or via a group
     * assignement. If not set, the Okta sync service is drawing its user list from
     * the whole organization.
     *
     * @generated from protobuf field: string app_id = 4;
     */
    appId: string;
    /**
     * NumUsersCreated is the number of Teleport users created in this
     * synchronization pass.
     *
     * @generated from protobuf field: int32 num_users_created = 5;
     */
    numUsersCreated: number;
    /**
     * NumUsersDeleted is the number of Teleport users deleted in this
     * synchronization pass.
     *
     * @generated from protobuf field: int32 num_users_deleted = 6;
     */
    numUsersDeleted: number;
    /**
     * NumUserModified is the number of Teleport users modified in this
     * synchronization pass.
     *
     * @generated from protobuf field: int32 num_users_modified = 7;
     */
    numUsersModified: number;
    /**
     * NumUsersTotal is the total number of Teleport users managed by the Okta
     * integration at the end of the synchronzaton pass.
     *
     * @generated from protobuf field: int32 num_users_total = 8;
     */
    numUsersTotal: number;
}
/**
 * SPIFFESVIDIssued is an event recorded when a SPIFFE SVID is issued.
 *
 * @generated from protobuf message events.SPIFFESVIDIssued
 */
export interface SPIFFESVIDIssued {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 3 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * SPIFFEID is the SPIFFE ID of the issued SVID
     *
     * @generated from protobuf field: string SPIFFEID = 4 [json_name = "SPIFFEID"];
     */
    sPIFFEID: string;
    /**
     * DNSSANs is the list of DNS SANs in the issued SVID
     *
     * @generated from protobuf field: repeated string DNSSANs = 5 [json_name = "DNSSANs"];
     */
    dNSSANs: string[];
    /**
     * IPSANs is the list of IP SANs in the issued SVID
     *
     * @generated from protobuf field: repeated string IPSANs = 6 [json_name = "IPSANs"];
     */
    iPSANs: string[];
    /**
     * SVIDType is `jwt` or `x509
     *
     * @generated from protobuf field: string SVIDType = 7 [json_name = "SVIDType"];
     */
    sVIDType: string;
    /**
     * SerialNumber is the serial number of the issued SVID
     *
     * @generated from protobuf field: string SerialNumber = 8 [json_name = "SerialNumber"];
     */
    serialNumber: string;
    /**
     * Hint is the hint of the issued SVID
     *
     * @generated from protobuf field: string Hint = 9 [json_name = "Hint"];
     */
    hint: string;
    /**
     * JTI is the JTI of the issued SVID.
     * Only present if the SVID is a JWT.
     *
     * @generated from protobuf field: string JTI = 10 [json_name = "JTI"];
     */
    jTI: string;
    /**
     * Audiences is the list of audiences in the issued SVID.
     * Only present if the SVID is a JWT.
     *
     * @generated from protobuf field: repeated string Audiences = 11 [json_name = "Audiences"];
     */
    audiences: string[];
    /**
     * The WorkloadIdentity resource that was used to issue the SVID, this will
     * be empty if the legacy RPCs were used.
     *
     * @generated from protobuf field: string WorkloadIdentity = 12 [json_name = "WorkloadIdentity"];
     */
    workloadIdentity: string;
    /**
     * The revision of the WorkloadIdentity resource that was used to issue the
     * SVID. This will be empty if the legacy RPCs were used.
     *
     * @generated from protobuf field: string WorkloadIdentityRevision = 13 [json_name = "WorkloadIdentityRevision"];
     */
    workloadIdentityRevision: string;
    /**
     * Attributes is the collection of data that was used to make the decision on
     * whether to issue the workload identity credential & to perform templating.
     *
     * @generated from protobuf field: google.protobuf.Struct Attributes = 14 [json_name = "Attributes"];
     */
    attributes?: Struct;
}
/**
 * AuthPreferenceUpdate is emitted when the auth preference is updated.
 *
 * @generated from protobuf message events.AuthPreferenceUpdate
 */
export interface AuthPreferenceUpdate {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Status indicates whether the update was successful.
     *
     * @generated from protobuf field: events.Status Status = 2 [json_name = "Status"];
     */
    status?: Status;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * AdminActionsMFA indicates whether MFA for admin actions was altered
     * while updating the authentication preference.
     *
     * @generated from protobuf field: events.AdminActionsMFAStatus AdminActionsMFA = 5 [json_name = "AdminActionsMFA"];
     */
    adminActionsMFA: AdminActionsMFAStatus;
}
/**
 * ClusterNetworkingConfigUpdate is emitted when the cluster networking config is updated.
 *
 * @generated from protobuf message events.ClusterNetworkingConfigUpdate
 */
export interface ClusterNetworkingConfigUpdate {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Status indicates whether the update was successful.
     *
     * @generated from protobuf field: events.Status Status = 2 [json_name = "Status"];
     */
    status?: Status;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
}
/**
 * SessionRecordingConfigUpdate is emitted when the session recording config is updated.
 *
 * @generated from protobuf message events.SessionRecordingConfigUpdate
 */
export interface SessionRecordingConfigUpdate {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Status indicates whether the update was successful.
     *
     * @generated from protobuf field: events.Status Status = 2 [json_name = "Status"];
     */
    status?: Status;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
}
/**
 * AccessPathChanged is emitted when access graph detects a change in a access path.
 *
 * @generated from protobuf message events.AccessPathChanged
 */
export interface AccessPathChanged {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ChangeID is the id of the change.
     *
     * @generated from protobuf field: string ChangeID = 2 [json_name = "ChangeID"];
     */
    changeID: string;
    /**
     * AffectedResourceID is the name of the affected resource.
     *
     * @generated from protobuf field: string AffectedResourceName = 3 [json_name = "AffectedResourceName"];
     */
    affectedResourceName: string;
    /**
     * AffectedResourceSource is the source of the affected resource, ex: Teleport, AWS, GitLab, etc.
     *
     * @generated from protobuf field: string AffectedResourceSource = 4 [json_name = "AffectedResourceSource"];
     */
    affectedResourceSource: string;
    /**
     * AffectedResourceType is the type of the affected resource, ex: user, role, etc.
     *
     * @generated from protobuf field: string AffectedResourceType = 5 [json_name = "AffectedResourceType"];
     */
    affectedResourceType: string;
}
/**
 * SpannerRPC is an event emitted when a Spanner client calls a Spanner RPC.
 *
 * @generated from protobuf message events.SpannerRPC
 */
export interface SpannerRPC {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * SessionMetadata is a common event session metadata.
     *
     * @generated from protobuf field: events.SessionMetadata Session = 3 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * Database contains database related metadata.
     *
     * @generated from protobuf field: events.DatabaseMetadata Database = 4 [json_name = "Database"];
     */
    database?: DatabaseMetadata;
    /**
     * Status indicates whether the RPC was successfully sent to the database.
     *
     * @generated from protobuf field: events.Status Status = 5 [json_name = "Status"];
     */
    status?: Status;
    /**
     * Procedure is the name of the remote procedure.
     *
     * @generated from protobuf field: string Procedure = 6 [json_name = "Procedure"];
     */
    procedure: string;
    /**
     * Args are the RPC arguments.
     *
     * @generated from protobuf field: google.protobuf.Struct Args = 7 [json_name = "Args"];
     */
    args?: Struct;
}
/**
 * AccessGraphSettingsUpdate is emitted when the Access Graph Settings config is updated.
 *
 * @generated from protobuf message events.AccessGraphSettingsUpdate
 */
export interface AccessGraphSettingsUpdate {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Status indicates whether the update was successful.
     *
     * @generated from protobuf field: events.Status Status = 2 [json_name = "Status"];
     */
    status?: Status;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
}
/**
 * SPIFFEFederationCreate is emitted when a SPIFFE federation is created.
 *
 * @generated from protobuf message events.SPIFFEFederationCreate
 */
export interface SPIFFEFederationCreate {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
}
/**
 * SPIFFEFederationDelete is emitted when a SPIFFE federation is deleted.
 *
 * @generated from protobuf message events.SPIFFEFederationDelete
 */
export interface SPIFFEFederationDelete {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
}
/**
 * AutoUpdateConfigCreate is emitted when an auto update config is created.
 *
 * @generated from protobuf message events.AutoUpdateConfigCreate
 */
export interface AutoUpdateConfigCreate {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * Status indicates whether the creation was successful.
     *
     * @generated from protobuf field: events.Status Status = 5 [json_name = "Status"];
     */
    status?: Status;
}
/**
 * AutoUpdateConfigUpdate is emitted when an auto update config is updated.
 *
 * @generated from protobuf message events.AutoUpdateConfigUpdate
 */
export interface AutoUpdateConfigUpdate {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Status indicates whether the update was successful.
     *
     * @generated from protobuf field: events.Status Status = 2 [json_name = "Status"];
     */
    status?: Status;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 5 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
}
/**
 * AutoUpdateConfigDelete is emitted when an auto update config is deleted.
 *
 * @generated from protobuf message events.AutoUpdateConfigDelete
 */
export interface AutoUpdateConfigDelete {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * Status indicates whether the deletion was successful.
     *
     * @generated from protobuf field: events.Status Status = 5 [json_name = "Status"];
     */
    status?: Status;
}
/**
 * AutoUpdateVersionCreate is emitted when an auto update version is created.
 *
 * @generated from protobuf message events.AutoUpdateVersionCreate
 */
export interface AutoUpdateVersionCreate {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * Status indicates whether the creation was successful.
     *
     * @generated from protobuf field: events.Status Status = 5 [json_name = "Status"];
     */
    status?: Status;
}
/**
 * AutoUpdateVersionUpdate is emitted when an auto update version is updated.
 *
 * @generated from protobuf message events.AutoUpdateVersionUpdate
 */
export interface AutoUpdateVersionUpdate {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Status indicates whether the update was successful.
     *
     * @generated from protobuf field: events.Status Status = 2 [json_name = "Status"];
     */
    status?: Status;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 5 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
}
/**
 * AutoUpdateVersionDelete is emitted when an auto update version is deleted.
 *
 * @generated from protobuf message events.AutoUpdateVersionDelete
 */
export interface AutoUpdateVersionDelete {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * Status indicates whether the deletion was successful.
     *
     * @generated from protobuf field: events.Status Status = 5 [json_name = "Status"];
     */
    status?: Status;
}
/**
 * AutoUpdateAgentRolloutTrigger is emitted when one or many groups from the auto update agent rollout are manually
 * triggered.
 *
 * @generated from protobuf message events.AutoUpdateAgentRolloutTrigger
 */
export interface AutoUpdateAgentRolloutTrigger {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 3 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * @generated from protobuf field: repeated string groups = 4;
     */
    groups: string[];
    /**
     * Status indicates whether the trigger was successful.
     *
     * @generated from protobuf field: events.Status Status = 5 [json_name = "Status"];
     */
    status?: Status;
}
/**
 * AutoUpdateAgentRolloutForceDone is emitted when one or many groups from the auto update agent rollout are manually
 * forced into the done state.
 *
 * @generated from protobuf message events.AutoUpdateAgentRolloutForceDone
 */
export interface AutoUpdateAgentRolloutForceDone {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 3 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * @generated from protobuf field: repeated string groups = 4;
     */
    groups: string[];
    /**
     * Status indicates whether the trigger was successful.
     *
     * @generated from protobuf field: events.Status Status = 5 [json_name = "Status"];
     */
    status?: Status;
}
/**
 * AutoUpdateAgentRolloutRollback is emitted when one or many groups from the auto update agent rollout are manually
 * rolledback.
 *
 * @generated from protobuf message events.AutoUpdateAgentRolloutRollback
 */
export interface AutoUpdateAgentRolloutRollback {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 3 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * @generated from protobuf field: repeated string groups = 4;
     */
    groups: string[];
    /**
     * Status indicates whether the trigger was successful.
     *
     * @generated from protobuf field: events.Status Status = 5 [json_name = "Status"];
     */
    status?: Status;
}
/**
 * StaticHostUserCreate is emitted when a static host user is created.
 *
 * @generated from protobuf message events.StaticHostUserCreate
 */
export interface StaticHostUserCreate {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Status indicates whether the creation was successful.
     *
     * @generated from protobuf field: events.Status Status = 2 [json_name = "Status"];
     */
    status?: Status;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 3 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 4 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 5 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
}
/**
 * StaticHostUserUpdate is emitted when a static host user is updated.
 *
 * @generated from protobuf message events.StaticHostUserUpdate
 */
export interface StaticHostUserUpdate {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Status indicates whether the update was successful.
     *
     * @generated from protobuf field: events.Status Status = 2 [json_name = "Status"];
     */
    status?: Status;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 3 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 4 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 5 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
}
/**
 * StaticHostUserDelete is emitted when a static host user is deleted.
 *
 * @generated from protobuf message events.StaticHostUserDelete
 */
export interface StaticHostUserDelete {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Status indicates whether the deletion was successful.
     *
     * @generated from protobuf field: events.Status Status = 2 [json_name = "Status"];
     */
    status?: Status;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 3 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 4 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 5 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
}
/**
 * CrownJewelCreate is emitted when a Access Graph CrownJewel is created.
 *
 * @generated from protobuf message events.CrownJewelCreate
 */
export interface CrownJewelCreate {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Status indicates whether the update was successful.
     *
     * @generated from protobuf field: events.Status Status = 2 [json_name = "Status"];
     */
    status?: Status;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * ResourceMetadata is a common resource event metadata.
     *
     * @generated from protobuf field: events.ResourceMetadata resource = 5;
     */
    resource?: ResourceMetadata;
    /**
     * CrownJewelQuery is the query used to track the crown jewel.
     *
     * @generated from protobuf field: string CrownJewelQuery = 6 [json_name = "CrownJewelQuery"];
     */
    crownJewelQuery: string;
}
/**
 * CrownJewelUpdate is emitted when a Access Graph CrownJewel is updated.
 *
 * @generated from protobuf message events.CrownJewelUpdate
 */
export interface CrownJewelUpdate {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Status indicates whether the update was successful.
     *
     * @generated from protobuf field: events.Status Status = 2 [json_name = "Status"];
     */
    status?: Status;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * ResourceMetadata is a common resource event metadata.
     *
     * @generated from protobuf field: events.ResourceMetadata resource = 5;
     */
    resource?: ResourceMetadata;
    /**
     * CurrentCrownJewelQuery is the current query used to track the crown jewel.
     *
     * @generated from protobuf field: string CurrentCrownJewelQuery = 6 [json_name = "CurrentCrownJewelQuery"];
     */
    currentCrownJewelQuery: string;
    /**
     * UpdatedCrownJewelQuery is the new query used to track the crown jewel.
     *
     * @generated from protobuf field: string UpdatedCrownJewelQuery = 7 [json_name = "UpdatedCrownJewelQuery"];
     */
    updatedCrownJewelQuery: string;
}
/**
 * CrownJewelDelete is emitted when a Access Graph CrownJewel is deleted.
 *
 * @generated from protobuf message events.CrownJewelDelete
 */
export interface CrownJewelDelete {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Status indicates whether the update was successful.
     *
     * @generated from protobuf field: events.Status Status = 2 [json_name = "Status"];
     */
    status?: Status;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * ResourceMetadata is a common resource event metadata.
     *
     * @generated from protobuf field: events.ResourceMetadata resource = 5;
     */
    resource?: ResourceMetadata;
}
/**
 * UserTaskCreate is emitted when a user task is created.
 *
 * @generated from protobuf message events.UserTaskCreate
 */
export interface UserTaskCreate {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Status indicates whether the update was successful.
     *
     * @generated from protobuf field: events.Status Status = 2 [json_name = "Status"];
     */
    status?: Status;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 3 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 4 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 5 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * UserTaskMetadata holds information about the user task.
     *
     * @generated from protobuf field: events.UserTaskMetadata UserTask = 6 [json_name = "UserTask"];
     */
    userTask?: UserTaskMetadata;
}
/**
 * UserTaskUpdate is emitted when a user task is updated.
 *
 * @generated from protobuf message events.UserTaskUpdate
 */
export interface UserTaskUpdate {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Status indicates whether the update was successful.
     *
     * @generated from protobuf field: events.Status Status = 2 [json_name = "Status"];
     */
    status?: Status;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 3 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 4 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection.
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 5 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * UserTaskMetadata holds information about the user task.
     *
     * @generated from protobuf field: events.UserTaskMetadata UserTask = 6 [json_name = "UserTask"];
     */
    userTask?: UserTaskMetadata;
    /**
     * CurrentUserTaskState is the current UserTask State.
     *
     * @generated from protobuf field: string CurrentUserTaskState = 7 [json_name = "CurrentUserTaskState"];
     */
    currentUserTaskState: string;
    /**
     * UpdatedUserTaskState is the updated UserTask State.
     *
     * @generated from protobuf field: string UpdatedUserTaskState = 8 [json_name = "UpdatedUserTaskState"];
     */
    updatedUserTaskState: string;
}
/**
 * UserTaskMetadata contains key fields for the UserTask.
 *
 * @generated from protobuf message events.UserTaskMetadata
 */
export interface UserTaskMetadata {
    /**
     * TaskType is type of the task.
     *
     * @generated from protobuf field: string TaskType = 1 [json_name = "TaskType"];
     */
    taskType: string;
    /**
     * IssueType is type of the issue task.
     *
     * @generated from protobuf field: string IssueType = 2 [json_name = "IssueType"];
     */
    issueType: string;
    /**
     * Integration is type of associated integration.
     *
     * @generated from protobuf field: string Integration = 3 [json_name = "Integration"];
     */
    integration: string;
}
/**
 * UserTaskDelete is emitted when a user task is deleted.
 *
 * @generated from protobuf message events.UserTaskDelete
 */
export interface UserTaskDelete {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Status indicates whether the update was successful.
     *
     * @generated from protobuf field: events.Status Status = 2 [json_name = "Status"];
     */
    status?: Status;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 3 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 4 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 5 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
}
/**
 * ContactCreate is emitted when a contact is created.
 *
 * @generated from protobuf message events.ContactCreate
 */
export interface ContactCreate {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * Status indicates whether the creation was successful.
     *
     * @generated from protobuf field: events.Status Status = 5 [json_name = "Status"];
     */
    status?: Status;
    /**
     * Email is the Email of the contact being deleted
     *
     * @generated from protobuf field: string Email = 6 [json_name = "Email"];
     */
    email: string;
    /**
     * ContactType is the type of the contact being deleted ('Business' or 'Security')
     *
     * @generated from protobuf field: events.ContactType ContactType = 7 [json_name = "ContactType"];
     */
    contactType: ContactType;
}
/**
 * ContactDelete is emitted when a contact is deleted.
 *
 * @generated from protobuf message events.ContactDelete
 */
export interface ContactDelete {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * Status indicates whether the deletion was successful.
     *
     * @generated from protobuf field: events.Status Status = 5 [json_name = "Status"];
     */
    status?: Status;
    /**
     * Email is the Email of the contact being deleted
     *
     * @generated from protobuf field: string Email = 6 [json_name = "Email"];
     */
    email: string;
    /**
     * ContactType is the type of the contact being deleted ('Business' or 'Security')
     *
     * @generated from protobuf field: events.ContactType ContactType = 7 [json_name = "ContactType"];
     */
    contactType: ContactType;
}
/**
 * WorkloadIdentityCreate is emitted when a WorkloadIdentity is created.
 *
 * @generated from protobuf message events.WorkloadIdentityCreate
 */
export interface WorkloadIdentityCreate {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * WorkloadIdentityData is a copy of the WorkloadIdentity resource
     *
     * @generated from protobuf field: google.protobuf.Struct WorkloadIdentityData = 5 [json_name = "WorkloadIdentityData"];
     */
    workloadIdentityData?: Struct;
}
/**
 * WorkloadIdentityUpdate is emitted when a WorkloadIdentity is updated.
 *
 * @generated from protobuf message events.WorkloadIdentityUpdate
 */
export interface WorkloadIdentityUpdate {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * WorkloadIdentityData is a copy of the WorkloadIdentity resource
     *
     * @generated from protobuf field: google.protobuf.Struct WorkloadIdentityData = 5 [json_name = "WorkloadIdentityData"];
     */
    workloadIdentityData?: Struct;
}
/**
 * WorkloadIdentityDelete is emitted when a WorkloadIdentity is deleted.
 *
 * @generated from protobuf message events.WorkloadIdentityDelete
 */
export interface WorkloadIdentityDelete {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
}
/**
 * WorkloadIdentityX509RevocationCreate is emitted when a
 * WorkloadIdentityX509Revocation is created.
 *
 * @generated from protobuf message events.WorkloadIdentityX509RevocationCreate
 */
export interface WorkloadIdentityX509RevocationCreate {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * Reason is the specified reason for the revocation.
     *
     * @generated from protobuf field: string Reason = 5 [json_name = "Reason"];
     */
    reason: string;
}
/**
 * WorkloadIdentityX509RevocationUpdate is emitted when a
 * WorkloadIdentityX509Revocation is updated.
 *
 * @generated from protobuf message events.WorkloadIdentityX509RevocationUpdate
 */
export interface WorkloadIdentityX509RevocationUpdate {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * Reason is the specified reason for the revocation.
     *
     * @generated from protobuf field: string Reason = 5 [json_name = "Reason"];
     */
    reason: string;
}
/**
 * WorkloadIdentityX509RevocationDelete is emitted when a
 * WorkloadIdentityX509Revocation is deleted.
 *
 * @generated from protobuf message events.WorkloadIdentityX509RevocationDelete
 */
export interface WorkloadIdentityX509RevocationDelete {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
}
/**
 * GitCommand is emitted when a user performs a Git fetch or push command.
 *
 * @generated from protobuf message events.GitCommand
 */
export interface GitCommand {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 3 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * SessionMetadata is a common event session metadata
     *
     * @generated from protobuf field: events.SessionMetadata Session = 4 [json_name = "Session"];
     */
    session?: SessionMetadata;
    /**
     * ServerMetadata is a common server metadata
     *
     * @generated from protobuf field: events.ServerMetadata Server = 5 [json_name = "Server"];
     */
    server?: ServerMetadata;
    /**
     * CommandMetadata is a common command metadata
     *
     * @generated from protobuf field: events.CommandMetadata Command = 6 [json_name = "Command"];
     */
    command?: CommandMetadata;
    /**
     * Service is the type of the git request like git-upload-pack or
     * git-receive-pack.
     *
     * @generated from protobuf field: string service = 8;
     */
    service: string;
    /**
     * Path is the Git repo path, usually <org>/<repo>.
     *
     * @generated from protobuf field: string path = 9;
     */
    path: string;
    /**
     * Actions defines details for a Git push.
     *
     * @generated from protobuf field: repeated events.GitCommandAction actions = 10;
     */
    actions: GitCommandAction[];
}
/**
 * GitCommandAction defines details for a Git push.
 *
 * @generated from protobuf message events.GitCommandAction
 */
export interface GitCommandAction {
    /**
     * Action type like create or update.
     *
     * @generated from protobuf field: string Action = 1 [json_name = "Action"];
     */
    action: string;
    /**
     * Reference name like ref/main/my_branch.
     *
     * @generated from protobuf field: string Reference = 2 [json_name = "Reference"];
     */
    reference: string;
    /**
     * Old is the old hash.
     *
     * @generated from protobuf field: string Old = 3 [json_name = "Old"];
     */
    old: string;
    /**
     * New is the new hash.
     *
     * @generated from protobuf field: string New = 4 [json_name = "New"];
     */
    new: string;
}
/**
 * AccessListInvalidMetadata contains metadata about invalid access lists.
 *
 * @generated from protobuf message events.AccessListInvalidMetadata
 */
export interface AccessListInvalidMetadata {
    /**
     * AccessListName is the name of the invalid access list.
     *
     * @generated from protobuf field: string AccessListName = 1 [json_name = "AccessListName"];
     */
    accessListName: string;
    /**
     * User is the username of the access list member who attempted to log in.
     *
     * @generated from protobuf field: string User = 2 [json_name = "User"];
     */
    user: string;
    /**
     * MissingRoles are the names of the non-existent roles being referenced by the access list, causing it to be invalid.
     *
     * @generated from protobuf field: repeated string MissingRoles = 3 [json_name = "MissingRoles"];
     */
    missingRoles: string[];
}
/**
 * UserLoginAccessListInvalid is emitted when a user who is a member of an invalid
 * access list logs in. It is used to indicate that the access list could not be
 * applied to the user's session.
 *
 * @generated from protobuf message events.UserLoginAccessListInvalid
 */
export interface UserLoginAccessListInvalid {
    /**
     * Metadata is common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * AccessListInvalidMetadata is the metadata for this access list invalid event.
     *
     * @generated from protobuf field: events.AccessListInvalidMetadata AccessListInvalidMetadata = 2 [json_name = "AccessListInvalidMetadata"];
     */
    accessListInvalidMetadata?: AccessListInvalidMetadata;
    /**
     * Status contains fields to indicate whether attempt was successful or not.
     *
     * @generated from protobuf field: events.Status Status = 3 [json_name = "Status"];
     */
    status?: Status;
}
/**
 * StableUNIXUserCreate is emitted whenever a new stable UNIX user is written in
 * the cluster state storage.
 *
 * @generated from protobuf message events.StableUNIXUserCreate
 */
export interface StableUNIXUserCreate {
    /**
     * Metadata is common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * @generated from protobuf field: events.StableUNIXUser stable_unix_user = 3;
     */
    stableUnixUser?: StableUNIXUser;
}
/**
 * @generated from protobuf message events.StableUNIXUser
 */
export interface StableUNIXUser {
    /**
     * @generated from protobuf field: string username = 1;
     */
    username: string;
    /**
     * @generated from protobuf field: int32 uid = 2;
     */
    uid: number;
}
/**
 * AWSICResourceSync is emitted when the AWS Identity Center integration
 * imports resources from Identity Center and reconciles them to Teleport.
 *
 * @generated from protobuf message events.AWSICResourceSync
 */
export interface AWSICResourceSync {
    /**
     * Metadata is the event metadata.
     *
     * @generated from protobuf field: events.Metadata metadata = 1;
     */
    metadata?: Metadata;
    /**
     * Total imported AWS accounts.
     *
     * @generated from protobuf field: int32 total_accounts = 2;
     */
    totalAccounts: number;
    /**
     * Total account assignments imported from Identity Center. Account assignments
     * are permissions assigned to users or groups.
     *
     * @generated from protobuf field: int32 total_account_assignments = 3;
     */
    totalAccountAssignments: number;
    /**
     * Total user groups imported from Identity Center.
     *
     * @generated from protobuf field: int32 total_user_groups = 4;
     */
    totalUserGroups: number;
    /**
     * Total permission sets imported from Identity Center.
     *
     * @generated from protobuf field: int32 total_permission_sets = 5;
     */
    totalPermissionSets: number;
    /**
     * Status is a resource sync status.
     *
     * @generated from protobuf field: events.Status Status = 6 [json_name = "Status"];
     */
    status?: Status;
}
/**
 * HealthCheckConfigCreate is emitted when a HealthCheckConfig is created.
 *
 * @generated from protobuf message events.HealthCheckConfigCreate
 */
export interface HealthCheckConfigCreate {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
}
/**
 * HealthCheckConfigUpdate is emitted when a HealthCheckConfig is updated.
 *
 * @generated from protobuf message events.HealthCheckConfigUpdate
 */
export interface HealthCheckConfigUpdate {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
}
/**
 * HealthCheckConfigDelete is emitted when a HealthCheckConfig is deleted.
 *
 * @generated from protobuf message events.HealthCheckConfigDelete
 */
export interface HealthCheckConfigDelete {
    /**
     * Metadata is a common event metadata
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * ResourceMetadata is a common resource event metadata
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 2 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
    /**
     * User is a common user event metadata
     *
     * @generated from protobuf field: events.UserMetadata User = 3 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 4 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
}
/**
 * @generated from protobuf message events.WorkloadIdentityX509IssuerOverrideCreate
 */
export interface WorkloadIdentityX509IssuerOverrideCreate {
    /**
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * @generated from protobuf field: events.ConnectionMetadata Connection = 3 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * @generated from protobuf field: events.ResourceMetadata Resource = 4 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
}
/**
 * @generated from protobuf message events.WorkloadIdentityX509IssuerOverrideDelete
 */
export interface WorkloadIdentityX509IssuerOverrideDelete {
    /**
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * @generated from protobuf field: events.ConnectionMetadata Connection = 3 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * @generated from protobuf field: events.ResourceMetadata Resource = 4 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
}
/**
 * SigstorePolicyCreate is emitted when a SigstorePolicy is created.
 *
 * @generated from protobuf message events.SigstorePolicyCreate
 */
export interface SigstorePolicyCreate {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection.
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 3 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * ResourceMetadata is a common resource event metadata.
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 4 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
}
/**
 * SigstorePolicyUpdate is emitted when a SigstorePolicy is updated.
 *
 * @generated from protobuf message events.SigstorePolicyUpdate
 */
export interface SigstorePolicyUpdate {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection.
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 3 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * ResourceMetadata is a common resource event metadata.
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 4 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
}
/**
 * SigstorePolicyDelete is emitted when a SigstorePolicy is deleted.
 *
 * @generated from protobuf message events.SigstorePolicyDelete
 */
export interface SigstorePolicyDelete {
    /**
     * Metadata is a common event metadata.
     *
     * @generated from protobuf field: events.Metadata Metadata = 1 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * User is a common user event metadata.
     *
     * @generated from protobuf field: events.UserMetadata User = 2 [json_name = "User"];
     */
    user?: UserMetadata;
    /**
     * ConnectionMetadata holds information about the connection.
     *
     * @generated from protobuf field: events.ConnectionMetadata Connection = 3 [json_name = "Connection"];
     */
    connection?: ConnectionMetadata;
    /**
     * ResourceMetadata is a common resource event metadata.
     *
     * @generated from protobuf field: events.ResourceMetadata Resource = 4 [json_name = "Resource"];
     */
    resource?: ResourceMetadata;
}
/**
 * The kind of user a given username refers to. Usernames should always refer to
 * a valid cluster user (even if temporary, e.g. SSO), but may be Machine ID
 * bot users.
 *
 * @generated from protobuf enum events.UserKind
 */
export enum UserKind {
    /**
     * Indicates a legacy cluster emitting events without a defined user kind.
     *
     * @generated from protobuf enum value: USER_KIND_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Indicates the user associated with this event is human, either created
     * locally or via SSO.
     *
     * @generated from protobuf enum value: USER_KIND_HUMAN = 1;
     */
    HUMAN = 1,
    /**
     * Indicates the user associated with this event is a Machine ID bot user.
     *
     * @generated from protobuf enum value: USER_KIND_BOT = 2;
     */
    BOT = 2
}
/**
 * UserOrigin is the origin of a user account.
 * Keep the values in sync with UserOrigin enum defined in
 * prehogv1 and prehogv1alpha.
 *
 * @generated from protobuf enum events.UserOrigin
 */
export enum UserOrigin {
    /**
     * Indicates a legacy cluster emitting events without a defined user origin.
     *
     * @generated from protobuf enum value: USER_ORIGIN_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Indicates a local user.
     *
     * @generated from protobuf enum value: USER_ORIGIN_LOCAL = 1;
     */
    LOCAL = 1,
    /**
     * Indicates an SSO user originated from the SAML or OIDC connector.
     *
     * @generated from protobuf enum value: USER_ORIGIN_SSO = 2;
     */
    SSO = 2,
    /**
     * Indicates a user originated from the Okta integration.
     *
     * @generated from protobuf enum value: USER_ORIGIN_OKTA = 3;
     */
    OKTA = 3,
    /**
     * Indicates a user originated from the SCIM integration.
     *
     * @generated from protobuf enum value: USER_ORIGIN_SCIM = 4;
     */
    SCIM = 4,
    /**
     * Indicates a user originated from the EntraID integration.
     *
     * @generated from protobuf enum value: USER_ORIGIN_ENTRAID = 5;
     */
    ENTRAID = 5
}
/**
 * Action communicates what was done in response to the event
 *
 * @generated from protobuf enum events.EventAction
 */
export enum EventAction {
    /**
     * @generated from protobuf enum value: OBSERVED = 0;
     */
    OBSERVED = 0,
    /**
     * @generated from protobuf enum value: DENIED = 1;
     */
    DENIED = 1
}
/**
 * SFTPAction denotes what type of SFTP request was made.
 * These actions were taken from https://datatracker.ietf.org/doc/html/draft-ietf-secsh-filexfer-02.
 *
 * @generated from protobuf enum events.SFTPAction
 */
export enum SFTPAction {
    /**
     * @generated from protobuf enum value: INVALID = 0;
     */
    INVALID = 0,
    /**
     * @generated from protobuf enum value: OPEN = 1;
     */
    OPEN = 1,
    /**
     * @generated from protobuf enum value: CLOSE = 2;
     */
    CLOSE = 2,
    /**
     * @generated from protobuf enum value: READ = 3;
     */
    READ = 3,
    /**
     * @generated from protobuf enum value: WRITE = 4;
     */
    WRITE = 4,
    /**
     * @generated from protobuf enum value: LSTAT = 5;
     */
    LSTAT = 5,
    /**
     * @generated from protobuf enum value: FSTAT = 6;
     */
    FSTAT = 6,
    /**
     * @generated from protobuf enum value: SETSTAT = 7;
     */
    SETSTAT = 7,
    /**
     * @generated from protobuf enum value: FSETSTAT = 8;
     */
    FSETSTAT = 8,
    /**
     * @generated from protobuf enum value: OPENDIR = 9;
     */
    OPENDIR = 9,
    /**
     * @generated from protobuf enum value: READDIR = 10;
     */
    READDIR = 10,
    /**
     * @generated from protobuf enum value: REMOVE = 11;
     */
    REMOVE = 11,
    /**
     * @generated from protobuf enum value: MKDIR = 12;
     */
    MKDIR = 12,
    /**
     * @generated from protobuf enum value: RMDIR = 13;
     */
    RMDIR = 13,
    /**
     * @generated from protobuf enum value: REALPATH = 14;
     */
    REALPATH = 14,
    /**
     * @generated from protobuf enum value: STAT = 15;
     */
    STAT = 15,
    /**
     * @generated from protobuf enum value: RENAME = 16;
     */
    RENAME = 16,
    /**
     * @generated from protobuf enum value: READLINK = 17;
     */
    READLINK = 17,
    /**
     * @generated from protobuf enum value: SYMLINK = 18;
     */
    SYMLINK = 18,
    /**
     * @generated from protobuf enum value: LINK = 19;
     */
    LINK = 19
}
/**
 * OSType is the same as teleport.devicetrust.v1.OSType.
 * Duplicated because gogo doesn't play well with protoc-gen-go.
 *
 * @generated from protobuf enum events.OSType
 */
export enum OSType {
    /**
     * @generated from protobuf enum value: OS_TYPE_UNSPECIFIED = 0;
     */
    OS_TYPE_UNSPECIFIED = 0,
    /**
     * Linux.
     *
     * @generated from protobuf enum value: OS_TYPE_LINUX = 1;
     */
    OS_TYPE_LINUX = 1,
    /**
     * macOS.
     *
     * @generated from protobuf enum value: OS_TYPE_MACOS = 2;
     */
    OS_TYPE_MACOS = 2,
    /**
     * Windows.
     *
     * @generated from protobuf enum value: OS_TYPE_WINDOWS = 3;
     */
    OS_TYPE_WINDOWS = 3
}
/**
 * DeviceOrigin is the same as teleport.devicetrust.v1.DeviceOrigin.
 * Duplicated because gogo doesn't play well with protoc-gen-go.
 *
 * @generated from protobuf enum events.DeviceOrigin
 */
export enum DeviceOrigin {
    /**
     * Unspecified or absent origin.
     *
     * @generated from protobuf enum value: DEVICE_ORIGIN_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Devices originated from direct API usage.
     *
     * @generated from protobuf enum value: DEVICE_ORIGIN_API = 1;
     */
    API = 1,
    /**
     * Devices originated from Jamf sync.
     *
     * @generated from protobuf enum value: DEVICE_ORIGIN_JAMF = 2;
     */
    JAMF = 2,
    /**
     * Source originated from Microsoft Intune sync.
     *
     * @generated from protobuf enum value: DEVICE_ORIGIN_INTUNE = 3;
     */
    INTUNE = 3
}
/**
 * ElasticsearchCategory specifies Elasticsearch request category.
 *
 * @generated from protobuf enum events.ElasticsearchCategory
 */
export enum ElasticsearchCategory {
    /**
     * ELASTICSEARCH_CATEGORY_GENERAL is for otherwise uncategorized calls.
     *
     * @generated from protobuf enum value: ELASTICSEARCH_CATEGORY_GENERAL = 0;
     */
    GENERAL = 0,
    /**
     * ELASTICSEARCH_CATEGORY_SECURITY is for _security and _ssl APIs.
     *
     * @generated from protobuf enum value: ELASTICSEARCH_CATEGORY_SECURITY = 1;
     */
    SECURITY = 1,
    /**
     * ELASTICSEARCH_CATEGORY_SEARCH is for search-related APIs.
     *
     * @generated from protobuf enum value: ELASTICSEARCH_CATEGORY_SEARCH = 2;
     */
    SEARCH = 2,
    /**
     * ELASTICSEARCH_CATEGORY_SQL covers _sql API.
     *
     * @generated from protobuf enum value: ELASTICSEARCH_CATEGORY_SQL = 3;
     */
    SQL = 3
}
/**
 * OpenSearchCategory specifies OpenSearch request category.
 *
 * @generated from protobuf enum events.OpenSearchCategory
 */
export enum OpenSearchCategory {
    /**
     * OPEN_SEARCH_CATEGORY_GENERAL is for otherwise uncategorized calls.
     *
     * @generated from protobuf enum value: OPEN_SEARCH_CATEGORY_GENERAL = 0;
     */
    GENERAL = 0,
    /**
     * OPEN_SEARCH_CATEGORY_SECURITY covers /_plugins/_security API.
     *
     * @generated from protobuf enum value: OPEN_SEARCH_CATEGORY_SECURITY = 1;
     */
    SECURITY = 1,
    /**
     * OPEN_SEARCH_CATEGORY_SEARCH is for search-related APIs.
     *
     * @generated from protobuf enum value: OPEN_SEARCH_CATEGORY_SEARCH = 2;
     */
    SEARCH = 2,
    /**
     * OPEN_SEARCH_CATEGORY_SQL covers /_plugins/_sql and /_plugins/_ppl API.
     *
     * @generated from protobuf enum value: OPEN_SEARCH_CATEGORY_SQL = 3;
     */
    SQL = 3
}
/**
 * @generated from protobuf enum events.AdminActionsMFAStatus
 */
export enum AdminActionsMFAStatus {
    /**
     * @generated from protobuf enum value: ADMIN_ACTIONS_MFA_STATUS_UNSPECIFIED = 0;
     */
    ADMIN_ACTIONS_MFA_STATUS_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: ADMIN_ACTIONS_MFA_STATUS_UNCHANGED = 1;
     */
    ADMIN_ACTIONS_MFA_STATUS_UNCHANGED = 1,
    /**
     * @generated from protobuf enum value: ADMIN_ACTIONS_MFA_STATUS_ENABLED = 2;
     */
    ADMIN_ACTIONS_MFA_STATUS_ENABLED = 2,
    /**
     * @generated from protobuf enum value: ADMIN_ACTIONS_MFA_STATUS_DISABLED = 3;
     */
    ADMIN_ACTIONS_MFA_STATUS_DISABLED = 3
}
/**
 * ContactType is the type of contact being added.
 *
 * @generated from protobuf enum events.ContactType
 */
export enum ContactType {
    /**
     * @generated from protobuf enum value: CONTACT_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: CONTACT_TYPE_BUSINESS = 1;
     */
    BUSINESS = 1,
    /**
     * @generated from protobuf enum value: CONTACT_TYPE_SECURITY = 2;
     */
    SECURITY = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class Metadata$Type extends MessageType<Metadata> {
    constructor() {
        super("events.Metadata", [
            { no: 1, name: "Index", kind: "scalar", jsonName: "Index", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "ei" } },
            { no: 2, name: "Type", kind: "scalar", jsonName: "Type", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "event" } },
            { no: 3, name: "ID", kind: "scalar", jsonName: "ID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "uid,omitempty" } },
            { no: 4, name: "Code", kind: "scalar", jsonName: "Code", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "code,omitempty" } },
            { no: 5, name: "Time", kind: "message", jsonName: "Time", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "time", "gogoproto.stdtime": true } },
            { no: 6, name: "ClusterName", kind: "scalar", jsonName: "ClusterName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "cluster_name,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<Metadata>): Metadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.index = 0n;
        message.type = "";
        message.iD = "";
        message.code = "";
        message.clusterName = "";
        if (value !== undefined)
            reflectionMergePartial<Metadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Metadata): Metadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 Index = 1 [json_name = "Index"];*/ 1:
                    message.index = reader.int64().toBigInt();
                    break;
                case /* string Type = 2 [json_name = "Type"];*/ 2:
                    message.type = reader.string();
                    break;
                case /* string ID = 3 [json_name = "ID"];*/ 3:
                    message.iD = reader.string();
                    break;
                case /* string Code = 4 [json_name = "Code"];*/ 4:
                    message.code = reader.string();
                    break;
                case /* google.protobuf.Timestamp Time = 5 [json_name = "Time"];*/ 5:
                    message.time = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.time);
                    break;
                case /* string ClusterName = 6 [json_name = "ClusterName"];*/ 6:
                    message.clusterName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Metadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 Index = 1 [json_name = "Index"]; */
        if (message.index !== 0n)
            writer.tag(1, WireType.Varint).int64(message.index);
        /* string Type = 2 [json_name = "Type"]; */
        if (message.type !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.type);
        /* string ID = 3 [json_name = "ID"]; */
        if (message.iD !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.iD);
        /* string Code = 4 [json_name = "Code"]; */
        if (message.code !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.code);
        /* google.protobuf.Timestamp Time = 5 [json_name = "Time"]; */
        if (message.time)
            Timestamp.internalBinaryWrite(message.time, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string ClusterName = 6 [json_name = "ClusterName"]; */
        if (message.clusterName !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.clusterName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.Metadata
 */
export const Metadata = new Metadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SessionMetadata$Type extends MessageType<SessionMetadata> {
    constructor() {
        super("events.SessionMetadata", [
            { no: 1, name: "SessionID", kind: "scalar", jsonName: "SessionID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sid" } },
            { no: 2, name: "WithMFA", kind: "scalar", jsonName: "WithMFA", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "with_mfa,omitempty" } },
            { no: 3, name: "PrivateKeyPolicy", kind: "scalar", jsonName: "PrivateKeyPolicy", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "private_key_policy,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<SessionMetadata>): SessionMetadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sessionID = "";
        message.withMFA = "";
        message.privateKeyPolicy = "";
        if (value !== undefined)
            reflectionMergePartial<SessionMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SessionMetadata): SessionMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string SessionID = 1 [json_name = "SessionID"];*/ 1:
                    message.sessionID = reader.string();
                    break;
                case /* string WithMFA = 2 [json_name = "WithMFA"];*/ 2:
                    message.withMFA = reader.string();
                    break;
                case /* string PrivateKeyPolicy = 3 [json_name = "PrivateKeyPolicy"];*/ 3:
                    message.privateKeyPolicy = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SessionMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string SessionID = 1 [json_name = "SessionID"]; */
        if (message.sessionID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sessionID);
        /* string WithMFA = 2 [json_name = "WithMFA"]; */
        if (message.withMFA !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.withMFA);
        /* string PrivateKeyPolicy = 3 [json_name = "PrivateKeyPolicy"]; */
        if (message.privateKeyPolicy !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.privateKeyPolicy);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.SessionMetadata
 */
export const SessionMetadata = new SessionMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserMetadata$Type extends MessageType<UserMetadata> {
    constructor() {
        super("events.UserMetadata", [
            { no: 1, name: "User", kind: "scalar", jsonName: "User", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "user,omitempty" } },
            { no: 2, name: "Login", kind: "scalar", jsonName: "Login", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "login,omitempty" } },
            { no: 3, name: "Impersonator", kind: "scalar", jsonName: "Impersonator", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "impersonator,omitempty" } },
            { no: 4, name: "AWSRoleARN", kind: "scalar", jsonName: "AWSRoleARN", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "aws_role_arn,omitempty" } },
            { no: 5, name: "AccessRequests", kind: "scalar", jsonName: "AccessRequests", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "access_requests,omitempty" } },
            { no: 6, name: "AzureIdentity", kind: "scalar", jsonName: "AzureIdentity", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "azure_identity,omitempty" } },
            { no: 7, name: "GCPServiceAccount", kind: "scalar", jsonName: "GCPServiceAccount", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "gcp_service_account,omitempty" } },
            { no: 8, name: "TrustedDevice", kind: "message", jsonName: "TrustedDevice", T: () => DeviceMetadata, options: { "gogoproto.jsontag": "trusted_device,omitempty" } },
            { no: 9, name: "RequiredPrivateKeyPolicy", kind: "scalar", jsonName: "RequiredPrivateKeyPolicy", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "required_private_key_policy,omitempty" } },
            { no: 10, name: "UserKind", kind: "enum", jsonName: "UserKind", T: () => ["events.UserKind", UserKind, "USER_KIND_"], options: { "gogoproto.jsontag": "user_kind,omitempty" } },
            { no: 11, name: "BotName", kind: "scalar", jsonName: "BotName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "bot_name,omitempty" } },
            { no: 12, name: "BotInstanceID", kind: "scalar", jsonName: "BotInstanceID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "bot_instance_id,omitempty" } },
            { no: 13, name: "UserOrigin", kind: "enum", jsonName: "UserOrigin", T: () => ["events.UserOrigin", UserOrigin, "USER_ORIGIN_"], options: { "gogoproto.jsontag": "user_origin,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<UserMetadata>): UserMetadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.user = "";
        message.login = "";
        message.impersonator = "";
        message.aWSRoleARN = "";
        message.accessRequests = [];
        message.azureIdentity = "";
        message.gCPServiceAccount = "";
        message.requiredPrivateKeyPolicy = "";
        message.userKind = 0;
        message.botName = "";
        message.botInstanceID = "";
        message.userOrigin = 0;
        if (value !== undefined)
            reflectionMergePartial<UserMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserMetadata): UserMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string User = 1 [json_name = "User"];*/ 1:
                    message.user = reader.string();
                    break;
                case /* string Login = 2 [json_name = "Login"];*/ 2:
                    message.login = reader.string();
                    break;
                case /* string Impersonator = 3 [json_name = "Impersonator"];*/ 3:
                    message.impersonator = reader.string();
                    break;
                case /* string AWSRoleARN = 4 [json_name = "AWSRoleARN"];*/ 4:
                    message.aWSRoleARN = reader.string();
                    break;
                case /* repeated string AccessRequests = 5 [json_name = "AccessRequests"];*/ 5:
                    message.accessRequests.push(reader.string());
                    break;
                case /* string AzureIdentity = 6 [json_name = "AzureIdentity"];*/ 6:
                    message.azureIdentity = reader.string();
                    break;
                case /* string GCPServiceAccount = 7 [json_name = "GCPServiceAccount"];*/ 7:
                    message.gCPServiceAccount = reader.string();
                    break;
                case /* events.DeviceMetadata TrustedDevice = 8 [json_name = "TrustedDevice"];*/ 8:
                    message.trustedDevice = DeviceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.trustedDevice);
                    break;
                case /* string RequiredPrivateKeyPolicy = 9 [json_name = "RequiredPrivateKeyPolicy"];*/ 9:
                    message.requiredPrivateKeyPolicy = reader.string();
                    break;
                case /* events.UserKind UserKind = 10 [json_name = "UserKind"];*/ 10:
                    message.userKind = reader.int32();
                    break;
                case /* string BotName = 11 [json_name = "BotName"];*/ 11:
                    message.botName = reader.string();
                    break;
                case /* string BotInstanceID = 12 [json_name = "BotInstanceID"];*/ 12:
                    message.botInstanceID = reader.string();
                    break;
                case /* events.UserOrigin UserOrigin = 13 [json_name = "UserOrigin"];*/ 13:
                    message.userOrigin = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string User = 1 [json_name = "User"]; */
        if (message.user !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.user);
        /* string Login = 2 [json_name = "Login"]; */
        if (message.login !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.login);
        /* string Impersonator = 3 [json_name = "Impersonator"]; */
        if (message.impersonator !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.impersonator);
        /* string AWSRoleARN = 4 [json_name = "AWSRoleARN"]; */
        if (message.aWSRoleARN !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.aWSRoleARN);
        /* repeated string AccessRequests = 5 [json_name = "AccessRequests"]; */
        for (let i = 0; i < message.accessRequests.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.accessRequests[i]);
        /* string AzureIdentity = 6 [json_name = "AzureIdentity"]; */
        if (message.azureIdentity !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.azureIdentity);
        /* string GCPServiceAccount = 7 [json_name = "GCPServiceAccount"]; */
        if (message.gCPServiceAccount !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.gCPServiceAccount);
        /* events.DeviceMetadata TrustedDevice = 8 [json_name = "TrustedDevice"]; */
        if (message.trustedDevice)
            DeviceMetadata.internalBinaryWrite(message.trustedDevice, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* string RequiredPrivateKeyPolicy = 9 [json_name = "RequiredPrivateKeyPolicy"]; */
        if (message.requiredPrivateKeyPolicy !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.requiredPrivateKeyPolicy);
        /* events.UserKind UserKind = 10 [json_name = "UserKind"]; */
        if (message.userKind !== 0)
            writer.tag(10, WireType.Varint).int32(message.userKind);
        /* string BotName = 11 [json_name = "BotName"]; */
        if (message.botName !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.botName);
        /* string BotInstanceID = 12 [json_name = "BotInstanceID"]; */
        if (message.botInstanceID !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.botInstanceID);
        /* events.UserOrigin UserOrigin = 13 [json_name = "UserOrigin"]; */
        if (message.userOrigin !== 0)
            writer.tag(13, WireType.Varint).int32(message.userOrigin);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.UserMetadata
 */
export const UserMetadata = new UserMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServerMetadata$Type extends MessageType<ServerMetadata> {
    constructor() {
        super("events.ServerMetadata", [
            { no: 1, name: "ServerNamespace", kind: "scalar", jsonName: "ServerNamespace", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "namespace,omitempty" } },
            { no: 2, name: "ServerID", kind: "scalar", jsonName: "ServerID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "server_id" } },
            { no: 3, name: "ServerHostname", kind: "scalar", jsonName: "ServerHostname", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "server_hostname,omitempty" } },
            { no: 4, name: "ServerAddr", kind: "scalar", jsonName: "ServerAddr", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "server_addr,omitempty" } },
            { no: 5, name: "ServerLabels", kind: "map", jsonName: "ServerLabels", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ }, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "server_labels,omitempty" } },
            { no: 6, name: "ForwardedBy", kind: "scalar", jsonName: "ForwardedBy", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "forwarded_by,omitempty" } },
            { no: 7, name: "ServerSubKind", kind: "scalar", jsonName: "ServerSubKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "server_sub_kind,omitempty" } },
            { no: 8, name: "ServerVersion", kind: "scalar", jsonName: "ServerVersion", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "server_version,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ServerMetadata>): ServerMetadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.serverNamespace = "";
        message.serverID = "";
        message.serverHostname = "";
        message.serverAddr = "";
        message.serverLabels = {};
        message.forwardedBy = "";
        message.serverSubKind = "";
        message.serverVersion = "";
        if (value !== undefined)
            reflectionMergePartial<ServerMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServerMetadata): ServerMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ServerNamespace = 1 [json_name = "ServerNamespace"];*/ 1:
                    message.serverNamespace = reader.string();
                    break;
                case /* string ServerID = 2 [json_name = "ServerID"];*/ 2:
                    message.serverID = reader.string();
                    break;
                case /* string ServerHostname = 3 [json_name = "ServerHostname"];*/ 3:
                    message.serverHostname = reader.string();
                    break;
                case /* string ServerAddr = 4 [json_name = "ServerAddr"];*/ 4:
                    message.serverAddr = reader.string();
                    break;
                case /* map<string, string> ServerLabels = 5 [json_name = "ServerLabels"];*/ 5:
                    this.binaryReadMap5(message.serverLabels, reader, options);
                    break;
                case /* string ForwardedBy = 6 [json_name = "ForwardedBy"];*/ 6:
                    message.forwardedBy = reader.string();
                    break;
                case /* string ServerSubKind = 7 [json_name = "ServerSubKind"];*/ 7:
                    message.serverSubKind = reader.string();
                    break;
                case /* string ServerVersion = 8 [json_name = "ServerVersion"];*/ 8:
                    message.serverVersion = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap5(map: ServerMetadata["serverLabels"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ServerMetadata["serverLabels"] | undefined, val: ServerMetadata["serverLabels"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field events.ServerMetadata.ServerLabels");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: ServerMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ServerNamespace = 1 [json_name = "ServerNamespace"]; */
        if (message.serverNamespace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.serverNamespace);
        /* string ServerID = 2 [json_name = "ServerID"]; */
        if (message.serverID !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.serverID);
        /* string ServerHostname = 3 [json_name = "ServerHostname"]; */
        if (message.serverHostname !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.serverHostname);
        /* string ServerAddr = 4 [json_name = "ServerAddr"]; */
        if (message.serverAddr !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.serverAddr);
        /* map<string, string> ServerLabels = 5 [json_name = "ServerLabels"]; */
        for (let k of globalThis.Object.keys(message.serverLabels))
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.serverLabels[k]).join();
        /* string ForwardedBy = 6 [json_name = "ForwardedBy"]; */
        if (message.forwardedBy !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.forwardedBy);
        /* string ServerSubKind = 7 [json_name = "ServerSubKind"]; */
        if (message.serverSubKind !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.serverSubKind);
        /* string ServerVersion = 8 [json_name = "ServerVersion"]; */
        if (message.serverVersion !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.serverVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.ServerMetadata
 */
export const ServerMetadata = new ServerMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConnectionMetadata$Type extends MessageType<ConnectionMetadata> {
    constructor() {
        super("events.ConnectionMetadata", [
            { no: 1, name: "LocalAddr", kind: "scalar", jsonName: "LocalAddr", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "addr.local,omitempty" } },
            { no: 2, name: "RemoteAddr", kind: "scalar", jsonName: "RemoteAddr", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "addr.remote,omitempty" } },
            { no: 3, name: "Protocol", kind: "scalar", jsonName: "Protocol", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "proto,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ConnectionMetadata>): ConnectionMetadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.localAddr = "";
        message.remoteAddr = "";
        message.protocol = "";
        if (value !== undefined)
            reflectionMergePartial<ConnectionMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConnectionMetadata): ConnectionMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string LocalAddr = 1 [json_name = "LocalAddr"];*/ 1:
                    message.localAddr = reader.string();
                    break;
                case /* string RemoteAddr = 2 [json_name = "RemoteAddr"];*/ 2:
                    message.remoteAddr = reader.string();
                    break;
                case /* string Protocol = 3 [json_name = "Protocol"];*/ 3:
                    message.protocol = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConnectionMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string LocalAddr = 1 [json_name = "LocalAddr"]; */
        if (message.localAddr !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.localAddr);
        /* string RemoteAddr = 2 [json_name = "RemoteAddr"]; */
        if (message.remoteAddr !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.remoteAddr);
        /* string Protocol = 3 [json_name = "Protocol"]; */
        if (message.protocol !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.protocol);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.ConnectionMetadata
 */
export const ConnectionMetadata = new ConnectionMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClientMetadata$Type extends MessageType<ClientMetadata> {
    constructor() {
        super("events.ClientMetadata", [
            { no: 1, name: "UserAgent", kind: "scalar", jsonName: "UserAgent", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "user_agent,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ClientMetadata>): ClientMetadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userAgent = "";
        if (value !== undefined)
            reflectionMergePartial<ClientMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClientMetadata): ClientMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string UserAgent = 1 [json_name = "UserAgent"];*/ 1:
                    message.userAgent = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClientMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string UserAgent = 1 [json_name = "UserAgent"]; */
        if (message.userAgent !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userAgent);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.ClientMetadata
 */
export const ClientMetadata = new ClientMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class KubernetesClusterMetadata$Type extends MessageType<KubernetesClusterMetadata> {
    constructor() {
        super("events.KubernetesClusterMetadata", [
            { no: 1, name: "KubernetesCluster", kind: "scalar", jsonName: "KubernetesCluster", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kubernetes_cluster,omitempty" } },
            { no: 2, name: "KubernetesUsers", kind: "scalar", jsonName: "KubernetesUsers", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kubernetes_users,omitempty" } },
            { no: 3, name: "KubernetesGroups", kind: "scalar", jsonName: "KubernetesGroups", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kubernetes_groups,omitempty" } },
            { no: 4, name: "KubernetesLabels", kind: "map", jsonName: "KubernetesLabels", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ }, options: { "gogoproto.jsontag": "kubernetes_labels,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<KubernetesClusterMetadata>): KubernetesClusterMetadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kubernetesCluster = "";
        message.kubernetesUsers = [];
        message.kubernetesGroups = [];
        message.kubernetesLabels = {};
        if (value !== undefined)
            reflectionMergePartial<KubernetesClusterMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KubernetesClusterMetadata): KubernetesClusterMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string KubernetesCluster = 1 [json_name = "KubernetesCluster"];*/ 1:
                    message.kubernetesCluster = reader.string();
                    break;
                case /* repeated string KubernetesUsers = 2 [json_name = "KubernetesUsers"];*/ 2:
                    message.kubernetesUsers.push(reader.string());
                    break;
                case /* repeated string KubernetesGroups = 3 [json_name = "KubernetesGroups"];*/ 3:
                    message.kubernetesGroups.push(reader.string());
                    break;
                case /* map<string, string> KubernetesLabels = 4 [json_name = "KubernetesLabels"];*/ 4:
                    this.binaryReadMap4(message.kubernetesLabels, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap4(map: KubernetesClusterMetadata["kubernetesLabels"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof KubernetesClusterMetadata["kubernetesLabels"] | undefined, val: KubernetesClusterMetadata["kubernetesLabels"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field events.KubernetesClusterMetadata.KubernetesLabels");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: KubernetesClusterMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string KubernetesCluster = 1 [json_name = "KubernetesCluster"]; */
        if (message.kubernetesCluster !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kubernetesCluster);
        /* repeated string KubernetesUsers = 2 [json_name = "KubernetesUsers"]; */
        for (let i = 0; i < message.kubernetesUsers.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.kubernetesUsers[i]);
        /* repeated string KubernetesGroups = 3 [json_name = "KubernetesGroups"]; */
        for (let i = 0; i < message.kubernetesGroups.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.kubernetesGroups[i]);
        /* map<string, string> KubernetesLabels = 4 [json_name = "KubernetesLabels"]; */
        for (let k of globalThis.Object.keys(message.kubernetesLabels))
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.kubernetesLabels[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.KubernetesClusterMetadata
 */
export const KubernetesClusterMetadata = new KubernetesClusterMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class KubernetesPodMetadata$Type extends MessageType<KubernetesPodMetadata> {
    constructor() {
        super("events.KubernetesPodMetadata", [
            { no: 1, name: "KubernetesPodName", kind: "scalar", jsonName: "KubernetesPodName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kubernetes_pod_name,omitempty" } },
            { no: 2, name: "KubernetesPodNamespace", kind: "scalar", jsonName: "KubernetesPodNamespace", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kubernetes_pod_namespace,omitempty" } },
            { no: 3, name: "KubernetesContainerName", kind: "scalar", jsonName: "KubernetesContainerName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kubernetes_container_name,omitempty" } },
            { no: 4, name: "KubernetesContainerImage", kind: "scalar", jsonName: "KubernetesContainerImage", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kubernetes_container_image,omitempty" } },
            { no: 5, name: "KubernetesNodeName", kind: "scalar", jsonName: "KubernetesNodeName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kubernetes_node_name,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<KubernetesPodMetadata>): KubernetesPodMetadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kubernetesPodName = "";
        message.kubernetesPodNamespace = "";
        message.kubernetesContainerName = "";
        message.kubernetesContainerImage = "";
        message.kubernetesNodeName = "";
        if (value !== undefined)
            reflectionMergePartial<KubernetesPodMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KubernetesPodMetadata): KubernetesPodMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string KubernetesPodName = 1 [json_name = "KubernetesPodName"];*/ 1:
                    message.kubernetesPodName = reader.string();
                    break;
                case /* string KubernetesPodNamespace = 2 [json_name = "KubernetesPodNamespace"];*/ 2:
                    message.kubernetesPodNamespace = reader.string();
                    break;
                case /* string KubernetesContainerName = 3 [json_name = "KubernetesContainerName"];*/ 3:
                    message.kubernetesContainerName = reader.string();
                    break;
                case /* string KubernetesContainerImage = 4 [json_name = "KubernetesContainerImage"];*/ 4:
                    message.kubernetesContainerImage = reader.string();
                    break;
                case /* string KubernetesNodeName = 5 [json_name = "KubernetesNodeName"];*/ 5:
                    message.kubernetesNodeName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: KubernetesPodMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string KubernetesPodName = 1 [json_name = "KubernetesPodName"]; */
        if (message.kubernetesPodName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kubernetesPodName);
        /* string KubernetesPodNamespace = 2 [json_name = "KubernetesPodNamespace"]; */
        if (message.kubernetesPodNamespace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.kubernetesPodNamespace);
        /* string KubernetesContainerName = 3 [json_name = "KubernetesContainerName"]; */
        if (message.kubernetesContainerName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.kubernetesContainerName);
        /* string KubernetesContainerImage = 4 [json_name = "KubernetesContainerImage"]; */
        if (message.kubernetesContainerImage !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.kubernetesContainerImage);
        /* string KubernetesNodeName = 5 [json_name = "KubernetesNodeName"]; */
        if (message.kubernetesNodeName !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.kubernetesNodeName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.KubernetesPodMetadata
 */
export const KubernetesPodMetadata = new KubernetesPodMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SAMLIdPServiceProviderMetadata$Type extends MessageType<SAMLIdPServiceProviderMetadata> {
    constructor() {
        super("events.SAMLIdPServiceProviderMetadata", [
            { no: 1, name: "ServiceProviderEntityID", kind: "scalar", jsonName: "ServiceProviderEntityID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "service_provider_entity_id,omitempty" } },
            { no: 2, name: "ServiceProviderShortcut", kind: "scalar", jsonName: "ServiceProviderShortcut", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "service_provider_shortcut,omitempty" } },
            { no: 3, name: "AttributeMapping", kind: "map", jsonName: "AttributeMapping", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ }, options: { "gogoproto.jsontag": "attribute_mapping,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<SAMLIdPServiceProviderMetadata>): SAMLIdPServiceProviderMetadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.serviceProviderEntityID = "";
        message.serviceProviderShortcut = "";
        message.attributeMapping = {};
        if (value !== undefined)
            reflectionMergePartial<SAMLIdPServiceProviderMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SAMLIdPServiceProviderMetadata): SAMLIdPServiceProviderMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ServiceProviderEntityID = 1 [json_name = "ServiceProviderEntityID"];*/ 1:
                    message.serviceProviderEntityID = reader.string();
                    break;
                case /* string ServiceProviderShortcut = 2 [json_name = "ServiceProviderShortcut"];*/ 2:
                    message.serviceProviderShortcut = reader.string();
                    break;
                case /* map<string, string> AttributeMapping = 3 [json_name = "AttributeMapping"];*/ 3:
                    this.binaryReadMap3(message.attributeMapping, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: SAMLIdPServiceProviderMetadata["attributeMapping"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof SAMLIdPServiceProviderMetadata["attributeMapping"] | undefined, val: SAMLIdPServiceProviderMetadata["attributeMapping"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field events.SAMLIdPServiceProviderMetadata.AttributeMapping");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: SAMLIdPServiceProviderMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ServiceProviderEntityID = 1 [json_name = "ServiceProviderEntityID"]; */
        if (message.serviceProviderEntityID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.serviceProviderEntityID);
        /* string ServiceProviderShortcut = 2 [json_name = "ServiceProviderShortcut"]; */
        if (message.serviceProviderShortcut !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.serviceProviderShortcut);
        /* map<string, string> AttributeMapping = 3 [json_name = "AttributeMapping"]; */
        for (let k of globalThis.Object.keys(message.attributeMapping))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.attributeMapping[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.SAMLIdPServiceProviderMetadata
 */
export const SAMLIdPServiceProviderMetadata = new SAMLIdPServiceProviderMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OktaResourcesUpdatedMetadata$Type extends MessageType<OktaResourcesUpdatedMetadata> {
    constructor() {
        super("events.OktaResourcesUpdatedMetadata", [
            { no: 1, name: "Added", kind: "scalar", jsonName: "Added", T: 5 /*ScalarType.INT32*/, options: { "gogoproto.jsontag": "added" } },
            { no: 2, name: "Updated", kind: "scalar", jsonName: "Updated", T: 5 /*ScalarType.INT32*/, options: { "gogoproto.jsontag": "updated" } },
            { no: 3, name: "Deleted", kind: "scalar", jsonName: "Deleted", T: 5 /*ScalarType.INT32*/, options: { "gogoproto.jsontag": "deleted" } },
            { no: 4, name: "AddedResources", kind: "message", jsonName: "AddedResources", repeat: 1 /*RepeatType.PACKED*/, T: () => OktaResource, options: { "gogoproto.jsontag": "added_resources" } },
            { no: 5, name: "UpdatedResources", kind: "message", jsonName: "UpdatedResources", repeat: 1 /*RepeatType.PACKED*/, T: () => OktaResource, options: { "gogoproto.jsontag": "updated_resources" } },
            { no: 6, name: "DeletedResources", kind: "message", jsonName: "DeletedResources", repeat: 1 /*RepeatType.PACKED*/, T: () => OktaResource, options: { "gogoproto.jsontag": "deleted_resources" } }
        ]);
    }
    create(value?: PartialMessage<OktaResourcesUpdatedMetadata>): OktaResourcesUpdatedMetadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.added = 0;
        message.updated = 0;
        message.deleted = 0;
        message.addedResources = [];
        message.updatedResources = [];
        message.deletedResources = [];
        if (value !== undefined)
            reflectionMergePartial<OktaResourcesUpdatedMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OktaResourcesUpdatedMetadata): OktaResourcesUpdatedMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 Added = 1 [json_name = "Added"];*/ 1:
                    message.added = reader.int32();
                    break;
                case /* int32 Updated = 2 [json_name = "Updated"];*/ 2:
                    message.updated = reader.int32();
                    break;
                case /* int32 Deleted = 3 [json_name = "Deleted"];*/ 3:
                    message.deleted = reader.int32();
                    break;
                case /* repeated events.OktaResource AddedResources = 4 [json_name = "AddedResources"];*/ 4:
                    message.addedResources.push(OktaResource.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated events.OktaResource UpdatedResources = 5 [json_name = "UpdatedResources"];*/ 5:
                    message.updatedResources.push(OktaResource.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated events.OktaResource DeletedResources = 6 [json_name = "DeletedResources"];*/ 6:
                    message.deletedResources.push(OktaResource.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OktaResourcesUpdatedMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 Added = 1 [json_name = "Added"]; */
        if (message.added !== 0)
            writer.tag(1, WireType.Varint).int32(message.added);
        /* int32 Updated = 2 [json_name = "Updated"]; */
        if (message.updated !== 0)
            writer.tag(2, WireType.Varint).int32(message.updated);
        /* int32 Deleted = 3 [json_name = "Deleted"]; */
        if (message.deleted !== 0)
            writer.tag(3, WireType.Varint).int32(message.deleted);
        /* repeated events.OktaResource AddedResources = 4 [json_name = "AddedResources"]; */
        for (let i = 0; i < message.addedResources.length; i++)
            OktaResource.internalBinaryWrite(message.addedResources[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated events.OktaResource UpdatedResources = 5 [json_name = "UpdatedResources"]; */
        for (let i = 0; i < message.updatedResources.length; i++)
            OktaResource.internalBinaryWrite(message.updatedResources[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated events.OktaResource DeletedResources = 6 [json_name = "DeletedResources"]; */
        for (let i = 0; i < message.deletedResources.length; i++)
            OktaResource.internalBinaryWrite(message.deletedResources[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.OktaResourcesUpdatedMetadata
 */
export const OktaResourcesUpdatedMetadata = new OktaResourcesUpdatedMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OktaResource$Type extends MessageType<OktaResource> {
    constructor() {
        super("events.OktaResource", [
            { no: 1, name: "ID", kind: "scalar", jsonName: "ID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "id" } },
            { no: 2, name: "Description", kind: "scalar", jsonName: "Description", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "description" } }
        ]);
    }
    create(value?: PartialMessage<OktaResource>): OktaResource {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.iD = "";
        message.description = "";
        if (value !== undefined)
            reflectionMergePartial<OktaResource>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OktaResource): OktaResource {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ID = 1 [json_name = "ID"];*/ 1:
                    message.iD = reader.string();
                    break;
                case /* string Description = 2 [json_name = "Description"];*/ 2:
                    message.description = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OktaResource, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ID = 1 [json_name = "ID"]; */
        if (message.iD !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.iD);
        /* string Description = 2 [json_name = "Description"]; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.OktaResource
 */
export const OktaResource = new OktaResource$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OktaAssignmentMetadata$Type extends MessageType<OktaAssignmentMetadata> {
    constructor() {
        super("events.OktaAssignmentMetadata", [
            { no: 1, name: "Source", kind: "scalar", jsonName: "Source", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "source,omitempty" } },
            { no: 2, name: "User", kind: "scalar", jsonName: "User", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "user,omitempty" } },
            { no: 3, name: "StartingStatus", kind: "scalar", jsonName: "StartingStatus", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "starting_status,omitempty" } },
            { no: 4, name: "EndingStatus", kind: "scalar", jsonName: "EndingStatus", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "ending_status,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<OktaAssignmentMetadata>): OktaAssignmentMetadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.source = "";
        message.user = "";
        message.startingStatus = "";
        message.endingStatus = "";
        if (value !== undefined)
            reflectionMergePartial<OktaAssignmentMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OktaAssignmentMetadata): OktaAssignmentMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Source = 1 [json_name = "Source"];*/ 1:
                    message.source = reader.string();
                    break;
                case /* string User = 2 [json_name = "User"];*/ 2:
                    message.user = reader.string();
                    break;
                case /* string StartingStatus = 3 [json_name = "StartingStatus"];*/ 3:
                    message.startingStatus = reader.string();
                    break;
                case /* string EndingStatus = 4 [json_name = "EndingStatus"];*/ 4:
                    message.endingStatus = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OktaAssignmentMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Source = 1 [json_name = "Source"]; */
        if (message.source !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.source);
        /* string User = 2 [json_name = "User"]; */
        if (message.user !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.user);
        /* string StartingStatus = 3 [json_name = "StartingStatus"]; */
        if (message.startingStatus !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.startingStatus);
        /* string EndingStatus = 4 [json_name = "EndingStatus"]; */
        if (message.endingStatus !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.endingStatus);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.OktaAssignmentMetadata
 */
export const OktaAssignmentMetadata = new OktaAssignmentMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessListMemberMetadata$Type extends MessageType<AccessListMemberMetadata> {
    constructor() {
        super("events.AccessListMemberMetadata", [
            { no: 1, name: "AccessListName", kind: "scalar", jsonName: "AccessListName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "access_list_name,omitempty" } },
            { no: 2, name: "Members", kind: "message", jsonName: "Members", repeat: 1 /*RepeatType.PACKED*/, T: () => AccessListMember, options: { "gogoproto.jsontag": "members,omitempty" } },
            { no: 4, name: "AccessListTitle", kind: "scalar", jsonName: "AccessListTitle", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "access_list_title,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<AccessListMemberMetadata>): AccessListMemberMetadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accessListName = "";
        message.members = [];
        message.accessListTitle = "";
        if (value !== undefined)
            reflectionMergePartial<AccessListMemberMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessListMemberMetadata): AccessListMemberMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string AccessListName = 1 [json_name = "AccessListName"];*/ 1:
                    message.accessListName = reader.string();
                    break;
                case /* repeated events.AccessListMember Members = 2 [json_name = "Members"];*/ 2:
                    message.members.push(AccessListMember.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string AccessListTitle = 4 [json_name = "AccessListTitle"];*/ 4:
                    message.accessListTitle = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessListMemberMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string AccessListName = 1 [json_name = "AccessListName"]; */
        if (message.accessListName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accessListName);
        /* repeated events.AccessListMember Members = 2 [json_name = "Members"]; */
        for (let i = 0; i < message.members.length; i++)
            AccessListMember.internalBinaryWrite(message.members[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string AccessListTitle = 4 [json_name = "AccessListTitle"]; */
        if (message.accessListTitle !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.accessListTitle);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.AccessListMemberMetadata
 */
export const AccessListMemberMetadata = new AccessListMemberMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessListMember$Type extends MessageType<AccessListMember> {
    constructor() {
        super("events.AccessListMember", [
            { no: 1, name: "JoinedOn", kind: "message", jsonName: "JoinedOn", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "joined_on,omitempty", "gogoproto.stdtime": true } },
            { no: 2, name: "RemovedOn", kind: "message", jsonName: "RemovedOn", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "removed_on,omitempty", "gogoproto.stdtime": true } },
            { no: 3, name: "Reason", kind: "scalar", jsonName: "Reason", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "reason,omitempty" } },
            { no: 4, name: "MemberName", kind: "scalar", jsonName: "MemberName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "member_name,omitempty" } },
            { no: 5, name: "membership_kind", kind: "enum", T: () => ["teleport.accesslist.v1.MembershipKind", MembershipKind, "MEMBERSHIP_KIND_"], options: { "gogoproto.jsontag": "membership_kind,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<AccessListMember>): AccessListMember {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.reason = "";
        message.memberName = "";
        message.membershipKind = 0;
        if (value !== undefined)
            reflectionMergePartial<AccessListMember>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessListMember): AccessListMember {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Timestamp JoinedOn = 1 [json_name = "JoinedOn"];*/ 1:
                    message.joinedOn = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.joinedOn);
                    break;
                case /* google.protobuf.Timestamp RemovedOn = 2 [json_name = "RemovedOn"];*/ 2:
                    message.removedOn = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.removedOn);
                    break;
                case /* string Reason = 3 [json_name = "Reason"];*/ 3:
                    message.reason = reader.string();
                    break;
                case /* string MemberName = 4 [json_name = "MemberName"];*/ 4:
                    message.memberName = reader.string();
                    break;
                case /* teleport.accesslist.v1.MembershipKind membership_kind */ 5:
                    message.membershipKind = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessListMember, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Timestamp JoinedOn = 1 [json_name = "JoinedOn"]; */
        if (message.joinedOn)
            Timestamp.internalBinaryWrite(message.joinedOn, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp RemovedOn = 2 [json_name = "RemovedOn"]; */
        if (message.removedOn)
            Timestamp.internalBinaryWrite(message.removedOn, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string Reason = 3 [json_name = "Reason"]; */
        if (message.reason !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.reason);
        /* string MemberName = 4 [json_name = "MemberName"]; */
        if (message.memberName !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.memberName);
        /* teleport.accesslist.v1.MembershipKind membership_kind = 5; */
        if (message.membershipKind !== 0)
            writer.tag(5, WireType.Varint).int32(message.membershipKind);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.AccessListMember
 */
export const AccessListMember = new AccessListMember$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessListReviewMembershipRequirementsChanged$Type extends MessageType<AccessListReviewMembershipRequirementsChanged> {
    constructor() {
        super("events.AccessListReviewMembershipRequirementsChanged", [
            { no: 1, name: "Roles", kind: "scalar", jsonName: "Roles", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "roles,omitempty" } },
            { no: 2, name: "Traits", kind: "map", jsonName: "Traits", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ }, options: { "gogoproto.jsontag": "traits,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<AccessListReviewMembershipRequirementsChanged>): AccessListReviewMembershipRequirementsChanged {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.roles = [];
        message.traits = {};
        if (value !== undefined)
            reflectionMergePartial<AccessListReviewMembershipRequirementsChanged>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessListReviewMembershipRequirementsChanged): AccessListReviewMembershipRequirementsChanged {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string Roles = 1 [json_name = "Roles"];*/ 1:
                    message.roles.push(reader.string());
                    break;
                case /* map<string, string> Traits = 2 [json_name = "Traits"];*/ 2:
                    this.binaryReadMap2(message.traits, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: AccessListReviewMembershipRequirementsChanged["traits"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AccessListReviewMembershipRequirementsChanged["traits"] | undefined, val: AccessListReviewMembershipRequirementsChanged["traits"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field events.AccessListReviewMembershipRequirementsChanged.Traits");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: AccessListReviewMembershipRequirementsChanged, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string Roles = 1 [json_name = "Roles"]; */
        for (let i = 0; i < message.roles.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.roles[i]);
        /* map<string, string> Traits = 2 [json_name = "Traits"]; */
        for (let k of globalThis.Object.keys(message.traits))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.traits[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.AccessListReviewMembershipRequirementsChanged
 */
export const AccessListReviewMembershipRequirementsChanged = new AccessListReviewMembershipRequirementsChanged$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessListReviewMetadata$Type extends MessageType<AccessListReviewMetadata> {
    constructor() {
        super("events.AccessListReviewMetadata", [
            { no: 1, name: "Message", kind: "scalar", jsonName: "Message", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "message,omitempty" } },
            { no: 2, name: "ReviewID", kind: "scalar", jsonName: "ReviewID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "review_id,omitempty" } },
            { no: 3, name: "MembershipRequirementsChanged", kind: "message", jsonName: "MembershipRequirementsChanged", T: () => AccessListReviewMembershipRequirementsChanged, options: { "gogoproto.jsontag": "membership_requirements_changed,omitempty" } },
            { no: 4, name: "ReviewFrequencyChanged", kind: "scalar", jsonName: "ReviewFrequencyChanged", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "review_frequency_changed,omitempty" } },
            { no: 5, name: "ReviewDayOfMonthChanged", kind: "scalar", jsonName: "ReviewDayOfMonthChanged", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "review_day_of_month_changed,omitempty" } },
            { no: 6, name: "RemovedMembers", kind: "scalar", jsonName: "RemovedMembers", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "removed_members,omitempty" } },
            { no: 7, name: "AccessListTitle", kind: "scalar", jsonName: "AccessListTitle", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "access_list_title,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<AccessListReviewMetadata>): AccessListReviewMetadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.message = "";
        message.reviewID = "";
        message.reviewFrequencyChanged = "";
        message.reviewDayOfMonthChanged = "";
        message.removedMembers = [];
        message.accessListTitle = "";
        if (value !== undefined)
            reflectionMergePartial<AccessListReviewMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessListReviewMetadata): AccessListReviewMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Message = 1 [json_name = "Message"];*/ 1:
                    message.message = reader.string();
                    break;
                case /* string ReviewID = 2 [json_name = "ReviewID"];*/ 2:
                    message.reviewID = reader.string();
                    break;
                case /* events.AccessListReviewMembershipRequirementsChanged MembershipRequirementsChanged = 3 [json_name = "MembershipRequirementsChanged"];*/ 3:
                    message.membershipRequirementsChanged = AccessListReviewMembershipRequirementsChanged.internalBinaryRead(reader, reader.uint32(), options, message.membershipRequirementsChanged);
                    break;
                case /* string ReviewFrequencyChanged = 4 [json_name = "ReviewFrequencyChanged"];*/ 4:
                    message.reviewFrequencyChanged = reader.string();
                    break;
                case /* string ReviewDayOfMonthChanged = 5 [json_name = "ReviewDayOfMonthChanged"];*/ 5:
                    message.reviewDayOfMonthChanged = reader.string();
                    break;
                case /* repeated string RemovedMembers = 6 [json_name = "RemovedMembers"];*/ 6:
                    message.removedMembers.push(reader.string());
                    break;
                case /* string AccessListTitle = 7 [json_name = "AccessListTitle"];*/ 7:
                    message.accessListTitle = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessListReviewMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Message = 1 [json_name = "Message"]; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        /* string ReviewID = 2 [json_name = "ReviewID"]; */
        if (message.reviewID !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.reviewID);
        /* events.AccessListReviewMembershipRequirementsChanged MembershipRequirementsChanged = 3 [json_name = "MembershipRequirementsChanged"]; */
        if (message.membershipRequirementsChanged)
            AccessListReviewMembershipRequirementsChanged.internalBinaryWrite(message.membershipRequirementsChanged, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string ReviewFrequencyChanged = 4 [json_name = "ReviewFrequencyChanged"]; */
        if (message.reviewFrequencyChanged !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.reviewFrequencyChanged);
        /* string ReviewDayOfMonthChanged = 5 [json_name = "ReviewDayOfMonthChanged"]; */
        if (message.reviewDayOfMonthChanged !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.reviewDayOfMonthChanged);
        /* repeated string RemovedMembers = 6 [json_name = "RemovedMembers"]; */
        for (let i = 0; i < message.removedMembers.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.removedMembers[i]);
        /* string AccessListTitle = 7 [json_name = "AccessListTitle"]; */
        if (message.accessListTitle !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.accessListTitle);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.AccessListReviewMetadata
 */
export const AccessListReviewMetadata = new AccessListReviewMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LockMetadata$Type extends MessageType<LockMetadata> {
    constructor() {
        super("events.LockMetadata", [
            { no: 4, name: "Target", kind: "message", jsonName: "Target", T: () => LockTarget, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "target" } }
        ]);
    }
    create(value?: PartialMessage<LockMetadata>): LockMetadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<LockMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LockMetadata): LockMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.LockTarget Target = 4 [json_name = "Target"];*/ 4:
                    message.target = LockTarget.internalBinaryRead(reader, reader.uint32(), options, message.target);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LockMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.LockTarget Target = 4 [json_name = "Target"]; */
        if (message.target)
            LockTarget.internalBinaryWrite(message.target, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.LockMetadata
 */
export const LockMetadata = new LockMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SessionStart$Type extends MessageType<SessionStart> {
    constructor() {
        super("events.SessionStart", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Server", kind: "message", jsonName: "Server", T: () => ServerMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 6, name: "TerminalSize", kind: "scalar", jsonName: "TerminalSize", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "size,omitempty" } },
            { no: 7, name: "KubernetesCluster", kind: "message", jsonName: "KubernetesCluster", T: () => KubernetesClusterMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 8, name: "KubernetesPod", kind: "message", jsonName: "KubernetesPod", T: () => KubernetesPodMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 9, name: "InitialCommand", kind: "scalar", jsonName: "InitialCommand", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "initial_command,omitempty" } },
            { no: 10, name: "SessionRecording", kind: "scalar", jsonName: "SessionRecording", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "session_recording,omitempty" } },
            { no: 12, name: "Invited", kind: "scalar", jsonName: "Invited", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "invited,omitempty" } },
            { no: 13, name: "Reason", kind: "scalar", jsonName: "Reason", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "reason,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<SessionStart>): SessionStart {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.terminalSize = "";
        message.initialCommand = [];
        message.sessionRecording = "";
        message.invited = [];
        message.reason = "";
        if (value !== undefined)
            reflectionMergePartial<SessionStart>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SessionStart): SessionStart {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.ServerMetadata Server = 4 [json_name = "Server"];*/ 4:
                    message.server = ServerMetadata.internalBinaryRead(reader, reader.uint32(), options, message.server);
                    break;
                case /* events.ConnectionMetadata Connection = 5 [json_name = "Connection"];*/ 5:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* string TerminalSize = 6 [json_name = "TerminalSize"];*/ 6:
                    message.terminalSize = reader.string();
                    break;
                case /* events.KubernetesClusterMetadata KubernetesCluster = 7 [json_name = "KubernetesCluster"];*/ 7:
                    message.kubernetesCluster = KubernetesClusterMetadata.internalBinaryRead(reader, reader.uint32(), options, message.kubernetesCluster);
                    break;
                case /* events.KubernetesPodMetadata KubernetesPod = 8 [json_name = "KubernetesPod"];*/ 8:
                    message.kubernetesPod = KubernetesPodMetadata.internalBinaryRead(reader, reader.uint32(), options, message.kubernetesPod);
                    break;
                case /* repeated string InitialCommand = 9 [json_name = "InitialCommand"];*/ 9:
                    message.initialCommand.push(reader.string());
                    break;
                case /* string SessionRecording = 10 [json_name = "SessionRecording"];*/ 10:
                    message.sessionRecording = reader.string();
                    break;
                case /* repeated string Invited = 12 [json_name = "Invited"];*/ 12:
                    message.invited.push(reader.string());
                    break;
                case /* string Reason = 13 [json_name = "Reason"];*/ 13:
                    message.reason = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SessionStart, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ServerMetadata Server = 4 [json_name = "Server"]; */
        if (message.server)
            ServerMetadata.internalBinaryWrite(message.server, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 5 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string TerminalSize = 6 [json_name = "TerminalSize"]; */
        if (message.terminalSize !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.terminalSize);
        /* events.KubernetesClusterMetadata KubernetesCluster = 7 [json_name = "KubernetesCluster"]; */
        if (message.kubernetesCluster)
            KubernetesClusterMetadata.internalBinaryWrite(message.kubernetesCluster, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* events.KubernetesPodMetadata KubernetesPod = 8 [json_name = "KubernetesPod"]; */
        if (message.kubernetesPod)
            KubernetesPodMetadata.internalBinaryWrite(message.kubernetesPod, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* repeated string InitialCommand = 9 [json_name = "InitialCommand"]; */
        for (let i = 0; i < message.initialCommand.length; i++)
            writer.tag(9, WireType.LengthDelimited).string(message.initialCommand[i]);
        /* string SessionRecording = 10 [json_name = "SessionRecording"]; */
        if (message.sessionRecording !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.sessionRecording);
        /* repeated string Invited = 12 [json_name = "Invited"]; */
        for (let i = 0; i < message.invited.length; i++)
            writer.tag(12, WireType.LengthDelimited).string(message.invited[i]);
        /* string Reason = 13 [json_name = "Reason"]; */
        if (message.reason !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.reason);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.SessionStart
 */
export const SessionStart = new SessionStart$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SessionJoin$Type extends MessageType<SessionJoin> {
    constructor() {
        super("events.SessionJoin", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Server", kind: "message", jsonName: "Server", T: () => ServerMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 6, name: "KubernetesCluster", kind: "message", jsonName: "KubernetesCluster", T: () => KubernetesClusterMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<SessionJoin>): SessionJoin {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SessionJoin>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SessionJoin): SessionJoin {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.ServerMetadata Server = 4 [json_name = "Server"];*/ 4:
                    message.server = ServerMetadata.internalBinaryRead(reader, reader.uint32(), options, message.server);
                    break;
                case /* events.ConnectionMetadata Connection = 5 [json_name = "Connection"];*/ 5:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* events.KubernetesClusterMetadata KubernetesCluster = 6 [json_name = "KubernetesCluster"];*/ 6:
                    message.kubernetesCluster = KubernetesClusterMetadata.internalBinaryRead(reader, reader.uint32(), options, message.kubernetesCluster);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SessionJoin, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ServerMetadata Server = 4 [json_name = "Server"]; */
        if (message.server)
            ServerMetadata.internalBinaryWrite(message.server, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 5 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* events.KubernetesClusterMetadata KubernetesCluster = 6 [json_name = "KubernetesCluster"]; */
        if (message.kubernetesCluster)
            KubernetesClusterMetadata.internalBinaryWrite(message.kubernetesCluster, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.SessionJoin
 */
export const SessionJoin = new SessionJoin$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SessionPrint$Type extends MessageType<SessionPrint> {
    constructor() {
        super("events.SessionPrint", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "ChunkIndex", kind: "scalar", jsonName: "ChunkIndex", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "ci" } },
            { no: 3, name: "Data", kind: "scalar", jsonName: "Data", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.nullable": true, "gogoproto.jsontag": "-" } },
            { no: 4, name: "Bytes", kind: "scalar", jsonName: "Bytes", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "bytes" } },
            { no: 5, name: "DelayMilliseconds", kind: "scalar", jsonName: "DelayMilliseconds", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "ms" } },
            { no: 6, name: "Offset", kind: "scalar", jsonName: "Offset", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "offset" } }
        ]);
    }
    create(value?: PartialMessage<SessionPrint>): SessionPrint {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.chunkIndex = 0n;
        message.data = new Uint8Array(0);
        message.bytes = 0n;
        message.delayMilliseconds = 0n;
        message.offset = 0n;
        if (value !== undefined)
            reflectionMergePartial<SessionPrint>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SessionPrint): SessionPrint {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* int64 ChunkIndex = 2 [json_name = "ChunkIndex"];*/ 2:
                    message.chunkIndex = reader.int64().toBigInt();
                    break;
                case /* bytes Data = 3 [json_name = "Data"];*/ 3:
                    message.data = reader.bytes();
                    break;
                case /* int64 Bytes = 4 [json_name = "Bytes"];*/ 4:
                    message.bytes = reader.int64().toBigInt();
                    break;
                case /* int64 DelayMilliseconds = 5 [json_name = "DelayMilliseconds"];*/ 5:
                    message.delayMilliseconds = reader.int64().toBigInt();
                    break;
                case /* int64 Offset = 6 [json_name = "Offset"];*/ 6:
                    message.offset = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SessionPrint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int64 ChunkIndex = 2 [json_name = "ChunkIndex"]; */
        if (message.chunkIndex !== 0n)
            writer.tag(2, WireType.Varint).int64(message.chunkIndex);
        /* bytes Data = 3 [json_name = "Data"]; */
        if (message.data.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.data);
        /* int64 Bytes = 4 [json_name = "Bytes"]; */
        if (message.bytes !== 0n)
            writer.tag(4, WireType.Varint).int64(message.bytes);
        /* int64 DelayMilliseconds = 5 [json_name = "DelayMilliseconds"]; */
        if (message.delayMilliseconds !== 0n)
            writer.tag(5, WireType.Varint).int64(message.delayMilliseconds);
        /* int64 Offset = 6 [json_name = "Offset"]; */
        if (message.offset !== 0n)
            writer.tag(6, WireType.Varint).int64(message.offset);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.SessionPrint
 */
export const SessionPrint = new SessionPrint$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DesktopRecording$Type extends MessageType<DesktopRecording> {
    constructor() {
        super("events.DesktopRecording", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Message", kind: "scalar", jsonName: "Message", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.nullable": true, "gogoproto.jsontag": "message" } },
            { no: 3, name: "DelayMilliseconds", kind: "scalar", jsonName: "DelayMilliseconds", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "ms" } }
        ]);
    }
    create(value?: PartialMessage<DesktopRecording>): DesktopRecording {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.message = new Uint8Array(0);
        message.delayMilliseconds = 0n;
        if (value !== undefined)
            reflectionMergePartial<DesktopRecording>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DesktopRecording): DesktopRecording {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* bytes Message = 2 [json_name = "Message"];*/ 2:
                    message.message = reader.bytes();
                    break;
                case /* int64 DelayMilliseconds = 3 [json_name = "DelayMilliseconds"];*/ 3:
                    message.delayMilliseconds = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DesktopRecording, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bytes Message = 2 [json_name = "Message"]; */
        if (message.message.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.message);
        /* int64 DelayMilliseconds = 3 [json_name = "DelayMilliseconds"]; */
        if (message.delayMilliseconds !== 0n)
            writer.tag(3, WireType.Varint).int64(message.delayMilliseconds);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.DesktopRecording
 */
export const DesktopRecording = new DesktopRecording$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DesktopClipboardReceive$Type extends MessageType<DesktopClipboardReceive> {
    constructor() {
        super("events.DesktopClipboardReceive", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "DesktopAddr", kind: "scalar", jsonName: "DesktopAddr", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "desktop_addr" } },
            { no: 6, name: "Length", kind: "scalar", jsonName: "Length", T: 5 /*ScalarType.INT32*/, options: { "gogoproto.jsontag": "length" } }
        ]);
    }
    create(value?: PartialMessage<DesktopClipboardReceive>): DesktopClipboardReceive {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.desktopAddr = "";
        message.length = 0;
        if (value !== undefined)
            reflectionMergePartial<DesktopClipboardReceive>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DesktopClipboardReceive): DesktopClipboardReceive {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* string DesktopAddr = 5 [json_name = "DesktopAddr"];*/ 5:
                    message.desktopAddr = reader.string();
                    break;
                case /* int32 Length = 6 [json_name = "Length"];*/ 6:
                    message.length = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DesktopClipboardReceive, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string DesktopAddr = 5 [json_name = "DesktopAddr"]; */
        if (message.desktopAddr !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.desktopAddr);
        /* int32 Length = 6 [json_name = "Length"]; */
        if (message.length !== 0)
            writer.tag(6, WireType.Varint).int32(message.length);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.DesktopClipboardReceive
 */
export const DesktopClipboardReceive = new DesktopClipboardReceive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DesktopClipboardSend$Type extends MessageType<DesktopClipboardSend> {
    constructor() {
        super("events.DesktopClipboardSend", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "DesktopAddr", kind: "scalar", jsonName: "DesktopAddr", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "desktop_addr" } },
            { no: 6, name: "Length", kind: "scalar", jsonName: "Length", T: 5 /*ScalarType.INT32*/, options: { "gogoproto.jsontag": "length" } }
        ]);
    }
    create(value?: PartialMessage<DesktopClipboardSend>): DesktopClipboardSend {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.desktopAddr = "";
        message.length = 0;
        if (value !== undefined)
            reflectionMergePartial<DesktopClipboardSend>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DesktopClipboardSend): DesktopClipboardSend {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* string DesktopAddr = 5 [json_name = "DesktopAddr"];*/ 5:
                    message.desktopAddr = reader.string();
                    break;
                case /* int32 Length = 6 [json_name = "Length"];*/ 6:
                    message.length = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DesktopClipboardSend, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string DesktopAddr = 5 [json_name = "DesktopAddr"]; */
        if (message.desktopAddr !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.desktopAddr);
        /* int32 Length = 6 [json_name = "Length"]; */
        if (message.length !== 0)
            writer.tag(6, WireType.Varint).int32(message.length);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.DesktopClipboardSend
 */
export const DesktopClipboardSend = new DesktopClipboardSend$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DesktopSharedDirectoryStart$Type extends MessageType<DesktopSharedDirectoryStart> {
    constructor() {
        super("events.DesktopSharedDirectoryStart", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 6, name: "DesktopAddr", kind: "scalar", jsonName: "DesktopAddr", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "desktop_addr" } },
            { no: 7, name: "DirectoryName", kind: "scalar", jsonName: "DirectoryName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "directory_name" } },
            { no: 8, name: "DirectoryID", kind: "scalar", jsonName: "DirectoryID", T: 13 /*ScalarType.UINT32*/, options: { "gogoproto.jsontag": "directory_id" } }
        ]);
    }
    create(value?: PartialMessage<DesktopSharedDirectoryStart>): DesktopSharedDirectoryStart {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.desktopAddr = "";
        message.directoryName = "";
        message.directoryID = 0;
        if (value !== undefined)
            reflectionMergePartial<DesktopSharedDirectoryStart>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DesktopSharedDirectoryStart): DesktopSharedDirectoryStart {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* events.Status Status = 5 [json_name = "Status"];*/ 5:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* string DesktopAddr = 6 [json_name = "DesktopAddr"];*/ 6:
                    message.desktopAddr = reader.string();
                    break;
                case /* string DirectoryName = 7 [json_name = "DirectoryName"];*/ 7:
                    message.directoryName = reader.string();
                    break;
                case /* uint32 DirectoryID = 8 [json_name = "DirectoryID"];*/ 8:
                    message.directoryID = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DesktopSharedDirectoryStart, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 5 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string DesktopAddr = 6 [json_name = "DesktopAddr"]; */
        if (message.desktopAddr !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.desktopAddr);
        /* string DirectoryName = 7 [json_name = "DirectoryName"]; */
        if (message.directoryName !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.directoryName);
        /* uint32 DirectoryID = 8 [json_name = "DirectoryID"]; */
        if (message.directoryID !== 0)
            writer.tag(8, WireType.Varint).uint32(message.directoryID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.DesktopSharedDirectoryStart
 */
export const DesktopSharedDirectoryStart = new DesktopSharedDirectoryStart$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DesktopSharedDirectoryRead$Type extends MessageType<DesktopSharedDirectoryRead> {
    constructor() {
        super("events.DesktopSharedDirectoryRead", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 6, name: "DesktopAddr", kind: "scalar", jsonName: "DesktopAddr", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "desktop_addr" } },
            { no: 7, name: "DirectoryName", kind: "scalar", jsonName: "DirectoryName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "directory_name" } },
            { no: 8, name: "DirectoryID", kind: "scalar", jsonName: "DirectoryID", T: 13 /*ScalarType.UINT32*/, options: { "gogoproto.jsontag": "directory_id" } },
            { no: 9, name: "Path", kind: "scalar", jsonName: "Path", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "file_path" } },
            { no: 10, name: "Length", kind: "scalar", jsonName: "Length", T: 13 /*ScalarType.UINT32*/, options: { "gogoproto.jsontag": "length" } },
            { no: 11, name: "Offset", kind: "scalar", jsonName: "Offset", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "offset" } }
        ]);
    }
    create(value?: PartialMessage<DesktopSharedDirectoryRead>): DesktopSharedDirectoryRead {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.desktopAddr = "";
        message.directoryName = "";
        message.directoryID = 0;
        message.path = "";
        message.length = 0;
        message.offset = 0n;
        if (value !== undefined)
            reflectionMergePartial<DesktopSharedDirectoryRead>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DesktopSharedDirectoryRead): DesktopSharedDirectoryRead {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* events.Status Status = 5 [json_name = "Status"];*/ 5:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* string DesktopAddr = 6 [json_name = "DesktopAddr"];*/ 6:
                    message.desktopAddr = reader.string();
                    break;
                case /* string DirectoryName = 7 [json_name = "DirectoryName"];*/ 7:
                    message.directoryName = reader.string();
                    break;
                case /* uint32 DirectoryID = 8 [json_name = "DirectoryID"];*/ 8:
                    message.directoryID = reader.uint32();
                    break;
                case /* string Path = 9 [json_name = "Path"];*/ 9:
                    message.path = reader.string();
                    break;
                case /* uint32 Length = 10 [json_name = "Length"];*/ 10:
                    message.length = reader.uint32();
                    break;
                case /* uint64 Offset = 11 [json_name = "Offset"];*/ 11:
                    message.offset = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DesktopSharedDirectoryRead, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 5 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string DesktopAddr = 6 [json_name = "DesktopAddr"]; */
        if (message.desktopAddr !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.desktopAddr);
        /* string DirectoryName = 7 [json_name = "DirectoryName"]; */
        if (message.directoryName !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.directoryName);
        /* uint32 DirectoryID = 8 [json_name = "DirectoryID"]; */
        if (message.directoryID !== 0)
            writer.tag(8, WireType.Varint).uint32(message.directoryID);
        /* string Path = 9 [json_name = "Path"]; */
        if (message.path !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.path);
        /* uint32 Length = 10 [json_name = "Length"]; */
        if (message.length !== 0)
            writer.tag(10, WireType.Varint).uint32(message.length);
        /* uint64 Offset = 11 [json_name = "Offset"]; */
        if (message.offset !== 0n)
            writer.tag(11, WireType.Varint).uint64(message.offset);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.DesktopSharedDirectoryRead
 */
export const DesktopSharedDirectoryRead = new DesktopSharedDirectoryRead$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DesktopSharedDirectoryWrite$Type extends MessageType<DesktopSharedDirectoryWrite> {
    constructor() {
        super("events.DesktopSharedDirectoryWrite", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 6, name: "DesktopAddr", kind: "scalar", jsonName: "DesktopAddr", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "desktop_addr" } },
            { no: 7, name: "DirectoryName", kind: "scalar", jsonName: "DirectoryName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "directory_name" } },
            { no: 8, name: "DirectoryID", kind: "scalar", jsonName: "DirectoryID", T: 13 /*ScalarType.UINT32*/, options: { "gogoproto.jsontag": "directory_id" } },
            { no: 9, name: "Path", kind: "scalar", jsonName: "Path", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "file_path" } },
            { no: 10, name: "Length", kind: "scalar", jsonName: "Length", T: 13 /*ScalarType.UINT32*/, options: { "gogoproto.jsontag": "length" } },
            { no: 11, name: "Offset", kind: "scalar", jsonName: "Offset", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "offset" } }
        ]);
    }
    create(value?: PartialMessage<DesktopSharedDirectoryWrite>): DesktopSharedDirectoryWrite {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.desktopAddr = "";
        message.directoryName = "";
        message.directoryID = 0;
        message.path = "";
        message.length = 0;
        message.offset = 0n;
        if (value !== undefined)
            reflectionMergePartial<DesktopSharedDirectoryWrite>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DesktopSharedDirectoryWrite): DesktopSharedDirectoryWrite {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* events.Status Status = 5 [json_name = "Status"];*/ 5:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* string DesktopAddr = 6 [json_name = "DesktopAddr"];*/ 6:
                    message.desktopAddr = reader.string();
                    break;
                case /* string DirectoryName = 7 [json_name = "DirectoryName"];*/ 7:
                    message.directoryName = reader.string();
                    break;
                case /* uint32 DirectoryID = 8 [json_name = "DirectoryID"];*/ 8:
                    message.directoryID = reader.uint32();
                    break;
                case /* string Path = 9 [json_name = "Path"];*/ 9:
                    message.path = reader.string();
                    break;
                case /* uint32 Length = 10 [json_name = "Length"];*/ 10:
                    message.length = reader.uint32();
                    break;
                case /* uint64 Offset = 11 [json_name = "Offset"];*/ 11:
                    message.offset = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DesktopSharedDirectoryWrite, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 5 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string DesktopAddr = 6 [json_name = "DesktopAddr"]; */
        if (message.desktopAddr !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.desktopAddr);
        /* string DirectoryName = 7 [json_name = "DirectoryName"]; */
        if (message.directoryName !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.directoryName);
        /* uint32 DirectoryID = 8 [json_name = "DirectoryID"]; */
        if (message.directoryID !== 0)
            writer.tag(8, WireType.Varint).uint32(message.directoryID);
        /* string Path = 9 [json_name = "Path"]; */
        if (message.path !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.path);
        /* uint32 Length = 10 [json_name = "Length"]; */
        if (message.length !== 0)
            writer.tag(10, WireType.Varint).uint32(message.length);
        /* uint64 Offset = 11 [json_name = "Offset"]; */
        if (message.offset !== 0n)
            writer.tag(11, WireType.Varint).uint64(message.offset);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.DesktopSharedDirectoryWrite
 */
export const DesktopSharedDirectoryWrite = new DesktopSharedDirectoryWrite$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SessionReject$Type extends MessageType<SessionReject> {
    constructor() {
        super("events.SessionReject", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Server", kind: "message", jsonName: "Server", T: () => ServerMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Reason", kind: "scalar", jsonName: "Reason", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "reason" } },
            { no: 6, name: "Maximum", kind: "scalar", jsonName: "Maximum", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "max" } }
        ]);
    }
    create(value?: PartialMessage<SessionReject>): SessionReject {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.reason = "";
        message.maximum = 0n;
        if (value !== undefined)
            reflectionMergePartial<SessionReject>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SessionReject): SessionReject {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ServerMetadata Server = 3 [json_name = "Server"];*/ 3:
                    message.server = ServerMetadata.internalBinaryRead(reader, reader.uint32(), options, message.server);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* string Reason = 5 [json_name = "Reason"];*/ 5:
                    message.reason = reader.string();
                    break;
                case /* int64 Maximum = 6 [json_name = "Maximum"];*/ 6:
                    message.maximum = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SessionReject, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ServerMetadata Server = 3 [json_name = "Server"]; */
        if (message.server)
            ServerMetadata.internalBinaryWrite(message.server, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string Reason = 5 [json_name = "Reason"]; */
        if (message.reason !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.reason);
        /* int64 Maximum = 6 [json_name = "Maximum"]; */
        if (message.maximum !== 0n)
            writer.tag(6, WireType.Varint).int64(message.maximum);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.SessionReject
 */
export const SessionReject = new SessionReject$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SessionConnect$Type extends MessageType<SessionConnect> {
    constructor() {
        super("events.SessionConnect", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Server", kind: "message", jsonName: "Server", T: () => ServerMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<SessionConnect>): SessionConnect {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SessionConnect>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SessionConnect): SessionConnect {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ServerMetadata Server = 2 [json_name = "Server"];*/ 2:
                    message.server = ServerMetadata.internalBinaryRead(reader, reader.uint32(), options, message.server);
                    break;
                case /* events.ConnectionMetadata Connection = 3 [json_name = "Connection"];*/ 3:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SessionConnect, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ServerMetadata Server = 2 [json_name = "Server"]; */
        if (message.server)
            ServerMetadata.internalBinaryWrite(message.server, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 3 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.SessionConnect
 */
export const SessionConnect = new SessionConnect$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FileTransferRequestEvent$Type extends MessageType<FileTransferRequestEvent> {
    constructor() {
        super("events.FileTransferRequestEvent", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "RequestID", kind: "scalar", jsonName: "RequestID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "requestID" } },
            { no: 4, name: "Approvers", kind: "scalar", jsonName: "Approvers", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "approvers" } },
            { no: 5, name: "Requester", kind: "scalar", jsonName: "Requester", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "requester" } },
            { no: 6, name: "Location", kind: "scalar", jsonName: "Location", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "location" } },
            { no: 7, name: "Download", kind: "scalar", jsonName: "Download", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "download" } },
            { no: 8, name: "Filename", kind: "scalar", jsonName: "Filename", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "filename" } }
        ]);
    }
    create(value?: PartialMessage<FileTransferRequestEvent>): FileTransferRequestEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.requestID = "";
        message.approvers = [];
        message.requester = "";
        message.location = "";
        message.download = false;
        message.filename = "";
        if (value !== undefined)
            reflectionMergePartial<FileTransferRequestEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FileTransferRequestEvent): FileTransferRequestEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.SessionMetadata Session = 2 [json_name = "Session"];*/ 2:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* string RequestID = 3 [json_name = "RequestID"];*/ 3:
                    message.requestID = reader.string();
                    break;
                case /* repeated string Approvers = 4 [json_name = "Approvers"];*/ 4:
                    message.approvers.push(reader.string());
                    break;
                case /* string Requester = 5 [json_name = "Requester"];*/ 5:
                    message.requester = reader.string();
                    break;
                case /* string Location = 6 [json_name = "Location"];*/ 6:
                    message.location = reader.string();
                    break;
                case /* bool Download = 7 [json_name = "Download"];*/ 7:
                    message.download = reader.bool();
                    break;
                case /* string Filename = 8 [json_name = "Filename"];*/ 8:
                    message.filename = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FileTransferRequestEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 2 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string RequestID = 3 [json_name = "RequestID"]; */
        if (message.requestID !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.requestID);
        /* repeated string Approvers = 4 [json_name = "Approvers"]; */
        for (let i = 0; i < message.approvers.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.approvers[i]);
        /* string Requester = 5 [json_name = "Requester"]; */
        if (message.requester !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.requester);
        /* string Location = 6 [json_name = "Location"]; */
        if (message.location !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.location);
        /* bool Download = 7 [json_name = "Download"]; */
        if (message.download !== false)
            writer.tag(7, WireType.Varint).bool(message.download);
        /* string Filename = 8 [json_name = "Filename"]; */
        if (message.filename !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.filename);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.FileTransferRequestEvent
 */
export const FileTransferRequestEvent = new FileTransferRequestEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Resize$Type extends MessageType<Resize> {
    constructor() {
        super("events.Resize", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Server", kind: "message", jsonName: "Server", T: () => ServerMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 6, name: "TerminalSize", kind: "scalar", jsonName: "TerminalSize", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "size,omitempty" } },
            { no: 7, name: "KubernetesCluster", kind: "message", jsonName: "KubernetesCluster", T: () => KubernetesClusterMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 8, name: "KubernetesPod", kind: "message", jsonName: "KubernetesPod", T: () => KubernetesPodMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<Resize>): Resize {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.terminalSize = "";
        if (value !== undefined)
            reflectionMergePartial<Resize>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Resize): Resize {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* events.ServerMetadata Server = 5 [json_name = "Server"];*/ 5:
                    message.server = ServerMetadata.internalBinaryRead(reader, reader.uint32(), options, message.server);
                    break;
                case /* string TerminalSize = 6 [json_name = "TerminalSize"];*/ 6:
                    message.terminalSize = reader.string();
                    break;
                case /* events.KubernetesClusterMetadata KubernetesCluster = 7 [json_name = "KubernetesCluster"];*/ 7:
                    message.kubernetesCluster = KubernetesClusterMetadata.internalBinaryRead(reader, reader.uint32(), options, message.kubernetesCluster);
                    break;
                case /* events.KubernetesPodMetadata KubernetesPod = 8 [json_name = "KubernetesPod"];*/ 8:
                    message.kubernetesPod = KubernetesPodMetadata.internalBinaryRead(reader, reader.uint32(), options, message.kubernetesPod);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Resize, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.ServerMetadata Server = 5 [json_name = "Server"]; */
        if (message.server)
            ServerMetadata.internalBinaryWrite(message.server, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string TerminalSize = 6 [json_name = "TerminalSize"]; */
        if (message.terminalSize !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.terminalSize);
        /* events.KubernetesClusterMetadata KubernetesCluster = 7 [json_name = "KubernetesCluster"]; */
        if (message.kubernetesCluster)
            KubernetesClusterMetadata.internalBinaryWrite(message.kubernetesCluster, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* events.KubernetesPodMetadata KubernetesPod = 8 [json_name = "KubernetesPod"]; */
        if (message.kubernetesPod)
            KubernetesPodMetadata.internalBinaryWrite(message.kubernetesPod, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.Resize
 */
export const Resize = new Resize$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SessionEnd$Type extends MessageType<SessionEnd> {
    constructor() {
        super("events.SessionEnd", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Server", kind: "message", jsonName: "Server", T: () => ServerMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 6, name: "EnhancedRecording", kind: "scalar", jsonName: "EnhancedRecording", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "enhanced_recording" } },
            { no: 7, name: "Interactive", kind: "scalar", jsonName: "Interactive", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "interactive" } },
            { no: 8, name: "Participants", kind: "scalar", jsonName: "Participants", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "participants" } },
            { no: 9, name: "StartTime", kind: "message", jsonName: "StartTime", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "session_start,omitempty", "gogoproto.stdtime": true } },
            { no: 10, name: "EndTime", kind: "message", jsonName: "EndTime", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "session_stop,omitempty", "gogoproto.stdtime": true } },
            { no: 11, name: "KubernetesCluster", kind: "message", jsonName: "KubernetesCluster", T: () => KubernetesClusterMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 12, name: "KubernetesPod", kind: "message", jsonName: "KubernetesPod", T: () => KubernetesPodMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 13, name: "InitialCommand", kind: "scalar", jsonName: "InitialCommand", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "initial_command,omitempty" } },
            { no: 14, name: "SessionRecording", kind: "scalar", jsonName: "SessionRecording", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "session_recording,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<SessionEnd>): SessionEnd {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.enhancedRecording = false;
        message.interactive = false;
        message.participants = [];
        message.initialCommand = [];
        message.sessionRecording = "";
        if (value !== undefined)
            reflectionMergePartial<SessionEnd>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SessionEnd): SessionEnd {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* events.ServerMetadata Server = 5 [json_name = "Server"];*/ 5:
                    message.server = ServerMetadata.internalBinaryRead(reader, reader.uint32(), options, message.server);
                    break;
                case /* bool EnhancedRecording = 6 [json_name = "EnhancedRecording"];*/ 6:
                    message.enhancedRecording = reader.bool();
                    break;
                case /* bool Interactive = 7 [json_name = "Interactive"];*/ 7:
                    message.interactive = reader.bool();
                    break;
                case /* repeated string Participants = 8 [json_name = "Participants"];*/ 8:
                    message.participants.push(reader.string());
                    break;
                case /* google.protobuf.Timestamp StartTime = 9 [json_name = "StartTime"];*/ 9:
                    message.startTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.startTime);
                    break;
                case /* google.protobuf.Timestamp EndTime = 10 [json_name = "EndTime"];*/ 10:
                    message.endTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.endTime);
                    break;
                case /* events.KubernetesClusterMetadata KubernetesCluster = 11 [json_name = "KubernetesCluster"];*/ 11:
                    message.kubernetesCluster = KubernetesClusterMetadata.internalBinaryRead(reader, reader.uint32(), options, message.kubernetesCluster);
                    break;
                case /* events.KubernetesPodMetadata KubernetesPod = 12 [json_name = "KubernetesPod"];*/ 12:
                    message.kubernetesPod = KubernetesPodMetadata.internalBinaryRead(reader, reader.uint32(), options, message.kubernetesPod);
                    break;
                case /* repeated string InitialCommand = 13 [json_name = "InitialCommand"];*/ 13:
                    message.initialCommand.push(reader.string());
                    break;
                case /* string SessionRecording = 14 [json_name = "SessionRecording"];*/ 14:
                    message.sessionRecording = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SessionEnd, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.ServerMetadata Server = 5 [json_name = "Server"]; */
        if (message.server)
            ServerMetadata.internalBinaryWrite(message.server, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* bool EnhancedRecording = 6 [json_name = "EnhancedRecording"]; */
        if (message.enhancedRecording !== false)
            writer.tag(6, WireType.Varint).bool(message.enhancedRecording);
        /* bool Interactive = 7 [json_name = "Interactive"]; */
        if (message.interactive !== false)
            writer.tag(7, WireType.Varint).bool(message.interactive);
        /* repeated string Participants = 8 [json_name = "Participants"]; */
        for (let i = 0; i < message.participants.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.participants[i]);
        /* google.protobuf.Timestamp StartTime = 9 [json_name = "StartTime"]; */
        if (message.startTime)
            Timestamp.internalBinaryWrite(message.startTime, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp EndTime = 10 [json_name = "EndTime"]; */
        if (message.endTime)
            Timestamp.internalBinaryWrite(message.endTime, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* events.KubernetesClusterMetadata KubernetesCluster = 11 [json_name = "KubernetesCluster"]; */
        if (message.kubernetesCluster)
            KubernetesClusterMetadata.internalBinaryWrite(message.kubernetesCluster, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* events.KubernetesPodMetadata KubernetesPod = 12 [json_name = "KubernetesPod"]; */
        if (message.kubernetesPod)
            KubernetesPodMetadata.internalBinaryWrite(message.kubernetesPod, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* repeated string InitialCommand = 13 [json_name = "InitialCommand"]; */
        for (let i = 0; i < message.initialCommand.length; i++)
            writer.tag(13, WireType.LengthDelimited).string(message.initialCommand[i]);
        /* string SessionRecording = 14 [json_name = "SessionRecording"]; */
        if (message.sessionRecording !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.sessionRecording);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.SessionEnd
 */
export const SessionEnd = new SessionEnd$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BPFMetadata$Type extends MessageType<BPFMetadata> {
    constructor() {
        super("events.BPFMetadata", [
            { no: 1, name: "PID", kind: "scalar", jsonName: "PID", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "pid" } },
            { no: 2, name: "CgroupID", kind: "scalar", jsonName: "CgroupID", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "cgroup_id" } },
            { no: 3, name: "Program", kind: "scalar", jsonName: "Program", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "program" } }
        ]);
    }
    create(value?: PartialMessage<BPFMetadata>): BPFMetadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pID = 0n;
        message.cgroupID = 0n;
        message.program = "";
        if (value !== undefined)
            reflectionMergePartial<BPFMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BPFMetadata): BPFMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 PID = 1 [json_name = "PID"];*/ 1:
                    message.pID = reader.uint64().toBigInt();
                    break;
                case /* uint64 CgroupID = 2 [json_name = "CgroupID"];*/ 2:
                    message.cgroupID = reader.uint64().toBigInt();
                    break;
                case /* string Program = 3 [json_name = "Program"];*/ 3:
                    message.program = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BPFMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 PID = 1 [json_name = "PID"]; */
        if (message.pID !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.pID);
        /* uint64 CgroupID = 2 [json_name = "CgroupID"]; */
        if (message.cgroupID !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.cgroupID);
        /* string Program = 3 [json_name = "Program"]; */
        if (message.program !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.program);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.BPFMetadata
 */
export const BPFMetadata = new BPFMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Status$Type extends MessageType<Status> {
    constructor() {
        super("events.Status", [
            { no: 1, name: "Success", kind: "scalar", jsonName: "Success", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "success" } },
            { no: 2, name: "Error", kind: "scalar", jsonName: "Error", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "error,omitempty" } },
            { no: 3, name: "UserMessage", kind: "scalar", jsonName: "UserMessage", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "message,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<Status>): Status {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        message.error = "";
        message.userMessage = "";
        if (value !== undefined)
            reflectionMergePartial<Status>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Status): Status {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool Success = 1 [json_name = "Success"];*/ 1:
                    message.success = reader.bool();
                    break;
                case /* string Error = 2 [json_name = "Error"];*/ 2:
                    message.error = reader.string();
                    break;
                case /* string UserMessage = 3 [json_name = "UserMessage"];*/ 3:
                    message.userMessage = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Status, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool Success = 1 [json_name = "Success"]; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* string Error = 2 [json_name = "Error"]; */
        if (message.error !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.error);
        /* string UserMessage = 3 [json_name = "UserMessage"]; */
        if (message.userMessage !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.userMessage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.Status
 */
export const Status = new Status$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SessionCommand$Type extends MessageType<SessionCommand> {
    constructor() {
        super("events.SessionCommand", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Server", kind: "message", jsonName: "Server", T: () => ServerMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "BPF", kind: "message", jsonName: "BPF", T: () => BPFMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 6, name: "PPID", kind: "scalar", jsonName: "PPID", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "ppid" } },
            { no: 7, name: "Path", kind: "scalar", jsonName: "Path", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "path" } },
            { no: 8, name: "Argv", kind: "scalar", jsonName: "Argv", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "argv" } },
            { no: 9, name: "ReturnCode", kind: "scalar", jsonName: "ReturnCode", T: 5 /*ScalarType.INT32*/, options: { "gogoproto.jsontag": "return_code" } }
        ]);
    }
    create(value?: PartialMessage<SessionCommand>): SessionCommand {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pPID = 0n;
        message.path = "";
        message.argv = [];
        message.returnCode = 0;
        if (value !== undefined)
            reflectionMergePartial<SessionCommand>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SessionCommand): SessionCommand {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.ServerMetadata Server = 4 [json_name = "Server"];*/ 4:
                    message.server = ServerMetadata.internalBinaryRead(reader, reader.uint32(), options, message.server);
                    break;
                case /* events.BPFMetadata BPF = 5 [json_name = "BPF"];*/ 5:
                    message.bPF = BPFMetadata.internalBinaryRead(reader, reader.uint32(), options, message.bPF);
                    break;
                case /* uint64 PPID = 6 [json_name = "PPID"];*/ 6:
                    message.pPID = reader.uint64().toBigInt();
                    break;
                case /* string Path = 7 [json_name = "Path"];*/ 7:
                    message.path = reader.string();
                    break;
                case /* repeated string Argv = 8 [json_name = "Argv"];*/ 8:
                    message.argv.push(reader.string());
                    break;
                case /* int32 ReturnCode = 9 [json_name = "ReturnCode"];*/ 9:
                    message.returnCode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SessionCommand, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ServerMetadata Server = 4 [json_name = "Server"]; */
        if (message.server)
            ServerMetadata.internalBinaryWrite(message.server, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.BPFMetadata BPF = 5 [json_name = "BPF"]; */
        if (message.bPF)
            BPFMetadata.internalBinaryWrite(message.bPF, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* uint64 PPID = 6 [json_name = "PPID"]; */
        if (message.pPID !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.pPID);
        /* string Path = 7 [json_name = "Path"]; */
        if (message.path !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.path);
        /* repeated string Argv = 8 [json_name = "Argv"]; */
        for (let i = 0; i < message.argv.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.argv[i]);
        /* int32 ReturnCode = 9 [json_name = "ReturnCode"]; */
        if (message.returnCode !== 0)
            writer.tag(9, WireType.Varint).int32(message.returnCode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.SessionCommand
 */
export const SessionCommand = new SessionCommand$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SessionDisk$Type extends MessageType<SessionDisk> {
    constructor() {
        super("events.SessionDisk", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Server", kind: "message", jsonName: "Server", T: () => ServerMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "BPF", kind: "message", jsonName: "BPF", T: () => BPFMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 6, name: "Path", kind: "scalar", jsonName: "Path", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "path" } },
            { no: 7, name: "Flags", kind: "scalar", jsonName: "Flags", T: 5 /*ScalarType.INT32*/, options: { "gogoproto.jsontag": "flags" } },
            { no: 8, name: "ReturnCode", kind: "scalar", jsonName: "ReturnCode", T: 5 /*ScalarType.INT32*/, options: { "gogoproto.jsontag": "return_code" } }
        ]);
    }
    create(value?: PartialMessage<SessionDisk>): SessionDisk {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.path = "";
        message.flags = 0;
        message.returnCode = 0;
        if (value !== undefined)
            reflectionMergePartial<SessionDisk>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SessionDisk): SessionDisk {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.ServerMetadata Server = 4 [json_name = "Server"];*/ 4:
                    message.server = ServerMetadata.internalBinaryRead(reader, reader.uint32(), options, message.server);
                    break;
                case /* events.BPFMetadata BPF = 5 [json_name = "BPF"];*/ 5:
                    message.bPF = BPFMetadata.internalBinaryRead(reader, reader.uint32(), options, message.bPF);
                    break;
                case /* string Path = 6 [json_name = "Path"];*/ 6:
                    message.path = reader.string();
                    break;
                case /* int32 Flags = 7 [json_name = "Flags"];*/ 7:
                    message.flags = reader.int32();
                    break;
                case /* int32 ReturnCode = 8 [json_name = "ReturnCode"];*/ 8:
                    message.returnCode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SessionDisk, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ServerMetadata Server = 4 [json_name = "Server"]; */
        if (message.server)
            ServerMetadata.internalBinaryWrite(message.server, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.BPFMetadata BPF = 5 [json_name = "BPF"]; */
        if (message.bPF)
            BPFMetadata.internalBinaryWrite(message.bPF, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string Path = 6 [json_name = "Path"]; */
        if (message.path !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.path);
        /* int32 Flags = 7 [json_name = "Flags"]; */
        if (message.flags !== 0)
            writer.tag(7, WireType.Varint).int32(message.flags);
        /* int32 ReturnCode = 8 [json_name = "ReturnCode"]; */
        if (message.returnCode !== 0)
            writer.tag(8, WireType.Varint).int32(message.returnCode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.SessionDisk
 */
export const SessionDisk = new SessionDisk$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SessionNetwork$Type extends MessageType<SessionNetwork> {
    constructor() {
        super("events.SessionNetwork", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Server", kind: "message", jsonName: "Server", T: () => ServerMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "BPF", kind: "message", jsonName: "BPF", T: () => BPFMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 6, name: "SrcAddr", kind: "scalar", jsonName: "SrcAddr", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "src_addr" } },
            { no: 7, name: "DstAddr", kind: "scalar", jsonName: "DstAddr", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "dst_addr" } },
            { no: 8, name: "DstPort", kind: "scalar", jsonName: "DstPort", T: 5 /*ScalarType.INT32*/, options: { "gogoproto.jsontag": "dst_port" } },
            { no: 9, name: "TCPVersion", kind: "scalar", jsonName: "TCPVersion", T: 5 /*ScalarType.INT32*/, options: { "gogoproto.jsontag": "version" } },
            { no: 10, name: "Operation", kind: "enum", jsonName: "Operation", T: () => ["events.SessionNetwork.NetworkOperation", SessionNetwork_NetworkOperation], options: { "gogoproto.jsontag": "operation" } },
            { no: 11, name: "Action", kind: "enum", jsonName: "Action", T: () => ["events.EventAction", EventAction], options: { "gogoproto.jsontag": "action" } }
        ]);
    }
    create(value?: PartialMessage<SessionNetwork>): SessionNetwork {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.srcAddr = "";
        message.dstAddr = "";
        message.dstPort = 0;
        message.tCPVersion = 0;
        message.operation = 0;
        message.action = 0;
        if (value !== undefined)
            reflectionMergePartial<SessionNetwork>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SessionNetwork): SessionNetwork {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.ServerMetadata Server = 4 [json_name = "Server"];*/ 4:
                    message.server = ServerMetadata.internalBinaryRead(reader, reader.uint32(), options, message.server);
                    break;
                case /* events.BPFMetadata BPF = 5 [json_name = "BPF"];*/ 5:
                    message.bPF = BPFMetadata.internalBinaryRead(reader, reader.uint32(), options, message.bPF);
                    break;
                case /* string SrcAddr = 6 [json_name = "SrcAddr"];*/ 6:
                    message.srcAddr = reader.string();
                    break;
                case /* string DstAddr = 7 [json_name = "DstAddr"];*/ 7:
                    message.dstAddr = reader.string();
                    break;
                case /* int32 DstPort = 8 [json_name = "DstPort"];*/ 8:
                    message.dstPort = reader.int32();
                    break;
                case /* int32 TCPVersion = 9 [json_name = "TCPVersion"];*/ 9:
                    message.tCPVersion = reader.int32();
                    break;
                case /* events.SessionNetwork.NetworkOperation Operation = 10 [json_name = "Operation"];*/ 10:
                    message.operation = reader.int32();
                    break;
                case /* events.EventAction Action = 11 [json_name = "Action"];*/ 11:
                    message.action = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SessionNetwork, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ServerMetadata Server = 4 [json_name = "Server"]; */
        if (message.server)
            ServerMetadata.internalBinaryWrite(message.server, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.BPFMetadata BPF = 5 [json_name = "BPF"]; */
        if (message.bPF)
            BPFMetadata.internalBinaryWrite(message.bPF, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string SrcAddr = 6 [json_name = "SrcAddr"]; */
        if (message.srcAddr !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.srcAddr);
        /* string DstAddr = 7 [json_name = "DstAddr"]; */
        if (message.dstAddr !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.dstAddr);
        /* int32 DstPort = 8 [json_name = "DstPort"]; */
        if (message.dstPort !== 0)
            writer.tag(8, WireType.Varint).int32(message.dstPort);
        /* int32 TCPVersion = 9 [json_name = "TCPVersion"]; */
        if (message.tCPVersion !== 0)
            writer.tag(9, WireType.Varint).int32(message.tCPVersion);
        /* events.SessionNetwork.NetworkOperation Operation = 10 [json_name = "Operation"]; */
        if (message.operation !== 0)
            writer.tag(10, WireType.Varint).int32(message.operation);
        /* events.EventAction Action = 11 [json_name = "Action"]; */
        if (message.action !== 0)
            writer.tag(11, WireType.Varint).int32(message.action);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.SessionNetwork
 */
export const SessionNetwork = new SessionNetwork$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SessionData$Type extends MessageType<SessionData> {
    constructor() {
        super("events.SessionData", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Server", kind: "message", jsonName: "Server", T: () => ServerMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 6, name: "BytesTransmitted", kind: "scalar", jsonName: "BytesTransmitted", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "tx" } },
            { no: 7, name: "BytesReceived", kind: "scalar", jsonName: "BytesReceived", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "rx" } }
        ]);
    }
    create(value?: PartialMessage<SessionData>): SessionData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.bytesTransmitted = 0n;
        message.bytesReceived = 0n;
        if (value !== undefined)
            reflectionMergePartial<SessionData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SessionData): SessionData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.ServerMetadata Server = 4 [json_name = "Server"];*/ 4:
                    message.server = ServerMetadata.internalBinaryRead(reader, reader.uint32(), options, message.server);
                    break;
                case /* events.ConnectionMetadata Connection = 5 [json_name = "Connection"];*/ 5:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* uint64 BytesTransmitted = 6 [json_name = "BytesTransmitted"];*/ 6:
                    message.bytesTransmitted = reader.uint64().toBigInt();
                    break;
                case /* uint64 BytesReceived = 7 [json_name = "BytesReceived"];*/ 7:
                    message.bytesReceived = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SessionData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ServerMetadata Server = 4 [json_name = "Server"]; */
        if (message.server)
            ServerMetadata.internalBinaryWrite(message.server, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 5 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* uint64 BytesTransmitted = 6 [json_name = "BytesTransmitted"]; */
        if (message.bytesTransmitted !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.bytesTransmitted);
        /* uint64 BytesReceived = 7 [json_name = "BytesReceived"]; */
        if (message.bytesReceived !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.bytesReceived);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.SessionData
 */
export const SessionData = new SessionData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SessionLeave$Type extends MessageType<SessionLeave> {
    constructor() {
        super("events.SessionLeave", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Server", kind: "message", jsonName: "Server", T: () => ServerMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<SessionLeave>): SessionLeave {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SessionLeave>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SessionLeave): SessionLeave {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.ServerMetadata Server = 4 [json_name = "Server"];*/ 4:
                    message.server = ServerMetadata.internalBinaryRead(reader, reader.uint32(), options, message.server);
                    break;
                case /* events.ConnectionMetadata Connection = 5 [json_name = "Connection"];*/ 5:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SessionLeave, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ServerMetadata Server = 4 [json_name = "Server"]; */
        if (message.server)
            ServerMetadata.internalBinaryWrite(message.server, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 5 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.SessionLeave
 */
export const SessionLeave = new SessionLeave$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserLogin$Type extends MessageType<UserLogin> {
    constructor() {
        super("events.UserLogin", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Method", kind: "scalar", jsonName: "Method", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "method,omitempty" } },
            { no: 5, name: "IdentityAttributes", kind: "message", jsonName: "IdentityAttributes", T: () => Struct, options: { "gogoproto.jsontag": "attributes,omitempty", "gogoproto.casttype": "Struct" } },
            { no: 6, name: "MFADevice", kind: "message", jsonName: "MFADevice", T: () => MFADeviceMetadata, options: { "gogoproto.jsontag": "mfa_device,omitempty" } },
            { no: 7, name: "Client", kind: "message", jsonName: "Client", T: () => ClientMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 8, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 9, name: "AppliedLoginRules", kind: "scalar", jsonName: "AppliedLoginRules", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "applied_login_rules,omitempty" } },
            { no: 10, name: "ConnectorID", kind: "scalar", jsonName: "ConnectorID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "connector_id,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<UserLogin>): UserLogin {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.method = "";
        message.appliedLoginRules = [];
        message.connectorID = "";
        if (value !== undefined)
            reflectionMergePartial<UserLogin>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserLogin): UserLogin {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.Status Status = 3 [json_name = "Status"];*/ 3:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* string Method = 4 [json_name = "Method"];*/ 4:
                    message.method = reader.string();
                    break;
                case /* google.protobuf.Struct IdentityAttributes = 5 [json_name = "IdentityAttributes"];*/ 5:
                    message.identityAttributes = Struct.internalBinaryRead(reader, reader.uint32(), options, message.identityAttributes);
                    break;
                case /* events.MFADeviceMetadata MFADevice = 6 [json_name = "MFADevice"];*/ 6:
                    message.mFADevice = MFADeviceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.mFADevice);
                    break;
                case /* events.ClientMetadata Client = 7 [json_name = "Client"];*/ 7:
                    message.client = ClientMetadata.internalBinaryRead(reader, reader.uint32(), options, message.client);
                    break;
                case /* events.ConnectionMetadata Connection = 8 [json_name = "Connection"];*/ 8:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* repeated string AppliedLoginRules = 9 [json_name = "AppliedLoginRules"];*/ 9:
                    message.appliedLoginRules.push(reader.string());
                    break;
                case /* string ConnectorID = 10 [json_name = "ConnectorID"];*/ 10:
                    message.connectorID = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserLogin, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 3 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string Method = 4 [json_name = "Method"]; */
        if (message.method !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.method);
        /* google.protobuf.Struct IdentityAttributes = 5 [json_name = "IdentityAttributes"]; */
        if (message.identityAttributes)
            Struct.internalBinaryWrite(message.identityAttributes, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* events.MFADeviceMetadata MFADevice = 6 [json_name = "MFADevice"]; */
        if (message.mFADevice)
            MFADeviceMetadata.internalBinaryWrite(message.mFADevice, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* events.ClientMetadata Client = 7 [json_name = "Client"]; */
        if (message.client)
            ClientMetadata.internalBinaryWrite(message.client, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 8 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* repeated string AppliedLoginRules = 9 [json_name = "AppliedLoginRules"]; */
        for (let i = 0; i < message.appliedLoginRules.length; i++)
            writer.tag(9, WireType.LengthDelimited).string(message.appliedLoginRules[i]);
        /* string ConnectorID = 10 [json_name = "ConnectorID"]; */
        if (message.connectorID !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.connectorID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.UserLogin
 */
export const UserLogin = new UserLogin$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateMFAAuthChallenge$Type extends MessageType<CreateMFAAuthChallenge> {
    constructor() {
        super("events.CreateMFAAuthChallenge", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "ChallengeScope", kind: "scalar", jsonName: "ChallengeScope", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "challenge_scope" } },
            { no: 4, name: "ChallengeAllowReuse", kind: "scalar", jsonName: "ChallengeAllowReuse", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "challenge_allow_reuse" } }
        ]);
    }
    create(value?: PartialMessage<CreateMFAAuthChallenge>): CreateMFAAuthChallenge {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.challengeScope = "";
        message.challengeAllowReuse = false;
        if (value !== undefined)
            reflectionMergePartial<CreateMFAAuthChallenge>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateMFAAuthChallenge): CreateMFAAuthChallenge {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* string ChallengeScope = 3 [json_name = "ChallengeScope"];*/ 3:
                    message.challengeScope = reader.string();
                    break;
                case /* bool ChallengeAllowReuse = 4 [json_name = "ChallengeAllowReuse"];*/ 4:
                    message.challengeAllowReuse = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateMFAAuthChallenge, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string ChallengeScope = 3 [json_name = "ChallengeScope"]; */
        if (message.challengeScope !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.challengeScope);
        /* bool ChallengeAllowReuse = 4 [json_name = "ChallengeAllowReuse"]; */
        if (message.challengeAllowReuse !== false)
            writer.tag(4, WireType.Varint).bool(message.challengeAllowReuse);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.CreateMFAAuthChallenge
 */
export const CreateMFAAuthChallenge = new CreateMFAAuthChallenge$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateMFAAuthResponse$Type extends MessageType<ValidateMFAAuthResponse> {
    constructor() {
        super("events.ValidateMFAAuthResponse", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "MFADevice", kind: "message", jsonName: "MFADevice", T: () => MFADeviceMetadata, options: { "gogoproto.jsontag": "mfa_device,omitempty" } },
            { no: 5, name: "ChallengeScope", kind: "scalar", jsonName: "ChallengeScope", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "challenge_scope" } },
            { no: 6, name: "ChallengeAllowReuse", kind: "scalar", jsonName: "ChallengeAllowReuse", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "challenge_allow_reuse" } }
        ]);
    }
    create(value?: PartialMessage<ValidateMFAAuthResponse>): ValidateMFAAuthResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.challengeScope = "";
        message.challengeAllowReuse = false;
        if (value !== undefined)
            reflectionMergePartial<ValidateMFAAuthResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidateMFAAuthResponse): ValidateMFAAuthResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.Status Status = 3 [json_name = "Status"];*/ 3:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* events.MFADeviceMetadata MFADevice = 4 [json_name = "MFADevice"];*/ 4:
                    message.mFADevice = MFADeviceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.mFADevice);
                    break;
                case /* string ChallengeScope = 5 [json_name = "ChallengeScope"];*/ 5:
                    message.challengeScope = reader.string();
                    break;
                case /* bool ChallengeAllowReuse = 6 [json_name = "ChallengeAllowReuse"];*/ 6:
                    message.challengeAllowReuse = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValidateMFAAuthResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 3 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.MFADeviceMetadata MFADevice = 4 [json_name = "MFADevice"]; */
        if (message.mFADevice)
            MFADeviceMetadata.internalBinaryWrite(message.mFADevice, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string ChallengeScope = 5 [json_name = "ChallengeScope"]; */
        if (message.challengeScope !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.challengeScope);
        /* bool ChallengeAllowReuse = 6 [json_name = "ChallengeAllowReuse"]; */
        if (message.challengeAllowReuse !== false)
            writer.tag(6, WireType.Varint).bool(message.challengeAllowReuse);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.ValidateMFAAuthResponse
 */
export const ValidateMFAAuthResponse = new ValidateMFAAuthResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResourceMetadata$Type extends MessageType<ResourceMetadata> {
    constructor() {
        super("events.ResourceMetadata", [
            { no: 1, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "name,omitempty" } },
            { no: 2, name: "Expires", kind: "message", jsonName: "Expires", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "expires,omitempty", "gogoproto.stdtime": true } },
            { no: 3, name: "UpdatedBy", kind: "scalar", jsonName: "UpdatedBy", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "updated_by,omitempty" } },
            { no: 4, name: "TTL", kind: "scalar", jsonName: "TTL", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "ttl,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ResourceMetadata>): ResourceMetadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.updatedBy = "";
        message.tTL = "";
        if (value !== undefined)
            reflectionMergePartial<ResourceMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResourceMetadata): ResourceMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Name = 1 [json_name = "Name"];*/ 1:
                    message.name = reader.string();
                    break;
                case /* google.protobuf.Timestamp Expires = 2 [json_name = "Expires"];*/ 2:
                    message.expires = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expires);
                    break;
                case /* string UpdatedBy = 3 [json_name = "UpdatedBy"];*/ 3:
                    message.updatedBy = reader.string();
                    break;
                case /* string TTL = 4 [json_name = "TTL"];*/ 4:
                    message.tTL = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResourceMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Name = 1 [json_name = "Name"]; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* google.protobuf.Timestamp Expires = 2 [json_name = "Expires"]; */
        if (message.expires)
            Timestamp.internalBinaryWrite(message.expires, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string UpdatedBy = 3 [json_name = "UpdatedBy"]; */
        if (message.updatedBy !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.updatedBy);
        /* string TTL = 4 [json_name = "TTL"]; */
        if (message.tTL !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.tTL);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.ResourceMetadata
 */
export const ResourceMetadata = new ResourceMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserCreate$Type extends MessageType<UserCreate> {
    constructor() {
        super("events.UserCreate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Roles", kind: "scalar", jsonName: "Roles", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "roles" } },
            { no: 5, name: "Connector", kind: "scalar", jsonName: "Connector", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "connector" } },
            { no: 6, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<UserCreate>): UserCreate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.roles = [];
        message.connector = "";
        if (value !== undefined)
            reflectionMergePartial<UserCreate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserCreate): UserCreate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ResourceMetadata Resource = 3 [json_name = "Resource"];*/ 3:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* repeated string Roles = 4 [json_name = "Roles"];*/ 4:
                    message.roles.push(reader.string());
                    break;
                case /* string Connector = 5 [json_name = "Connector"];*/ 5:
                    message.connector = reader.string();
                    break;
                case /* events.ConnectionMetadata Connection = 6 [json_name = "Connection"];*/ 6:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserCreate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 3 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated string Roles = 4 [json_name = "Roles"]; */
        for (let i = 0; i < message.roles.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.roles[i]);
        /* string Connector = 5 [json_name = "Connector"]; */
        if (message.connector !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.connector);
        /* events.ConnectionMetadata Connection = 6 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.UserCreate
 */
export const UserCreate = new UserCreate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserUpdate$Type extends MessageType<UserUpdate> {
    constructor() {
        super("events.UserUpdate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Roles", kind: "scalar", jsonName: "Roles", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "roles" } },
            { no: 5, name: "Connector", kind: "scalar", jsonName: "Connector", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "connector" } },
            { no: 6, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<UserUpdate>): UserUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.roles = [];
        message.connector = "";
        if (value !== undefined)
            reflectionMergePartial<UserUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserUpdate): UserUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ResourceMetadata Resource = 3 [json_name = "Resource"];*/ 3:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* repeated string Roles = 4 [json_name = "Roles"];*/ 4:
                    message.roles.push(reader.string());
                    break;
                case /* string Connector = 5 [json_name = "Connector"];*/ 5:
                    message.connector = reader.string();
                    break;
                case /* events.ConnectionMetadata Connection = 6 [json_name = "Connection"];*/ 6:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 3 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated string Roles = 4 [json_name = "Roles"]; */
        for (let i = 0; i < message.roles.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.roles[i]);
        /* string Connector = 5 [json_name = "Connector"]; */
        if (message.connector !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.connector);
        /* events.ConnectionMetadata Connection = 6 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.UserUpdate
 */
export const UserUpdate = new UserUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserDelete$Type extends MessageType<UserDelete> {
    constructor() {
        super("events.UserDelete", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<UserDelete>): UserDelete {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UserDelete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserDelete): UserDelete {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ResourceMetadata Resource = 3 [json_name = "Resource"];*/ 3:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserDelete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 3 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.UserDelete
 */
export const UserDelete = new UserDelete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserPasswordChange$Type extends MessageType<UserPasswordChange> {
    constructor() {
        super("events.UserPasswordChange", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<UserPasswordChange>): UserPasswordChange {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UserPasswordChange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserPasswordChange): UserPasswordChange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 3 [json_name = "Connection"];*/ 3:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserPasswordChange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 3 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.UserPasswordChange
 */
export const UserPasswordChange = new UserPasswordChange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessRequestCreate$Type extends MessageType<AccessRequestCreate> {
    constructor() {
        super("events.AccessRequestCreate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Roles", kind: "scalar", jsonName: "Roles", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "roles,omitempty" } },
            { no: 5, name: "RequestID", kind: "scalar", jsonName: "RequestID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "id" } },
            { no: 6, name: "RequestState", kind: "scalar", jsonName: "RequestState", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "state" } },
            { no: 7, name: "Delegator", kind: "scalar", jsonName: "Delegator", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "delegator,omitempty" } },
            { no: 8, name: "Reason", kind: "scalar", jsonName: "Reason", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "reason,omitempty" } },
            { no: 9, name: "Annotations", kind: "message", jsonName: "Annotations", T: () => Struct, options: { "gogoproto.jsontag": "annotations,omitempty", "gogoproto.casttype": "Struct" } },
            { no: 10, name: "Reviewer", kind: "scalar", jsonName: "Reviewer", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "reviewer,omitempty" } },
            { no: 11, name: "ProposedState", kind: "scalar", jsonName: "ProposedState", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "proposed_state,omitempty" } },
            { no: 12, name: "RequestedResourceIDs", kind: "message", jsonName: "RequestedResourceIDs", repeat: 1 /*RepeatType.PACKED*/, T: () => ResourceID, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "resource_ids,omitempty" } },
            { no: 13, name: "MaxDuration", kind: "message", jsonName: "MaxDuration", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "max_duration,omitempty", "gogoproto.stdtime": true } },
            { no: 15, name: "PromotedAccessListName", kind: "scalar", jsonName: "PromotedAccessListName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "promoted_access_list_name,omitempty" } },
            { no: 16, name: "AssumeStartTime", kind: "message", jsonName: "AssumeStartTime", T: () => Timestamp, options: { "gogoproto.nullable": true, "gogoproto.jsontag": "assume_start_time,omitempty", "gogoproto.stdtime": true } }
        ]);
    }
    create(value?: PartialMessage<AccessRequestCreate>): AccessRequestCreate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.roles = [];
        message.requestID = "";
        message.requestState = "";
        message.delegator = "";
        message.reason = "";
        message.reviewer = "";
        message.proposedState = "";
        message.requestedResourceIDs = [];
        message.promotedAccessListName = "";
        if (value !== undefined)
            reflectionMergePartial<AccessRequestCreate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessRequestCreate): AccessRequestCreate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ResourceMetadata Resource = 3 [json_name = "Resource"];*/ 3:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* repeated string Roles = 4 [json_name = "Roles"];*/ 4:
                    message.roles.push(reader.string());
                    break;
                case /* string RequestID = 5 [json_name = "RequestID"];*/ 5:
                    message.requestID = reader.string();
                    break;
                case /* string RequestState = 6 [json_name = "RequestState"];*/ 6:
                    message.requestState = reader.string();
                    break;
                case /* string Delegator = 7 [json_name = "Delegator"];*/ 7:
                    message.delegator = reader.string();
                    break;
                case /* string Reason = 8 [json_name = "Reason"];*/ 8:
                    message.reason = reader.string();
                    break;
                case /* google.protobuf.Struct Annotations = 9 [json_name = "Annotations"];*/ 9:
                    message.annotations = Struct.internalBinaryRead(reader, reader.uint32(), options, message.annotations);
                    break;
                case /* string Reviewer = 10 [json_name = "Reviewer"];*/ 10:
                    message.reviewer = reader.string();
                    break;
                case /* string ProposedState = 11 [json_name = "ProposedState"];*/ 11:
                    message.proposedState = reader.string();
                    break;
                case /* repeated events.ResourceID RequestedResourceIDs = 12 [json_name = "RequestedResourceIDs"];*/ 12:
                    message.requestedResourceIDs.push(ResourceID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.Timestamp MaxDuration = 13 [json_name = "MaxDuration"];*/ 13:
                    message.maxDuration = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.maxDuration);
                    break;
                case /* string PromotedAccessListName = 15 [json_name = "PromotedAccessListName"];*/ 15:
                    message.promotedAccessListName = reader.string();
                    break;
                case /* google.protobuf.Timestamp AssumeStartTime = 16 [json_name = "AssumeStartTime"];*/ 16:
                    message.assumeStartTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.assumeStartTime);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessRequestCreate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 3 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated string Roles = 4 [json_name = "Roles"]; */
        for (let i = 0; i < message.roles.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.roles[i]);
        /* string RequestID = 5 [json_name = "RequestID"]; */
        if (message.requestID !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.requestID);
        /* string RequestState = 6 [json_name = "RequestState"]; */
        if (message.requestState !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.requestState);
        /* string Delegator = 7 [json_name = "Delegator"]; */
        if (message.delegator !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.delegator);
        /* string Reason = 8 [json_name = "Reason"]; */
        if (message.reason !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.reason);
        /* google.protobuf.Struct Annotations = 9 [json_name = "Annotations"]; */
        if (message.annotations)
            Struct.internalBinaryWrite(message.annotations, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* string Reviewer = 10 [json_name = "Reviewer"]; */
        if (message.reviewer !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.reviewer);
        /* string ProposedState = 11 [json_name = "ProposedState"]; */
        if (message.proposedState !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.proposedState);
        /* repeated events.ResourceID RequestedResourceIDs = 12 [json_name = "RequestedResourceIDs"]; */
        for (let i = 0; i < message.requestedResourceIDs.length; i++)
            ResourceID.internalBinaryWrite(message.requestedResourceIDs[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp MaxDuration = 13 [json_name = "MaxDuration"]; */
        if (message.maxDuration)
            Timestamp.internalBinaryWrite(message.maxDuration, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* string PromotedAccessListName = 15 [json_name = "PromotedAccessListName"]; */
        if (message.promotedAccessListName !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.promotedAccessListName);
        /* google.protobuf.Timestamp AssumeStartTime = 16 [json_name = "AssumeStartTime"]; */
        if (message.assumeStartTime)
            Timestamp.internalBinaryWrite(message.assumeStartTime, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.AccessRequestCreate
 */
export const AccessRequestCreate = new AccessRequestCreate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessRequestExpire$Type extends MessageType<AccessRequestExpire> {
    constructor() {
        super("events.AccessRequestExpire", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "RequestID", kind: "scalar", jsonName: "RequestID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "id" } },
            { no: 4, name: "ResourceExpiry", kind: "message", jsonName: "ResourceExpiry", T: () => Timestamp, options: { "gogoproto.nullable": true, "gogoproto.jsontag": "expiry,omitempty", "gogoproto.stdtime": true } }
        ]);
    }
    create(value?: PartialMessage<AccessRequestExpire>): AccessRequestExpire {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.requestID = "";
        if (value !== undefined)
            reflectionMergePartial<AccessRequestExpire>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessRequestExpire): AccessRequestExpire {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* string RequestID = 3 [json_name = "RequestID"];*/ 3:
                    message.requestID = reader.string();
                    break;
                case /* google.protobuf.Timestamp ResourceExpiry = 4 [json_name = "ResourceExpiry"];*/ 4:
                    message.resourceExpiry = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.resourceExpiry);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessRequestExpire, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string RequestID = 3 [json_name = "RequestID"]; */
        if (message.requestID !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.requestID);
        /* google.protobuf.Timestamp ResourceExpiry = 4 [json_name = "ResourceExpiry"]; */
        if (message.resourceExpiry)
            Timestamp.internalBinaryWrite(message.resourceExpiry, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.AccessRequestExpire
 */
export const AccessRequestExpire = new AccessRequestExpire$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResourceID$Type extends MessageType<ResourceID> {
    constructor() {
        super("events.ResourceID", [
            { no: 1, name: "ClusterName", kind: "scalar", jsonName: "ClusterName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "cluster" } },
            { no: 2, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 3, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "name" } },
            { no: 4, name: "SubResourceName", kind: "scalar", jsonName: "SubResourceName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub_resource,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ResourceID>): ResourceID {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterName = "";
        message.kind = "";
        message.name = "";
        message.subResourceName = "";
        if (value !== undefined)
            reflectionMergePartial<ResourceID>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResourceID): ResourceID {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ClusterName = 1 [json_name = "ClusterName"];*/ 1:
                    message.clusterName = reader.string();
                    break;
                case /* string Kind = 2 [json_name = "Kind"];*/ 2:
                    message.kind = reader.string();
                    break;
                case /* string Name = 3 [json_name = "Name"];*/ 3:
                    message.name = reader.string();
                    break;
                case /* string SubResourceName = 4 [json_name = "SubResourceName"];*/ 4:
                    message.subResourceName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResourceID, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ClusterName = 1 [json_name = "ClusterName"]; */
        if (message.clusterName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterName);
        /* string Kind = 2 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.kind);
        /* string Name = 3 [json_name = "Name"]; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string SubResourceName = 4 [json_name = "SubResourceName"]; */
        if (message.subResourceName !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.subResourceName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.ResourceID
 */
export const ResourceID = new ResourceID$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessRequestDelete$Type extends MessageType<AccessRequestDelete> {
    constructor() {
        super("events.AccessRequestDelete", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "RequestID", kind: "scalar", jsonName: "RequestID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "id" } }
        ]);
    }
    create(value?: PartialMessage<AccessRequestDelete>): AccessRequestDelete {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.requestID = "";
        if (value !== undefined)
            reflectionMergePartial<AccessRequestDelete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessRequestDelete): AccessRequestDelete {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* string RequestID = 3 [json_name = "RequestID"];*/ 3:
                    message.requestID = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessRequestDelete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string RequestID = 3 [json_name = "RequestID"]; */
        if (message.requestID !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.requestID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.AccessRequestDelete
 */
export const AccessRequestDelete = new AccessRequestDelete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PortForward$Type extends MessageType<PortForward> {
    constructor() {
        super("events.PortForward", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Addr", kind: "scalar", jsonName: "Addr", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "addr" } },
            { no: 6, name: "KubernetesCluster", kind: "message", jsonName: "KubernetesCluster", T: () => KubernetesClusterMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 7, name: "KubernetesPod", kind: "message", jsonName: "KubernetesPod", T: () => KubernetesPodMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<PortForward>): PortForward {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.addr = "";
        if (value !== undefined)
            reflectionMergePartial<PortForward>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PortForward): PortForward {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 3 [json_name = "Connection"];*/ 3:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* events.Status Status = 4 [json_name = "Status"];*/ 4:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* string Addr = 5 [json_name = "Addr"];*/ 5:
                    message.addr = reader.string();
                    break;
                case /* events.KubernetesClusterMetadata KubernetesCluster = 6 [json_name = "KubernetesCluster"];*/ 6:
                    message.kubernetesCluster = KubernetesClusterMetadata.internalBinaryRead(reader, reader.uint32(), options, message.kubernetesCluster);
                    break;
                case /* events.KubernetesPodMetadata KubernetesPod = 7 [json_name = "KubernetesPod"];*/ 7:
                    message.kubernetesPod = KubernetesPodMetadata.internalBinaryRead(reader, reader.uint32(), options, message.kubernetesPod);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PortForward, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 3 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 4 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string Addr = 5 [json_name = "Addr"]; */
        if (message.addr !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.addr);
        /* events.KubernetesClusterMetadata KubernetesCluster = 6 [json_name = "KubernetesCluster"]; */
        if (message.kubernetesCluster)
            KubernetesClusterMetadata.internalBinaryWrite(message.kubernetesCluster, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* events.KubernetesPodMetadata KubernetesPod = 7 [json_name = "KubernetesPod"]; */
        if (message.kubernetesPod)
            KubernetesPodMetadata.internalBinaryWrite(message.kubernetesPod, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.PortForward
 */
export const PortForward = new PortForward$Type();
// @generated message type with reflection information, may provide speed optimized methods
class X11Forward$Type extends MessageType<X11Forward> {
    constructor() {
        super("events.X11Forward", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<X11Forward>): X11Forward {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<X11Forward>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: X11Forward): X11Forward {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 3 [json_name = "Connection"];*/ 3:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* events.Status Status = 4 [json_name = "Status"];*/ 4:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: X11Forward, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 3 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 4 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.X11Forward
 */
export const X11Forward = new X11Forward$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandMetadata$Type extends MessageType<CommandMetadata> {
    constructor() {
        super("events.CommandMetadata", [
            { no: 1, name: "Command", kind: "scalar", jsonName: "Command", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "command" } },
            { no: 2, name: "ExitCode", kind: "scalar", jsonName: "ExitCode", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "exitCode,omitempty" } },
            { no: 3, name: "Error", kind: "scalar", jsonName: "Error", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "exitError,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<CommandMetadata>): CommandMetadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.command = "";
        message.exitCode = "";
        message.error = "";
        if (value !== undefined)
            reflectionMergePartial<CommandMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CommandMetadata): CommandMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Command = 1 [json_name = "Command"];*/ 1:
                    message.command = reader.string();
                    break;
                case /* string ExitCode = 2 [json_name = "ExitCode"];*/ 2:
                    message.exitCode = reader.string();
                    break;
                case /* string Error = 3 [json_name = "Error"];*/ 3:
                    message.error = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CommandMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Command = 1 [json_name = "Command"]; */
        if (message.command !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.command);
        /* string ExitCode = 2 [json_name = "ExitCode"]; */
        if (message.exitCode !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.exitCode);
        /* string Error = 3 [json_name = "Error"]; */
        if (message.error !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.CommandMetadata
 */
export const CommandMetadata = new CommandMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Exec$Type extends MessageType<Exec> {
    constructor() {
        super("events.Exec", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Server", kind: "message", jsonName: "Server", T: () => ServerMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 6, name: "Command", kind: "message", jsonName: "Command", T: () => CommandMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 7, name: "KubernetesCluster", kind: "message", jsonName: "KubernetesCluster", T: () => KubernetesClusterMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 8, name: "KubernetesPod", kind: "message", jsonName: "KubernetesPod", T: () => KubernetesPodMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<Exec>): Exec {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Exec>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Exec): Exec {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 3 [json_name = "Connection"];*/ 3:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* events.SessionMetadata Session = 4 [json_name = "Session"];*/ 4:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.ServerMetadata Server = 5 [json_name = "Server"];*/ 5:
                    message.server = ServerMetadata.internalBinaryRead(reader, reader.uint32(), options, message.server);
                    break;
                case /* events.CommandMetadata Command = 6 [json_name = "Command"];*/ 6:
                    message.command = CommandMetadata.internalBinaryRead(reader, reader.uint32(), options, message.command);
                    break;
                case /* events.KubernetesClusterMetadata KubernetesCluster = 7 [json_name = "KubernetesCluster"];*/ 7:
                    message.kubernetesCluster = KubernetesClusterMetadata.internalBinaryRead(reader, reader.uint32(), options, message.kubernetesCluster);
                    break;
                case /* events.KubernetesPodMetadata KubernetesPod = 8 [json_name = "KubernetesPod"];*/ 8:
                    message.kubernetesPod = KubernetesPodMetadata.internalBinaryRead(reader, reader.uint32(), options, message.kubernetesPod);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Exec, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 3 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 4 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.ServerMetadata Server = 5 [json_name = "Server"]; */
        if (message.server)
            ServerMetadata.internalBinaryWrite(message.server, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* events.CommandMetadata Command = 6 [json_name = "Command"]; */
        if (message.command)
            CommandMetadata.internalBinaryWrite(message.command, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* events.KubernetesClusterMetadata KubernetesCluster = 7 [json_name = "KubernetesCluster"]; */
        if (message.kubernetesCluster)
            KubernetesClusterMetadata.internalBinaryWrite(message.kubernetesCluster, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* events.KubernetesPodMetadata KubernetesPod = 8 [json_name = "KubernetesPod"]; */
        if (message.kubernetesPod)
            KubernetesPodMetadata.internalBinaryWrite(message.kubernetesPod, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.Exec
 */
export const Exec = new Exec$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SCP$Type extends MessageType<SCP> {
    constructor() {
        super("events.SCP", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Server", kind: "message", jsonName: "Server", T: () => ServerMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 6, name: "Command", kind: "message", jsonName: "Command", T: () => CommandMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 7, name: "Path", kind: "scalar", jsonName: "Path", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "path" } },
            { no: 8, name: "Action", kind: "scalar", jsonName: "Action", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "action" } }
        ]);
    }
    create(value?: PartialMessage<SCP>): SCP {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.path = "";
        message.action = "";
        if (value !== undefined)
            reflectionMergePartial<SCP>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SCP): SCP {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 3 [json_name = "Connection"];*/ 3:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* events.SessionMetadata Session = 4 [json_name = "Session"];*/ 4:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.ServerMetadata Server = 5 [json_name = "Server"];*/ 5:
                    message.server = ServerMetadata.internalBinaryRead(reader, reader.uint32(), options, message.server);
                    break;
                case /* events.CommandMetadata Command = 6 [json_name = "Command"];*/ 6:
                    message.command = CommandMetadata.internalBinaryRead(reader, reader.uint32(), options, message.command);
                    break;
                case /* string Path = 7 [json_name = "Path"];*/ 7:
                    message.path = reader.string();
                    break;
                case /* string Action = 8 [json_name = "Action"];*/ 8:
                    message.action = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SCP, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 3 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 4 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.ServerMetadata Server = 5 [json_name = "Server"]; */
        if (message.server)
            ServerMetadata.internalBinaryWrite(message.server, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* events.CommandMetadata Command = 6 [json_name = "Command"]; */
        if (message.command)
            CommandMetadata.internalBinaryWrite(message.command, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* string Path = 7 [json_name = "Path"]; */
        if (message.path !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.path);
        /* string Action = 8 [json_name = "Action"]; */
        if (message.action !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.action);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.SCP
 */
export const SCP = new SCP$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SFTPAttributes$Type extends MessageType<SFTPAttributes> {
    constructor() {
        super("events.SFTPAttributes", [
            { no: 1, name: "FileSize", kind: "message", jsonName: "FileSize", T: () => UInt64Value, options: { "gogoproto.jsontag": "file_size", "gogoproto.wktpointer": true } },
            { no: 2, name: "UID", kind: "message", jsonName: "UID", T: () => UInt32Value, options: { "gogoproto.jsontag": "uid", "gogoproto.wktpointer": true } },
            { no: 3, name: "GID", kind: "message", jsonName: "GID", T: () => UInt32Value, options: { "gogoproto.jsontag": "gid", "gogoproto.wktpointer": true } },
            { no: 4, name: "Permissions", kind: "message", jsonName: "Permissions", T: () => UInt32Value, options: { "gogoproto.jsontag": "permissions", "gogoproto.wktpointer": true } },
            { no: 5, name: "AccessTime", kind: "message", jsonName: "AccessTime", T: () => Timestamp, options: { "gogoproto.jsontag": "access_time,omitempty", "gogoproto.stdtime": true } },
            { no: 6, name: "ModificationTime", kind: "message", jsonName: "ModificationTime", T: () => Timestamp, options: { "gogoproto.jsontag": "modification_time,omitempty", "gogoproto.stdtime": true } }
        ]);
    }
    create(value?: PartialMessage<SFTPAttributes>): SFTPAttributes {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SFTPAttributes>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SFTPAttributes): SFTPAttributes {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.UInt64Value FileSize = 1 [json_name = "FileSize"];*/ 1:
                    message.fileSize = UInt64Value.internalBinaryRead(reader, reader.uint32(), options, message.fileSize);
                    break;
                case /* google.protobuf.UInt32Value UID = 2 [json_name = "UID"];*/ 2:
                    message.uID = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.uID);
                    break;
                case /* google.protobuf.UInt32Value GID = 3 [json_name = "GID"];*/ 3:
                    message.gID = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.gID);
                    break;
                case /* google.protobuf.UInt32Value Permissions = 4 [json_name = "Permissions"];*/ 4:
                    message.permissions = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.permissions);
                    break;
                case /* google.protobuf.Timestamp AccessTime = 5 [json_name = "AccessTime"];*/ 5:
                    message.accessTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.accessTime);
                    break;
                case /* google.protobuf.Timestamp ModificationTime = 6 [json_name = "ModificationTime"];*/ 6:
                    message.modificationTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.modificationTime);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SFTPAttributes, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.UInt64Value FileSize = 1 [json_name = "FileSize"]; */
        if (message.fileSize)
            UInt64Value.internalBinaryWrite(message.fileSize, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value UID = 2 [json_name = "UID"]; */
        if (message.uID)
            UInt32Value.internalBinaryWrite(message.uID, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value GID = 3 [json_name = "GID"]; */
        if (message.gID)
            UInt32Value.internalBinaryWrite(message.gID, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value Permissions = 4 [json_name = "Permissions"]; */
        if (message.permissions)
            UInt32Value.internalBinaryWrite(message.permissions, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp AccessTime = 5 [json_name = "AccessTime"]; */
        if (message.accessTime)
            Timestamp.internalBinaryWrite(message.accessTime, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp ModificationTime = 6 [json_name = "ModificationTime"]; */
        if (message.modificationTime)
            Timestamp.internalBinaryWrite(message.modificationTime, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.SFTPAttributes
 */
export const SFTPAttributes = new SFTPAttributes$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SFTP$Type extends MessageType<SFTP> {
    constructor() {
        super("events.SFTP", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Server", kind: "message", jsonName: "Server", T: () => ServerMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 6, name: "WorkingDirectory", kind: "scalar", jsonName: "WorkingDirectory", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "working_directory" } },
            { no: 7, name: "Path", kind: "scalar", jsonName: "Path", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "path" } },
            { no: 8, name: "TargetPath", kind: "scalar", jsonName: "TargetPath", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "target_path,omitempty" } },
            { no: 9, name: "Flags", kind: "scalar", jsonName: "Flags", T: 13 /*ScalarType.UINT32*/, options: { "gogoproto.jsontag": "flags,omitempty" } },
            { no: 10, name: "Attributes", kind: "message", jsonName: "Attributes", T: () => SFTPAttributes, options: { "gogoproto.jsontag": "attributes,omitempty" } },
            { no: 11, name: "Action", kind: "enum", jsonName: "Action", T: () => ["events.SFTPAction", SFTPAction], options: { "gogoproto.jsontag": "action" } },
            { no: 12, name: "Error", kind: "scalar", jsonName: "Error", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "error,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<SFTP>): SFTP {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workingDirectory = "";
        message.path = "";
        message.targetPath = "";
        message.flags = 0;
        message.action = 0;
        message.error = "";
        if (value !== undefined)
            reflectionMergePartial<SFTP>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SFTP): SFTP {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 3 [json_name = "Connection"];*/ 3:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* events.SessionMetadata Session = 4 [json_name = "Session"];*/ 4:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.ServerMetadata Server = 5 [json_name = "Server"];*/ 5:
                    message.server = ServerMetadata.internalBinaryRead(reader, reader.uint32(), options, message.server);
                    break;
                case /* string WorkingDirectory = 6 [json_name = "WorkingDirectory"];*/ 6:
                    message.workingDirectory = reader.string();
                    break;
                case /* string Path = 7 [json_name = "Path"];*/ 7:
                    message.path = reader.string();
                    break;
                case /* string TargetPath = 8 [json_name = "TargetPath"];*/ 8:
                    message.targetPath = reader.string();
                    break;
                case /* uint32 Flags = 9 [json_name = "Flags"];*/ 9:
                    message.flags = reader.uint32();
                    break;
                case /* events.SFTPAttributes Attributes = 10 [json_name = "Attributes"];*/ 10:
                    message.attributes = SFTPAttributes.internalBinaryRead(reader, reader.uint32(), options, message.attributes);
                    break;
                case /* events.SFTPAction Action = 11 [json_name = "Action"];*/ 11:
                    message.action = reader.int32();
                    break;
                case /* string Error = 12 [json_name = "Error"];*/ 12:
                    message.error = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SFTP, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 3 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 4 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.ServerMetadata Server = 5 [json_name = "Server"]; */
        if (message.server)
            ServerMetadata.internalBinaryWrite(message.server, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string WorkingDirectory = 6 [json_name = "WorkingDirectory"]; */
        if (message.workingDirectory !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.workingDirectory);
        /* string Path = 7 [json_name = "Path"]; */
        if (message.path !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.path);
        /* string TargetPath = 8 [json_name = "TargetPath"]; */
        if (message.targetPath !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.targetPath);
        /* uint32 Flags = 9 [json_name = "Flags"]; */
        if (message.flags !== 0)
            writer.tag(9, WireType.Varint).uint32(message.flags);
        /* events.SFTPAttributes Attributes = 10 [json_name = "Attributes"]; */
        if (message.attributes)
            SFTPAttributes.internalBinaryWrite(message.attributes, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* events.SFTPAction Action = 11 [json_name = "Action"]; */
        if (message.action !== 0)
            writer.tag(11, WireType.Varint).int32(message.action);
        /* string Error = 12 [json_name = "Error"]; */
        if (message.error !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.SFTP
 */
export const SFTP = new SFTP$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SFTPSummary$Type extends MessageType<SFTPSummary> {
    constructor() {
        super("events.SFTPSummary", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Server", kind: "message", jsonName: "Server", T: () => ServerMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 6, name: "FileTransferStats", kind: "message", jsonName: "FileTransferStats", repeat: 1 /*RepeatType.PACKED*/, T: () => FileTransferStat, options: { "gogoproto.jsontag": "file_transfer_stats" } }
        ]);
    }
    create(value?: PartialMessage<SFTPSummary>): SFTPSummary {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fileTransferStats = [];
        if (value !== undefined)
            reflectionMergePartial<SFTPSummary>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SFTPSummary): SFTPSummary {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 3 [json_name = "Connection"];*/ 3:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* events.SessionMetadata Session = 4 [json_name = "Session"];*/ 4:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.ServerMetadata Server = 5 [json_name = "Server"];*/ 5:
                    message.server = ServerMetadata.internalBinaryRead(reader, reader.uint32(), options, message.server);
                    break;
                case /* repeated events.FileTransferStat FileTransferStats = 6 [json_name = "FileTransferStats"];*/ 6:
                    message.fileTransferStats.push(FileTransferStat.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SFTPSummary, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 3 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 4 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.ServerMetadata Server = 5 [json_name = "Server"]; */
        if (message.server)
            ServerMetadata.internalBinaryWrite(message.server, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated events.FileTransferStat FileTransferStats = 6 [json_name = "FileTransferStats"]; */
        for (let i = 0; i < message.fileTransferStats.length; i++)
            FileTransferStat.internalBinaryWrite(message.fileTransferStats[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.SFTPSummary
 */
export const SFTPSummary = new SFTPSummary$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FileTransferStat$Type extends MessageType<FileTransferStat> {
    constructor() {
        super("events.FileTransferStat", [
            { no: 1, name: "Path", kind: "scalar", jsonName: "Path", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "path" } },
            { no: 2, name: "BytesRead", kind: "scalar", jsonName: "BytesRead", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "bytes_read" } },
            { no: 3, name: "BytesWritten", kind: "scalar", jsonName: "BytesWritten", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "bytes_written" } }
        ]);
    }
    create(value?: PartialMessage<FileTransferStat>): FileTransferStat {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.path = "";
        message.bytesRead = 0n;
        message.bytesWritten = 0n;
        if (value !== undefined)
            reflectionMergePartial<FileTransferStat>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FileTransferStat): FileTransferStat {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Path = 1 [json_name = "Path"];*/ 1:
                    message.path = reader.string();
                    break;
                case /* uint64 BytesRead = 2 [json_name = "BytesRead"];*/ 2:
                    message.bytesRead = reader.uint64().toBigInt();
                    break;
                case /* uint64 BytesWritten = 3 [json_name = "BytesWritten"];*/ 3:
                    message.bytesWritten = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FileTransferStat, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Path = 1 [json_name = "Path"]; */
        if (message.path !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.path);
        /* uint64 BytesRead = 2 [json_name = "BytesRead"]; */
        if (message.bytesRead !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.bytesRead);
        /* uint64 BytesWritten = 3 [json_name = "BytesWritten"]; */
        if (message.bytesWritten !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.bytesWritten);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.FileTransferStat
 */
export const FileTransferStat = new FileTransferStat$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Subsystem$Type extends MessageType<Subsystem> {
    constructor() {
        super("events.Subsystem", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "name" } },
            { no: 5, name: "Error", kind: "scalar", jsonName: "Error", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "exitError" } },
            { no: 6, name: "Server", kind: "message", jsonName: "Server", T: () => ServerMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<Subsystem>): Subsystem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.error = "";
        if (value !== undefined)
            reflectionMergePartial<Subsystem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Subsystem): Subsystem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 3 [json_name = "Connection"];*/ 3:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* string Name = 4 [json_name = "Name"];*/ 4:
                    message.name = reader.string();
                    break;
                case /* string Error = 5 [json_name = "Error"];*/ 5:
                    message.error = reader.string();
                    break;
                case /* events.ServerMetadata Server = 6 [json_name = "Server"];*/ 6:
                    message.server = ServerMetadata.internalBinaryRead(reader, reader.uint32(), options, message.server);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Subsystem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 3 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string Name = 4 [json_name = "Name"]; */
        if (message.name !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.name);
        /* string Error = 5 [json_name = "Error"]; */
        if (message.error !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.error);
        /* events.ServerMetadata Server = 6 [json_name = "Server"]; */
        if (message.server)
            ServerMetadata.internalBinaryWrite(message.server, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.Subsystem
 */
export const Subsystem = new Subsystem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClientDisconnect$Type extends MessageType<ClientDisconnect> {
    constructor() {
        super("events.ClientDisconnect", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Server", kind: "message", jsonName: "Server", T: () => ServerMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Reason", kind: "scalar", jsonName: "Reason", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "reason" } }
        ]);
    }
    create(value?: PartialMessage<ClientDisconnect>): ClientDisconnect {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.reason = "";
        if (value !== undefined)
            reflectionMergePartial<ClientDisconnect>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClientDisconnect): ClientDisconnect {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 3 [json_name = "Connection"];*/ 3:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* events.ServerMetadata Server = 4 [json_name = "Server"];*/ 4:
                    message.server = ServerMetadata.internalBinaryRead(reader, reader.uint32(), options, message.server);
                    break;
                case /* string Reason = 5 [json_name = "Reason"];*/ 5:
                    message.reason = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClientDisconnect, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 3 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ServerMetadata Server = 4 [json_name = "Server"]; */
        if (message.server)
            ServerMetadata.internalBinaryWrite(message.server, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string Reason = 5 [json_name = "Reason"]; */
        if (message.reason !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.reason);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.ClientDisconnect
 */
export const ClientDisconnect = new ClientDisconnect$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthAttempt$Type extends MessageType<AuthAttempt> {
    constructor() {
        super("events.AuthAttempt", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<AuthAttempt>): AuthAttempt {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AuthAttempt>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthAttempt): AuthAttempt {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 3 [json_name = "Connection"];*/ 3:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* events.Status Status = 4 [json_name = "Status"];*/ 4:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthAttempt, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 3 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 4 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.AuthAttempt
 */
export const AuthAttempt = new AuthAttempt$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserTokenCreate$Type extends MessageType<UserTokenCreate> {
    constructor() {
        super("events.UserTokenCreate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<UserTokenCreate>): UserTokenCreate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UserTokenCreate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserTokenCreate): UserTokenCreate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserTokenCreate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.UserTokenCreate
 */
export const UserTokenCreate = new UserTokenCreate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RoleCreate$Type extends MessageType<RoleCreate> {
    constructor() {
        super("events.RoleCreate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<RoleCreate>): RoleCreate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RoleCreate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RoleCreate): RoleCreate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RoleCreate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.RoleCreate
 */
export const RoleCreate = new RoleCreate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RoleUpdate$Type extends MessageType<RoleUpdate> {
    constructor() {
        super("events.RoleUpdate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<RoleUpdate>): RoleUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RoleUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RoleUpdate): RoleUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RoleUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.RoleUpdate
 */
export const RoleUpdate = new RoleUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RoleDelete$Type extends MessageType<RoleDelete> {
    constructor() {
        super("events.RoleDelete", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<RoleDelete>): RoleDelete {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RoleDelete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RoleDelete): RoleDelete {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RoleDelete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.RoleDelete
 */
export const RoleDelete = new RoleDelete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotCreate$Type extends MessageType<BotCreate> {
    constructor() {
        super("events.BotCreate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<BotCreate>): BotCreate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<BotCreate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BotCreate): BotCreate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BotCreate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.BotCreate
 */
export const BotCreate = new BotCreate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotUpdate$Type extends MessageType<BotUpdate> {
    constructor() {
        super("events.BotUpdate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<BotUpdate>): BotUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<BotUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BotUpdate): BotUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BotUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.BotUpdate
 */
export const BotUpdate = new BotUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotDelete$Type extends MessageType<BotDelete> {
    constructor() {
        super("events.BotDelete", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<BotDelete>): BotDelete {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<BotDelete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BotDelete): BotDelete {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BotDelete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.BotDelete
 */
export const BotDelete = new BotDelete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrustedClusterCreate$Type extends MessageType<TrustedClusterCreate> {
    constructor() {
        super("events.TrustedClusterCreate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<TrustedClusterCreate>): TrustedClusterCreate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TrustedClusterCreate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrustedClusterCreate): TrustedClusterCreate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrustedClusterCreate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.TrustedClusterCreate
 */
export const TrustedClusterCreate = new TrustedClusterCreate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrustedClusterDelete$Type extends MessageType<TrustedClusterDelete> {
    constructor() {
        super("events.TrustedClusterDelete", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<TrustedClusterDelete>): TrustedClusterDelete {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TrustedClusterDelete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrustedClusterDelete): TrustedClusterDelete {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrustedClusterDelete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.TrustedClusterDelete
 */
export const TrustedClusterDelete = new TrustedClusterDelete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProvisionTokenCreate$Type extends MessageType<ProvisionTokenCreate> {
    constructor() {
        super("events.ProvisionTokenCreate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Roles", kind: "scalar", jsonName: "Roles", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "roles,omitempty", "gogoproto.casttype": "github.com/gravitational/teleport/api/types.SystemRole" } },
            { no: 5, name: "JoinMethod", kind: "scalar", jsonName: "JoinMethod", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "join_method,omitempty", "gogoproto.casttype": "github.com/gravitational/teleport/api/types.JoinMethod" } }
        ]);
    }
    create(value?: PartialMessage<ProvisionTokenCreate>): ProvisionTokenCreate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.roles = [];
        message.joinMethod = "";
        if (value !== undefined)
            reflectionMergePartial<ProvisionTokenCreate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProvisionTokenCreate): ProvisionTokenCreate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* repeated string Roles = 4 [json_name = "Roles"];*/ 4:
                    message.roles.push(reader.string());
                    break;
                case /* string JoinMethod = 5 [json_name = "JoinMethod"];*/ 5:
                    message.joinMethod = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProvisionTokenCreate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated string Roles = 4 [json_name = "Roles"]; */
        for (let i = 0; i < message.roles.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.roles[i]);
        /* string JoinMethod = 5 [json_name = "JoinMethod"]; */
        if (message.joinMethod !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.joinMethod);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.ProvisionTokenCreate
 */
export const ProvisionTokenCreate = new ProvisionTokenCreate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrustedClusterTokenCreate$Type extends MessageType<TrustedClusterTokenCreate> {
    constructor() {
        super("events.TrustedClusterTokenCreate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<TrustedClusterTokenCreate>): TrustedClusterTokenCreate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TrustedClusterTokenCreate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrustedClusterTokenCreate): TrustedClusterTokenCreate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrustedClusterTokenCreate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.TrustedClusterTokenCreate
 */
export const TrustedClusterTokenCreate = new TrustedClusterTokenCreate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GithubConnectorCreate$Type extends MessageType<GithubConnectorCreate> {
    constructor() {
        super("events.GithubConnectorCreate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<GithubConnectorCreate>): GithubConnectorCreate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GithubConnectorCreate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GithubConnectorCreate): GithubConnectorCreate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GithubConnectorCreate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.GithubConnectorCreate
 */
export const GithubConnectorCreate = new GithubConnectorCreate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GithubConnectorUpdate$Type extends MessageType<GithubConnectorUpdate> {
    constructor() {
        super("events.GithubConnectorUpdate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<GithubConnectorUpdate>): GithubConnectorUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GithubConnectorUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GithubConnectorUpdate): GithubConnectorUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GithubConnectorUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.GithubConnectorUpdate
 */
export const GithubConnectorUpdate = new GithubConnectorUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GithubConnectorDelete$Type extends MessageType<GithubConnectorDelete> {
    constructor() {
        super("events.GithubConnectorDelete", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<GithubConnectorDelete>): GithubConnectorDelete {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GithubConnectorDelete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GithubConnectorDelete): GithubConnectorDelete {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GithubConnectorDelete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.GithubConnectorDelete
 */
export const GithubConnectorDelete = new GithubConnectorDelete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OIDCConnectorCreate$Type extends MessageType<OIDCConnectorCreate> {
    constructor() {
        super("events.OIDCConnectorCreate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<OIDCConnectorCreate>): OIDCConnectorCreate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<OIDCConnectorCreate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OIDCConnectorCreate): OIDCConnectorCreate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OIDCConnectorCreate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.OIDCConnectorCreate
 */
export const OIDCConnectorCreate = new OIDCConnectorCreate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OIDCConnectorUpdate$Type extends MessageType<OIDCConnectorUpdate> {
    constructor() {
        super("events.OIDCConnectorUpdate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<OIDCConnectorUpdate>): OIDCConnectorUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<OIDCConnectorUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OIDCConnectorUpdate): OIDCConnectorUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OIDCConnectorUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.OIDCConnectorUpdate
 */
export const OIDCConnectorUpdate = new OIDCConnectorUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OIDCConnectorDelete$Type extends MessageType<OIDCConnectorDelete> {
    constructor() {
        super("events.OIDCConnectorDelete", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<OIDCConnectorDelete>): OIDCConnectorDelete {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<OIDCConnectorDelete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OIDCConnectorDelete): OIDCConnectorDelete {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OIDCConnectorDelete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.OIDCConnectorDelete
 */
export const OIDCConnectorDelete = new OIDCConnectorDelete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SAMLConnectorCreate$Type extends MessageType<SAMLConnectorCreate> {
    constructor() {
        super("events.SAMLConnectorCreate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connector", kind: "message", jsonName: "Connector", T: () => SAMLConnectorV2, options: { "gogoproto.jsontag": "connector" } }
        ]);
    }
    create(value?: PartialMessage<SAMLConnectorCreate>): SAMLConnectorCreate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SAMLConnectorCreate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SAMLConnectorCreate): SAMLConnectorCreate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* types.SAMLConnectorV2 Connector = 4 [json_name = "Connector"];*/ 4:
                    message.connector = SAMLConnectorV2.internalBinaryRead(reader, reader.uint32(), options, message.connector);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SAMLConnectorCreate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* types.SAMLConnectorV2 Connector = 4 [json_name = "Connector"]; */
        if (message.connector)
            SAMLConnectorV2.internalBinaryWrite(message.connector, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.SAMLConnectorCreate
 */
export const SAMLConnectorCreate = new SAMLConnectorCreate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SAMLConnectorUpdate$Type extends MessageType<SAMLConnectorUpdate> {
    constructor() {
        super("events.SAMLConnectorUpdate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connector", kind: "message", jsonName: "Connector", T: () => SAMLConnectorV2, options: { "gogoproto.jsontag": "connector" } }
        ]);
    }
    create(value?: PartialMessage<SAMLConnectorUpdate>): SAMLConnectorUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SAMLConnectorUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SAMLConnectorUpdate): SAMLConnectorUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* types.SAMLConnectorV2 Connector = 4 [json_name = "Connector"];*/ 4:
                    message.connector = SAMLConnectorV2.internalBinaryRead(reader, reader.uint32(), options, message.connector);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SAMLConnectorUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* types.SAMLConnectorV2 Connector = 4 [json_name = "Connector"]; */
        if (message.connector)
            SAMLConnectorV2.internalBinaryWrite(message.connector, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.SAMLConnectorUpdate
 */
export const SAMLConnectorUpdate = new SAMLConnectorUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SAMLConnectorDelete$Type extends MessageType<SAMLConnectorDelete> {
    constructor() {
        super("events.SAMLConnectorDelete", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<SAMLConnectorDelete>): SAMLConnectorDelete {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SAMLConnectorDelete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SAMLConnectorDelete): SAMLConnectorDelete {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SAMLConnectorDelete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.SAMLConnectorDelete
 */
export const SAMLConnectorDelete = new SAMLConnectorDelete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class KubeRequest$Type extends MessageType<KubeRequest> {
    constructor() {
        super("events.KubeRequest", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Server", kind: "message", jsonName: "Server", T: () => ServerMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "RequestPath", kind: "scalar", jsonName: "RequestPath", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "request_path" } },
            { no: 6, name: "Verb", kind: "scalar", jsonName: "Verb", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "verb" } },
            { no: 7, name: "ResourceAPIGroup", kind: "scalar", jsonName: "ResourceAPIGroup", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "resource_api_group,omitempty" } },
            { no: 8, name: "ResourceNamespace", kind: "scalar", jsonName: "ResourceNamespace", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "resource_namespace,omitempty" } },
            { no: 9, name: "ResourceKind", kind: "scalar", jsonName: "ResourceKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "resource_kind,omitempty" } },
            { no: 10, name: "ResourceName", kind: "scalar", jsonName: "ResourceName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "resource_name,omitempty" } },
            { no: 11, name: "ResponseCode", kind: "scalar", jsonName: "ResponseCode", T: 5 /*ScalarType.INT32*/, options: { "gogoproto.jsontag": "response_code" } },
            { no: 12, name: "Kubernetes", kind: "message", jsonName: "Kubernetes", T: () => KubernetesClusterMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 13, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<KubeRequest>): KubeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.requestPath = "";
        message.verb = "";
        message.resourceAPIGroup = "";
        message.resourceNamespace = "";
        message.resourceKind = "";
        message.resourceName = "";
        message.responseCode = 0;
        if (value !== undefined)
            reflectionMergePartial<KubeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KubeRequest): KubeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 3 [json_name = "Connection"];*/ 3:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* events.ServerMetadata Server = 4 [json_name = "Server"];*/ 4:
                    message.server = ServerMetadata.internalBinaryRead(reader, reader.uint32(), options, message.server);
                    break;
                case /* string RequestPath = 5 [json_name = "RequestPath"];*/ 5:
                    message.requestPath = reader.string();
                    break;
                case /* string Verb = 6 [json_name = "Verb"];*/ 6:
                    message.verb = reader.string();
                    break;
                case /* string ResourceAPIGroup = 7 [json_name = "ResourceAPIGroup"];*/ 7:
                    message.resourceAPIGroup = reader.string();
                    break;
                case /* string ResourceNamespace = 8 [json_name = "ResourceNamespace"];*/ 8:
                    message.resourceNamespace = reader.string();
                    break;
                case /* string ResourceKind = 9 [json_name = "ResourceKind"];*/ 9:
                    message.resourceKind = reader.string();
                    break;
                case /* string ResourceName = 10 [json_name = "ResourceName"];*/ 10:
                    message.resourceName = reader.string();
                    break;
                case /* int32 ResponseCode = 11 [json_name = "ResponseCode"];*/ 11:
                    message.responseCode = reader.int32();
                    break;
                case /* events.KubernetesClusterMetadata Kubernetes = 12 [json_name = "Kubernetes"];*/ 12:
                    message.kubernetes = KubernetesClusterMetadata.internalBinaryRead(reader, reader.uint32(), options, message.kubernetes);
                    break;
                case /* events.SessionMetadata Session = 13 [json_name = "Session"];*/ 13:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: KubeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 3 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ServerMetadata Server = 4 [json_name = "Server"]; */
        if (message.server)
            ServerMetadata.internalBinaryWrite(message.server, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string RequestPath = 5 [json_name = "RequestPath"]; */
        if (message.requestPath !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.requestPath);
        /* string Verb = 6 [json_name = "Verb"]; */
        if (message.verb !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.verb);
        /* string ResourceAPIGroup = 7 [json_name = "ResourceAPIGroup"]; */
        if (message.resourceAPIGroup !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.resourceAPIGroup);
        /* string ResourceNamespace = 8 [json_name = "ResourceNamespace"]; */
        if (message.resourceNamespace !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.resourceNamespace);
        /* string ResourceKind = 9 [json_name = "ResourceKind"]; */
        if (message.resourceKind !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.resourceKind);
        /* string ResourceName = 10 [json_name = "ResourceName"]; */
        if (message.resourceName !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.resourceName);
        /* int32 ResponseCode = 11 [json_name = "ResponseCode"]; */
        if (message.responseCode !== 0)
            writer.tag(11, WireType.Varint).int32(message.responseCode);
        /* events.KubernetesClusterMetadata Kubernetes = 12 [json_name = "Kubernetes"]; */
        if (message.kubernetes)
            KubernetesClusterMetadata.internalBinaryWrite(message.kubernetes, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 13 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.KubeRequest
 */
export const KubeRequest = new KubeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppMetadata$Type extends MessageType<AppMetadata> {
    constructor() {
        super("events.AppMetadata", [
            { no: 1, name: "AppURI", kind: "scalar", jsonName: "AppURI", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "app_uri,omitempty" } },
            { no: 2, name: "AppPublicAddr", kind: "scalar", jsonName: "AppPublicAddr", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "app_public_addr,omitempty" } },
            { no: 3, name: "AppLabels", kind: "map", jsonName: "AppLabels", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ }, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "app_labels,omitempty" } },
            { no: 4, name: "AppName", kind: "scalar", jsonName: "AppName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "app_name,omitempty" } },
            { no: 5, name: "AppTargetPort", kind: "scalar", jsonName: "AppTargetPort", T: 13 /*ScalarType.UINT32*/, options: { "gogoproto.jsontag": "app_target_port,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<AppMetadata>): AppMetadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.appURI = "";
        message.appPublicAddr = "";
        message.appLabels = {};
        message.appName = "";
        message.appTargetPort = 0;
        if (value !== undefined)
            reflectionMergePartial<AppMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppMetadata): AppMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string AppURI = 1 [json_name = "AppURI"];*/ 1:
                    message.appURI = reader.string();
                    break;
                case /* string AppPublicAddr = 2 [json_name = "AppPublicAddr"];*/ 2:
                    message.appPublicAddr = reader.string();
                    break;
                case /* map<string, string> AppLabels = 3 [json_name = "AppLabels"];*/ 3:
                    this.binaryReadMap3(message.appLabels, reader, options);
                    break;
                case /* string AppName = 4 [json_name = "AppName"];*/ 4:
                    message.appName = reader.string();
                    break;
                case /* uint32 AppTargetPort = 5 [json_name = "AppTargetPort"];*/ 5:
                    message.appTargetPort = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: AppMetadata["appLabels"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AppMetadata["appLabels"] | undefined, val: AppMetadata["appLabels"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field events.AppMetadata.AppLabels");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: AppMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string AppURI = 1 [json_name = "AppURI"]; */
        if (message.appURI !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.appURI);
        /* string AppPublicAddr = 2 [json_name = "AppPublicAddr"]; */
        if (message.appPublicAddr !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.appPublicAddr);
        /* map<string, string> AppLabels = 3 [json_name = "AppLabels"]; */
        for (let k of globalThis.Object.keys(message.appLabels))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.appLabels[k]).join();
        /* string AppName = 4 [json_name = "AppName"]; */
        if (message.appName !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.appName);
        /* uint32 AppTargetPort = 5 [json_name = "AppTargetPort"]; */
        if (message.appTargetPort !== 0)
            writer.tag(5, WireType.Varint).uint32(message.appTargetPort);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.AppMetadata
 */
export const AppMetadata = new AppMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppCreate$Type extends MessageType<AppCreate> {
    constructor() {
        super("events.AppCreate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "App", kind: "message", jsonName: "App", T: () => AppMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<AppCreate>): AppCreate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AppCreate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppCreate): AppCreate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ResourceMetadata Resource = 3 [json_name = "Resource"];*/ 3:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.AppMetadata App = 4 [json_name = "App"];*/ 4:
                    message.app = AppMetadata.internalBinaryRead(reader, reader.uint32(), options, message.app);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppCreate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 3 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.AppMetadata App = 4 [json_name = "App"]; */
        if (message.app)
            AppMetadata.internalBinaryWrite(message.app, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.AppCreate
 */
export const AppCreate = new AppCreate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppUpdate$Type extends MessageType<AppUpdate> {
    constructor() {
        super("events.AppUpdate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "App", kind: "message", jsonName: "App", T: () => AppMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<AppUpdate>): AppUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AppUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppUpdate): AppUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ResourceMetadata Resource = 3 [json_name = "Resource"];*/ 3:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.AppMetadata App = 4 [json_name = "App"];*/ 4:
                    message.app = AppMetadata.internalBinaryRead(reader, reader.uint32(), options, message.app);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 3 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.AppMetadata App = 4 [json_name = "App"]; */
        if (message.app)
            AppMetadata.internalBinaryWrite(message.app, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.AppUpdate
 */
export const AppUpdate = new AppUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppDelete$Type extends MessageType<AppDelete> {
    constructor() {
        super("events.AppDelete", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<AppDelete>): AppDelete {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AppDelete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppDelete): AppDelete {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ResourceMetadata Resource = 3 [json_name = "Resource"];*/ 3:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppDelete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 3 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.AppDelete
 */
export const AppDelete = new AppDelete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppSessionStart$Type extends MessageType<AppSessionStart> {
    constructor() {
        super("events.AppSessionStart", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Server", kind: "message", jsonName: "Server", T: () => ServerMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 7, name: "PublicAddr", kind: "scalar", jsonName: "PublicAddr", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "public_addr" } },
            { no: 8, name: "App", kind: "message", jsonName: "App", T: () => AppMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<AppSessionStart>): AppSessionStart {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.publicAddr = "";
        if (value !== undefined)
            reflectionMergePartial<AppSessionStart>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppSessionStart): AppSessionStart {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.ServerMetadata Server = 4 [json_name = "Server"];*/ 4:
                    message.server = ServerMetadata.internalBinaryRead(reader, reader.uint32(), options, message.server);
                    break;
                case /* events.ConnectionMetadata Connection = 5 [json_name = "Connection"];*/ 5:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* string PublicAddr = 7 [deprecated = true, json_name = "PublicAddr"];*/ 7:
                    message.publicAddr = reader.string();
                    break;
                case /* events.AppMetadata App = 8 [json_name = "App"];*/ 8:
                    message.app = AppMetadata.internalBinaryRead(reader, reader.uint32(), options, message.app);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppSessionStart, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ServerMetadata Server = 4 [json_name = "Server"]; */
        if (message.server)
            ServerMetadata.internalBinaryWrite(message.server, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 5 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string PublicAddr = 7 [deprecated = true, json_name = "PublicAddr"]; */
        if (message.publicAddr !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.publicAddr);
        /* events.AppMetadata App = 8 [json_name = "App"]; */
        if (message.app)
            AppMetadata.internalBinaryWrite(message.app, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.AppSessionStart
 */
export const AppSessionStart = new AppSessionStart$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppSessionEnd$Type extends MessageType<AppSessionEnd> {
    constructor() {
        super("events.AppSessionEnd", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Server", kind: "message", jsonName: "Server", T: () => ServerMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 6, name: "App", kind: "message", jsonName: "App", T: () => AppMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<AppSessionEnd>): AppSessionEnd {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AppSessionEnd>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppSessionEnd): AppSessionEnd {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.ServerMetadata Server = 4 [json_name = "Server"];*/ 4:
                    message.server = ServerMetadata.internalBinaryRead(reader, reader.uint32(), options, message.server);
                    break;
                case /* events.ConnectionMetadata Connection = 5 [json_name = "Connection"];*/ 5:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* events.AppMetadata App = 6 [json_name = "App"];*/ 6:
                    message.app = AppMetadata.internalBinaryRead(reader, reader.uint32(), options, message.app);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppSessionEnd, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ServerMetadata Server = 4 [json_name = "Server"]; */
        if (message.server)
            ServerMetadata.internalBinaryWrite(message.server, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 5 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* events.AppMetadata App = 6 [json_name = "App"]; */
        if (message.app)
            AppMetadata.internalBinaryWrite(message.app, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.AppSessionEnd
 */
export const AppSessionEnd = new AppSessionEnd$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppSessionChunk$Type extends MessageType<AppSessionChunk> {
    constructor() {
        super("events.AppSessionChunk", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Server", kind: "message", jsonName: "Server", T: () => ServerMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 6, name: "SessionChunkID", kind: "scalar", jsonName: "SessionChunkID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "session_chunk_id" } },
            { no: 7, name: "App", kind: "message", jsonName: "App", T: () => AppMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<AppSessionChunk>): AppSessionChunk {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sessionChunkID = "";
        if (value !== undefined)
            reflectionMergePartial<AppSessionChunk>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppSessionChunk): AppSessionChunk {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.ServerMetadata Server = 4 [json_name = "Server"];*/ 4:
                    message.server = ServerMetadata.internalBinaryRead(reader, reader.uint32(), options, message.server);
                    break;
                case /* events.ConnectionMetadata Connection = 5 [json_name = "Connection"];*/ 5:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* string SessionChunkID = 6 [json_name = "SessionChunkID"];*/ 6:
                    message.sessionChunkID = reader.string();
                    break;
                case /* events.AppMetadata App = 7 [json_name = "App"];*/ 7:
                    message.app = AppMetadata.internalBinaryRead(reader, reader.uint32(), options, message.app);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppSessionChunk, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ServerMetadata Server = 4 [json_name = "Server"]; */
        if (message.server)
            ServerMetadata.internalBinaryWrite(message.server, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 5 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string SessionChunkID = 6 [json_name = "SessionChunkID"]; */
        if (message.sessionChunkID !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.sessionChunkID);
        /* events.AppMetadata App = 7 [json_name = "App"]; */
        if (message.app)
            AppMetadata.internalBinaryWrite(message.app, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.AppSessionChunk
 */
export const AppSessionChunk = new AppSessionChunk$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppSessionRequest$Type extends MessageType<AppSessionRequest> {
    constructor() {
        super("events.AppSessionRequest", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "StatusCode", kind: "scalar", jsonName: "StatusCode", T: 13 /*ScalarType.UINT32*/, options: { "gogoproto.jsontag": "status_code" } },
            { no: 3, name: "Path", kind: "scalar", jsonName: "Path", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "path" } },
            { no: 4, name: "RawQuery", kind: "scalar", jsonName: "RawQuery", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "raw_query" } },
            { no: 5, name: "Method", kind: "scalar", jsonName: "Method", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "method" } },
            { no: 6, name: "App", kind: "message", jsonName: "App", T: () => AppMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 7, name: "AWS", kind: "message", jsonName: "AWS", T: () => AWSRequestMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<AppSessionRequest>): AppSessionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statusCode = 0;
        message.path = "";
        message.rawQuery = "";
        message.method = "";
        if (value !== undefined)
            reflectionMergePartial<AppSessionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppSessionRequest): AppSessionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* uint32 StatusCode = 2 [json_name = "StatusCode"];*/ 2:
                    message.statusCode = reader.uint32();
                    break;
                case /* string Path = 3 [json_name = "Path"];*/ 3:
                    message.path = reader.string();
                    break;
                case /* string RawQuery = 4 [json_name = "RawQuery"];*/ 4:
                    message.rawQuery = reader.string();
                    break;
                case /* string Method = 5 [json_name = "Method"];*/ 5:
                    message.method = reader.string();
                    break;
                case /* events.AppMetadata App = 6 [json_name = "App"];*/ 6:
                    message.app = AppMetadata.internalBinaryRead(reader, reader.uint32(), options, message.app);
                    break;
                case /* events.AWSRequestMetadata AWS = 7 [json_name = "AWS"];*/ 7:
                    message.aWS = AWSRequestMetadata.internalBinaryRead(reader, reader.uint32(), options, message.aWS);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppSessionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 StatusCode = 2 [json_name = "StatusCode"]; */
        if (message.statusCode !== 0)
            writer.tag(2, WireType.Varint).uint32(message.statusCode);
        /* string Path = 3 [json_name = "Path"]; */
        if (message.path !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.path);
        /* string RawQuery = 4 [json_name = "RawQuery"]; */
        if (message.rawQuery !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.rawQuery);
        /* string Method = 5 [json_name = "Method"]; */
        if (message.method !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.method);
        /* events.AppMetadata App = 6 [json_name = "App"]; */
        if (message.app)
            AppMetadata.internalBinaryWrite(message.app, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* events.AWSRequestMetadata AWS = 7 [json_name = "AWS"]; */
        if (message.aWS)
            AWSRequestMetadata.internalBinaryWrite(message.aWS, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.AppSessionRequest
 */
export const AppSessionRequest = new AppSessionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AWSRequestMetadata$Type extends MessageType<AWSRequestMetadata> {
    constructor() {
        super("events.AWSRequestMetadata", [
            { no: 1, name: "AWSRegion", kind: "scalar", jsonName: "AWSRegion", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "aws_region,omitempty" } },
            { no: 2, name: "AWSService", kind: "scalar", jsonName: "AWSService", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "aws_service,omitempty" } },
            { no: 3, name: "AWSHost", kind: "scalar", jsonName: "AWSHost", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "aws_host,omitempty" } },
            { no: 4, name: "AWSAssumedRole", kind: "scalar", jsonName: "AWSAssumedRole", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "aws_assumed_role,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<AWSRequestMetadata>): AWSRequestMetadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.aWSRegion = "";
        message.aWSService = "";
        message.aWSHost = "";
        message.aWSAssumedRole = "";
        if (value !== undefined)
            reflectionMergePartial<AWSRequestMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AWSRequestMetadata): AWSRequestMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string AWSRegion = 1 [json_name = "AWSRegion"];*/ 1:
                    message.aWSRegion = reader.string();
                    break;
                case /* string AWSService = 2 [json_name = "AWSService"];*/ 2:
                    message.aWSService = reader.string();
                    break;
                case /* string AWSHost = 3 [json_name = "AWSHost"];*/ 3:
                    message.aWSHost = reader.string();
                    break;
                case /* string AWSAssumedRole = 4 [json_name = "AWSAssumedRole"];*/ 4:
                    message.aWSAssumedRole = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AWSRequestMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string AWSRegion = 1 [json_name = "AWSRegion"]; */
        if (message.aWSRegion !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.aWSRegion);
        /* string AWSService = 2 [json_name = "AWSService"]; */
        if (message.aWSService !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.aWSService);
        /* string AWSHost = 3 [json_name = "AWSHost"]; */
        if (message.aWSHost !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.aWSHost);
        /* string AWSAssumedRole = 4 [json_name = "AWSAssumedRole"]; */
        if (message.aWSAssumedRole !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.aWSAssumedRole);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.AWSRequestMetadata
 */
export const AWSRequestMetadata = new AWSRequestMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DatabaseMetadata$Type extends MessageType<DatabaseMetadata> {
    constructor() {
        super("events.DatabaseMetadata", [
            { no: 1, name: "DatabaseService", kind: "scalar", jsonName: "DatabaseService", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "db_service,omitempty" } },
            { no: 2, name: "DatabaseProtocol", kind: "scalar", jsonName: "DatabaseProtocol", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "db_protocol" } },
            { no: 3, name: "DatabaseURI", kind: "scalar", jsonName: "DatabaseURI", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "db_uri" } },
            { no: 4, name: "DatabaseName", kind: "scalar", jsonName: "DatabaseName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "db_name,omitempty" } },
            { no: 5, name: "DatabaseUser", kind: "scalar", jsonName: "DatabaseUser", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "db_user,omitempty" } },
            { no: 6, name: "DatabaseLabels", kind: "map", jsonName: "DatabaseLabels", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ }, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "db_labels,omitempty" } },
            { no: 7, name: "DatabaseAWSRegion", kind: "scalar", jsonName: "DatabaseAWSRegion", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "db_aws_region,omitempty" } },
            { no: 8, name: "DatabaseAWSRedshiftClusterID", kind: "scalar", jsonName: "DatabaseAWSRedshiftClusterID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "db_aws_redshift_cluster_id,omitempty" } },
            { no: 9, name: "DatabaseGCPProjectID", kind: "scalar", jsonName: "DatabaseGCPProjectID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "db_gcp_project_id,omitempty" } },
            { no: 10, name: "DatabaseGCPInstanceID", kind: "scalar", jsonName: "DatabaseGCPInstanceID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "db_gcp_instance_id,omitempty" } },
            { no: 11, name: "DatabaseRoles", kind: "scalar", jsonName: "DatabaseRoles", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "db_roles,omitempty" } },
            { no: 12, name: "DatabaseType", kind: "scalar", jsonName: "DatabaseType", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "db_type,omitempty" } },
            { no: 13, name: "DatabaseOrigin", kind: "scalar", jsonName: "DatabaseOrigin", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "db_origin,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<DatabaseMetadata>): DatabaseMetadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.databaseService = "";
        message.databaseProtocol = "";
        message.databaseURI = "";
        message.databaseName = "";
        message.databaseUser = "";
        message.databaseLabels = {};
        message.databaseAWSRegion = "";
        message.databaseAWSRedshiftClusterID = "";
        message.databaseGCPProjectID = "";
        message.databaseGCPInstanceID = "";
        message.databaseRoles = [];
        message.databaseType = "";
        message.databaseOrigin = "";
        if (value !== undefined)
            reflectionMergePartial<DatabaseMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DatabaseMetadata): DatabaseMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string DatabaseService = 1 [json_name = "DatabaseService"];*/ 1:
                    message.databaseService = reader.string();
                    break;
                case /* string DatabaseProtocol = 2 [json_name = "DatabaseProtocol"];*/ 2:
                    message.databaseProtocol = reader.string();
                    break;
                case /* string DatabaseURI = 3 [json_name = "DatabaseURI"];*/ 3:
                    message.databaseURI = reader.string();
                    break;
                case /* string DatabaseName = 4 [json_name = "DatabaseName"];*/ 4:
                    message.databaseName = reader.string();
                    break;
                case /* string DatabaseUser = 5 [json_name = "DatabaseUser"];*/ 5:
                    message.databaseUser = reader.string();
                    break;
                case /* map<string, string> DatabaseLabels = 6 [json_name = "DatabaseLabels"];*/ 6:
                    this.binaryReadMap6(message.databaseLabels, reader, options);
                    break;
                case /* string DatabaseAWSRegion = 7 [json_name = "DatabaseAWSRegion"];*/ 7:
                    message.databaseAWSRegion = reader.string();
                    break;
                case /* string DatabaseAWSRedshiftClusterID = 8 [json_name = "DatabaseAWSRedshiftClusterID"];*/ 8:
                    message.databaseAWSRedshiftClusterID = reader.string();
                    break;
                case /* string DatabaseGCPProjectID = 9 [json_name = "DatabaseGCPProjectID"];*/ 9:
                    message.databaseGCPProjectID = reader.string();
                    break;
                case /* string DatabaseGCPInstanceID = 10 [json_name = "DatabaseGCPInstanceID"];*/ 10:
                    message.databaseGCPInstanceID = reader.string();
                    break;
                case /* repeated string DatabaseRoles = 11 [json_name = "DatabaseRoles"];*/ 11:
                    message.databaseRoles.push(reader.string());
                    break;
                case /* string DatabaseType = 12 [json_name = "DatabaseType"];*/ 12:
                    message.databaseType = reader.string();
                    break;
                case /* string DatabaseOrigin = 13 [json_name = "DatabaseOrigin"];*/ 13:
                    message.databaseOrigin = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap6(map: DatabaseMetadata["databaseLabels"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof DatabaseMetadata["databaseLabels"] | undefined, val: DatabaseMetadata["databaseLabels"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field events.DatabaseMetadata.DatabaseLabels");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: DatabaseMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string DatabaseService = 1 [json_name = "DatabaseService"]; */
        if (message.databaseService !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.databaseService);
        /* string DatabaseProtocol = 2 [json_name = "DatabaseProtocol"]; */
        if (message.databaseProtocol !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.databaseProtocol);
        /* string DatabaseURI = 3 [json_name = "DatabaseURI"]; */
        if (message.databaseURI !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.databaseURI);
        /* string DatabaseName = 4 [json_name = "DatabaseName"]; */
        if (message.databaseName !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.databaseName);
        /* string DatabaseUser = 5 [json_name = "DatabaseUser"]; */
        if (message.databaseUser !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.databaseUser);
        /* map<string, string> DatabaseLabels = 6 [json_name = "DatabaseLabels"]; */
        for (let k of globalThis.Object.keys(message.databaseLabels))
            writer.tag(6, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.databaseLabels[k]).join();
        /* string DatabaseAWSRegion = 7 [json_name = "DatabaseAWSRegion"]; */
        if (message.databaseAWSRegion !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.databaseAWSRegion);
        /* string DatabaseAWSRedshiftClusterID = 8 [json_name = "DatabaseAWSRedshiftClusterID"]; */
        if (message.databaseAWSRedshiftClusterID !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.databaseAWSRedshiftClusterID);
        /* string DatabaseGCPProjectID = 9 [json_name = "DatabaseGCPProjectID"]; */
        if (message.databaseGCPProjectID !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.databaseGCPProjectID);
        /* string DatabaseGCPInstanceID = 10 [json_name = "DatabaseGCPInstanceID"]; */
        if (message.databaseGCPInstanceID !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.databaseGCPInstanceID);
        /* repeated string DatabaseRoles = 11 [json_name = "DatabaseRoles"]; */
        for (let i = 0; i < message.databaseRoles.length; i++)
            writer.tag(11, WireType.LengthDelimited).string(message.databaseRoles[i]);
        /* string DatabaseType = 12 [json_name = "DatabaseType"]; */
        if (message.databaseType !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.databaseType);
        /* string DatabaseOrigin = 13 [json_name = "DatabaseOrigin"]; */
        if (message.databaseOrigin !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.databaseOrigin);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.DatabaseMetadata
 */
export const DatabaseMetadata = new DatabaseMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DatabaseCreate$Type extends MessageType<DatabaseCreate> {
    constructor() {
        super("events.DatabaseCreate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Database", kind: "message", jsonName: "Database", T: () => DatabaseMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<DatabaseCreate>): DatabaseCreate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DatabaseCreate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DatabaseCreate): DatabaseCreate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ResourceMetadata Resource = 3 [json_name = "Resource"];*/ 3:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.DatabaseMetadata Database = 4 [json_name = "Database"];*/ 4:
                    message.database = DatabaseMetadata.internalBinaryRead(reader, reader.uint32(), options, message.database);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DatabaseCreate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 3 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseMetadata Database = 4 [json_name = "Database"]; */
        if (message.database)
            DatabaseMetadata.internalBinaryWrite(message.database, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.DatabaseCreate
 */
export const DatabaseCreate = new DatabaseCreate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DatabaseUpdate$Type extends MessageType<DatabaseUpdate> {
    constructor() {
        super("events.DatabaseUpdate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Database", kind: "message", jsonName: "Database", T: () => DatabaseMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<DatabaseUpdate>): DatabaseUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DatabaseUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DatabaseUpdate): DatabaseUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ResourceMetadata Resource = 3 [json_name = "Resource"];*/ 3:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.DatabaseMetadata Database = 4 [json_name = "Database"];*/ 4:
                    message.database = DatabaseMetadata.internalBinaryRead(reader, reader.uint32(), options, message.database);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DatabaseUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 3 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseMetadata Database = 4 [json_name = "Database"]; */
        if (message.database)
            DatabaseMetadata.internalBinaryWrite(message.database, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.DatabaseUpdate
 */
export const DatabaseUpdate = new DatabaseUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DatabaseDelete$Type extends MessageType<DatabaseDelete> {
    constructor() {
        super("events.DatabaseDelete", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<DatabaseDelete>): DatabaseDelete {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DatabaseDelete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DatabaseDelete): DatabaseDelete {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ResourceMetadata Resource = 3 [json_name = "Resource"];*/ 3:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DatabaseDelete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 3 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.DatabaseDelete
 */
export const DatabaseDelete = new DatabaseDelete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DatabaseSessionStart$Type extends MessageType<DatabaseSessionStart> {
    constructor() {
        super("events.DatabaseSessionStart", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Server", kind: "message", jsonName: "Server", T: () => ServerMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 6, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 7, name: "Database", kind: "message", jsonName: "Database", T: () => DatabaseMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 8, name: "PostgresPID", kind: "scalar", jsonName: "PostgresPID", T: 13 /*ScalarType.UINT32*/, options: { "gogoproto.jsontag": "postgres_pid,omitempty" } },
            { no: 9, name: "Client", kind: "message", jsonName: "Client", T: () => ClientMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<DatabaseSessionStart>): DatabaseSessionStart {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.postgresPID = 0;
        if (value !== undefined)
            reflectionMergePartial<DatabaseSessionStart>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DatabaseSessionStart): DatabaseSessionStart {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.ServerMetadata Server = 4 [json_name = "Server"];*/ 4:
                    message.server = ServerMetadata.internalBinaryRead(reader, reader.uint32(), options, message.server);
                    break;
                case /* events.ConnectionMetadata Connection = 5 [json_name = "Connection"];*/ 5:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* events.Status Status = 6 [json_name = "Status"];*/ 6:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* events.DatabaseMetadata Database = 7 [json_name = "Database"];*/ 7:
                    message.database = DatabaseMetadata.internalBinaryRead(reader, reader.uint32(), options, message.database);
                    break;
                case /* uint32 PostgresPID = 8 [json_name = "PostgresPID"];*/ 8:
                    message.postgresPID = reader.uint32();
                    break;
                case /* events.ClientMetadata Client = 9 [json_name = "Client"];*/ 9:
                    message.client = ClientMetadata.internalBinaryRead(reader, reader.uint32(), options, message.client);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DatabaseSessionStart, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ServerMetadata Server = 4 [json_name = "Server"]; */
        if (message.server)
            ServerMetadata.internalBinaryWrite(message.server, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 5 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 6 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseMetadata Database = 7 [json_name = "Database"]; */
        if (message.database)
            DatabaseMetadata.internalBinaryWrite(message.database, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* uint32 PostgresPID = 8 [json_name = "PostgresPID"]; */
        if (message.postgresPID !== 0)
            writer.tag(8, WireType.Varint).uint32(message.postgresPID);
        /* events.ClientMetadata Client = 9 [json_name = "Client"]; */
        if (message.client)
            ClientMetadata.internalBinaryWrite(message.client, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.DatabaseSessionStart
 */
export const DatabaseSessionStart = new DatabaseSessionStart$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DatabaseSessionQuery$Type extends MessageType<DatabaseSessionQuery> {
    constructor() {
        super("events.DatabaseSessionQuery", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Database", kind: "message", jsonName: "Database", T: () => DatabaseMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "DatabaseQuery", kind: "scalar", jsonName: "DatabaseQuery", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "db_query" } },
            { no: 6, name: "DatabaseQueryParameters", kind: "scalar", jsonName: "DatabaseQueryParameters", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "db_query_parameters,omitempty" } },
            { no: 7, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<DatabaseSessionQuery>): DatabaseSessionQuery {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.databaseQuery = "";
        message.databaseQueryParameters = [];
        if (value !== undefined)
            reflectionMergePartial<DatabaseSessionQuery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DatabaseSessionQuery): DatabaseSessionQuery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.DatabaseMetadata Database = 4 [json_name = "Database"];*/ 4:
                    message.database = DatabaseMetadata.internalBinaryRead(reader, reader.uint32(), options, message.database);
                    break;
                case /* string DatabaseQuery = 5 [json_name = "DatabaseQuery"];*/ 5:
                    message.databaseQuery = reader.string();
                    break;
                case /* repeated string DatabaseQueryParameters = 6 [json_name = "DatabaseQueryParameters"];*/ 6:
                    message.databaseQueryParameters.push(reader.string());
                    break;
                case /* events.Status Status = 7 [json_name = "Status"];*/ 7:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DatabaseSessionQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseMetadata Database = 4 [json_name = "Database"]; */
        if (message.database)
            DatabaseMetadata.internalBinaryWrite(message.database, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string DatabaseQuery = 5 [json_name = "DatabaseQuery"]; */
        if (message.databaseQuery !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.databaseQuery);
        /* repeated string DatabaseQueryParameters = 6 [json_name = "DatabaseQueryParameters"]; */
        for (let i = 0; i < message.databaseQueryParameters.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.databaseQueryParameters[i]);
        /* events.Status Status = 7 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.DatabaseSessionQuery
 */
export const DatabaseSessionQuery = new DatabaseSessionQuery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DatabaseSessionCommandResult$Type extends MessageType<DatabaseSessionCommandResult> {
    constructor() {
        super("events.DatabaseSessionCommandResult", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Database", kind: "message", jsonName: "Database", T: () => DatabaseMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 6, name: "AffectedRecords", kind: "scalar", jsonName: "AffectedRecords", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "affected_records,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<DatabaseSessionCommandResult>): DatabaseSessionCommandResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.affectedRecords = 0n;
        if (value !== undefined)
            reflectionMergePartial<DatabaseSessionCommandResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DatabaseSessionCommandResult): DatabaseSessionCommandResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.DatabaseMetadata Database = 4 [json_name = "Database"];*/ 4:
                    message.database = DatabaseMetadata.internalBinaryRead(reader, reader.uint32(), options, message.database);
                    break;
                case /* events.Status Status = 5 [json_name = "Status"];*/ 5:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* uint64 AffectedRecords = 6 [json_name = "AffectedRecords"];*/ 6:
                    message.affectedRecords = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DatabaseSessionCommandResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseMetadata Database = 4 [json_name = "Database"]; */
        if (message.database)
            DatabaseMetadata.internalBinaryWrite(message.database, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 5 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* uint64 AffectedRecords = 6 [json_name = "AffectedRecords"]; */
        if (message.affectedRecords !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.affectedRecords);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.DatabaseSessionCommandResult
 */
export const DatabaseSessionCommandResult = new DatabaseSessionCommandResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DatabasePermissionUpdate$Type extends MessageType<DatabasePermissionUpdate> {
    constructor() {
        super("events.DatabasePermissionUpdate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Database", kind: "message", jsonName: "Database", T: () => DatabaseMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "PermissionSummary", kind: "message", jsonName: "PermissionSummary", repeat: 1 /*RepeatType.PACKED*/, T: () => DatabasePermissionEntry, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "permission_summary" } },
            { no: 6, name: "AffectedObjectCounts", kind: "map", jsonName: "AffectedObjectCounts", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 5 /*ScalarType.INT32*/ }, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "affected_object_counts" } }
        ]);
    }
    create(value?: PartialMessage<DatabasePermissionUpdate>): DatabasePermissionUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.permissionSummary = [];
        message.affectedObjectCounts = {};
        if (value !== undefined)
            reflectionMergePartial<DatabasePermissionUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DatabasePermissionUpdate): DatabasePermissionUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.DatabaseMetadata Database = 4 [json_name = "Database"];*/ 4:
                    message.database = DatabaseMetadata.internalBinaryRead(reader, reader.uint32(), options, message.database);
                    break;
                case /* repeated events.DatabasePermissionEntry PermissionSummary = 5 [json_name = "PermissionSummary"];*/ 5:
                    message.permissionSummary.push(DatabasePermissionEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* map<string, int32> AffectedObjectCounts = 6 [json_name = "AffectedObjectCounts"];*/ 6:
                    this.binaryReadMap6(message.affectedObjectCounts, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap6(map: DatabasePermissionUpdate["affectedObjectCounts"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof DatabasePermissionUpdate["affectedObjectCounts"] | undefined, val: DatabasePermissionUpdate["affectedObjectCounts"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field events.DatabasePermissionUpdate.AffectedObjectCounts");
            }
        }
        map[key ?? ""] = val ?? 0;
    }
    internalBinaryWrite(message: DatabasePermissionUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseMetadata Database = 4 [json_name = "Database"]; */
        if (message.database)
            DatabaseMetadata.internalBinaryWrite(message.database, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated events.DatabasePermissionEntry PermissionSummary = 5 [json_name = "PermissionSummary"]; */
        for (let i = 0; i < message.permissionSummary.length; i++)
            DatabasePermissionEntry.internalBinaryWrite(message.permissionSummary[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* map<string, int32> AffectedObjectCounts = 6 [json_name = "AffectedObjectCounts"]; */
        for (let k of globalThis.Object.keys(message.affectedObjectCounts))
            writer.tag(6, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).int32(message.affectedObjectCounts[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.DatabasePermissionUpdate
 */
export const DatabasePermissionUpdate = new DatabasePermissionUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DatabasePermissionEntry$Type extends MessageType<DatabasePermissionEntry> {
    constructor() {
        super("events.DatabasePermissionEntry", [
            { no: 1, name: "Permission", kind: "scalar", jsonName: "Permission", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "permission" } },
            { no: 2, name: "Counts", kind: "map", jsonName: "Counts", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 5 /*ScalarType.INT32*/ }, options: { "gogoproto.jsontag": "counts" } }
        ]);
    }
    create(value?: PartialMessage<DatabasePermissionEntry>): DatabasePermissionEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.permission = "";
        message.counts = {};
        if (value !== undefined)
            reflectionMergePartial<DatabasePermissionEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DatabasePermissionEntry): DatabasePermissionEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Permission = 1 [json_name = "Permission"];*/ 1:
                    message.permission = reader.string();
                    break;
                case /* map<string, int32> Counts = 2 [json_name = "Counts"];*/ 2:
                    this.binaryReadMap2(message.counts, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: DatabasePermissionEntry["counts"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof DatabasePermissionEntry["counts"] | undefined, val: DatabasePermissionEntry["counts"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field events.DatabasePermissionEntry.Counts");
            }
        }
        map[key ?? ""] = val ?? 0;
    }
    internalBinaryWrite(message: DatabasePermissionEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Permission = 1 [json_name = "Permission"]; */
        if (message.permission !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.permission);
        /* map<string, int32> Counts = 2 [json_name = "Counts"]; */
        for (let k of globalThis.Object.keys(message.counts))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).int32(message.counts[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.DatabasePermissionEntry
 */
export const DatabasePermissionEntry = new DatabasePermissionEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DatabaseUserCreate$Type extends MessageType<DatabaseUserCreate> {
    constructor() {
        super("events.DatabaseUserCreate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Database", kind: "message", jsonName: "Database", T: () => DatabaseMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 6, name: "Username", kind: "scalar", jsonName: "Username", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "username" } },
            { no: 7, name: "Roles", kind: "scalar", jsonName: "Roles", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "roles" } }
        ]);
    }
    create(value?: PartialMessage<DatabaseUserCreate>): DatabaseUserCreate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.username = "";
        message.roles = [];
        if (value !== undefined)
            reflectionMergePartial<DatabaseUserCreate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DatabaseUserCreate): DatabaseUserCreate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.DatabaseMetadata Database = 4 [json_name = "Database"];*/ 4:
                    message.database = DatabaseMetadata.internalBinaryRead(reader, reader.uint32(), options, message.database);
                    break;
                case /* events.Status Status = 5 [json_name = "Status"];*/ 5:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* string Username = 6 [json_name = "Username"];*/ 6:
                    message.username = reader.string();
                    break;
                case /* repeated string Roles = 7 [json_name = "Roles"];*/ 7:
                    message.roles.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DatabaseUserCreate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseMetadata Database = 4 [json_name = "Database"]; */
        if (message.database)
            DatabaseMetadata.internalBinaryWrite(message.database, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 5 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string Username = 6 [json_name = "Username"]; */
        if (message.username !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.username);
        /* repeated string Roles = 7 [json_name = "Roles"]; */
        for (let i = 0; i < message.roles.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.roles[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.DatabaseUserCreate
 */
export const DatabaseUserCreate = new DatabaseUserCreate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DatabaseUserDeactivate$Type extends MessageType<DatabaseUserDeactivate> {
    constructor() {
        super("events.DatabaseUserDeactivate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Database", kind: "message", jsonName: "Database", T: () => DatabaseMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 6, name: "Username", kind: "scalar", jsonName: "Username", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "username" } },
            { no: 7, name: "Delete", kind: "scalar", jsonName: "Delete", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "delete" } }
        ]);
    }
    create(value?: PartialMessage<DatabaseUserDeactivate>): DatabaseUserDeactivate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.username = "";
        message.delete = false;
        if (value !== undefined)
            reflectionMergePartial<DatabaseUserDeactivate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DatabaseUserDeactivate): DatabaseUserDeactivate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.DatabaseMetadata Database = 4 [json_name = "Database"];*/ 4:
                    message.database = DatabaseMetadata.internalBinaryRead(reader, reader.uint32(), options, message.database);
                    break;
                case /* events.Status Status = 5 [json_name = "Status"];*/ 5:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* string Username = 6 [json_name = "Username"];*/ 6:
                    message.username = reader.string();
                    break;
                case /* bool Delete = 7 [json_name = "Delete"];*/ 7:
                    message.delete = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DatabaseUserDeactivate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseMetadata Database = 4 [json_name = "Database"]; */
        if (message.database)
            DatabaseMetadata.internalBinaryWrite(message.database, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 5 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string Username = 6 [json_name = "Username"]; */
        if (message.username !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.username);
        /* bool Delete = 7 [json_name = "Delete"]; */
        if (message.delete !== false)
            writer.tag(7, WireType.Varint).bool(message.delete);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.DatabaseUserDeactivate
 */
export const DatabaseUserDeactivate = new DatabaseUserDeactivate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PostgresParse$Type extends MessageType<PostgresParse> {
    constructor() {
        super("events.PostgresParse", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Database", kind: "message", jsonName: "Database", T: () => DatabaseMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "StatementName", kind: "scalar", jsonName: "StatementName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "statement_name" } },
            { no: 6, name: "Query", kind: "scalar", jsonName: "Query", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "query" } }
        ]);
    }
    create(value?: PartialMessage<PostgresParse>): PostgresParse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statementName = "";
        message.query = "";
        if (value !== undefined)
            reflectionMergePartial<PostgresParse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PostgresParse): PostgresParse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.DatabaseMetadata Database = 4 [json_name = "Database"];*/ 4:
                    message.database = DatabaseMetadata.internalBinaryRead(reader, reader.uint32(), options, message.database);
                    break;
                case /* string StatementName = 5 [json_name = "StatementName"];*/ 5:
                    message.statementName = reader.string();
                    break;
                case /* string Query = 6 [json_name = "Query"];*/ 6:
                    message.query = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PostgresParse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseMetadata Database = 4 [json_name = "Database"]; */
        if (message.database)
            DatabaseMetadata.internalBinaryWrite(message.database, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string StatementName = 5 [json_name = "StatementName"]; */
        if (message.statementName !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.statementName);
        /* string Query = 6 [json_name = "Query"]; */
        if (message.query !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.query);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.PostgresParse
 */
export const PostgresParse = new PostgresParse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PostgresBind$Type extends MessageType<PostgresBind> {
    constructor() {
        super("events.PostgresBind", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Database", kind: "message", jsonName: "Database", T: () => DatabaseMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "StatementName", kind: "scalar", jsonName: "StatementName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "statement_name" } },
            { no: 6, name: "PortalName", kind: "scalar", jsonName: "PortalName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "portal_name" } },
            { no: 7, name: "Parameters", kind: "scalar", jsonName: "Parameters", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "parameters" } }
        ]);
    }
    create(value?: PartialMessage<PostgresBind>): PostgresBind {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statementName = "";
        message.portalName = "";
        message.parameters = [];
        if (value !== undefined)
            reflectionMergePartial<PostgresBind>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PostgresBind): PostgresBind {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.DatabaseMetadata Database = 4 [json_name = "Database"];*/ 4:
                    message.database = DatabaseMetadata.internalBinaryRead(reader, reader.uint32(), options, message.database);
                    break;
                case /* string StatementName = 5 [json_name = "StatementName"];*/ 5:
                    message.statementName = reader.string();
                    break;
                case /* string PortalName = 6 [json_name = "PortalName"];*/ 6:
                    message.portalName = reader.string();
                    break;
                case /* repeated string Parameters = 7 [json_name = "Parameters"];*/ 7:
                    message.parameters.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PostgresBind, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseMetadata Database = 4 [json_name = "Database"]; */
        if (message.database)
            DatabaseMetadata.internalBinaryWrite(message.database, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string StatementName = 5 [json_name = "StatementName"]; */
        if (message.statementName !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.statementName);
        /* string PortalName = 6 [json_name = "PortalName"]; */
        if (message.portalName !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.portalName);
        /* repeated string Parameters = 7 [json_name = "Parameters"]; */
        for (let i = 0; i < message.parameters.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.parameters[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.PostgresBind
 */
export const PostgresBind = new PostgresBind$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PostgresExecute$Type extends MessageType<PostgresExecute> {
    constructor() {
        super("events.PostgresExecute", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Database", kind: "message", jsonName: "Database", T: () => DatabaseMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "PortalName", kind: "scalar", jsonName: "PortalName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "portal_name" } }
        ]);
    }
    create(value?: PartialMessage<PostgresExecute>): PostgresExecute {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.portalName = "";
        if (value !== undefined)
            reflectionMergePartial<PostgresExecute>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PostgresExecute): PostgresExecute {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.DatabaseMetadata Database = 4 [json_name = "Database"];*/ 4:
                    message.database = DatabaseMetadata.internalBinaryRead(reader, reader.uint32(), options, message.database);
                    break;
                case /* string PortalName = 5 [json_name = "PortalName"];*/ 5:
                    message.portalName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PostgresExecute, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseMetadata Database = 4 [json_name = "Database"]; */
        if (message.database)
            DatabaseMetadata.internalBinaryWrite(message.database, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string PortalName = 5 [json_name = "PortalName"]; */
        if (message.portalName !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.portalName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.PostgresExecute
 */
export const PostgresExecute = new PostgresExecute$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PostgresClose$Type extends MessageType<PostgresClose> {
    constructor() {
        super("events.PostgresClose", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Database", kind: "message", jsonName: "Database", T: () => DatabaseMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "StatementName", kind: "scalar", jsonName: "StatementName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "statement_name" } },
            { no: 6, name: "PortalName", kind: "scalar", jsonName: "PortalName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "portal_name" } }
        ]);
    }
    create(value?: PartialMessage<PostgresClose>): PostgresClose {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statementName = "";
        message.portalName = "";
        if (value !== undefined)
            reflectionMergePartial<PostgresClose>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PostgresClose): PostgresClose {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.DatabaseMetadata Database = 4 [json_name = "Database"];*/ 4:
                    message.database = DatabaseMetadata.internalBinaryRead(reader, reader.uint32(), options, message.database);
                    break;
                case /* string StatementName = 5 [json_name = "StatementName"];*/ 5:
                    message.statementName = reader.string();
                    break;
                case /* string PortalName = 6 [json_name = "PortalName"];*/ 6:
                    message.portalName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PostgresClose, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseMetadata Database = 4 [json_name = "Database"]; */
        if (message.database)
            DatabaseMetadata.internalBinaryWrite(message.database, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string StatementName = 5 [json_name = "StatementName"]; */
        if (message.statementName !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.statementName);
        /* string PortalName = 6 [json_name = "PortalName"]; */
        if (message.portalName !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.portalName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.PostgresClose
 */
export const PostgresClose = new PostgresClose$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PostgresFunctionCall$Type extends MessageType<PostgresFunctionCall> {
    constructor() {
        super("events.PostgresFunctionCall", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Database", kind: "message", jsonName: "Database", T: () => DatabaseMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "FunctionOID", kind: "scalar", jsonName: "FunctionOID", T: 13 /*ScalarType.UINT32*/, options: { "gogoproto.jsontag": "function_oid" } },
            { no: 6, name: "FunctionArgs", kind: "scalar", jsonName: "FunctionArgs", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "function_args,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<PostgresFunctionCall>): PostgresFunctionCall {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.functionOID = 0;
        message.functionArgs = [];
        if (value !== undefined)
            reflectionMergePartial<PostgresFunctionCall>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PostgresFunctionCall): PostgresFunctionCall {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.DatabaseMetadata Database = 4 [json_name = "Database"];*/ 4:
                    message.database = DatabaseMetadata.internalBinaryRead(reader, reader.uint32(), options, message.database);
                    break;
                case /* uint32 FunctionOID = 5 [json_name = "FunctionOID"];*/ 5:
                    message.functionOID = reader.uint32();
                    break;
                case /* repeated string FunctionArgs = 6 [json_name = "FunctionArgs"];*/ 6:
                    message.functionArgs.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PostgresFunctionCall, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseMetadata Database = 4 [json_name = "Database"]; */
        if (message.database)
            DatabaseMetadata.internalBinaryWrite(message.database, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* uint32 FunctionOID = 5 [json_name = "FunctionOID"]; */
        if (message.functionOID !== 0)
            writer.tag(5, WireType.Varint).uint32(message.functionOID);
        /* repeated string FunctionArgs = 6 [json_name = "FunctionArgs"]; */
        for (let i = 0; i < message.functionArgs.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.functionArgs[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.PostgresFunctionCall
 */
export const PostgresFunctionCall = new PostgresFunctionCall$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WindowsDesktopSessionStart$Type extends MessageType<WindowsDesktopSessionStart> {
    constructor() {
        super("events.WindowsDesktopSessionStart", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 6, name: "WindowsDesktopService", kind: "scalar", jsonName: "WindowsDesktopService", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "windows_desktop_service" } },
            { no: 7, name: "DesktopAddr", kind: "scalar", jsonName: "DesktopAddr", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "desktop_addr" } },
            { no: 8, name: "Domain", kind: "scalar", jsonName: "Domain", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "windows_domain" } },
            { no: 9, name: "WindowsUser", kind: "scalar", jsonName: "WindowsUser", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "windows_user" } },
            { no: 10, name: "DesktopLabels", kind: "map", jsonName: "DesktopLabels", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ }, options: { "gogoproto.jsontag": "desktop_labels" } },
            { no: 11, name: "DesktopName", kind: "scalar", jsonName: "DesktopName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "desktop_name" } },
            { no: 12, name: "AllowUserCreation", kind: "scalar", jsonName: "AllowUserCreation", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "allow_user_creation" } },
            { no: 13, name: "NLA", kind: "scalar", jsonName: "NLA", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "nla" } }
        ]);
    }
    create(value?: PartialMessage<WindowsDesktopSessionStart>): WindowsDesktopSessionStart {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.windowsDesktopService = "";
        message.desktopAddr = "";
        message.domain = "";
        message.windowsUser = "";
        message.desktopLabels = {};
        message.desktopName = "";
        message.allowUserCreation = false;
        message.nLA = false;
        if (value !== undefined)
            reflectionMergePartial<WindowsDesktopSessionStart>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WindowsDesktopSessionStart): WindowsDesktopSessionStart {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* events.Status Status = 5 [json_name = "Status"];*/ 5:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* string WindowsDesktopService = 6 [json_name = "WindowsDesktopService"];*/ 6:
                    message.windowsDesktopService = reader.string();
                    break;
                case /* string DesktopAddr = 7 [json_name = "DesktopAddr"];*/ 7:
                    message.desktopAddr = reader.string();
                    break;
                case /* string Domain = 8 [json_name = "Domain"];*/ 8:
                    message.domain = reader.string();
                    break;
                case /* string WindowsUser = 9 [json_name = "WindowsUser"];*/ 9:
                    message.windowsUser = reader.string();
                    break;
                case /* map<string, string> DesktopLabels = 10 [json_name = "DesktopLabels"];*/ 10:
                    this.binaryReadMap10(message.desktopLabels, reader, options);
                    break;
                case /* string DesktopName = 11 [json_name = "DesktopName"];*/ 11:
                    message.desktopName = reader.string();
                    break;
                case /* bool AllowUserCreation = 12 [json_name = "AllowUserCreation"];*/ 12:
                    message.allowUserCreation = reader.bool();
                    break;
                case /* bool NLA = 13 [json_name = "NLA"];*/ 13:
                    message.nLA = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap10(map: WindowsDesktopSessionStart["desktopLabels"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof WindowsDesktopSessionStart["desktopLabels"] | undefined, val: WindowsDesktopSessionStart["desktopLabels"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field events.WindowsDesktopSessionStart.DesktopLabels");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: WindowsDesktopSessionStart, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 5 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string WindowsDesktopService = 6 [json_name = "WindowsDesktopService"]; */
        if (message.windowsDesktopService !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.windowsDesktopService);
        /* string DesktopAddr = 7 [json_name = "DesktopAddr"]; */
        if (message.desktopAddr !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.desktopAddr);
        /* string Domain = 8 [json_name = "Domain"]; */
        if (message.domain !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.domain);
        /* string WindowsUser = 9 [json_name = "WindowsUser"]; */
        if (message.windowsUser !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.windowsUser);
        /* map<string, string> DesktopLabels = 10 [json_name = "DesktopLabels"]; */
        for (let k of globalThis.Object.keys(message.desktopLabels))
            writer.tag(10, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.desktopLabels[k]).join();
        /* string DesktopName = 11 [json_name = "DesktopName"]; */
        if (message.desktopName !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.desktopName);
        /* bool AllowUserCreation = 12 [json_name = "AllowUserCreation"]; */
        if (message.allowUserCreation !== false)
            writer.tag(12, WireType.Varint).bool(message.allowUserCreation);
        /* bool NLA = 13 [json_name = "NLA"]; */
        if (message.nLA !== false)
            writer.tag(13, WireType.Varint).bool(message.nLA);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.WindowsDesktopSessionStart
 */
export const WindowsDesktopSessionStart = new WindowsDesktopSessionStart$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DatabaseSessionEnd$Type extends MessageType<DatabaseSessionEnd> {
    constructor() {
        super("events.DatabaseSessionEnd", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Database", kind: "message", jsonName: "Database", T: () => DatabaseMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "StartTime", kind: "message", jsonName: "StartTime", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "session_start,omitempty", "gogoproto.stdtime": true } },
            { no: 6, name: "EndTime", kind: "message", jsonName: "EndTime", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "session_stop,omitempty", "gogoproto.stdtime": true } }
        ]);
    }
    create(value?: PartialMessage<DatabaseSessionEnd>): DatabaseSessionEnd {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DatabaseSessionEnd>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DatabaseSessionEnd): DatabaseSessionEnd {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.DatabaseMetadata Database = 4 [json_name = "Database"];*/ 4:
                    message.database = DatabaseMetadata.internalBinaryRead(reader, reader.uint32(), options, message.database);
                    break;
                case /* google.protobuf.Timestamp StartTime = 5 [json_name = "StartTime"];*/ 5:
                    message.startTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.startTime);
                    break;
                case /* google.protobuf.Timestamp EndTime = 6 [json_name = "EndTime"];*/ 6:
                    message.endTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.endTime);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DatabaseSessionEnd, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseMetadata Database = 4 [json_name = "Database"]; */
        if (message.database)
            DatabaseMetadata.internalBinaryWrite(message.database, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp StartTime = 5 [json_name = "StartTime"]; */
        if (message.startTime)
            Timestamp.internalBinaryWrite(message.startTime, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp EndTime = 6 [json_name = "EndTime"]; */
        if (message.endTime)
            Timestamp.internalBinaryWrite(message.endTime, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.DatabaseSessionEnd
 */
export const DatabaseSessionEnd = new DatabaseSessionEnd$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MFADeviceMetadata$Type extends MessageType<MFADeviceMetadata> {
    constructor() {
        super("events.MFADeviceMetadata", [
            { no: 1, name: "DeviceName", kind: "scalar", jsonName: "DeviceName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "mfa_device_name" } },
            { no: 2, name: "DeviceID", kind: "scalar", jsonName: "DeviceID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "mfa_device_uuid" } },
            { no: 3, name: "DeviceType", kind: "scalar", jsonName: "DeviceType", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "mfa_device_type" } }
        ]);
    }
    create(value?: PartialMessage<MFADeviceMetadata>): MFADeviceMetadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.deviceName = "";
        message.deviceID = "";
        message.deviceType = "";
        if (value !== undefined)
            reflectionMergePartial<MFADeviceMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MFADeviceMetadata): MFADeviceMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string DeviceName = 1 [json_name = "DeviceName"];*/ 1:
                    message.deviceName = reader.string();
                    break;
                case /* string DeviceID = 2 [json_name = "DeviceID"];*/ 2:
                    message.deviceID = reader.string();
                    break;
                case /* string DeviceType = 3 [json_name = "DeviceType"];*/ 3:
                    message.deviceType = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MFADeviceMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string DeviceName = 1 [json_name = "DeviceName"]; */
        if (message.deviceName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.deviceName);
        /* string DeviceID = 2 [json_name = "DeviceID"]; */
        if (message.deviceID !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.deviceID);
        /* string DeviceType = 3 [json_name = "DeviceType"]; */
        if (message.deviceType !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.deviceType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.MFADeviceMetadata
 */
export const MFADeviceMetadata = new MFADeviceMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MFADeviceAdd$Type extends MessageType<MFADeviceAdd> {
    constructor() {
        super("events.MFADeviceAdd", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Device", kind: "message", jsonName: "Device", T: () => MFADeviceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<MFADeviceAdd>): MFADeviceAdd {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MFADeviceAdd>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MFADeviceAdd): MFADeviceAdd {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.MFADeviceMetadata Device = 3 [json_name = "Device"];*/ 3:
                    message.device = MFADeviceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.device);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MFADeviceAdd, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.MFADeviceMetadata Device = 3 [json_name = "Device"]; */
        if (message.device)
            MFADeviceMetadata.internalBinaryWrite(message.device, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.MFADeviceAdd
 */
export const MFADeviceAdd = new MFADeviceAdd$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MFADeviceDelete$Type extends MessageType<MFADeviceDelete> {
    constructor() {
        super("events.MFADeviceDelete", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Device", kind: "message", jsonName: "Device", T: () => MFADeviceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<MFADeviceDelete>): MFADeviceDelete {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MFADeviceDelete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MFADeviceDelete): MFADeviceDelete {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.MFADeviceMetadata Device = 3 [json_name = "Device"];*/ 3:
                    message.device = MFADeviceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.device);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MFADeviceDelete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.MFADeviceMetadata Device = 3 [json_name = "Device"]; */
        if (message.device)
            MFADeviceMetadata.internalBinaryWrite(message.device, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.MFADeviceDelete
 */
export const MFADeviceDelete = new MFADeviceDelete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BillingInformationUpdate$Type extends MessageType<BillingInformationUpdate> {
    constructor() {
        super("events.BillingInformationUpdate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<BillingInformationUpdate>): BillingInformationUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<BillingInformationUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BillingInformationUpdate): BillingInformationUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BillingInformationUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.BillingInformationUpdate
 */
export const BillingInformationUpdate = new BillingInformationUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BillingCardCreate$Type extends MessageType<BillingCardCreate> {
    constructor() {
        super("events.BillingCardCreate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<BillingCardCreate>): BillingCardCreate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<BillingCardCreate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BillingCardCreate): BillingCardCreate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BillingCardCreate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.BillingCardCreate
 */
export const BillingCardCreate = new BillingCardCreate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BillingCardDelete$Type extends MessageType<BillingCardDelete> {
    constructor() {
        super("events.BillingCardDelete", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<BillingCardDelete>): BillingCardDelete {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<BillingCardDelete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BillingCardDelete): BillingCardDelete {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BillingCardDelete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.BillingCardDelete
 */
export const BillingCardDelete = new BillingCardDelete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LockCreate$Type extends MessageType<LockCreate> {
    constructor() {
        super("events.LockCreate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Target", kind: "message", jsonName: "Target", T: () => LockTarget, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "target" } },
            { no: 5, name: "Lock", kind: "message", jsonName: "Lock", T: () => LockMetadata, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "lock" } }
        ]);
    }
    create(value?: PartialMessage<LockCreate>): LockCreate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<LockCreate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LockCreate): LockCreate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* types.LockTarget Target = 4 [deprecated = true, json_name = "Target"];*/ 4:
                    message.target = LockTarget.internalBinaryRead(reader, reader.uint32(), options, message.target);
                    break;
                case /* events.LockMetadata Lock = 5 [json_name = "Lock"];*/ 5:
                    message.lock = LockMetadata.internalBinaryRead(reader, reader.uint32(), options, message.lock);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LockCreate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* types.LockTarget Target = 4 [deprecated = true, json_name = "Target"]; */
        if (message.target)
            LockTarget.internalBinaryWrite(message.target, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.LockMetadata Lock = 5 [json_name = "Lock"]; */
        if (message.lock)
            LockMetadata.internalBinaryWrite(message.lock, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.LockCreate
 */
export const LockCreate = new LockCreate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LockDelete$Type extends MessageType<LockDelete> {
    constructor() {
        super("events.LockDelete", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Lock", kind: "message", jsonName: "Lock", T: () => LockMetadata, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "lock" } }
        ]);
    }
    create(value?: PartialMessage<LockDelete>): LockDelete {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<LockDelete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LockDelete): LockDelete {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.LockMetadata Lock = 4 [json_name = "Lock"];*/ 4:
                    message.lock = LockMetadata.internalBinaryRead(reader, reader.uint32(), options, message.lock);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LockDelete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.LockMetadata Lock = 4 [json_name = "Lock"]; */
        if (message.lock)
            LockMetadata.internalBinaryWrite(message.lock, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.LockDelete
 */
export const LockDelete = new LockDelete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RecoveryCodeGenerate$Type extends MessageType<RecoveryCodeGenerate> {
    constructor() {
        super("events.RecoveryCodeGenerate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<RecoveryCodeGenerate>): RecoveryCodeGenerate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RecoveryCodeGenerate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RecoveryCodeGenerate): RecoveryCodeGenerate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RecoveryCodeGenerate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.RecoveryCodeGenerate
 */
export const RecoveryCodeGenerate = new RecoveryCodeGenerate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RecoveryCodeUsed$Type extends MessageType<RecoveryCodeUsed> {
    constructor() {
        super("events.RecoveryCodeUsed", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<RecoveryCodeUsed>): RecoveryCodeUsed {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RecoveryCodeUsed>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RecoveryCodeUsed): RecoveryCodeUsed {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.Status Status = 3 [json_name = "Status"];*/ 3:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RecoveryCodeUsed, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 3 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.RecoveryCodeUsed
 */
export const RecoveryCodeUsed = new RecoveryCodeUsed$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WindowsDesktopSessionEnd$Type extends MessageType<WindowsDesktopSessionEnd> {
    constructor() {
        super("events.WindowsDesktopSessionEnd", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "WindowsDesktopService", kind: "scalar", jsonName: "WindowsDesktopService", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "windows_desktop_service" } },
            { no: 5, name: "DesktopAddr", kind: "scalar", jsonName: "DesktopAddr", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "desktop_addr" } },
            { no: 6, name: "Domain", kind: "scalar", jsonName: "Domain", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "windows_domain" } },
            { no: 7, name: "WindowsUser", kind: "scalar", jsonName: "WindowsUser", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "windows_user" } },
            { no: 8, name: "DesktopLabels", kind: "map", jsonName: "DesktopLabels", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ }, options: { "gogoproto.jsontag": "desktop_labels" } },
            { no: 9, name: "StartTime", kind: "message", jsonName: "StartTime", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "session_start,omitempty", "gogoproto.stdtime": true } },
            { no: 10, name: "EndTime", kind: "message", jsonName: "EndTime", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "session_stop,omitempty", "gogoproto.stdtime": true } },
            { no: 11, name: "DesktopName", kind: "scalar", jsonName: "DesktopName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "desktop_name" } },
            { no: 12, name: "Recorded", kind: "scalar", jsonName: "Recorded", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "recorded" } },
            { no: 13, name: "Participants", kind: "scalar", jsonName: "Participants", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "participants" } }
        ]);
    }
    create(value?: PartialMessage<WindowsDesktopSessionEnd>): WindowsDesktopSessionEnd {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.windowsDesktopService = "";
        message.desktopAddr = "";
        message.domain = "";
        message.windowsUser = "";
        message.desktopLabels = {};
        message.desktopName = "";
        message.recorded = false;
        message.participants = [];
        if (value !== undefined)
            reflectionMergePartial<WindowsDesktopSessionEnd>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WindowsDesktopSessionEnd): WindowsDesktopSessionEnd {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* string WindowsDesktopService = 4 [json_name = "WindowsDesktopService"];*/ 4:
                    message.windowsDesktopService = reader.string();
                    break;
                case /* string DesktopAddr = 5 [json_name = "DesktopAddr"];*/ 5:
                    message.desktopAddr = reader.string();
                    break;
                case /* string Domain = 6 [json_name = "Domain"];*/ 6:
                    message.domain = reader.string();
                    break;
                case /* string WindowsUser = 7 [json_name = "WindowsUser"];*/ 7:
                    message.windowsUser = reader.string();
                    break;
                case /* map<string, string> DesktopLabels = 8 [json_name = "DesktopLabels"];*/ 8:
                    this.binaryReadMap8(message.desktopLabels, reader, options);
                    break;
                case /* google.protobuf.Timestamp StartTime = 9 [json_name = "StartTime"];*/ 9:
                    message.startTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.startTime);
                    break;
                case /* google.protobuf.Timestamp EndTime = 10 [json_name = "EndTime"];*/ 10:
                    message.endTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.endTime);
                    break;
                case /* string DesktopName = 11 [json_name = "DesktopName"];*/ 11:
                    message.desktopName = reader.string();
                    break;
                case /* bool Recorded = 12 [json_name = "Recorded"];*/ 12:
                    message.recorded = reader.bool();
                    break;
                case /* repeated string Participants = 13 [json_name = "Participants"];*/ 13:
                    message.participants.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap8(map: WindowsDesktopSessionEnd["desktopLabels"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof WindowsDesktopSessionEnd["desktopLabels"] | undefined, val: WindowsDesktopSessionEnd["desktopLabels"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field events.WindowsDesktopSessionEnd.DesktopLabels");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: WindowsDesktopSessionEnd, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string WindowsDesktopService = 4 [json_name = "WindowsDesktopService"]; */
        if (message.windowsDesktopService !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.windowsDesktopService);
        /* string DesktopAddr = 5 [json_name = "DesktopAddr"]; */
        if (message.desktopAddr !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.desktopAddr);
        /* string Domain = 6 [json_name = "Domain"]; */
        if (message.domain !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.domain);
        /* string WindowsUser = 7 [json_name = "WindowsUser"]; */
        if (message.windowsUser !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.windowsUser);
        /* map<string, string> DesktopLabels = 8 [json_name = "DesktopLabels"]; */
        for (let k of globalThis.Object.keys(message.desktopLabels))
            writer.tag(8, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.desktopLabels[k]).join();
        /* google.protobuf.Timestamp StartTime = 9 [json_name = "StartTime"]; */
        if (message.startTime)
            Timestamp.internalBinaryWrite(message.startTime, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp EndTime = 10 [json_name = "EndTime"]; */
        if (message.endTime)
            Timestamp.internalBinaryWrite(message.endTime, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* string DesktopName = 11 [json_name = "DesktopName"]; */
        if (message.desktopName !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.desktopName);
        /* bool Recorded = 12 [json_name = "Recorded"]; */
        if (message.recorded !== false)
            writer.tag(12, WireType.Varint).bool(message.recorded);
        /* repeated string Participants = 13 [json_name = "Participants"]; */
        for (let i = 0; i < message.participants.length; i++)
            writer.tag(13, WireType.LengthDelimited).string(message.participants[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.WindowsDesktopSessionEnd
 */
export const WindowsDesktopSessionEnd = new WindowsDesktopSessionEnd$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CertificateCreate$Type extends MessageType<CertificateCreate> {
    constructor() {
        super("events.CertificateCreate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "CertificateType", kind: "scalar", jsonName: "CertificateType", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "cert_type,omitempty" } },
            { no: 3, name: "Identity", kind: "message", jsonName: "Identity", T: () => Identity, options: { "gogoproto.jsontag": "identity" } },
            { no: 4, name: "Client", kind: "message", jsonName: "Client", T: () => ClientMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<CertificateCreate>): CertificateCreate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.certificateType = "";
        if (value !== undefined)
            reflectionMergePartial<CertificateCreate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CertificateCreate): CertificateCreate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* string CertificateType = 2 [json_name = "CertificateType"];*/ 2:
                    message.certificateType = reader.string();
                    break;
                case /* events.Identity Identity = 3 [json_name = "Identity"];*/ 3:
                    message.identity = Identity.internalBinaryRead(reader, reader.uint32(), options, message.identity);
                    break;
                case /* events.ClientMetadata Client = 4 [json_name = "Client"];*/ 4:
                    message.client = ClientMetadata.internalBinaryRead(reader, reader.uint32(), options, message.client);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CertificateCreate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string CertificateType = 2 [json_name = "CertificateType"]; */
        if (message.certificateType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.certificateType);
        /* events.Identity Identity = 3 [json_name = "Identity"]; */
        if (message.identity)
            Identity.internalBinaryWrite(message.identity, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ClientMetadata Client = 4 [json_name = "Client"]; */
        if (message.client)
            ClientMetadata.internalBinaryWrite(message.client, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.CertificateCreate
 */
export const CertificateCreate = new CertificateCreate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RenewableCertificateGenerationMismatch$Type extends MessageType<RenewableCertificateGenerationMismatch> {
    constructor() {
        super("events.RenewableCertificateGenerationMismatch", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "UserMetadata", kind: "message", jsonName: "UserMetadata", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<RenewableCertificateGenerationMismatch>): RenewableCertificateGenerationMismatch {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RenewableCertificateGenerationMismatch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RenewableCertificateGenerationMismatch): RenewableCertificateGenerationMismatch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata UserMetadata = 2 [json_name = "UserMetadata"];*/ 2:
                    message.userMetadata = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.userMetadata);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RenewableCertificateGenerationMismatch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata UserMetadata = 2 [json_name = "UserMetadata"]; */
        if (message.userMetadata)
            UserMetadata.internalBinaryWrite(message.userMetadata, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.RenewableCertificateGenerationMismatch
 */
export const RenewableCertificateGenerationMismatch = new RenewableCertificateGenerationMismatch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotJoin$Type extends MessageType<BotJoin> {
    constructor() {
        super("events.BotJoin", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "BotName", kind: "scalar", jsonName: "BotName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "bot_name,omitempty" } },
            { no: 4, name: "Method", kind: "scalar", jsonName: "Method", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "method,omitempty" } },
            { no: 5, name: "TokenName", kind: "scalar", jsonName: "TokenName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "token_name,omitempty" } },
            { no: 6, name: "Attributes", kind: "message", jsonName: "Attributes", T: () => Struct, options: { "gogoproto.jsontag": "attributes,omitempty", "gogoproto.casttype": "Struct" } },
            { no: 7, name: "UserName", kind: "scalar", jsonName: "UserName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "user_name,omitempty" } },
            { no: 8, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 9, name: "BotInstanceID", kind: "scalar", jsonName: "BotInstanceID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "bot_instance_id,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<BotJoin>): BotJoin {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.botName = "";
        message.method = "";
        message.tokenName = "";
        message.userName = "";
        message.botInstanceID = "";
        if (value !== undefined)
            reflectionMergePartial<BotJoin>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BotJoin): BotJoin {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.Status Status = 2 [json_name = "Status"];*/ 2:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* string BotName = 3 [json_name = "BotName"];*/ 3:
                    message.botName = reader.string();
                    break;
                case /* string Method = 4 [json_name = "Method"];*/ 4:
                    message.method = reader.string();
                    break;
                case /* string TokenName = 5 [json_name = "TokenName"];*/ 5:
                    message.tokenName = reader.string();
                    break;
                case /* google.protobuf.Struct Attributes = 6 [json_name = "Attributes"];*/ 6:
                    message.attributes = Struct.internalBinaryRead(reader, reader.uint32(), options, message.attributes);
                    break;
                case /* string UserName = 7 [json_name = "UserName"];*/ 7:
                    message.userName = reader.string();
                    break;
                case /* events.ConnectionMetadata Connection = 8 [json_name = "Connection"];*/ 8:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* string BotInstanceID = 9 [json_name = "BotInstanceID"];*/ 9:
                    message.botInstanceID = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BotJoin, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 2 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string BotName = 3 [json_name = "BotName"]; */
        if (message.botName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.botName);
        /* string Method = 4 [json_name = "Method"]; */
        if (message.method !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.method);
        /* string TokenName = 5 [json_name = "TokenName"]; */
        if (message.tokenName !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.tokenName);
        /* google.protobuf.Struct Attributes = 6 [json_name = "Attributes"]; */
        if (message.attributes)
            Struct.internalBinaryWrite(message.attributes, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* string UserName = 7 [json_name = "UserName"]; */
        if (message.userName !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.userName);
        /* events.ConnectionMetadata Connection = 8 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* string BotInstanceID = 9 [json_name = "BotInstanceID"]; */
        if (message.botInstanceID !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.botInstanceID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.BotJoin
 */
export const BotJoin = new BotJoin$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InstanceJoin$Type extends MessageType<InstanceJoin> {
    constructor() {
        super("events.InstanceJoin", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "HostID", kind: "scalar", jsonName: "HostID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "host_id,omitempty" } },
            { no: 4, name: "NodeName", kind: "scalar", jsonName: "NodeName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "node_name,omitempty" } },
            { no: 5, name: "Role", kind: "scalar", jsonName: "Role", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "role,omitempty" } },
            { no: 6, name: "Method", kind: "scalar", jsonName: "Method", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "method,omitempty" } },
            { no: 7, name: "TokenName", kind: "scalar", jsonName: "TokenName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "token_name,omitempty" } },
            { no: 8, name: "Attributes", kind: "message", jsonName: "Attributes", T: () => Struct, options: { "gogoproto.jsontag": "attributes,omitempty", "gogoproto.casttype": "Struct" } },
            { no: 9, name: "TokenExpires", kind: "message", jsonName: "TokenExpires", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "token_expires", "gogoproto.stdtime": true } },
            { no: 10, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<InstanceJoin>): InstanceJoin {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hostID = "";
        message.nodeName = "";
        message.role = "";
        message.method = "";
        message.tokenName = "";
        if (value !== undefined)
            reflectionMergePartial<InstanceJoin>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InstanceJoin): InstanceJoin {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.Status Status = 2 [json_name = "Status"];*/ 2:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* string HostID = 3 [json_name = "HostID"];*/ 3:
                    message.hostID = reader.string();
                    break;
                case /* string NodeName = 4 [json_name = "NodeName"];*/ 4:
                    message.nodeName = reader.string();
                    break;
                case /* string Role = 5 [json_name = "Role"];*/ 5:
                    message.role = reader.string();
                    break;
                case /* string Method = 6 [json_name = "Method"];*/ 6:
                    message.method = reader.string();
                    break;
                case /* string TokenName = 7 [json_name = "TokenName"];*/ 7:
                    message.tokenName = reader.string();
                    break;
                case /* google.protobuf.Struct Attributes = 8 [json_name = "Attributes"];*/ 8:
                    message.attributes = Struct.internalBinaryRead(reader, reader.uint32(), options, message.attributes);
                    break;
                case /* google.protobuf.Timestamp TokenExpires = 9 [json_name = "TokenExpires"];*/ 9:
                    message.tokenExpires = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.tokenExpires);
                    break;
                case /* events.ConnectionMetadata Connection = 10 [json_name = "Connection"];*/ 10:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InstanceJoin, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 2 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string HostID = 3 [json_name = "HostID"]; */
        if (message.hostID !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.hostID);
        /* string NodeName = 4 [json_name = "NodeName"]; */
        if (message.nodeName !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.nodeName);
        /* string Role = 5 [json_name = "Role"]; */
        if (message.role !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.role);
        /* string Method = 6 [json_name = "Method"]; */
        if (message.method !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.method);
        /* string TokenName = 7 [json_name = "TokenName"]; */
        if (message.tokenName !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.tokenName);
        /* google.protobuf.Struct Attributes = 8 [json_name = "Attributes"]; */
        if (message.attributes)
            Struct.internalBinaryWrite(message.attributes, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp TokenExpires = 9 [json_name = "TokenExpires"]; */
        if (message.tokenExpires)
            Timestamp.internalBinaryWrite(message.tokenExpires, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 10 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.InstanceJoin
 */
export const InstanceJoin = new InstanceJoin$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Unknown$Type extends MessageType<Unknown> {
    constructor() {
        super("events.Unknown", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "UnknownType", kind: "scalar", jsonName: "UnknownType", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "unknown_event" } },
            { no: 3, name: "UnknownCode", kind: "scalar", jsonName: "UnknownCode", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "unknown_code,omitempty" } },
            { no: 4, name: "Data", kind: "scalar", jsonName: "Data", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "data" } }
        ]);
    }
    create(value?: PartialMessage<Unknown>): Unknown {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.unknownType = "";
        message.unknownCode = "";
        message.data = "";
        if (value !== undefined)
            reflectionMergePartial<Unknown>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Unknown): Unknown {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* string UnknownType = 2 [json_name = "UnknownType"];*/ 2:
                    message.unknownType = reader.string();
                    break;
                case /* string UnknownCode = 3 [json_name = "UnknownCode"];*/ 3:
                    message.unknownCode = reader.string();
                    break;
                case /* string Data = 4 [json_name = "Data"];*/ 4:
                    message.data = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Unknown, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string UnknownType = 2 [json_name = "UnknownType"]; */
        if (message.unknownType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.unknownType);
        /* string UnknownCode = 3 [json_name = "UnknownCode"]; */
        if (message.unknownCode !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.unknownCode);
        /* string Data = 4 [json_name = "Data"]; */
        if (message.data !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.Unknown
 */
export const Unknown = new Unknown$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeviceMetadata$Type extends MessageType<DeviceMetadata> {
    constructor() {
        super("events.DeviceMetadata", [
            { no: 1, name: "device_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "device_id" } },
            { no: 2, name: "os_type", kind: "enum", T: () => ["events.OSType", OSType], options: { "gogoproto.jsontag": "os_type,omitempty" } },
            { no: 3, name: "asset_tag", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "asset_tag,omitempty" } },
            { no: 4, name: "credential_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "credential_id,omitempty" } },
            { no: 5, name: "device_origin", kind: "enum", T: () => ["events.DeviceOrigin", DeviceOrigin, "DEVICE_ORIGIN_"], options: { "gogoproto.jsontag": "device_origin,omitempty" } },
            { no: 6, name: "web_authentication", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "web_authentication,omitempty" } },
            { no: 8, name: "web_authentication_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "web_authentication_id,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<DeviceMetadata>): DeviceMetadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.deviceId = "";
        message.osType = 0;
        message.assetTag = "";
        message.credentialId = "";
        message.deviceOrigin = 0;
        message.webAuthentication = false;
        message.webAuthenticationId = "";
        if (value !== undefined)
            reflectionMergePartial<DeviceMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeviceMetadata): DeviceMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string device_id */ 1:
                    message.deviceId = reader.string();
                    break;
                case /* events.OSType os_type */ 2:
                    message.osType = reader.int32();
                    break;
                case /* string asset_tag */ 3:
                    message.assetTag = reader.string();
                    break;
                case /* string credential_id */ 4:
                    message.credentialId = reader.string();
                    break;
                case /* events.DeviceOrigin device_origin */ 5:
                    message.deviceOrigin = reader.int32();
                    break;
                case /* bool web_authentication */ 6:
                    message.webAuthentication = reader.bool();
                    break;
                case /* string web_authentication_id */ 8:
                    message.webAuthenticationId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeviceMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string device_id = 1; */
        if (message.deviceId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.deviceId);
        /* events.OSType os_type = 2; */
        if (message.osType !== 0)
            writer.tag(2, WireType.Varint).int32(message.osType);
        /* string asset_tag = 3; */
        if (message.assetTag !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.assetTag);
        /* string credential_id = 4; */
        if (message.credentialId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.credentialId);
        /* events.DeviceOrigin device_origin = 5; */
        if (message.deviceOrigin !== 0)
            writer.tag(5, WireType.Varint).int32(message.deviceOrigin);
        /* bool web_authentication = 6; */
        if (message.webAuthentication !== false)
            writer.tag(6, WireType.Varint).bool(message.webAuthentication);
        /* string web_authentication_id = 8; */
        if (message.webAuthenticationId !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.webAuthenticationId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.DeviceMetadata
 */
export const DeviceMetadata = new DeviceMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeviceEvent$Type extends MessageType<DeviceEvent> {
    constructor() {
        super("events.DeviceEvent", [
            { no: 1, name: "metadata", kind: "message", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "status", kind: "message", T: () => Status },
            { no: 3, name: "device", kind: "message", T: () => DeviceMetadata },
            { no: 4, name: "user", kind: "message", T: () => UserMetadata }
        ]);
    }
    create(value?: PartialMessage<DeviceEvent>): DeviceEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeviceEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeviceEvent): DeviceEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata metadata */ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.Status status */ 2:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* events.DeviceMetadata device */ 3:
                    message.device = DeviceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.device);
                    break;
                case /* events.UserMetadata user */ 4:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeviceEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata metadata = 1; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.Status status = 2; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.DeviceMetadata device = 3; */
        if (message.device)
            DeviceMetadata.internalBinaryWrite(message.device, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata user = 4; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.DeviceEvent
 */
export const DeviceEvent = new DeviceEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeviceEvent2$Type extends MessageType<DeviceEvent2> {
    constructor() {
        super("events.DeviceEvent2", [
            { no: 1, name: "metadata", kind: "message", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "device", kind: "message", T: () => DeviceMetadata, options: { "gogoproto.jsontag": "device" } },
            { no: 5, name: "status", kind: "message", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 6, name: "user", kind: "message", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<DeviceEvent2>): DeviceEvent2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeviceEvent2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeviceEvent2): DeviceEvent2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata metadata */ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.DeviceMetadata device */ 3:
                    message.device = DeviceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.device);
                    break;
                case /* events.Status status */ 5:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* events.UserMetadata user */ 6:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeviceEvent2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata metadata = 1; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.DeviceMetadata device = 3; */
        if (message.device)
            DeviceMetadata.internalBinaryWrite(message.device, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.Status status = 5; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata user = 6; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.DeviceEvent2
 */
export const DeviceEvent2 = new DeviceEvent2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DiscoveryConfigCreate$Type extends MessageType<DiscoveryConfigCreate> {
    constructor() {
        super("events.DiscoveryConfigCreate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<DiscoveryConfigCreate>): DiscoveryConfigCreate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DiscoveryConfigCreate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DiscoveryConfigCreate): DiscoveryConfigCreate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ResourceMetadata Resource = 3 [json_name = "Resource"];*/ 3:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DiscoveryConfigCreate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 3 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.DiscoveryConfigCreate
 */
export const DiscoveryConfigCreate = new DiscoveryConfigCreate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DiscoveryConfigUpdate$Type extends MessageType<DiscoveryConfigUpdate> {
    constructor() {
        super("events.DiscoveryConfigUpdate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<DiscoveryConfigUpdate>): DiscoveryConfigUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DiscoveryConfigUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DiscoveryConfigUpdate): DiscoveryConfigUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ResourceMetadata Resource = 3 [json_name = "Resource"];*/ 3:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DiscoveryConfigUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 3 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.DiscoveryConfigUpdate
 */
export const DiscoveryConfigUpdate = new DiscoveryConfigUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DiscoveryConfigDelete$Type extends MessageType<DiscoveryConfigDelete> {
    constructor() {
        super("events.DiscoveryConfigDelete", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<DiscoveryConfigDelete>): DiscoveryConfigDelete {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DiscoveryConfigDelete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DiscoveryConfigDelete): DiscoveryConfigDelete {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ResourceMetadata Resource = 3 [json_name = "Resource"];*/ 3:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DiscoveryConfigDelete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 3 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.DiscoveryConfigDelete
 */
export const DiscoveryConfigDelete = new DiscoveryConfigDelete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DiscoveryConfigDeleteAll$Type extends MessageType<DiscoveryConfigDeleteAll> {
    constructor() {
        super("events.DiscoveryConfigDeleteAll", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<DiscoveryConfigDeleteAll>): DiscoveryConfigDeleteAll {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DiscoveryConfigDeleteAll>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DiscoveryConfigDeleteAll): DiscoveryConfigDeleteAll {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 3 [json_name = "Connection"];*/ 3:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DiscoveryConfigDeleteAll, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 3 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.DiscoveryConfigDeleteAll
 */
export const DiscoveryConfigDeleteAll = new DiscoveryConfigDeleteAll$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IntegrationCreate$Type extends MessageType<IntegrationCreate> {
    constructor() {
        super("events.IntegrationCreate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Integration", kind: "message", jsonName: "Integration", T: () => IntegrationMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<IntegrationCreate>): IntegrationCreate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<IntegrationCreate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IntegrationCreate): IntegrationCreate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ResourceMetadata Resource = 3 [json_name = "Resource"];*/ 3:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.IntegrationMetadata Integration = 4 [json_name = "Integration"];*/ 4:
                    message.integration = IntegrationMetadata.internalBinaryRead(reader, reader.uint32(), options, message.integration);
                    break;
                case /* events.ConnectionMetadata Connection = 5 [json_name = "Connection"];*/ 5:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IntegrationCreate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 3 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.IntegrationMetadata Integration = 4 [json_name = "Integration"]; */
        if (message.integration)
            IntegrationMetadata.internalBinaryWrite(message.integration, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 5 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.IntegrationCreate
 */
export const IntegrationCreate = new IntegrationCreate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IntegrationUpdate$Type extends MessageType<IntegrationUpdate> {
    constructor() {
        super("events.IntegrationUpdate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Integration", kind: "message", jsonName: "Integration", T: () => IntegrationMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<IntegrationUpdate>): IntegrationUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<IntegrationUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IntegrationUpdate): IntegrationUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ResourceMetadata Resource = 3 [json_name = "Resource"];*/ 3:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.IntegrationMetadata Integration = 4 [json_name = "Integration"];*/ 4:
                    message.integration = IntegrationMetadata.internalBinaryRead(reader, reader.uint32(), options, message.integration);
                    break;
                case /* events.ConnectionMetadata Connection = 5 [json_name = "Connection"];*/ 5:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IntegrationUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 3 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.IntegrationMetadata Integration = 4 [json_name = "Integration"]; */
        if (message.integration)
            IntegrationMetadata.internalBinaryWrite(message.integration, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 5 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.IntegrationUpdate
 */
export const IntegrationUpdate = new IntegrationUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IntegrationDelete$Type extends MessageType<IntegrationDelete> {
    constructor() {
        super("events.IntegrationDelete", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Integration", kind: "message", jsonName: "Integration", T: () => IntegrationMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<IntegrationDelete>): IntegrationDelete {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<IntegrationDelete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IntegrationDelete): IntegrationDelete {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ResourceMetadata Resource = 3 [json_name = "Resource"];*/ 3:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.IntegrationMetadata Integration = 4 [json_name = "Integration"];*/ 4:
                    message.integration = IntegrationMetadata.internalBinaryRead(reader, reader.uint32(), options, message.integration);
                    break;
                case /* events.ConnectionMetadata Connection = 5 [json_name = "Connection"];*/ 5:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IntegrationDelete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 3 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.IntegrationMetadata Integration = 4 [json_name = "Integration"]; */
        if (message.integration)
            IntegrationMetadata.internalBinaryWrite(message.integration, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 5 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.IntegrationDelete
 */
export const IntegrationDelete = new IntegrationDelete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IntegrationMetadata$Type extends MessageType<IntegrationMetadata> {
    constructor() {
        super("events.IntegrationMetadata", [
            { no: 1, name: "SubKind", kind: "scalar", jsonName: "SubKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub_kind" } },
            { no: 2, name: "AWSOIDC", kind: "message", jsonName: "AWSOIDC", T: () => AWSOIDCIntegrationMetadata, options: { "gogoproto.jsontag": "aws_oidc,omitempty" } },
            { no: 3, name: "AzureOIDC", kind: "message", jsonName: "AzureOIDC", T: () => AzureOIDCIntegrationMetadata, options: { "gogoproto.jsontag": "azure_oidc,omitempty" } },
            { no: 4, name: "GitHub", kind: "message", jsonName: "GitHub", T: () => GitHubIntegrationMetadata, options: { "gogoproto.jsontag": "github,omitempty" } },
            { no: 5, name: "AWSRA", kind: "message", jsonName: "AWSRA", T: () => AWSRAIntegrationMetadata, options: { "gogoproto.jsontag": "aws_ra,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<IntegrationMetadata>): IntegrationMetadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subKind = "";
        if (value !== undefined)
            reflectionMergePartial<IntegrationMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IntegrationMetadata): IntegrationMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string SubKind = 1 [json_name = "SubKind"];*/ 1:
                    message.subKind = reader.string();
                    break;
                case /* events.AWSOIDCIntegrationMetadata AWSOIDC = 2 [json_name = "AWSOIDC"];*/ 2:
                    message.aWSOIDC = AWSOIDCIntegrationMetadata.internalBinaryRead(reader, reader.uint32(), options, message.aWSOIDC);
                    break;
                case /* events.AzureOIDCIntegrationMetadata AzureOIDC = 3 [json_name = "AzureOIDC"];*/ 3:
                    message.azureOIDC = AzureOIDCIntegrationMetadata.internalBinaryRead(reader, reader.uint32(), options, message.azureOIDC);
                    break;
                case /* events.GitHubIntegrationMetadata GitHub = 4 [json_name = "GitHub"];*/ 4:
                    message.gitHub = GitHubIntegrationMetadata.internalBinaryRead(reader, reader.uint32(), options, message.gitHub);
                    break;
                case /* events.AWSRAIntegrationMetadata AWSRA = 5 [json_name = "AWSRA"];*/ 5:
                    message.aWSRA = AWSRAIntegrationMetadata.internalBinaryRead(reader, reader.uint32(), options, message.aWSRA);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IntegrationMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string SubKind = 1 [json_name = "SubKind"]; */
        if (message.subKind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subKind);
        /* events.AWSOIDCIntegrationMetadata AWSOIDC = 2 [json_name = "AWSOIDC"]; */
        if (message.aWSOIDC)
            AWSOIDCIntegrationMetadata.internalBinaryWrite(message.aWSOIDC, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.AzureOIDCIntegrationMetadata AzureOIDC = 3 [json_name = "AzureOIDC"]; */
        if (message.azureOIDC)
            AzureOIDCIntegrationMetadata.internalBinaryWrite(message.azureOIDC, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.GitHubIntegrationMetadata GitHub = 4 [json_name = "GitHub"]; */
        if (message.gitHub)
            GitHubIntegrationMetadata.internalBinaryWrite(message.gitHub, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.AWSRAIntegrationMetadata AWSRA = 5 [json_name = "AWSRA"]; */
        if (message.aWSRA)
            AWSRAIntegrationMetadata.internalBinaryWrite(message.aWSRA, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.IntegrationMetadata
 */
export const IntegrationMetadata = new IntegrationMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AWSOIDCIntegrationMetadata$Type extends MessageType<AWSOIDCIntegrationMetadata> {
    constructor() {
        super("events.AWSOIDCIntegrationMetadata", [
            { no: 1, name: "RoleARN", kind: "scalar", jsonName: "RoleARN", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "role_arn,omitempty" } },
            { no: 2, name: "IssuerS3URI", kind: "scalar", jsonName: "IssuerS3URI", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "issuer_s3_uri,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<AWSOIDCIntegrationMetadata>): AWSOIDCIntegrationMetadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.roleARN = "";
        message.issuerS3URI = "";
        if (value !== undefined)
            reflectionMergePartial<AWSOIDCIntegrationMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AWSOIDCIntegrationMetadata): AWSOIDCIntegrationMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string RoleARN = 1 [json_name = "RoleARN"];*/ 1:
                    message.roleARN = reader.string();
                    break;
                case /* string IssuerS3URI = 2 [json_name = "IssuerS3URI"];*/ 2:
                    message.issuerS3URI = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AWSOIDCIntegrationMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string RoleARN = 1 [json_name = "RoleARN"]; */
        if (message.roleARN !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.roleARN);
        /* string IssuerS3URI = 2 [json_name = "IssuerS3URI"]; */
        if (message.issuerS3URI !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.issuerS3URI);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.AWSOIDCIntegrationMetadata
 */
export const AWSOIDCIntegrationMetadata = new AWSOIDCIntegrationMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AzureOIDCIntegrationMetadata$Type extends MessageType<AzureOIDCIntegrationMetadata> {
    constructor() {
        super("events.AzureOIDCIntegrationMetadata", [
            { no: 1, name: "TenantID", kind: "scalar", jsonName: "TenantID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "tenant_id,omitempty" } },
            { no: 2, name: "ClientID", kind: "scalar", jsonName: "ClientID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "client_id,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<AzureOIDCIntegrationMetadata>): AzureOIDCIntegrationMetadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tenantID = "";
        message.clientID = "";
        if (value !== undefined)
            reflectionMergePartial<AzureOIDCIntegrationMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AzureOIDCIntegrationMetadata): AzureOIDCIntegrationMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string TenantID = 1 [json_name = "TenantID"];*/ 1:
                    message.tenantID = reader.string();
                    break;
                case /* string ClientID = 2 [json_name = "ClientID"];*/ 2:
                    message.clientID = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AzureOIDCIntegrationMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string TenantID = 1 [json_name = "TenantID"]; */
        if (message.tenantID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tenantID);
        /* string ClientID = 2 [json_name = "ClientID"]; */
        if (message.clientID !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.clientID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.AzureOIDCIntegrationMetadata
 */
export const AzureOIDCIntegrationMetadata = new AzureOIDCIntegrationMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GitHubIntegrationMetadata$Type extends MessageType<GitHubIntegrationMetadata> {
    constructor() {
        super("events.GitHubIntegrationMetadata", [
            { no: 1, name: "Organization", kind: "scalar", jsonName: "Organization", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "organization,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<GitHubIntegrationMetadata>): GitHubIntegrationMetadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.organization = "";
        if (value !== undefined)
            reflectionMergePartial<GitHubIntegrationMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GitHubIntegrationMetadata): GitHubIntegrationMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Organization = 1 [json_name = "Organization"];*/ 1:
                    message.organization = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GitHubIntegrationMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Organization = 1 [json_name = "Organization"]; */
        if (message.organization !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.organization);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.GitHubIntegrationMetadata
 */
export const GitHubIntegrationMetadata = new GitHubIntegrationMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AWSRAIntegrationMetadata$Type extends MessageType<AWSRAIntegrationMetadata> {
    constructor() {
        super("events.AWSRAIntegrationMetadata", [
            { no: 1, name: "TrustAnchorARN", kind: "scalar", jsonName: "TrustAnchorARN", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "trust_anchor_arn,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<AWSRAIntegrationMetadata>): AWSRAIntegrationMetadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.trustAnchorARN = "";
        if (value !== undefined)
            reflectionMergePartial<AWSRAIntegrationMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AWSRAIntegrationMetadata): AWSRAIntegrationMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string TrustAnchorARN = 1 [json_name = "TrustAnchorARN"];*/ 1:
                    message.trustAnchorARN = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AWSRAIntegrationMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string TrustAnchorARN = 1 [json_name = "TrustAnchorARN"]; */
        if (message.trustAnchorARN !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.trustAnchorARN);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.AWSRAIntegrationMetadata
 */
export const AWSRAIntegrationMetadata = new AWSRAIntegrationMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginCreate$Type extends MessageType<PluginCreate> {
    constructor() {
        super("events.PluginCreate", [
            { no: 1, name: "metadata", kind: "message", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "user", kind: "message", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "resource", kind: "message", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "plugin", kind: "message", T: () => PluginMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "connection", kind: "message", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<PluginCreate>): PluginCreate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PluginCreate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginCreate): PluginCreate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata metadata */ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata user */ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ResourceMetadata resource */ 3:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.PluginMetadata plugin */ 4:
                    message.plugin = PluginMetadata.internalBinaryRead(reader, reader.uint32(), options, message.plugin);
                    break;
                case /* events.ConnectionMetadata connection */ 5:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginCreate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata metadata = 1; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata user = 2; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata resource = 3; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.PluginMetadata plugin = 4; */
        if (message.plugin)
            PluginMetadata.internalBinaryWrite(message.plugin, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata connection = 5; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.PluginCreate
 */
export const PluginCreate = new PluginCreate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginUpdate$Type extends MessageType<PluginUpdate> {
    constructor() {
        super("events.PluginUpdate", [
            { no: 1, name: "metadata", kind: "message", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "user", kind: "message", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "resource", kind: "message", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "plugin", kind: "message", T: () => PluginMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "connection", kind: "message", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<PluginUpdate>): PluginUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PluginUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginUpdate): PluginUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata metadata */ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata user */ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ResourceMetadata resource */ 3:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.PluginMetadata plugin */ 4:
                    message.plugin = PluginMetadata.internalBinaryRead(reader, reader.uint32(), options, message.plugin);
                    break;
                case /* events.ConnectionMetadata connection */ 5:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata metadata = 1; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata user = 2; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata resource = 3; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.PluginMetadata plugin = 4; */
        if (message.plugin)
            PluginMetadata.internalBinaryWrite(message.plugin, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata connection = 5; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.PluginUpdate
 */
export const PluginUpdate = new PluginUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginDelete$Type extends MessageType<PluginDelete> {
    constructor() {
        super("events.PluginDelete", [
            { no: 1, name: "metadata", kind: "message", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "user", kind: "message", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "resource", kind: "message", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "plugin", kind: "message", T: () => PluginMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "connection", kind: "message", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<PluginDelete>): PluginDelete {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PluginDelete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginDelete): PluginDelete {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata metadata */ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata user */ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ResourceMetadata resource */ 3:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.PluginMetadata plugin */ 4:
                    message.plugin = PluginMetadata.internalBinaryRead(reader, reader.uint32(), options, message.plugin);
                    break;
                case /* events.ConnectionMetadata connection */ 5:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginDelete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata metadata = 1; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata user = 2; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata resource = 3; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.PluginMetadata plugin = 4; */
        if (message.plugin)
            PluginMetadata.internalBinaryWrite(message.plugin, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata connection = 5; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.PluginDelete
 */
export const PluginDelete = new PluginDelete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginMetadata$Type extends MessageType<PluginMetadata> {
    constructor() {
        super("events.PluginMetadata", [
            { no: 1, name: "plugin_type", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "plugin_type" } },
            { no: 3, name: "has_credentials", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "has_credentials" } },
            { no: 4, name: "reuses_credentials", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "reuses_credentials" } },
            { no: 5, name: "plugin_data", kind: "message", T: () => Struct, options: { "gogoproto.jsontag": "plugin_data,omitempty", "gogoproto.casttype": "Struct" } }
        ]);
    }
    create(value?: PartialMessage<PluginMetadata>): PluginMetadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pluginType = "";
        message.hasCredentials = false;
        message.reusesCredentials = false;
        if (value !== undefined)
            reflectionMergePartial<PluginMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginMetadata): PluginMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string plugin_type */ 1:
                    message.pluginType = reader.string();
                    break;
                case /* bool has_credentials */ 3:
                    message.hasCredentials = reader.bool();
                    break;
                case /* bool reuses_credentials */ 4:
                    message.reusesCredentials = reader.bool();
                    break;
                case /* google.protobuf.Struct plugin_data */ 5:
                    message.pluginData = Struct.internalBinaryRead(reader, reader.uint32(), options, message.pluginData);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string plugin_type = 1; */
        if (message.pluginType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.pluginType);
        /* bool has_credentials = 3; */
        if (message.hasCredentials !== false)
            writer.tag(3, WireType.Varint).bool(message.hasCredentials);
        /* bool reuses_credentials = 4; */
        if (message.reusesCredentials !== false)
            writer.tag(4, WireType.Varint).bool(message.reusesCredentials);
        /* google.protobuf.Struct plugin_data = 5; */
        if (message.pluginData)
            Struct.internalBinaryWrite(message.pluginData, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.PluginMetadata
 */
export const PluginMetadata = new PluginMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OneOf$Type extends MessageType<OneOf> {
    constructor() {
        super("events.OneOf", [
            { no: 1, name: "UserLogin", kind: "message", jsonName: "UserLogin", oneof: "event", T: () => UserLogin },
            { no: 2, name: "UserCreate", kind: "message", jsonName: "UserCreate", oneof: "event", T: () => UserCreate },
            { no: 3, name: "UserDelete", kind: "message", jsonName: "UserDelete", oneof: "event", T: () => UserDelete },
            { no: 4, name: "UserPasswordChange", kind: "message", jsonName: "UserPasswordChange", oneof: "event", T: () => UserPasswordChange },
            { no: 5, name: "SessionStart", kind: "message", jsonName: "SessionStart", oneof: "event", T: () => SessionStart },
            { no: 6, name: "SessionJoin", kind: "message", jsonName: "SessionJoin", oneof: "event", T: () => SessionJoin },
            { no: 7, name: "SessionPrint", kind: "message", jsonName: "SessionPrint", oneof: "event", T: () => SessionPrint },
            { no: 8, name: "SessionReject", kind: "message", jsonName: "SessionReject", oneof: "event", T: () => SessionReject },
            { no: 9, name: "Resize", kind: "message", jsonName: "Resize", oneof: "event", T: () => Resize },
            { no: 10, name: "SessionEnd", kind: "message", jsonName: "SessionEnd", oneof: "event", T: () => SessionEnd },
            { no: 11, name: "SessionCommand", kind: "message", jsonName: "SessionCommand", oneof: "event", T: () => SessionCommand },
            { no: 12, name: "SessionDisk", kind: "message", jsonName: "SessionDisk", oneof: "event", T: () => SessionDisk },
            { no: 13, name: "SessionNetwork", kind: "message", jsonName: "SessionNetwork", oneof: "event", T: () => SessionNetwork },
            { no: 14, name: "SessionData", kind: "message", jsonName: "SessionData", oneof: "event", T: () => SessionData },
            { no: 15, name: "SessionLeave", kind: "message", jsonName: "SessionLeave", oneof: "event", T: () => SessionLeave },
            { no: 16, name: "PortForward", kind: "message", jsonName: "PortForward", oneof: "event", T: () => PortForward },
            { no: 17, name: "X11Forward", kind: "message", jsonName: "X11Forward", oneof: "event", T: () => X11Forward },
            { no: 18, name: "SCP", kind: "message", jsonName: "SCP", oneof: "event", T: () => SCP },
            { no: 19, name: "Exec", kind: "message", jsonName: "Exec", oneof: "event", T: () => Exec },
            { no: 20, name: "Subsystem", kind: "message", jsonName: "Subsystem", oneof: "event", T: () => Subsystem },
            { no: 21, name: "ClientDisconnect", kind: "message", jsonName: "ClientDisconnect", oneof: "event", T: () => ClientDisconnect },
            { no: 22, name: "AuthAttempt", kind: "message", jsonName: "AuthAttempt", oneof: "event", T: () => AuthAttempt },
            { no: 23, name: "AccessRequestCreate", kind: "message", jsonName: "AccessRequestCreate", oneof: "event", T: () => AccessRequestCreate },
            { no: 24, name: "UserTokenCreate", kind: "message", jsonName: "UserTokenCreate", oneof: "event", T: () => UserTokenCreate },
            { no: 25, name: "RoleCreate", kind: "message", jsonName: "RoleCreate", oneof: "event", T: () => RoleCreate },
            { no: 26, name: "RoleDelete", kind: "message", jsonName: "RoleDelete", oneof: "event", T: () => RoleDelete },
            { no: 27, name: "TrustedClusterCreate", kind: "message", jsonName: "TrustedClusterCreate", oneof: "event", T: () => TrustedClusterCreate },
            { no: 28, name: "TrustedClusterDelete", kind: "message", jsonName: "TrustedClusterDelete", oneof: "event", T: () => TrustedClusterDelete },
            { no: 29, name: "TrustedClusterTokenCreate", kind: "message", jsonName: "TrustedClusterTokenCreate", oneof: "event", T: () => TrustedClusterTokenCreate },
            { no: 30, name: "GithubConnectorCreate", kind: "message", jsonName: "GithubConnectorCreate", oneof: "event", T: () => GithubConnectorCreate },
            { no: 31, name: "GithubConnectorDelete", kind: "message", jsonName: "GithubConnectorDelete", oneof: "event", T: () => GithubConnectorDelete },
            { no: 32, name: "OIDCConnectorCreate", kind: "message", jsonName: "OIDCConnectorCreate", oneof: "event", T: () => OIDCConnectorCreate },
            { no: 33, name: "OIDCConnectorDelete", kind: "message", jsonName: "OIDCConnectorDelete", oneof: "event", T: () => OIDCConnectorDelete },
            { no: 34, name: "SAMLConnectorCreate", kind: "message", jsonName: "SAMLConnectorCreate", oneof: "event", T: () => SAMLConnectorCreate },
            { no: 35, name: "SAMLConnectorDelete", kind: "message", jsonName: "SAMLConnectorDelete", oneof: "event", T: () => SAMLConnectorDelete },
            { no: 36, name: "KubeRequest", kind: "message", jsonName: "KubeRequest", oneof: "event", T: () => KubeRequest },
            { no: 37, name: "AppSessionStart", kind: "message", jsonName: "AppSessionStart", oneof: "event", T: () => AppSessionStart },
            { no: 38, name: "AppSessionChunk", kind: "message", jsonName: "AppSessionChunk", oneof: "event", T: () => AppSessionChunk },
            { no: 39, name: "AppSessionRequest", kind: "message", jsonName: "AppSessionRequest", oneof: "event", T: () => AppSessionRequest },
            { no: 40, name: "DatabaseSessionStart", kind: "message", jsonName: "DatabaseSessionStart", oneof: "event", T: () => DatabaseSessionStart },
            { no: 41, name: "DatabaseSessionEnd", kind: "message", jsonName: "DatabaseSessionEnd", oneof: "event", T: () => DatabaseSessionEnd },
            { no: 42, name: "DatabaseSessionQuery", kind: "message", jsonName: "DatabaseSessionQuery", oneof: "event", T: () => DatabaseSessionQuery },
            { no: 43, name: "SessionUpload", kind: "message", jsonName: "SessionUpload", oneof: "event", T: () => SessionUpload },
            { no: 44, name: "MFADeviceAdd", kind: "message", jsonName: "MFADeviceAdd", oneof: "event", T: () => MFADeviceAdd },
            { no: 45, name: "MFADeviceDelete", kind: "message", jsonName: "MFADeviceDelete", oneof: "event", T: () => MFADeviceDelete },
            { no: 46, name: "BillingInformationUpdate", kind: "message", jsonName: "BillingInformationUpdate", oneof: "event", T: () => BillingInformationUpdate },
            { no: 47, name: "BillingCardCreate", kind: "message", jsonName: "BillingCardCreate", oneof: "event", T: () => BillingCardCreate },
            { no: 48, name: "BillingCardDelete", kind: "message", jsonName: "BillingCardDelete", oneof: "event", T: () => BillingCardDelete },
            { no: 49, name: "LockCreate", kind: "message", jsonName: "LockCreate", oneof: "event", T: () => LockCreate },
            { no: 50, name: "LockDelete", kind: "message", jsonName: "LockDelete", oneof: "event", T: () => LockDelete },
            { no: 51, name: "RecoveryCodeGenerate", kind: "message", jsonName: "RecoveryCodeGenerate", oneof: "event", T: () => RecoveryCodeGenerate },
            { no: 52, name: "RecoveryCodeUsed", kind: "message", jsonName: "RecoveryCodeUsed", oneof: "event", T: () => RecoveryCodeUsed },
            { no: 53, name: "DatabaseCreate", kind: "message", jsonName: "DatabaseCreate", oneof: "event", T: () => DatabaseCreate },
            { no: 54, name: "DatabaseUpdate", kind: "message", jsonName: "DatabaseUpdate", oneof: "event", T: () => DatabaseUpdate },
            { no: 55, name: "DatabaseDelete", kind: "message", jsonName: "DatabaseDelete", oneof: "event", T: () => DatabaseDelete },
            { no: 56, name: "AppCreate", kind: "message", jsonName: "AppCreate", oneof: "event", T: () => AppCreate },
            { no: 57, name: "AppUpdate", kind: "message", jsonName: "AppUpdate", oneof: "event", T: () => AppUpdate },
            { no: 58, name: "AppDelete", kind: "message", jsonName: "AppDelete", oneof: "event", T: () => AppDelete },
            { no: 59, name: "WindowsDesktopSessionStart", kind: "message", jsonName: "WindowsDesktopSessionStart", oneof: "event", T: () => WindowsDesktopSessionStart },
            { no: 60, name: "WindowsDesktopSessionEnd", kind: "message", jsonName: "WindowsDesktopSessionEnd", oneof: "event", T: () => WindowsDesktopSessionEnd },
            { no: 61, name: "PostgresParse", kind: "message", jsonName: "PostgresParse", oneof: "event", T: () => PostgresParse },
            { no: 62, name: "PostgresBind", kind: "message", jsonName: "PostgresBind", oneof: "event", T: () => PostgresBind },
            { no: 63, name: "PostgresExecute", kind: "message", jsonName: "PostgresExecute", oneof: "event", T: () => PostgresExecute },
            { no: 64, name: "PostgresClose", kind: "message", jsonName: "PostgresClose", oneof: "event", T: () => PostgresClose },
            { no: 65, name: "PostgresFunctionCall", kind: "message", jsonName: "PostgresFunctionCall", oneof: "event", T: () => PostgresFunctionCall },
            { no: 66, name: "AccessRequestDelete", kind: "message", jsonName: "AccessRequestDelete", oneof: "event", T: () => AccessRequestDelete },
            { no: 67, name: "SessionConnect", kind: "message", jsonName: "SessionConnect", oneof: "event", T: () => SessionConnect },
            { no: 68, name: "CertificateCreate", kind: "message", jsonName: "CertificateCreate", oneof: "event", T: () => CertificateCreate },
            { no: 69, name: "DesktopRecording", kind: "message", jsonName: "DesktopRecording", oneof: "event", T: () => DesktopRecording },
            { no: 70, name: "DesktopClipboardSend", kind: "message", jsonName: "DesktopClipboardSend", oneof: "event", T: () => DesktopClipboardSend },
            { no: 71, name: "DesktopClipboardReceive", kind: "message", jsonName: "DesktopClipboardReceive", oneof: "event", T: () => DesktopClipboardReceive },
            { no: 72, name: "MySQLStatementPrepare", kind: "message", jsonName: "MySQLStatementPrepare", oneof: "event", T: () => MySQLStatementPrepare },
            { no: 73, name: "MySQLStatementExecute", kind: "message", jsonName: "MySQLStatementExecute", oneof: "event", T: () => MySQLStatementExecute },
            { no: 74, name: "MySQLStatementSendLongData", kind: "message", jsonName: "MySQLStatementSendLongData", oneof: "event", T: () => MySQLStatementSendLongData },
            { no: 75, name: "MySQLStatementClose", kind: "message", jsonName: "MySQLStatementClose", oneof: "event", T: () => MySQLStatementClose },
            { no: 76, name: "MySQLStatementReset", kind: "message", jsonName: "MySQLStatementReset", oneof: "event", T: () => MySQLStatementReset },
            { no: 77, name: "MySQLStatementFetch", kind: "message", jsonName: "MySQLStatementFetch", oneof: "event", T: () => MySQLStatementFetch },
            { no: 78, name: "MySQLStatementBulkExecute", kind: "message", jsonName: "MySQLStatementBulkExecute", oneof: "event", T: () => MySQLStatementBulkExecute },
            { no: 79, name: "RenewableCertificateGenerationMismatch", kind: "message", jsonName: "RenewableCertificateGenerationMismatch", oneof: "event", T: () => RenewableCertificateGenerationMismatch },
            { no: 80, name: "Unknown", kind: "message", jsonName: "Unknown", oneof: "event", T: () => Unknown },
            { no: 81, name: "MySQLInitDB", kind: "message", jsonName: "MySQLInitDB", oneof: "event", T: () => MySQLInitDB },
            { no: 82, name: "MySQLCreateDB", kind: "message", jsonName: "MySQLCreateDB", oneof: "event", T: () => MySQLCreateDB },
            { no: 83, name: "MySQLDropDB", kind: "message", jsonName: "MySQLDropDB", oneof: "event", T: () => MySQLDropDB },
            { no: 84, name: "MySQLShutDown", kind: "message", jsonName: "MySQLShutDown", oneof: "event", T: () => MySQLShutDown },
            { no: 85, name: "MySQLProcessKill", kind: "message", jsonName: "MySQLProcessKill", oneof: "event", T: () => MySQLProcessKill },
            { no: 86, name: "MySQLDebug", kind: "message", jsonName: "MySQLDebug", oneof: "event", T: () => MySQLDebug },
            { no: 87, name: "MySQLRefresh", kind: "message", jsonName: "MySQLRefresh", oneof: "event", T: () => MySQLRefresh },
            { no: 88, name: "AccessRequestResourceSearch", kind: "message", jsonName: "AccessRequestResourceSearch", oneof: "event", T: () => AccessRequestResourceSearch },
            { no: 89, name: "SQLServerRPCRequest", kind: "message", jsonName: "SQLServerRPCRequest", oneof: "event", T: () => SQLServerRPCRequest },
            { no: 90, name: "DatabaseSessionMalformedPacket", kind: "message", jsonName: "DatabaseSessionMalformedPacket", oneof: "event", T: () => DatabaseSessionMalformedPacket },
            { no: 91, name: "SFTP", kind: "message", jsonName: "SFTP", oneof: "event", T: () => SFTP },
            { no: 92, name: "UpgradeWindowStartUpdate", kind: "message", jsonName: "UpgradeWindowStartUpdate", oneof: "event", T: () => UpgradeWindowStartUpdate },
            { no: 93, name: "AppSessionEnd", kind: "message", jsonName: "AppSessionEnd", oneof: "event", T: () => AppSessionEnd },
            { no: 94, name: "SessionRecordingAccess", kind: "message", jsonName: "SessionRecordingAccess", oneof: "event", T: () => SessionRecordingAccess },
            { no: 96, name: "KubernetesClusterCreate", kind: "message", jsonName: "KubernetesClusterCreate", oneof: "event", T: () => KubernetesClusterCreate },
            { no: 97, name: "KubernetesClusterUpdate", kind: "message", jsonName: "KubernetesClusterUpdate", oneof: "event", T: () => KubernetesClusterUpdate },
            { no: 98, name: "KubernetesClusterDelete", kind: "message", jsonName: "KubernetesClusterDelete", oneof: "event", T: () => KubernetesClusterDelete },
            { no: 99, name: "SSMRun", kind: "message", jsonName: "SSMRun", oneof: "event", T: () => SSMRun },
            { no: 100, name: "ElasticsearchRequest", kind: "message", jsonName: "ElasticsearchRequest", oneof: "event", T: () => ElasticsearchRequest },
            { no: 101, name: "CassandraBatch", kind: "message", jsonName: "CassandraBatch", oneof: "event", T: () => CassandraBatch },
            { no: 102, name: "CassandraPrepare", kind: "message", jsonName: "CassandraPrepare", oneof: "event", T: () => CassandraPrepare },
            { no: 103, name: "CassandraRegister", kind: "message", jsonName: "CassandraRegister", oneof: "event", T: () => CassandraRegister },
            { no: 104, name: "CassandraExecute", kind: "message", jsonName: "CassandraExecute", oneof: "event", T: () => CassandraExecute },
            { no: 105, name: "AppSessionDynamoDBRequest", kind: "message", jsonName: "AppSessionDynamoDBRequest", oneof: "event", T: () => AppSessionDynamoDBRequest },
            { no: 106, name: "DesktopSharedDirectoryStart", kind: "message", jsonName: "DesktopSharedDirectoryStart", oneof: "event", T: () => DesktopSharedDirectoryStart },
            { no: 107, name: "DesktopSharedDirectoryRead", kind: "message", jsonName: "DesktopSharedDirectoryRead", oneof: "event", T: () => DesktopSharedDirectoryRead },
            { no: 108, name: "DesktopSharedDirectoryWrite", kind: "message", jsonName: "DesktopSharedDirectoryWrite", oneof: "event", T: () => DesktopSharedDirectoryWrite },
            { no: 109, name: "DynamoDBRequest", kind: "message", jsonName: "DynamoDBRequest", oneof: "event", T: () => DynamoDBRequest },
            { no: 110, name: "BotJoin", kind: "message", jsonName: "BotJoin", oneof: "event", T: () => BotJoin },
            { no: 111, name: "InstanceJoin", kind: "message", jsonName: "InstanceJoin", oneof: "event", T: () => InstanceJoin },
            { no: 112, name: "DeviceEvent", kind: "message", jsonName: "DeviceEvent", oneof: "event", T: () => DeviceEvent },
            { no: 113, name: "LoginRuleCreate", kind: "message", jsonName: "LoginRuleCreate", oneof: "event", T: () => LoginRuleCreate },
            { no: 114, name: "LoginRuleDelete", kind: "message", jsonName: "LoginRuleDelete", oneof: "event", T: () => LoginRuleDelete },
            { no: 115, name: "SAMLIdPAuthAttempt", kind: "message", jsonName: "SAMLIdPAuthAttempt", oneof: "event", T: () => SAMLIdPAuthAttempt },
            { no: 116, name: "SAMLIdPServiceProviderCreate", kind: "message", jsonName: "SAMLIdPServiceProviderCreate", oneof: "event", T: () => SAMLIdPServiceProviderCreate },
            { no: 117, name: "SAMLIdPServiceProviderUpdate", kind: "message", jsonName: "SAMLIdPServiceProviderUpdate", oneof: "event", T: () => SAMLIdPServiceProviderUpdate },
            { no: 118, name: "SAMLIdPServiceProviderDelete", kind: "message", jsonName: "SAMLIdPServiceProviderDelete", oneof: "event", T: () => SAMLIdPServiceProviderDelete },
            { no: 119, name: "SAMLIdPServiceProviderDeleteAll", kind: "message", jsonName: "SAMLIdPServiceProviderDeleteAll", oneof: "event", T: () => SAMLIdPServiceProviderDeleteAll },
            { no: 120, name: "OpenSearchRequest", kind: "message", jsonName: "OpenSearchRequest", oneof: "event", T: () => OpenSearchRequest },
            { no: 121, name: "DeviceEvent2", kind: "message", jsonName: "DeviceEvent2", oneof: "event", T: () => DeviceEvent2 },
            { no: 122, name: "OktaResourcesUpdate", kind: "message", jsonName: "OktaResourcesUpdate", oneof: "event", T: () => OktaResourcesUpdate },
            { no: 123, name: "OktaSyncFailure", kind: "message", jsonName: "OktaSyncFailure", oneof: "event", T: () => OktaSyncFailure },
            { no: 124, name: "OktaAssignmentResult", kind: "message", jsonName: "OktaAssignmentResult", oneof: "event", T: () => OktaAssignmentResult },
            { no: 125, name: "ProvisionTokenCreate", kind: "message", jsonName: "ProvisionTokenCreate", oneof: "event", T: () => ProvisionTokenCreate },
            { no: 126, name: "AccessListCreate", kind: "message", jsonName: "AccessListCreate", oneof: "event", T: () => AccessListCreate },
            { no: 127, name: "AccessListUpdate", kind: "message", jsonName: "AccessListUpdate", oneof: "event", T: () => AccessListUpdate },
            { no: 128, name: "AccessListDelete", kind: "message", jsonName: "AccessListDelete", oneof: "event", T: () => AccessListDelete },
            { no: 129, name: "AccessListReview", kind: "message", jsonName: "AccessListReview", oneof: "event", T: () => AccessListReview },
            { no: 130, name: "AccessListMemberCreate", kind: "message", jsonName: "AccessListMemberCreate", oneof: "event", T: () => AccessListMemberCreate },
            { no: 131, name: "AccessListMemberUpdate", kind: "message", jsonName: "AccessListMemberUpdate", oneof: "event", T: () => AccessListMemberUpdate },
            { no: 132, name: "AccessListMemberDelete", kind: "message", jsonName: "AccessListMemberDelete", oneof: "event", T: () => AccessListMemberDelete },
            { no: 133, name: "AccessListMemberDeleteAllForAccessList", kind: "message", jsonName: "AccessListMemberDeleteAllForAccessList", oneof: "event", T: () => AccessListMemberDeleteAllForAccessList },
            { no: 134, name: "AuditQueryRun", kind: "message", jsonName: "AuditQueryRun", oneof: "event", T: () => AuditQueryRun },
            { no: 135, name: "SecurityReportRun", kind: "message", jsonName: "SecurityReportRun", oneof: "event", T: () => SecurityReportRun },
            { no: 136, name: "GithubConnectorUpdate", kind: "message", jsonName: "GithubConnectorUpdate", oneof: "event", T: () => GithubConnectorUpdate },
            { no: 137, name: "OIDCConnectorUpdate", kind: "message", jsonName: "OIDCConnectorUpdate", oneof: "event", T: () => OIDCConnectorUpdate },
            { no: 138, name: "SAMLConnectorUpdate", kind: "message", jsonName: "SAMLConnectorUpdate", oneof: "event", T: () => SAMLConnectorUpdate },
            { no: 139, name: "RoleUpdate", kind: "message", jsonName: "RoleUpdate", oneof: "event", T: () => RoleUpdate },
            { no: 140, name: "UserUpdate", kind: "message", jsonName: "UserUpdate", oneof: "event", T: () => UserUpdate },
            { no: 141, name: "ExternalAuditStorageEnable", kind: "message", jsonName: "ExternalAuditStorageEnable", oneof: "event", T: () => ExternalAuditStorageEnable },
            { no: 142, name: "ExternalAuditStorageDisable", kind: "message", jsonName: "ExternalAuditStorageDisable", oneof: "event", T: () => ExternalAuditStorageDisable },
            { no: 143, name: "BotCreate", kind: "message", jsonName: "BotCreate", oneof: "event", T: () => BotCreate },
            { no: 144, name: "BotDelete", kind: "message", jsonName: "BotDelete", oneof: "event", T: () => BotDelete },
            { no: 145, name: "BotUpdate", kind: "message", jsonName: "BotUpdate", oneof: "event", T: () => BotUpdate },
            { no: 146, name: "CreateMFAAuthChallenge", kind: "message", jsonName: "CreateMFAAuthChallenge", oneof: "event", T: () => CreateMFAAuthChallenge },
            { no: 147, name: "ValidateMFAAuthResponse", kind: "message", jsonName: "ValidateMFAAuthResponse", oneof: "event", T: () => ValidateMFAAuthResponse },
            { no: 148, name: "OktaAccessListSync", kind: "message", jsonName: "OktaAccessListSync", oneof: "event", T: () => OktaAccessListSync },
            { no: 149, name: "DatabasePermissionUpdate", kind: "message", jsonName: "DatabasePermissionUpdate", oneof: "event", T: () => DatabasePermissionUpdate },
            { no: 150, name: "SPIFFESVIDIssued", kind: "message", jsonName: "SPIFFESVIDIssued", oneof: "event", T: () => SPIFFESVIDIssued },
            { no: 151, name: "OktaUserSync", kind: "message", jsonName: "OktaUserSync", oneof: "event", T: () => OktaUserSync },
            { no: 152, name: "AuthPreferenceUpdate", kind: "message", jsonName: "AuthPreferenceUpdate", oneof: "event", T: () => AuthPreferenceUpdate },
            { no: 153, name: "SessionRecordingConfigUpdate", kind: "message", jsonName: "SessionRecordingConfigUpdate", oneof: "event", T: () => SessionRecordingConfigUpdate },
            { no: 154, name: "ClusterNetworkingConfigUpdate", kind: "message", jsonName: "ClusterNetworkingConfigUpdate", oneof: "event", T: () => ClusterNetworkingConfigUpdate },
            { no: 155, name: "DatabaseUserCreate", kind: "message", jsonName: "DatabaseUserCreate", oneof: "event", T: () => DatabaseUserCreate },
            { no: 156, name: "DatabaseUserDeactivate", kind: "message", jsonName: "DatabaseUserDeactivate", oneof: "event", T: () => DatabaseUserDeactivate },
            { no: 157, name: "AccessPathChanged", kind: "message", jsonName: "AccessPathChanged", oneof: "event", T: () => AccessPathChanged },
            { no: 158, name: "SpannerRPC", kind: "message", jsonName: "SpannerRPC", oneof: "event", T: () => SpannerRPC },
            { no: 159, name: "DatabaseSessionCommandResult", kind: "message", jsonName: "DatabaseSessionCommandResult", oneof: "event", T: () => DatabaseSessionCommandResult },
            { no: 160, name: "DiscoveryConfigCreate", kind: "message", jsonName: "DiscoveryConfigCreate", oneof: "event", T: () => DiscoveryConfigCreate },
            { no: 161, name: "DiscoveryConfigUpdate", kind: "message", jsonName: "DiscoveryConfigUpdate", oneof: "event", T: () => DiscoveryConfigUpdate },
            { no: 162, name: "DiscoveryConfigDelete", kind: "message", jsonName: "DiscoveryConfigDelete", oneof: "event", T: () => DiscoveryConfigDelete },
            { no: 163, name: "DiscoveryConfigDeleteAll", kind: "message", jsonName: "DiscoveryConfigDeleteAll", oneof: "event", T: () => DiscoveryConfigDeleteAll },
            { no: 164, name: "AccessGraphSettingsUpdate", kind: "message", jsonName: "AccessGraphSettingsUpdate", oneof: "event", T: () => AccessGraphSettingsUpdate },
            { no: 165, name: "IntegrationCreate", kind: "message", jsonName: "IntegrationCreate", oneof: "event", T: () => IntegrationCreate },
            { no: 166, name: "IntegrationUpdate", kind: "message", jsonName: "IntegrationUpdate", oneof: "event", T: () => IntegrationUpdate },
            { no: 167, name: "IntegrationDelete", kind: "message", jsonName: "IntegrationDelete", oneof: "event", T: () => IntegrationDelete },
            { no: 168, name: "SPIFFEFederationCreate", kind: "message", jsonName: "SPIFFEFederationCreate", oneof: "event", T: () => SPIFFEFederationCreate },
            { no: 169, name: "SPIFFEFederationDelete", kind: "message", jsonName: "SPIFFEFederationDelete", oneof: "event", T: () => SPIFFEFederationDelete },
            { no: 170, name: "PluginCreate", kind: "message", jsonName: "PluginCreate", oneof: "event", T: () => PluginCreate },
            { no: 171, name: "PluginUpdate", kind: "message", jsonName: "PluginUpdate", oneof: "event", T: () => PluginUpdate },
            { no: 172, name: "PluginDelete", kind: "message", jsonName: "PluginDelete", oneof: "event", T: () => PluginDelete },
            { no: 173, name: "AutoUpdateConfigCreate", kind: "message", jsonName: "AutoUpdateConfigCreate", oneof: "event", T: () => AutoUpdateConfigCreate },
            { no: 174, name: "AutoUpdateConfigUpdate", kind: "message", jsonName: "AutoUpdateConfigUpdate", oneof: "event", T: () => AutoUpdateConfigUpdate },
            { no: 175, name: "AutoUpdateConfigDelete", kind: "message", jsonName: "AutoUpdateConfigDelete", oneof: "event", T: () => AutoUpdateConfigDelete },
            { no: 176, name: "AutoUpdateVersionCreate", kind: "message", jsonName: "AutoUpdateVersionCreate", oneof: "event", T: () => AutoUpdateVersionCreate },
            { no: 177, name: "AutoUpdateVersionUpdate", kind: "message", jsonName: "AutoUpdateVersionUpdate", oneof: "event", T: () => AutoUpdateVersionUpdate },
            { no: 178, name: "AutoUpdateVersionDelete", kind: "message", jsonName: "AutoUpdateVersionDelete", oneof: "event", T: () => AutoUpdateVersionDelete },
            { no: 179, name: "StaticHostUserCreate", kind: "message", jsonName: "StaticHostUserCreate", oneof: "event", T: () => StaticHostUserCreate },
            { no: 180, name: "StaticHostUserUpdate", kind: "message", jsonName: "StaticHostUserUpdate", oneof: "event", T: () => StaticHostUserUpdate },
            { no: 181, name: "StaticHostUserDelete", kind: "message", jsonName: "StaticHostUserDelete", oneof: "event", T: () => StaticHostUserDelete },
            { no: 182, name: "CrownJewelCreate", kind: "message", jsonName: "CrownJewelCreate", oneof: "event", T: () => CrownJewelCreate },
            { no: 183, name: "CrownJewelUpdate", kind: "message", jsonName: "CrownJewelUpdate", oneof: "event", T: () => CrownJewelUpdate },
            { no: 184, name: "CrownJewelDelete", kind: "message", jsonName: "CrownJewelDelete", oneof: "event", T: () => CrownJewelDelete },
            { no: 188, name: "UserTaskCreate", kind: "message", jsonName: "UserTaskCreate", oneof: "event", T: () => UserTaskCreate },
            { no: 189, name: "UserTaskUpdate", kind: "message", jsonName: "UserTaskUpdate", oneof: "event", T: () => UserTaskUpdate },
            { no: 190, name: "UserTaskDelete", kind: "message", jsonName: "UserTaskDelete", oneof: "event", T: () => UserTaskDelete },
            { no: 191, name: "SFTPSummary", kind: "message", jsonName: "SFTPSummary", oneof: "event", T: () => SFTPSummary },
            { no: 192, name: "ContactCreate", kind: "message", jsonName: "ContactCreate", oneof: "event", T: () => ContactCreate },
            { no: 193, name: "ContactDelete", kind: "message", jsonName: "ContactDelete", oneof: "event", T: () => ContactDelete },
            { no: 194, name: "WorkloadIdentityCreate", kind: "message", jsonName: "WorkloadIdentityCreate", oneof: "event", T: () => WorkloadIdentityCreate },
            { no: 195, name: "WorkloadIdentityUpdate", kind: "message", jsonName: "WorkloadIdentityUpdate", oneof: "event", T: () => WorkloadIdentityUpdate },
            { no: 196, name: "WorkloadIdentityDelete", kind: "message", jsonName: "WorkloadIdentityDelete", oneof: "event", T: () => WorkloadIdentityDelete },
            { no: 197, name: "GitCommand", kind: "message", jsonName: "GitCommand", oneof: "event", T: () => GitCommand },
            { no: 198, name: "UserLoginAccessListInvalid", kind: "message", jsonName: "UserLoginAccessListInvalid", oneof: "event", T: () => UserLoginAccessListInvalid },
            { no: 199, name: "AccessRequestExpire", kind: "message", jsonName: "AccessRequestExpire", oneof: "event", T: () => AccessRequestExpire },
            { no: 200, name: "StableUNIXUserCreate", kind: "message", jsonName: "StableUNIXUserCreate", oneof: "event", T: () => StableUNIXUserCreate },
            { no: 201, name: "WorkloadIdentityX509RevocationCreate", kind: "message", jsonName: "WorkloadIdentityX509RevocationCreate", oneof: "event", T: () => WorkloadIdentityX509RevocationCreate },
            { no: 202, name: "WorkloadIdentityX509RevocationDelete", kind: "message", jsonName: "WorkloadIdentityX509RevocationDelete", oneof: "event", T: () => WorkloadIdentityX509RevocationDelete },
            { no: 203, name: "WorkloadIdentityX509RevocationUpdate", kind: "message", jsonName: "WorkloadIdentityX509RevocationUpdate", oneof: "event", T: () => WorkloadIdentityX509RevocationUpdate },
            { no: 204, name: "AWSICResourceSync", kind: "message", jsonName: "AWSICResourceSync", oneof: "event", T: () => AWSICResourceSync },
            { no: 205, name: "HealthCheckConfigCreate", kind: "message", jsonName: "HealthCheckConfigCreate", oneof: "event", T: () => HealthCheckConfigCreate },
            { no: 206, name: "HealthCheckConfigUpdate", kind: "message", jsonName: "HealthCheckConfigUpdate", oneof: "event", T: () => HealthCheckConfigUpdate },
            { no: 207, name: "HealthCheckConfigDelete", kind: "message", jsonName: "HealthCheckConfigDelete", oneof: "event", T: () => HealthCheckConfigDelete },
            { no: 208, name: "WorkloadIdentityX509IssuerOverrideCreate", kind: "message", jsonName: "WorkloadIdentityX509IssuerOverrideCreate", oneof: "event", T: () => WorkloadIdentityX509IssuerOverrideCreate },
            { no: 209, name: "WorkloadIdentityX509IssuerOverrideDelete", kind: "message", jsonName: "WorkloadIdentityX509IssuerOverrideDelete", oneof: "event", T: () => WorkloadIdentityX509IssuerOverrideDelete },
            { no: 210, name: "SigstorePolicyCreate", kind: "message", jsonName: "SigstorePolicyCreate", oneof: "event", T: () => SigstorePolicyCreate },
            { no: 211, name: "SigstorePolicyUpdate", kind: "message", jsonName: "SigstorePolicyUpdate", oneof: "event", T: () => SigstorePolicyUpdate },
            { no: 212, name: "SigstorePolicyDelete", kind: "message", jsonName: "SigstorePolicyDelete", oneof: "event", T: () => SigstorePolicyDelete },
            { no: 213, name: "AutoUpdateAgentRolloutTrigger", kind: "message", jsonName: "AutoUpdateAgentRolloutTrigger", oneof: "event", T: () => AutoUpdateAgentRolloutTrigger },
            { no: 214, name: "AutoUpdateAgentRolloutForceDone", kind: "message", jsonName: "AutoUpdateAgentRolloutForceDone", oneof: "event", T: () => AutoUpdateAgentRolloutForceDone },
            { no: 215, name: "AutoUpdateAgentRolloutRollback", kind: "message", jsonName: "AutoUpdateAgentRolloutRollback", oneof: "event", T: () => AutoUpdateAgentRolloutRollback }
        ]);
    }
    create(value?: PartialMessage<OneOf>): OneOf {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.event = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<OneOf>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OneOf): OneOf {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.UserLogin UserLogin = 1 [json_name = "UserLogin"];*/ 1:
                    message.event = {
                        oneofKind: "userLogin",
                        userLogin: UserLogin.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).userLogin)
                    };
                    break;
                case /* events.UserCreate UserCreate = 2 [json_name = "UserCreate"];*/ 2:
                    message.event = {
                        oneofKind: "userCreate",
                        userCreate: UserCreate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).userCreate)
                    };
                    break;
                case /* events.UserDelete UserDelete = 3 [json_name = "UserDelete"];*/ 3:
                    message.event = {
                        oneofKind: "userDelete",
                        userDelete: UserDelete.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).userDelete)
                    };
                    break;
                case /* events.UserPasswordChange UserPasswordChange = 4 [json_name = "UserPasswordChange"];*/ 4:
                    message.event = {
                        oneofKind: "userPasswordChange",
                        userPasswordChange: UserPasswordChange.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).userPasswordChange)
                    };
                    break;
                case /* events.SessionStart SessionStart = 5 [json_name = "SessionStart"];*/ 5:
                    message.event = {
                        oneofKind: "sessionStart",
                        sessionStart: SessionStart.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).sessionStart)
                    };
                    break;
                case /* events.SessionJoin SessionJoin = 6 [json_name = "SessionJoin"];*/ 6:
                    message.event = {
                        oneofKind: "sessionJoin",
                        sessionJoin: SessionJoin.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).sessionJoin)
                    };
                    break;
                case /* events.SessionPrint SessionPrint = 7 [json_name = "SessionPrint"];*/ 7:
                    message.event = {
                        oneofKind: "sessionPrint",
                        sessionPrint: SessionPrint.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).sessionPrint)
                    };
                    break;
                case /* events.SessionReject SessionReject = 8 [json_name = "SessionReject"];*/ 8:
                    message.event = {
                        oneofKind: "sessionReject",
                        sessionReject: SessionReject.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).sessionReject)
                    };
                    break;
                case /* events.Resize Resize = 9 [json_name = "Resize"];*/ 9:
                    message.event = {
                        oneofKind: "resize",
                        resize: Resize.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).resize)
                    };
                    break;
                case /* events.SessionEnd SessionEnd = 10 [json_name = "SessionEnd"];*/ 10:
                    message.event = {
                        oneofKind: "sessionEnd",
                        sessionEnd: SessionEnd.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).sessionEnd)
                    };
                    break;
                case /* events.SessionCommand SessionCommand = 11 [json_name = "SessionCommand"];*/ 11:
                    message.event = {
                        oneofKind: "sessionCommand",
                        sessionCommand: SessionCommand.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).sessionCommand)
                    };
                    break;
                case /* events.SessionDisk SessionDisk = 12 [json_name = "SessionDisk"];*/ 12:
                    message.event = {
                        oneofKind: "sessionDisk",
                        sessionDisk: SessionDisk.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).sessionDisk)
                    };
                    break;
                case /* events.SessionNetwork SessionNetwork = 13 [json_name = "SessionNetwork"];*/ 13:
                    message.event = {
                        oneofKind: "sessionNetwork",
                        sessionNetwork: SessionNetwork.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).sessionNetwork)
                    };
                    break;
                case /* events.SessionData SessionData = 14 [json_name = "SessionData"];*/ 14:
                    message.event = {
                        oneofKind: "sessionData",
                        sessionData: SessionData.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).sessionData)
                    };
                    break;
                case /* events.SessionLeave SessionLeave = 15 [json_name = "SessionLeave"];*/ 15:
                    message.event = {
                        oneofKind: "sessionLeave",
                        sessionLeave: SessionLeave.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).sessionLeave)
                    };
                    break;
                case /* events.PortForward PortForward = 16 [json_name = "PortForward"];*/ 16:
                    message.event = {
                        oneofKind: "portForward",
                        portForward: PortForward.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).portForward)
                    };
                    break;
                case /* events.X11Forward X11Forward = 17 [json_name = "X11Forward"];*/ 17:
                    message.event = {
                        oneofKind: "x11Forward",
                        x11Forward: X11Forward.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).x11Forward)
                    };
                    break;
                case /* events.SCP SCP = 18 [json_name = "SCP"];*/ 18:
                    message.event = {
                        oneofKind: "sCP",
                        sCP: SCP.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).sCP)
                    };
                    break;
                case /* events.Exec Exec = 19 [json_name = "Exec"];*/ 19:
                    message.event = {
                        oneofKind: "exec",
                        exec: Exec.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).exec)
                    };
                    break;
                case /* events.Subsystem Subsystem = 20 [json_name = "Subsystem"];*/ 20:
                    message.event = {
                        oneofKind: "subsystem",
                        subsystem: Subsystem.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).subsystem)
                    };
                    break;
                case /* events.ClientDisconnect ClientDisconnect = 21 [json_name = "ClientDisconnect"];*/ 21:
                    message.event = {
                        oneofKind: "clientDisconnect",
                        clientDisconnect: ClientDisconnect.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).clientDisconnect)
                    };
                    break;
                case /* events.AuthAttempt AuthAttempt = 22 [json_name = "AuthAttempt"];*/ 22:
                    message.event = {
                        oneofKind: "authAttempt",
                        authAttempt: AuthAttempt.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).authAttempt)
                    };
                    break;
                case /* events.AccessRequestCreate AccessRequestCreate = 23 [json_name = "AccessRequestCreate"];*/ 23:
                    message.event = {
                        oneofKind: "accessRequestCreate",
                        accessRequestCreate: AccessRequestCreate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).accessRequestCreate)
                    };
                    break;
                case /* events.UserTokenCreate UserTokenCreate = 24 [json_name = "UserTokenCreate"];*/ 24:
                    message.event = {
                        oneofKind: "userTokenCreate",
                        userTokenCreate: UserTokenCreate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).userTokenCreate)
                    };
                    break;
                case /* events.RoleCreate RoleCreate = 25 [json_name = "RoleCreate"];*/ 25:
                    message.event = {
                        oneofKind: "roleCreate",
                        roleCreate: RoleCreate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).roleCreate)
                    };
                    break;
                case /* events.RoleDelete RoleDelete = 26 [json_name = "RoleDelete"];*/ 26:
                    message.event = {
                        oneofKind: "roleDelete",
                        roleDelete: RoleDelete.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).roleDelete)
                    };
                    break;
                case /* events.TrustedClusterCreate TrustedClusterCreate = 27 [json_name = "TrustedClusterCreate"];*/ 27:
                    message.event = {
                        oneofKind: "trustedClusterCreate",
                        trustedClusterCreate: TrustedClusterCreate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).trustedClusterCreate)
                    };
                    break;
                case /* events.TrustedClusterDelete TrustedClusterDelete = 28 [json_name = "TrustedClusterDelete"];*/ 28:
                    message.event = {
                        oneofKind: "trustedClusterDelete",
                        trustedClusterDelete: TrustedClusterDelete.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).trustedClusterDelete)
                    };
                    break;
                case /* events.TrustedClusterTokenCreate TrustedClusterTokenCreate = 29 [json_name = "TrustedClusterTokenCreate"];*/ 29:
                    message.event = {
                        oneofKind: "trustedClusterTokenCreate",
                        trustedClusterTokenCreate: TrustedClusterTokenCreate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).trustedClusterTokenCreate)
                    };
                    break;
                case /* events.GithubConnectorCreate GithubConnectorCreate = 30 [json_name = "GithubConnectorCreate"];*/ 30:
                    message.event = {
                        oneofKind: "githubConnectorCreate",
                        githubConnectorCreate: GithubConnectorCreate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).githubConnectorCreate)
                    };
                    break;
                case /* events.GithubConnectorDelete GithubConnectorDelete = 31 [json_name = "GithubConnectorDelete"];*/ 31:
                    message.event = {
                        oneofKind: "githubConnectorDelete",
                        githubConnectorDelete: GithubConnectorDelete.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).githubConnectorDelete)
                    };
                    break;
                case /* events.OIDCConnectorCreate OIDCConnectorCreate = 32 [json_name = "OIDCConnectorCreate"];*/ 32:
                    message.event = {
                        oneofKind: "oIDCConnectorCreate",
                        oIDCConnectorCreate: OIDCConnectorCreate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).oIDCConnectorCreate)
                    };
                    break;
                case /* events.OIDCConnectorDelete OIDCConnectorDelete = 33 [json_name = "OIDCConnectorDelete"];*/ 33:
                    message.event = {
                        oneofKind: "oIDCConnectorDelete",
                        oIDCConnectorDelete: OIDCConnectorDelete.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).oIDCConnectorDelete)
                    };
                    break;
                case /* events.SAMLConnectorCreate SAMLConnectorCreate = 34 [json_name = "SAMLConnectorCreate"];*/ 34:
                    message.event = {
                        oneofKind: "sAMLConnectorCreate",
                        sAMLConnectorCreate: SAMLConnectorCreate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).sAMLConnectorCreate)
                    };
                    break;
                case /* events.SAMLConnectorDelete SAMLConnectorDelete = 35 [json_name = "SAMLConnectorDelete"];*/ 35:
                    message.event = {
                        oneofKind: "sAMLConnectorDelete",
                        sAMLConnectorDelete: SAMLConnectorDelete.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).sAMLConnectorDelete)
                    };
                    break;
                case /* events.KubeRequest KubeRequest = 36 [json_name = "KubeRequest"];*/ 36:
                    message.event = {
                        oneofKind: "kubeRequest",
                        kubeRequest: KubeRequest.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).kubeRequest)
                    };
                    break;
                case /* events.AppSessionStart AppSessionStart = 37 [json_name = "AppSessionStart"];*/ 37:
                    message.event = {
                        oneofKind: "appSessionStart",
                        appSessionStart: AppSessionStart.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).appSessionStart)
                    };
                    break;
                case /* events.AppSessionChunk AppSessionChunk = 38 [json_name = "AppSessionChunk"];*/ 38:
                    message.event = {
                        oneofKind: "appSessionChunk",
                        appSessionChunk: AppSessionChunk.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).appSessionChunk)
                    };
                    break;
                case /* events.AppSessionRequest AppSessionRequest = 39 [json_name = "AppSessionRequest"];*/ 39:
                    message.event = {
                        oneofKind: "appSessionRequest",
                        appSessionRequest: AppSessionRequest.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).appSessionRequest)
                    };
                    break;
                case /* events.DatabaseSessionStart DatabaseSessionStart = 40 [json_name = "DatabaseSessionStart"];*/ 40:
                    message.event = {
                        oneofKind: "databaseSessionStart",
                        databaseSessionStart: DatabaseSessionStart.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).databaseSessionStart)
                    };
                    break;
                case /* events.DatabaseSessionEnd DatabaseSessionEnd = 41 [json_name = "DatabaseSessionEnd"];*/ 41:
                    message.event = {
                        oneofKind: "databaseSessionEnd",
                        databaseSessionEnd: DatabaseSessionEnd.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).databaseSessionEnd)
                    };
                    break;
                case /* events.DatabaseSessionQuery DatabaseSessionQuery = 42 [json_name = "DatabaseSessionQuery"];*/ 42:
                    message.event = {
                        oneofKind: "databaseSessionQuery",
                        databaseSessionQuery: DatabaseSessionQuery.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).databaseSessionQuery)
                    };
                    break;
                case /* events.SessionUpload SessionUpload = 43 [json_name = "SessionUpload"];*/ 43:
                    message.event = {
                        oneofKind: "sessionUpload",
                        sessionUpload: SessionUpload.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).sessionUpload)
                    };
                    break;
                case /* events.MFADeviceAdd MFADeviceAdd = 44 [json_name = "MFADeviceAdd"];*/ 44:
                    message.event = {
                        oneofKind: "mFADeviceAdd",
                        mFADeviceAdd: MFADeviceAdd.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).mFADeviceAdd)
                    };
                    break;
                case /* events.MFADeviceDelete MFADeviceDelete = 45 [json_name = "MFADeviceDelete"];*/ 45:
                    message.event = {
                        oneofKind: "mFADeviceDelete",
                        mFADeviceDelete: MFADeviceDelete.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).mFADeviceDelete)
                    };
                    break;
                case /* events.BillingInformationUpdate BillingInformationUpdate = 46 [json_name = "BillingInformationUpdate"];*/ 46:
                    message.event = {
                        oneofKind: "billingInformationUpdate",
                        billingInformationUpdate: BillingInformationUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).billingInformationUpdate)
                    };
                    break;
                case /* events.BillingCardCreate BillingCardCreate = 47 [json_name = "BillingCardCreate"];*/ 47:
                    message.event = {
                        oneofKind: "billingCardCreate",
                        billingCardCreate: BillingCardCreate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).billingCardCreate)
                    };
                    break;
                case /* events.BillingCardDelete BillingCardDelete = 48 [json_name = "BillingCardDelete"];*/ 48:
                    message.event = {
                        oneofKind: "billingCardDelete",
                        billingCardDelete: BillingCardDelete.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).billingCardDelete)
                    };
                    break;
                case /* events.LockCreate LockCreate = 49 [json_name = "LockCreate"];*/ 49:
                    message.event = {
                        oneofKind: "lockCreate",
                        lockCreate: LockCreate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).lockCreate)
                    };
                    break;
                case /* events.LockDelete LockDelete = 50 [json_name = "LockDelete"];*/ 50:
                    message.event = {
                        oneofKind: "lockDelete",
                        lockDelete: LockDelete.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).lockDelete)
                    };
                    break;
                case /* events.RecoveryCodeGenerate RecoveryCodeGenerate = 51 [json_name = "RecoveryCodeGenerate"];*/ 51:
                    message.event = {
                        oneofKind: "recoveryCodeGenerate",
                        recoveryCodeGenerate: RecoveryCodeGenerate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).recoveryCodeGenerate)
                    };
                    break;
                case /* events.RecoveryCodeUsed RecoveryCodeUsed = 52 [json_name = "RecoveryCodeUsed"];*/ 52:
                    message.event = {
                        oneofKind: "recoveryCodeUsed",
                        recoveryCodeUsed: RecoveryCodeUsed.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).recoveryCodeUsed)
                    };
                    break;
                case /* events.DatabaseCreate DatabaseCreate = 53 [json_name = "DatabaseCreate"];*/ 53:
                    message.event = {
                        oneofKind: "databaseCreate",
                        databaseCreate: DatabaseCreate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).databaseCreate)
                    };
                    break;
                case /* events.DatabaseUpdate DatabaseUpdate = 54 [json_name = "DatabaseUpdate"];*/ 54:
                    message.event = {
                        oneofKind: "databaseUpdate",
                        databaseUpdate: DatabaseUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).databaseUpdate)
                    };
                    break;
                case /* events.DatabaseDelete DatabaseDelete = 55 [json_name = "DatabaseDelete"];*/ 55:
                    message.event = {
                        oneofKind: "databaseDelete",
                        databaseDelete: DatabaseDelete.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).databaseDelete)
                    };
                    break;
                case /* events.AppCreate AppCreate = 56 [json_name = "AppCreate"];*/ 56:
                    message.event = {
                        oneofKind: "appCreate",
                        appCreate: AppCreate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).appCreate)
                    };
                    break;
                case /* events.AppUpdate AppUpdate = 57 [json_name = "AppUpdate"];*/ 57:
                    message.event = {
                        oneofKind: "appUpdate",
                        appUpdate: AppUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).appUpdate)
                    };
                    break;
                case /* events.AppDelete AppDelete = 58 [json_name = "AppDelete"];*/ 58:
                    message.event = {
                        oneofKind: "appDelete",
                        appDelete: AppDelete.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).appDelete)
                    };
                    break;
                case /* events.WindowsDesktopSessionStart WindowsDesktopSessionStart = 59 [json_name = "WindowsDesktopSessionStart"];*/ 59:
                    message.event = {
                        oneofKind: "windowsDesktopSessionStart",
                        windowsDesktopSessionStart: WindowsDesktopSessionStart.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).windowsDesktopSessionStart)
                    };
                    break;
                case /* events.WindowsDesktopSessionEnd WindowsDesktopSessionEnd = 60 [json_name = "WindowsDesktopSessionEnd"];*/ 60:
                    message.event = {
                        oneofKind: "windowsDesktopSessionEnd",
                        windowsDesktopSessionEnd: WindowsDesktopSessionEnd.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).windowsDesktopSessionEnd)
                    };
                    break;
                case /* events.PostgresParse PostgresParse = 61 [json_name = "PostgresParse"];*/ 61:
                    message.event = {
                        oneofKind: "postgresParse",
                        postgresParse: PostgresParse.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).postgresParse)
                    };
                    break;
                case /* events.PostgresBind PostgresBind = 62 [json_name = "PostgresBind"];*/ 62:
                    message.event = {
                        oneofKind: "postgresBind",
                        postgresBind: PostgresBind.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).postgresBind)
                    };
                    break;
                case /* events.PostgresExecute PostgresExecute = 63 [json_name = "PostgresExecute"];*/ 63:
                    message.event = {
                        oneofKind: "postgresExecute",
                        postgresExecute: PostgresExecute.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).postgresExecute)
                    };
                    break;
                case /* events.PostgresClose PostgresClose = 64 [json_name = "PostgresClose"];*/ 64:
                    message.event = {
                        oneofKind: "postgresClose",
                        postgresClose: PostgresClose.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).postgresClose)
                    };
                    break;
                case /* events.PostgresFunctionCall PostgresFunctionCall = 65 [json_name = "PostgresFunctionCall"];*/ 65:
                    message.event = {
                        oneofKind: "postgresFunctionCall",
                        postgresFunctionCall: PostgresFunctionCall.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).postgresFunctionCall)
                    };
                    break;
                case /* events.AccessRequestDelete AccessRequestDelete = 66 [json_name = "AccessRequestDelete"];*/ 66:
                    message.event = {
                        oneofKind: "accessRequestDelete",
                        accessRequestDelete: AccessRequestDelete.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).accessRequestDelete)
                    };
                    break;
                case /* events.SessionConnect SessionConnect = 67 [json_name = "SessionConnect"];*/ 67:
                    message.event = {
                        oneofKind: "sessionConnect",
                        sessionConnect: SessionConnect.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).sessionConnect)
                    };
                    break;
                case /* events.CertificateCreate CertificateCreate = 68 [json_name = "CertificateCreate"];*/ 68:
                    message.event = {
                        oneofKind: "certificateCreate",
                        certificateCreate: CertificateCreate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).certificateCreate)
                    };
                    break;
                case /* events.DesktopRecording DesktopRecording = 69 [json_name = "DesktopRecording"];*/ 69:
                    message.event = {
                        oneofKind: "desktopRecording",
                        desktopRecording: DesktopRecording.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).desktopRecording)
                    };
                    break;
                case /* events.DesktopClipboardSend DesktopClipboardSend = 70 [json_name = "DesktopClipboardSend"];*/ 70:
                    message.event = {
                        oneofKind: "desktopClipboardSend",
                        desktopClipboardSend: DesktopClipboardSend.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).desktopClipboardSend)
                    };
                    break;
                case /* events.DesktopClipboardReceive DesktopClipboardReceive = 71 [json_name = "DesktopClipboardReceive"];*/ 71:
                    message.event = {
                        oneofKind: "desktopClipboardReceive",
                        desktopClipboardReceive: DesktopClipboardReceive.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).desktopClipboardReceive)
                    };
                    break;
                case /* events.MySQLStatementPrepare MySQLStatementPrepare = 72 [json_name = "MySQLStatementPrepare"];*/ 72:
                    message.event = {
                        oneofKind: "mySQLStatementPrepare",
                        mySQLStatementPrepare: MySQLStatementPrepare.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).mySQLStatementPrepare)
                    };
                    break;
                case /* events.MySQLStatementExecute MySQLStatementExecute = 73 [json_name = "MySQLStatementExecute"];*/ 73:
                    message.event = {
                        oneofKind: "mySQLStatementExecute",
                        mySQLStatementExecute: MySQLStatementExecute.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).mySQLStatementExecute)
                    };
                    break;
                case /* events.MySQLStatementSendLongData MySQLStatementSendLongData = 74 [json_name = "MySQLStatementSendLongData"];*/ 74:
                    message.event = {
                        oneofKind: "mySQLStatementSendLongData",
                        mySQLStatementSendLongData: MySQLStatementSendLongData.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).mySQLStatementSendLongData)
                    };
                    break;
                case /* events.MySQLStatementClose MySQLStatementClose = 75 [json_name = "MySQLStatementClose"];*/ 75:
                    message.event = {
                        oneofKind: "mySQLStatementClose",
                        mySQLStatementClose: MySQLStatementClose.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).mySQLStatementClose)
                    };
                    break;
                case /* events.MySQLStatementReset MySQLStatementReset = 76 [json_name = "MySQLStatementReset"];*/ 76:
                    message.event = {
                        oneofKind: "mySQLStatementReset",
                        mySQLStatementReset: MySQLStatementReset.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).mySQLStatementReset)
                    };
                    break;
                case /* events.MySQLStatementFetch MySQLStatementFetch = 77 [json_name = "MySQLStatementFetch"];*/ 77:
                    message.event = {
                        oneofKind: "mySQLStatementFetch",
                        mySQLStatementFetch: MySQLStatementFetch.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).mySQLStatementFetch)
                    };
                    break;
                case /* events.MySQLStatementBulkExecute MySQLStatementBulkExecute = 78 [json_name = "MySQLStatementBulkExecute"];*/ 78:
                    message.event = {
                        oneofKind: "mySQLStatementBulkExecute",
                        mySQLStatementBulkExecute: MySQLStatementBulkExecute.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).mySQLStatementBulkExecute)
                    };
                    break;
                case /* events.RenewableCertificateGenerationMismatch RenewableCertificateGenerationMismatch = 79 [json_name = "RenewableCertificateGenerationMismatch"];*/ 79:
                    message.event = {
                        oneofKind: "renewableCertificateGenerationMismatch",
                        renewableCertificateGenerationMismatch: RenewableCertificateGenerationMismatch.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).renewableCertificateGenerationMismatch)
                    };
                    break;
                case /* events.Unknown Unknown = 80 [json_name = "Unknown"];*/ 80:
                    message.event = {
                        oneofKind: "unknown",
                        unknown: Unknown.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).unknown)
                    };
                    break;
                case /* events.MySQLInitDB MySQLInitDB = 81 [json_name = "MySQLInitDB"];*/ 81:
                    message.event = {
                        oneofKind: "mySQLInitDB",
                        mySQLInitDB: MySQLInitDB.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).mySQLInitDB)
                    };
                    break;
                case /* events.MySQLCreateDB MySQLCreateDB = 82 [json_name = "MySQLCreateDB"];*/ 82:
                    message.event = {
                        oneofKind: "mySQLCreateDB",
                        mySQLCreateDB: MySQLCreateDB.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).mySQLCreateDB)
                    };
                    break;
                case /* events.MySQLDropDB MySQLDropDB = 83 [json_name = "MySQLDropDB"];*/ 83:
                    message.event = {
                        oneofKind: "mySQLDropDB",
                        mySQLDropDB: MySQLDropDB.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).mySQLDropDB)
                    };
                    break;
                case /* events.MySQLShutDown MySQLShutDown = 84 [json_name = "MySQLShutDown"];*/ 84:
                    message.event = {
                        oneofKind: "mySQLShutDown",
                        mySQLShutDown: MySQLShutDown.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).mySQLShutDown)
                    };
                    break;
                case /* events.MySQLProcessKill MySQLProcessKill = 85 [json_name = "MySQLProcessKill"];*/ 85:
                    message.event = {
                        oneofKind: "mySQLProcessKill",
                        mySQLProcessKill: MySQLProcessKill.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).mySQLProcessKill)
                    };
                    break;
                case /* events.MySQLDebug MySQLDebug = 86 [json_name = "MySQLDebug"];*/ 86:
                    message.event = {
                        oneofKind: "mySQLDebug",
                        mySQLDebug: MySQLDebug.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).mySQLDebug)
                    };
                    break;
                case /* events.MySQLRefresh MySQLRefresh = 87 [json_name = "MySQLRefresh"];*/ 87:
                    message.event = {
                        oneofKind: "mySQLRefresh",
                        mySQLRefresh: MySQLRefresh.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).mySQLRefresh)
                    };
                    break;
                case /* events.AccessRequestResourceSearch AccessRequestResourceSearch = 88 [json_name = "AccessRequestResourceSearch"];*/ 88:
                    message.event = {
                        oneofKind: "accessRequestResourceSearch",
                        accessRequestResourceSearch: AccessRequestResourceSearch.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).accessRequestResourceSearch)
                    };
                    break;
                case /* events.SQLServerRPCRequest SQLServerRPCRequest = 89 [json_name = "SQLServerRPCRequest"];*/ 89:
                    message.event = {
                        oneofKind: "sQLServerRPCRequest",
                        sQLServerRPCRequest: SQLServerRPCRequest.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).sQLServerRPCRequest)
                    };
                    break;
                case /* events.DatabaseSessionMalformedPacket DatabaseSessionMalformedPacket = 90 [json_name = "DatabaseSessionMalformedPacket"];*/ 90:
                    message.event = {
                        oneofKind: "databaseSessionMalformedPacket",
                        databaseSessionMalformedPacket: DatabaseSessionMalformedPacket.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).databaseSessionMalformedPacket)
                    };
                    break;
                case /* events.SFTP SFTP = 91 [json_name = "SFTP"];*/ 91:
                    message.event = {
                        oneofKind: "sFTP",
                        sFTP: SFTP.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).sFTP)
                    };
                    break;
                case /* events.UpgradeWindowStartUpdate UpgradeWindowStartUpdate = 92 [json_name = "UpgradeWindowStartUpdate"];*/ 92:
                    message.event = {
                        oneofKind: "upgradeWindowStartUpdate",
                        upgradeWindowStartUpdate: UpgradeWindowStartUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).upgradeWindowStartUpdate)
                    };
                    break;
                case /* events.AppSessionEnd AppSessionEnd = 93 [json_name = "AppSessionEnd"];*/ 93:
                    message.event = {
                        oneofKind: "appSessionEnd",
                        appSessionEnd: AppSessionEnd.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).appSessionEnd)
                    };
                    break;
                case /* events.SessionRecordingAccess SessionRecordingAccess = 94 [json_name = "SessionRecordingAccess"];*/ 94:
                    message.event = {
                        oneofKind: "sessionRecordingAccess",
                        sessionRecordingAccess: SessionRecordingAccess.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).sessionRecordingAccess)
                    };
                    break;
                case /* events.KubernetesClusterCreate KubernetesClusterCreate = 96 [json_name = "KubernetesClusterCreate"];*/ 96:
                    message.event = {
                        oneofKind: "kubernetesClusterCreate",
                        kubernetesClusterCreate: KubernetesClusterCreate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).kubernetesClusterCreate)
                    };
                    break;
                case /* events.KubernetesClusterUpdate KubernetesClusterUpdate = 97 [json_name = "KubernetesClusterUpdate"];*/ 97:
                    message.event = {
                        oneofKind: "kubernetesClusterUpdate",
                        kubernetesClusterUpdate: KubernetesClusterUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).kubernetesClusterUpdate)
                    };
                    break;
                case /* events.KubernetesClusterDelete KubernetesClusterDelete = 98 [json_name = "KubernetesClusterDelete"];*/ 98:
                    message.event = {
                        oneofKind: "kubernetesClusterDelete",
                        kubernetesClusterDelete: KubernetesClusterDelete.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).kubernetesClusterDelete)
                    };
                    break;
                case /* events.SSMRun SSMRun = 99 [json_name = "SSMRun"];*/ 99:
                    message.event = {
                        oneofKind: "sSMRun",
                        sSMRun: SSMRun.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).sSMRun)
                    };
                    break;
                case /* events.ElasticsearchRequest ElasticsearchRequest = 100 [json_name = "ElasticsearchRequest"];*/ 100:
                    message.event = {
                        oneofKind: "elasticsearchRequest",
                        elasticsearchRequest: ElasticsearchRequest.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).elasticsearchRequest)
                    };
                    break;
                case /* events.CassandraBatch CassandraBatch = 101 [json_name = "CassandraBatch"];*/ 101:
                    message.event = {
                        oneofKind: "cassandraBatch",
                        cassandraBatch: CassandraBatch.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).cassandraBatch)
                    };
                    break;
                case /* events.CassandraPrepare CassandraPrepare = 102 [json_name = "CassandraPrepare"];*/ 102:
                    message.event = {
                        oneofKind: "cassandraPrepare",
                        cassandraPrepare: CassandraPrepare.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).cassandraPrepare)
                    };
                    break;
                case /* events.CassandraRegister CassandraRegister = 103 [json_name = "CassandraRegister"];*/ 103:
                    message.event = {
                        oneofKind: "cassandraRegister",
                        cassandraRegister: CassandraRegister.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).cassandraRegister)
                    };
                    break;
                case /* events.CassandraExecute CassandraExecute = 104 [json_name = "CassandraExecute"];*/ 104:
                    message.event = {
                        oneofKind: "cassandraExecute",
                        cassandraExecute: CassandraExecute.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).cassandraExecute)
                    };
                    break;
                case /* events.AppSessionDynamoDBRequest AppSessionDynamoDBRequest = 105 [json_name = "AppSessionDynamoDBRequest"];*/ 105:
                    message.event = {
                        oneofKind: "appSessionDynamoDBRequest",
                        appSessionDynamoDBRequest: AppSessionDynamoDBRequest.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).appSessionDynamoDBRequest)
                    };
                    break;
                case /* events.DesktopSharedDirectoryStart DesktopSharedDirectoryStart = 106 [json_name = "DesktopSharedDirectoryStart"];*/ 106:
                    message.event = {
                        oneofKind: "desktopSharedDirectoryStart",
                        desktopSharedDirectoryStart: DesktopSharedDirectoryStart.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).desktopSharedDirectoryStart)
                    };
                    break;
                case /* events.DesktopSharedDirectoryRead DesktopSharedDirectoryRead = 107 [json_name = "DesktopSharedDirectoryRead"];*/ 107:
                    message.event = {
                        oneofKind: "desktopSharedDirectoryRead",
                        desktopSharedDirectoryRead: DesktopSharedDirectoryRead.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).desktopSharedDirectoryRead)
                    };
                    break;
                case /* events.DesktopSharedDirectoryWrite DesktopSharedDirectoryWrite = 108 [json_name = "DesktopSharedDirectoryWrite"];*/ 108:
                    message.event = {
                        oneofKind: "desktopSharedDirectoryWrite",
                        desktopSharedDirectoryWrite: DesktopSharedDirectoryWrite.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).desktopSharedDirectoryWrite)
                    };
                    break;
                case /* events.DynamoDBRequest DynamoDBRequest = 109 [json_name = "DynamoDBRequest"];*/ 109:
                    message.event = {
                        oneofKind: "dynamoDBRequest",
                        dynamoDBRequest: DynamoDBRequest.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).dynamoDBRequest)
                    };
                    break;
                case /* events.BotJoin BotJoin = 110 [json_name = "BotJoin"];*/ 110:
                    message.event = {
                        oneofKind: "botJoin",
                        botJoin: BotJoin.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).botJoin)
                    };
                    break;
                case /* events.InstanceJoin InstanceJoin = 111 [json_name = "InstanceJoin"];*/ 111:
                    message.event = {
                        oneofKind: "instanceJoin",
                        instanceJoin: InstanceJoin.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).instanceJoin)
                    };
                    break;
                case /* events.DeviceEvent DeviceEvent = 112 [json_name = "DeviceEvent"];*/ 112:
                    message.event = {
                        oneofKind: "deviceEvent",
                        deviceEvent: DeviceEvent.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).deviceEvent)
                    };
                    break;
                case /* events.LoginRuleCreate LoginRuleCreate = 113 [json_name = "LoginRuleCreate"];*/ 113:
                    message.event = {
                        oneofKind: "loginRuleCreate",
                        loginRuleCreate: LoginRuleCreate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).loginRuleCreate)
                    };
                    break;
                case /* events.LoginRuleDelete LoginRuleDelete = 114 [json_name = "LoginRuleDelete"];*/ 114:
                    message.event = {
                        oneofKind: "loginRuleDelete",
                        loginRuleDelete: LoginRuleDelete.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).loginRuleDelete)
                    };
                    break;
                case /* events.SAMLIdPAuthAttempt SAMLIdPAuthAttempt = 115 [json_name = "SAMLIdPAuthAttempt"];*/ 115:
                    message.event = {
                        oneofKind: "sAMLIdPAuthAttempt",
                        sAMLIdPAuthAttempt: SAMLIdPAuthAttempt.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).sAMLIdPAuthAttempt)
                    };
                    break;
                case /* events.SAMLIdPServiceProviderCreate SAMLIdPServiceProviderCreate = 116 [json_name = "SAMLIdPServiceProviderCreate"];*/ 116:
                    message.event = {
                        oneofKind: "sAMLIdPServiceProviderCreate",
                        sAMLIdPServiceProviderCreate: SAMLIdPServiceProviderCreate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).sAMLIdPServiceProviderCreate)
                    };
                    break;
                case /* events.SAMLIdPServiceProviderUpdate SAMLIdPServiceProviderUpdate = 117 [json_name = "SAMLIdPServiceProviderUpdate"];*/ 117:
                    message.event = {
                        oneofKind: "sAMLIdPServiceProviderUpdate",
                        sAMLIdPServiceProviderUpdate: SAMLIdPServiceProviderUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).sAMLIdPServiceProviderUpdate)
                    };
                    break;
                case /* events.SAMLIdPServiceProviderDelete SAMLIdPServiceProviderDelete = 118 [json_name = "SAMLIdPServiceProviderDelete"];*/ 118:
                    message.event = {
                        oneofKind: "sAMLIdPServiceProviderDelete",
                        sAMLIdPServiceProviderDelete: SAMLIdPServiceProviderDelete.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).sAMLIdPServiceProviderDelete)
                    };
                    break;
                case /* events.SAMLIdPServiceProviderDeleteAll SAMLIdPServiceProviderDeleteAll = 119 [json_name = "SAMLIdPServiceProviderDeleteAll"];*/ 119:
                    message.event = {
                        oneofKind: "sAMLIdPServiceProviderDeleteAll",
                        sAMLIdPServiceProviderDeleteAll: SAMLIdPServiceProviderDeleteAll.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).sAMLIdPServiceProviderDeleteAll)
                    };
                    break;
                case /* events.OpenSearchRequest OpenSearchRequest = 120 [json_name = "OpenSearchRequest"];*/ 120:
                    message.event = {
                        oneofKind: "openSearchRequest",
                        openSearchRequest: OpenSearchRequest.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).openSearchRequest)
                    };
                    break;
                case /* events.DeviceEvent2 DeviceEvent2 = 121 [json_name = "DeviceEvent2"];*/ 121:
                    message.event = {
                        oneofKind: "deviceEvent2",
                        deviceEvent2: DeviceEvent2.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).deviceEvent2)
                    };
                    break;
                case /* events.OktaResourcesUpdate OktaResourcesUpdate = 122 [json_name = "OktaResourcesUpdate"];*/ 122:
                    message.event = {
                        oneofKind: "oktaResourcesUpdate",
                        oktaResourcesUpdate: OktaResourcesUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).oktaResourcesUpdate)
                    };
                    break;
                case /* events.OktaSyncFailure OktaSyncFailure = 123 [json_name = "OktaSyncFailure"];*/ 123:
                    message.event = {
                        oneofKind: "oktaSyncFailure",
                        oktaSyncFailure: OktaSyncFailure.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).oktaSyncFailure)
                    };
                    break;
                case /* events.OktaAssignmentResult OktaAssignmentResult = 124 [json_name = "OktaAssignmentResult"];*/ 124:
                    message.event = {
                        oneofKind: "oktaAssignmentResult",
                        oktaAssignmentResult: OktaAssignmentResult.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).oktaAssignmentResult)
                    };
                    break;
                case /* events.ProvisionTokenCreate ProvisionTokenCreate = 125 [json_name = "ProvisionTokenCreate"];*/ 125:
                    message.event = {
                        oneofKind: "provisionTokenCreate",
                        provisionTokenCreate: ProvisionTokenCreate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).provisionTokenCreate)
                    };
                    break;
                case /* events.AccessListCreate AccessListCreate = 126 [json_name = "AccessListCreate"];*/ 126:
                    message.event = {
                        oneofKind: "accessListCreate",
                        accessListCreate: AccessListCreate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).accessListCreate)
                    };
                    break;
                case /* events.AccessListUpdate AccessListUpdate = 127 [json_name = "AccessListUpdate"];*/ 127:
                    message.event = {
                        oneofKind: "accessListUpdate",
                        accessListUpdate: AccessListUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).accessListUpdate)
                    };
                    break;
                case /* events.AccessListDelete AccessListDelete = 128 [json_name = "AccessListDelete"];*/ 128:
                    message.event = {
                        oneofKind: "accessListDelete",
                        accessListDelete: AccessListDelete.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).accessListDelete)
                    };
                    break;
                case /* events.AccessListReview AccessListReview = 129 [json_name = "AccessListReview"];*/ 129:
                    message.event = {
                        oneofKind: "accessListReview",
                        accessListReview: AccessListReview.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).accessListReview)
                    };
                    break;
                case /* events.AccessListMemberCreate AccessListMemberCreate = 130 [json_name = "AccessListMemberCreate"];*/ 130:
                    message.event = {
                        oneofKind: "accessListMemberCreate",
                        accessListMemberCreate: AccessListMemberCreate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).accessListMemberCreate)
                    };
                    break;
                case /* events.AccessListMemberUpdate AccessListMemberUpdate = 131 [json_name = "AccessListMemberUpdate"];*/ 131:
                    message.event = {
                        oneofKind: "accessListMemberUpdate",
                        accessListMemberUpdate: AccessListMemberUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).accessListMemberUpdate)
                    };
                    break;
                case /* events.AccessListMemberDelete AccessListMemberDelete = 132 [json_name = "AccessListMemberDelete"];*/ 132:
                    message.event = {
                        oneofKind: "accessListMemberDelete",
                        accessListMemberDelete: AccessListMemberDelete.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).accessListMemberDelete)
                    };
                    break;
                case /* events.AccessListMemberDeleteAllForAccessList AccessListMemberDeleteAllForAccessList = 133 [json_name = "AccessListMemberDeleteAllForAccessList"];*/ 133:
                    message.event = {
                        oneofKind: "accessListMemberDeleteAllForAccessList",
                        accessListMemberDeleteAllForAccessList: AccessListMemberDeleteAllForAccessList.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).accessListMemberDeleteAllForAccessList)
                    };
                    break;
                case /* events.AuditQueryRun AuditQueryRun = 134 [json_name = "AuditQueryRun"];*/ 134:
                    message.event = {
                        oneofKind: "auditQueryRun",
                        auditQueryRun: AuditQueryRun.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).auditQueryRun)
                    };
                    break;
                case /* events.SecurityReportRun SecurityReportRun = 135 [json_name = "SecurityReportRun"];*/ 135:
                    message.event = {
                        oneofKind: "securityReportRun",
                        securityReportRun: SecurityReportRun.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).securityReportRun)
                    };
                    break;
                case /* events.GithubConnectorUpdate GithubConnectorUpdate = 136 [json_name = "GithubConnectorUpdate"];*/ 136:
                    message.event = {
                        oneofKind: "githubConnectorUpdate",
                        githubConnectorUpdate: GithubConnectorUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).githubConnectorUpdate)
                    };
                    break;
                case /* events.OIDCConnectorUpdate OIDCConnectorUpdate = 137 [json_name = "OIDCConnectorUpdate"];*/ 137:
                    message.event = {
                        oneofKind: "oIDCConnectorUpdate",
                        oIDCConnectorUpdate: OIDCConnectorUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).oIDCConnectorUpdate)
                    };
                    break;
                case /* events.SAMLConnectorUpdate SAMLConnectorUpdate = 138 [json_name = "SAMLConnectorUpdate"];*/ 138:
                    message.event = {
                        oneofKind: "sAMLConnectorUpdate",
                        sAMLConnectorUpdate: SAMLConnectorUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).sAMLConnectorUpdate)
                    };
                    break;
                case /* events.RoleUpdate RoleUpdate = 139 [json_name = "RoleUpdate"];*/ 139:
                    message.event = {
                        oneofKind: "roleUpdate",
                        roleUpdate: RoleUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).roleUpdate)
                    };
                    break;
                case /* events.UserUpdate UserUpdate = 140 [json_name = "UserUpdate"];*/ 140:
                    message.event = {
                        oneofKind: "userUpdate",
                        userUpdate: UserUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).userUpdate)
                    };
                    break;
                case /* events.ExternalAuditStorageEnable ExternalAuditStorageEnable = 141 [json_name = "ExternalAuditStorageEnable"];*/ 141:
                    message.event = {
                        oneofKind: "externalAuditStorageEnable",
                        externalAuditStorageEnable: ExternalAuditStorageEnable.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).externalAuditStorageEnable)
                    };
                    break;
                case /* events.ExternalAuditStorageDisable ExternalAuditStorageDisable = 142 [json_name = "ExternalAuditStorageDisable"];*/ 142:
                    message.event = {
                        oneofKind: "externalAuditStorageDisable",
                        externalAuditStorageDisable: ExternalAuditStorageDisable.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).externalAuditStorageDisable)
                    };
                    break;
                case /* events.BotCreate BotCreate = 143 [json_name = "BotCreate"];*/ 143:
                    message.event = {
                        oneofKind: "botCreate",
                        botCreate: BotCreate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).botCreate)
                    };
                    break;
                case /* events.BotDelete BotDelete = 144 [json_name = "BotDelete"];*/ 144:
                    message.event = {
                        oneofKind: "botDelete",
                        botDelete: BotDelete.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).botDelete)
                    };
                    break;
                case /* events.BotUpdate BotUpdate = 145 [json_name = "BotUpdate"];*/ 145:
                    message.event = {
                        oneofKind: "botUpdate",
                        botUpdate: BotUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).botUpdate)
                    };
                    break;
                case /* events.CreateMFAAuthChallenge CreateMFAAuthChallenge = 146 [json_name = "CreateMFAAuthChallenge"];*/ 146:
                    message.event = {
                        oneofKind: "createMFAAuthChallenge",
                        createMFAAuthChallenge: CreateMFAAuthChallenge.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).createMFAAuthChallenge)
                    };
                    break;
                case /* events.ValidateMFAAuthResponse ValidateMFAAuthResponse = 147 [json_name = "ValidateMFAAuthResponse"];*/ 147:
                    message.event = {
                        oneofKind: "validateMFAAuthResponse",
                        validateMFAAuthResponse: ValidateMFAAuthResponse.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).validateMFAAuthResponse)
                    };
                    break;
                case /* events.OktaAccessListSync OktaAccessListSync = 148 [json_name = "OktaAccessListSync"];*/ 148:
                    message.event = {
                        oneofKind: "oktaAccessListSync",
                        oktaAccessListSync: OktaAccessListSync.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).oktaAccessListSync)
                    };
                    break;
                case /* events.DatabasePermissionUpdate DatabasePermissionUpdate = 149 [json_name = "DatabasePermissionUpdate"];*/ 149:
                    message.event = {
                        oneofKind: "databasePermissionUpdate",
                        databasePermissionUpdate: DatabasePermissionUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).databasePermissionUpdate)
                    };
                    break;
                case /* events.SPIFFESVIDIssued SPIFFESVIDIssued = 150 [json_name = "SPIFFESVIDIssued"];*/ 150:
                    message.event = {
                        oneofKind: "sPIFFESVIDIssued",
                        sPIFFESVIDIssued: SPIFFESVIDIssued.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).sPIFFESVIDIssued)
                    };
                    break;
                case /* events.OktaUserSync OktaUserSync = 151 [json_name = "OktaUserSync"];*/ 151:
                    message.event = {
                        oneofKind: "oktaUserSync",
                        oktaUserSync: OktaUserSync.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).oktaUserSync)
                    };
                    break;
                case /* events.AuthPreferenceUpdate AuthPreferenceUpdate = 152 [json_name = "AuthPreferenceUpdate"];*/ 152:
                    message.event = {
                        oneofKind: "authPreferenceUpdate",
                        authPreferenceUpdate: AuthPreferenceUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).authPreferenceUpdate)
                    };
                    break;
                case /* events.SessionRecordingConfigUpdate SessionRecordingConfigUpdate = 153 [json_name = "SessionRecordingConfigUpdate"];*/ 153:
                    message.event = {
                        oneofKind: "sessionRecordingConfigUpdate",
                        sessionRecordingConfigUpdate: SessionRecordingConfigUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).sessionRecordingConfigUpdate)
                    };
                    break;
                case /* events.ClusterNetworkingConfigUpdate ClusterNetworkingConfigUpdate = 154 [json_name = "ClusterNetworkingConfigUpdate"];*/ 154:
                    message.event = {
                        oneofKind: "clusterNetworkingConfigUpdate",
                        clusterNetworkingConfigUpdate: ClusterNetworkingConfigUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).clusterNetworkingConfigUpdate)
                    };
                    break;
                case /* events.DatabaseUserCreate DatabaseUserCreate = 155 [json_name = "DatabaseUserCreate"];*/ 155:
                    message.event = {
                        oneofKind: "databaseUserCreate",
                        databaseUserCreate: DatabaseUserCreate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).databaseUserCreate)
                    };
                    break;
                case /* events.DatabaseUserDeactivate DatabaseUserDeactivate = 156 [json_name = "DatabaseUserDeactivate"];*/ 156:
                    message.event = {
                        oneofKind: "databaseUserDeactivate",
                        databaseUserDeactivate: DatabaseUserDeactivate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).databaseUserDeactivate)
                    };
                    break;
                case /* events.AccessPathChanged AccessPathChanged = 157 [json_name = "AccessPathChanged"];*/ 157:
                    message.event = {
                        oneofKind: "accessPathChanged",
                        accessPathChanged: AccessPathChanged.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).accessPathChanged)
                    };
                    break;
                case /* events.SpannerRPC SpannerRPC = 158 [json_name = "SpannerRPC"];*/ 158:
                    message.event = {
                        oneofKind: "spannerRPC",
                        spannerRPC: SpannerRPC.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).spannerRPC)
                    };
                    break;
                case /* events.DatabaseSessionCommandResult DatabaseSessionCommandResult = 159 [json_name = "DatabaseSessionCommandResult"];*/ 159:
                    message.event = {
                        oneofKind: "databaseSessionCommandResult",
                        databaseSessionCommandResult: DatabaseSessionCommandResult.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).databaseSessionCommandResult)
                    };
                    break;
                case /* events.DiscoveryConfigCreate DiscoveryConfigCreate = 160 [json_name = "DiscoveryConfigCreate"];*/ 160:
                    message.event = {
                        oneofKind: "discoveryConfigCreate",
                        discoveryConfigCreate: DiscoveryConfigCreate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).discoveryConfigCreate)
                    };
                    break;
                case /* events.DiscoveryConfigUpdate DiscoveryConfigUpdate = 161 [json_name = "DiscoveryConfigUpdate"];*/ 161:
                    message.event = {
                        oneofKind: "discoveryConfigUpdate",
                        discoveryConfigUpdate: DiscoveryConfigUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).discoveryConfigUpdate)
                    };
                    break;
                case /* events.DiscoveryConfigDelete DiscoveryConfigDelete = 162 [json_name = "DiscoveryConfigDelete"];*/ 162:
                    message.event = {
                        oneofKind: "discoveryConfigDelete",
                        discoveryConfigDelete: DiscoveryConfigDelete.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).discoveryConfigDelete)
                    };
                    break;
                case /* events.DiscoveryConfigDeleteAll DiscoveryConfigDeleteAll = 163 [json_name = "DiscoveryConfigDeleteAll"];*/ 163:
                    message.event = {
                        oneofKind: "discoveryConfigDeleteAll",
                        discoveryConfigDeleteAll: DiscoveryConfigDeleteAll.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).discoveryConfigDeleteAll)
                    };
                    break;
                case /* events.AccessGraphSettingsUpdate AccessGraphSettingsUpdate = 164 [json_name = "AccessGraphSettingsUpdate"];*/ 164:
                    message.event = {
                        oneofKind: "accessGraphSettingsUpdate",
                        accessGraphSettingsUpdate: AccessGraphSettingsUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).accessGraphSettingsUpdate)
                    };
                    break;
                case /* events.IntegrationCreate IntegrationCreate = 165 [json_name = "IntegrationCreate"];*/ 165:
                    message.event = {
                        oneofKind: "integrationCreate",
                        integrationCreate: IntegrationCreate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).integrationCreate)
                    };
                    break;
                case /* events.IntegrationUpdate IntegrationUpdate = 166 [json_name = "IntegrationUpdate"];*/ 166:
                    message.event = {
                        oneofKind: "integrationUpdate",
                        integrationUpdate: IntegrationUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).integrationUpdate)
                    };
                    break;
                case /* events.IntegrationDelete IntegrationDelete = 167 [json_name = "IntegrationDelete"];*/ 167:
                    message.event = {
                        oneofKind: "integrationDelete",
                        integrationDelete: IntegrationDelete.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).integrationDelete)
                    };
                    break;
                case /* events.SPIFFEFederationCreate SPIFFEFederationCreate = 168 [json_name = "SPIFFEFederationCreate"];*/ 168:
                    message.event = {
                        oneofKind: "sPIFFEFederationCreate",
                        sPIFFEFederationCreate: SPIFFEFederationCreate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).sPIFFEFederationCreate)
                    };
                    break;
                case /* events.SPIFFEFederationDelete SPIFFEFederationDelete = 169 [json_name = "SPIFFEFederationDelete"];*/ 169:
                    message.event = {
                        oneofKind: "sPIFFEFederationDelete",
                        sPIFFEFederationDelete: SPIFFEFederationDelete.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).sPIFFEFederationDelete)
                    };
                    break;
                case /* events.PluginCreate PluginCreate = 170 [json_name = "PluginCreate"];*/ 170:
                    message.event = {
                        oneofKind: "pluginCreate",
                        pluginCreate: PluginCreate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).pluginCreate)
                    };
                    break;
                case /* events.PluginUpdate PluginUpdate = 171 [json_name = "PluginUpdate"];*/ 171:
                    message.event = {
                        oneofKind: "pluginUpdate",
                        pluginUpdate: PluginUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).pluginUpdate)
                    };
                    break;
                case /* events.PluginDelete PluginDelete = 172 [json_name = "PluginDelete"];*/ 172:
                    message.event = {
                        oneofKind: "pluginDelete",
                        pluginDelete: PluginDelete.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).pluginDelete)
                    };
                    break;
                case /* events.AutoUpdateConfigCreate AutoUpdateConfigCreate = 173 [json_name = "AutoUpdateConfigCreate"];*/ 173:
                    message.event = {
                        oneofKind: "autoUpdateConfigCreate",
                        autoUpdateConfigCreate: AutoUpdateConfigCreate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).autoUpdateConfigCreate)
                    };
                    break;
                case /* events.AutoUpdateConfigUpdate AutoUpdateConfigUpdate = 174 [json_name = "AutoUpdateConfigUpdate"];*/ 174:
                    message.event = {
                        oneofKind: "autoUpdateConfigUpdate",
                        autoUpdateConfigUpdate: AutoUpdateConfigUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).autoUpdateConfigUpdate)
                    };
                    break;
                case /* events.AutoUpdateConfigDelete AutoUpdateConfigDelete = 175 [json_name = "AutoUpdateConfigDelete"];*/ 175:
                    message.event = {
                        oneofKind: "autoUpdateConfigDelete",
                        autoUpdateConfigDelete: AutoUpdateConfigDelete.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).autoUpdateConfigDelete)
                    };
                    break;
                case /* events.AutoUpdateVersionCreate AutoUpdateVersionCreate = 176 [json_name = "AutoUpdateVersionCreate"];*/ 176:
                    message.event = {
                        oneofKind: "autoUpdateVersionCreate",
                        autoUpdateVersionCreate: AutoUpdateVersionCreate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).autoUpdateVersionCreate)
                    };
                    break;
                case /* events.AutoUpdateVersionUpdate AutoUpdateVersionUpdate = 177 [json_name = "AutoUpdateVersionUpdate"];*/ 177:
                    message.event = {
                        oneofKind: "autoUpdateVersionUpdate",
                        autoUpdateVersionUpdate: AutoUpdateVersionUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).autoUpdateVersionUpdate)
                    };
                    break;
                case /* events.AutoUpdateVersionDelete AutoUpdateVersionDelete = 178 [json_name = "AutoUpdateVersionDelete"];*/ 178:
                    message.event = {
                        oneofKind: "autoUpdateVersionDelete",
                        autoUpdateVersionDelete: AutoUpdateVersionDelete.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).autoUpdateVersionDelete)
                    };
                    break;
                case /* events.StaticHostUserCreate StaticHostUserCreate = 179 [json_name = "StaticHostUserCreate"];*/ 179:
                    message.event = {
                        oneofKind: "staticHostUserCreate",
                        staticHostUserCreate: StaticHostUserCreate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).staticHostUserCreate)
                    };
                    break;
                case /* events.StaticHostUserUpdate StaticHostUserUpdate = 180 [json_name = "StaticHostUserUpdate"];*/ 180:
                    message.event = {
                        oneofKind: "staticHostUserUpdate",
                        staticHostUserUpdate: StaticHostUserUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).staticHostUserUpdate)
                    };
                    break;
                case /* events.StaticHostUserDelete StaticHostUserDelete = 181 [json_name = "StaticHostUserDelete"];*/ 181:
                    message.event = {
                        oneofKind: "staticHostUserDelete",
                        staticHostUserDelete: StaticHostUserDelete.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).staticHostUserDelete)
                    };
                    break;
                case /* events.CrownJewelCreate CrownJewelCreate = 182 [json_name = "CrownJewelCreate"];*/ 182:
                    message.event = {
                        oneofKind: "crownJewelCreate",
                        crownJewelCreate: CrownJewelCreate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).crownJewelCreate)
                    };
                    break;
                case /* events.CrownJewelUpdate CrownJewelUpdate = 183 [json_name = "CrownJewelUpdate"];*/ 183:
                    message.event = {
                        oneofKind: "crownJewelUpdate",
                        crownJewelUpdate: CrownJewelUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).crownJewelUpdate)
                    };
                    break;
                case /* events.CrownJewelDelete CrownJewelDelete = 184 [json_name = "CrownJewelDelete"];*/ 184:
                    message.event = {
                        oneofKind: "crownJewelDelete",
                        crownJewelDelete: CrownJewelDelete.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).crownJewelDelete)
                    };
                    break;
                case /* events.UserTaskCreate UserTaskCreate = 188 [json_name = "UserTaskCreate"];*/ 188:
                    message.event = {
                        oneofKind: "userTaskCreate",
                        userTaskCreate: UserTaskCreate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).userTaskCreate)
                    };
                    break;
                case /* events.UserTaskUpdate UserTaskUpdate = 189 [json_name = "UserTaskUpdate"];*/ 189:
                    message.event = {
                        oneofKind: "userTaskUpdate",
                        userTaskUpdate: UserTaskUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).userTaskUpdate)
                    };
                    break;
                case /* events.UserTaskDelete UserTaskDelete = 190 [json_name = "UserTaskDelete"];*/ 190:
                    message.event = {
                        oneofKind: "userTaskDelete",
                        userTaskDelete: UserTaskDelete.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).userTaskDelete)
                    };
                    break;
                case /* events.SFTPSummary SFTPSummary = 191 [json_name = "SFTPSummary"];*/ 191:
                    message.event = {
                        oneofKind: "sFTPSummary",
                        sFTPSummary: SFTPSummary.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).sFTPSummary)
                    };
                    break;
                case /* events.ContactCreate ContactCreate = 192 [json_name = "ContactCreate"];*/ 192:
                    message.event = {
                        oneofKind: "contactCreate",
                        contactCreate: ContactCreate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).contactCreate)
                    };
                    break;
                case /* events.ContactDelete ContactDelete = 193 [json_name = "ContactDelete"];*/ 193:
                    message.event = {
                        oneofKind: "contactDelete",
                        contactDelete: ContactDelete.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).contactDelete)
                    };
                    break;
                case /* events.WorkloadIdentityCreate WorkloadIdentityCreate = 194 [json_name = "WorkloadIdentityCreate"];*/ 194:
                    message.event = {
                        oneofKind: "workloadIdentityCreate",
                        workloadIdentityCreate: WorkloadIdentityCreate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).workloadIdentityCreate)
                    };
                    break;
                case /* events.WorkloadIdentityUpdate WorkloadIdentityUpdate = 195 [json_name = "WorkloadIdentityUpdate"];*/ 195:
                    message.event = {
                        oneofKind: "workloadIdentityUpdate",
                        workloadIdentityUpdate: WorkloadIdentityUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).workloadIdentityUpdate)
                    };
                    break;
                case /* events.WorkloadIdentityDelete WorkloadIdentityDelete = 196 [json_name = "WorkloadIdentityDelete"];*/ 196:
                    message.event = {
                        oneofKind: "workloadIdentityDelete",
                        workloadIdentityDelete: WorkloadIdentityDelete.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).workloadIdentityDelete)
                    };
                    break;
                case /* events.GitCommand GitCommand = 197 [json_name = "GitCommand"];*/ 197:
                    message.event = {
                        oneofKind: "gitCommand",
                        gitCommand: GitCommand.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).gitCommand)
                    };
                    break;
                case /* events.UserLoginAccessListInvalid UserLoginAccessListInvalid = 198 [json_name = "UserLoginAccessListInvalid"];*/ 198:
                    message.event = {
                        oneofKind: "userLoginAccessListInvalid",
                        userLoginAccessListInvalid: UserLoginAccessListInvalid.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).userLoginAccessListInvalid)
                    };
                    break;
                case /* events.AccessRequestExpire AccessRequestExpire = 199 [json_name = "AccessRequestExpire"];*/ 199:
                    message.event = {
                        oneofKind: "accessRequestExpire",
                        accessRequestExpire: AccessRequestExpire.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).accessRequestExpire)
                    };
                    break;
                case /* events.StableUNIXUserCreate StableUNIXUserCreate = 200 [json_name = "StableUNIXUserCreate"];*/ 200:
                    message.event = {
                        oneofKind: "stableUNIXUserCreate",
                        stableUNIXUserCreate: StableUNIXUserCreate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).stableUNIXUserCreate)
                    };
                    break;
                case /* events.WorkloadIdentityX509RevocationCreate WorkloadIdentityX509RevocationCreate = 201 [json_name = "WorkloadIdentityX509RevocationCreate"];*/ 201:
                    message.event = {
                        oneofKind: "workloadIdentityX509RevocationCreate",
                        workloadIdentityX509RevocationCreate: WorkloadIdentityX509RevocationCreate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).workloadIdentityX509RevocationCreate)
                    };
                    break;
                case /* events.WorkloadIdentityX509RevocationDelete WorkloadIdentityX509RevocationDelete = 202 [json_name = "WorkloadIdentityX509RevocationDelete"];*/ 202:
                    message.event = {
                        oneofKind: "workloadIdentityX509RevocationDelete",
                        workloadIdentityX509RevocationDelete: WorkloadIdentityX509RevocationDelete.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).workloadIdentityX509RevocationDelete)
                    };
                    break;
                case /* events.WorkloadIdentityX509RevocationUpdate WorkloadIdentityX509RevocationUpdate = 203 [json_name = "WorkloadIdentityX509RevocationUpdate"];*/ 203:
                    message.event = {
                        oneofKind: "workloadIdentityX509RevocationUpdate",
                        workloadIdentityX509RevocationUpdate: WorkloadIdentityX509RevocationUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).workloadIdentityX509RevocationUpdate)
                    };
                    break;
                case /* events.AWSICResourceSync AWSICResourceSync = 204 [json_name = "AWSICResourceSync"];*/ 204:
                    message.event = {
                        oneofKind: "aWSICResourceSync",
                        aWSICResourceSync: AWSICResourceSync.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).aWSICResourceSync)
                    };
                    break;
                case /* events.HealthCheckConfigCreate HealthCheckConfigCreate = 205 [json_name = "HealthCheckConfigCreate"];*/ 205:
                    message.event = {
                        oneofKind: "healthCheckConfigCreate",
                        healthCheckConfigCreate: HealthCheckConfigCreate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).healthCheckConfigCreate)
                    };
                    break;
                case /* events.HealthCheckConfigUpdate HealthCheckConfigUpdate = 206 [json_name = "HealthCheckConfigUpdate"];*/ 206:
                    message.event = {
                        oneofKind: "healthCheckConfigUpdate",
                        healthCheckConfigUpdate: HealthCheckConfigUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).healthCheckConfigUpdate)
                    };
                    break;
                case /* events.HealthCheckConfigDelete HealthCheckConfigDelete = 207 [json_name = "HealthCheckConfigDelete"];*/ 207:
                    message.event = {
                        oneofKind: "healthCheckConfigDelete",
                        healthCheckConfigDelete: HealthCheckConfigDelete.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).healthCheckConfigDelete)
                    };
                    break;
                case /* events.WorkloadIdentityX509IssuerOverrideCreate WorkloadIdentityX509IssuerOverrideCreate = 208 [json_name = "WorkloadIdentityX509IssuerOverrideCreate"];*/ 208:
                    message.event = {
                        oneofKind: "workloadIdentityX509IssuerOverrideCreate",
                        workloadIdentityX509IssuerOverrideCreate: WorkloadIdentityX509IssuerOverrideCreate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).workloadIdentityX509IssuerOverrideCreate)
                    };
                    break;
                case /* events.WorkloadIdentityX509IssuerOverrideDelete WorkloadIdentityX509IssuerOverrideDelete = 209 [json_name = "WorkloadIdentityX509IssuerOverrideDelete"];*/ 209:
                    message.event = {
                        oneofKind: "workloadIdentityX509IssuerOverrideDelete",
                        workloadIdentityX509IssuerOverrideDelete: WorkloadIdentityX509IssuerOverrideDelete.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).workloadIdentityX509IssuerOverrideDelete)
                    };
                    break;
                case /* events.SigstorePolicyCreate SigstorePolicyCreate = 210 [json_name = "SigstorePolicyCreate"];*/ 210:
                    message.event = {
                        oneofKind: "sigstorePolicyCreate",
                        sigstorePolicyCreate: SigstorePolicyCreate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).sigstorePolicyCreate)
                    };
                    break;
                case /* events.SigstorePolicyUpdate SigstorePolicyUpdate = 211 [json_name = "SigstorePolicyUpdate"];*/ 211:
                    message.event = {
                        oneofKind: "sigstorePolicyUpdate",
                        sigstorePolicyUpdate: SigstorePolicyUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).sigstorePolicyUpdate)
                    };
                    break;
                case /* events.SigstorePolicyDelete SigstorePolicyDelete = 212 [json_name = "SigstorePolicyDelete"];*/ 212:
                    message.event = {
                        oneofKind: "sigstorePolicyDelete",
                        sigstorePolicyDelete: SigstorePolicyDelete.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).sigstorePolicyDelete)
                    };
                    break;
                case /* events.AutoUpdateAgentRolloutTrigger AutoUpdateAgentRolloutTrigger = 213 [json_name = "AutoUpdateAgentRolloutTrigger"];*/ 213:
                    message.event = {
                        oneofKind: "autoUpdateAgentRolloutTrigger",
                        autoUpdateAgentRolloutTrigger: AutoUpdateAgentRolloutTrigger.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).autoUpdateAgentRolloutTrigger)
                    };
                    break;
                case /* events.AutoUpdateAgentRolloutForceDone AutoUpdateAgentRolloutForceDone = 214 [json_name = "AutoUpdateAgentRolloutForceDone"];*/ 214:
                    message.event = {
                        oneofKind: "autoUpdateAgentRolloutForceDone",
                        autoUpdateAgentRolloutForceDone: AutoUpdateAgentRolloutForceDone.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).autoUpdateAgentRolloutForceDone)
                    };
                    break;
                case /* events.AutoUpdateAgentRolloutRollback AutoUpdateAgentRolloutRollback = 215 [json_name = "AutoUpdateAgentRolloutRollback"];*/ 215:
                    message.event = {
                        oneofKind: "autoUpdateAgentRolloutRollback",
                        autoUpdateAgentRolloutRollback: AutoUpdateAgentRolloutRollback.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).autoUpdateAgentRolloutRollback)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OneOf, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.UserLogin UserLogin = 1 [json_name = "UserLogin"]; */
        if (message.event.oneofKind === "userLogin")
            UserLogin.internalBinaryWrite(message.event.userLogin, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserCreate UserCreate = 2 [json_name = "UserCreate"]; */
        if (message.event.oneofKind === "userCreate")
            UserCreate.internalBinaryWrite(message.event.userCreate, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserDelete UserDelete = 3 [json_name = "UserDelete"]; */
        if (message.event.oneofKind === "userDelete")
            UserDelete.internalBinaryWrite(message.event.userDelete, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.UserPasswordChange UserPasswordChange = 4 [json_name = "UserPasswordChange"]; */
        if (message.event.oneofKind === "userPasswordChange")
            UserPasswordChange.internalBinaryWrite(message.event.userPasswordChange, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionStart SessionStart = 5 [json_name = "SessionStart"]; */
        if (message.event.oneofKind === "sessionStart")
            SessionStart.internalBinaryWrite(message.event.sessionStart, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionJoin SessionJoin = 6 [json_name = "SessionJoin"]; */
        if (message.event.oneofKind === "sessionJoin")
            SessionJoin.internalBinaryWrite(message.event.sessionJoin, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionPrint SessionPrint = 7 [json_name = "SessionPrint"]; */
        if (message.event.oneofKind === "sessionPrint")
            SessionPrint.internalBinaryWrite(message.event.sessionPrint, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionReject SessionReject = 8 [json_name = "SessionReject"]; */
        if (message.event.oneofKind === "sessionReject")
            SessionReject.internalBinaryWrite(message.event.sessionReject, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* events.Resize Resize = 9 [json_name = "Resize"]; */
        if (message.event.oneofKind === "resize")
            Resize.internalBinaryWrite(message.event.resize, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionEnd SessionEnd = 10 [json_name = "SessionEnd"]; */
        if (message.event.oneofKind === "sessionEnd")
            SessionEnd.internalBinaryWrite(message.event.sessionEnd, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionCommand SessionCommand = 11 [json_name = "SessionCommand"]; */
        if (message.event.oneofKind === "sessionCommand")
            SessionCommand.internalBinaryWrite(message.event.sessionCommand, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionDisk SessionDisk = 12 [json_name = "SessionDisk"]; */
        if (message.event.oneofKind === "sessionDisk")
            SessionDisk.internalBinaryWrite(message.event.sessionDisk, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionNetwork SessionNetwork = 13 [json_name = "SessionNetwork"]; */
        if (message.event.oneofKind === "sessionNetwork")
            SessionNetwork.internalBinaryWrite(message.event.sessionNetwork, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionData SessionData = 14 [json_name = "SessionData"]; */
        if (message.event.oneofKind === "sessionData")
            SessionData.internalBinaryWrite(message.event.sessionData, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionLeave SessionLeave = 15 [json_name = "SessionLeave"]; */
        if (message.event.oneofKind === "sessionLeave")
            SessionLeave.internalBinaryWrite(message.event.sessionLeave, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* events.PortForward PortForward = 16 [json_name = "PortForward"]; */
        if (message.event.oneofKind === "portForward")
            PortForward.internalBinaryWrite(message.event.portForward, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* events.X11Forward X11Forward = 17 [json_name = "X11Forward"]; */
        if (message.event.oneofKind === "x11Forward")
            X11Forward.internalBinaryWrite(message.event.x11Forward, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* events.SCP SCP = 18 [json_name = "SCP"]; */
        if (message.event.oneofKind === "sCP")
            SCP.internalBinaryWrite(message.event.sCP, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* events.Exec Exec = 19 [json_name = "Exec"]; */
        if (message.event.oneofKind === "exec")
            Exec.internalBinaryWrite(message.event.exec, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* events.Subsystem Subsystem = 20 [json_name = "Subsystem"]; */
        if (message.event.oneofKind === "subsystem")
            Subsystem.internalBinaryWrite(message.event.subsystem, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* events.ClientDisconnect ClientDisconnect = 21 [json_name = "ClientDisconnect"]; */
        if (message.event.oneofKind === "clientDisconnect")
            ClientDisconnect.internalBinaryWrite(message.event.clientDisconnect, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        /* events.AuthAttempt AuthAttempt = 22 [json_name = "AuthAttempt"]; */
        if (message.event.oneofKind === "authAttempt")
            AuthAttempt.internalBinaryWrite(message.event.authAttempt, writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        /* events.AccessRequestCreate AccessRequestCreate = 23 [json_name = "AccessRequestCreate"]; */
        if (message.event.oneofKind === "accessRequestCreate")
            AccessRequestCreate.internalBinaryWrite(message.event.accessRequestCreate, writer.tag(23, WireType.LengthDelimited).fork(), options).join();
        /* events.UserTokenCreate UserTokenCreate = 24 [json_name = "UserTokenCreate"]; */
        if (message.event.oneofKind === "userTokenCreate")
            UserTokenCreate.internalBinaryWrite(message.event.userTokenCreate, writer.tag(24, WireType.LengthDelimited).fork(), options).join();
        /* events.RoleCreate RoleCreate = 25 [json_name = "RoleCreate"]; */
        if (message.event.oneofKind === "roleCreate")
            RoleCreate.internalBinaryWrite(message.event.roleCreate, writer.tag(25, WireType.LengthDelimited).fork(), options).join();
        /* events.RoleDelete RoleDelete = 26 [json_name = "RoleDelete"]; */
        if (message.event.oneofKind === "roleDelete")
            RoleDelete.internalBinaryWrite(message.event.roleDelete, writer.tag(26, WireType.LengthDelimited).fork(), options).join();
        /* events.TrustedClusterCreate TrustedClusterCreate = 27 [json_name = "TrustedClusterCreate"]; */
        if (message.event.oneofKind === "trustedClusterCreate")
            TrustedClusterCreate.internalBinaryWrite(message.event.trustedClusterCreate, writer.tag(27, WireType.LengthDelimited).fork(), options).join();
        /* events.TrustedClusterDelete TrustedClusterDelete = 28 [json_name = "TrustedClusterDelete"]; */
        if (message.event.oneofKind === "trustedClusterDelete")
            TrustedClusterDelete.internalBinaryWrite(message.event.trustedClusterDelete, writer.tag(28, WireType.LengthDelimited).fork(), options).join();
        /* events.TrustedClusterTokenCreate TrustedClusterTokenCreate = 29 [json_name = "TrustedClusterTokenCreate"]; */
        if (message.event.oneofKind === "trustedClusterTokenCreate")
            TrustedClusterTokenCreate.internalBinaryWrite(message.event.trustedClusterTokenCreate, writer.tag(29, WireType.LengthDelimited).fork(), options).join();
        /* events.GithubConnectorCreate GithubConnectorCreate = 30 [json_name = "GithubConnectorCreate"]; */
        if (message.event.oneofKind === "githubConnectorCreate")
            GithubConnectorCreate.internalBinaryWrite(message.event.githubConnectorCreate, writer.tag(30, WireType.LengthDelimited).fork(), options).join();
        /* events.GithubConnectorDelete GithubConnectorDelete = 31 [json_name = "GithubConnectorDelete"]; */
        if (message.event.oneofKind === "githubConnectorDelete")
            GithubConnectorDelete.internalBinaryWrite(message.event.githubConnectorDelete, writer.tag(31, WireType.LengthDelimited).fork(), options).join();
        /* events.OIDCConnectorCreate OIDCConnectorCreate = 32 [json_name = "OIDCConnectorCreate"]; */
        if (message.event.oneofKind === "oIDCConnectorCreate")
            OIDCConnectorCreate.internalBinaryWrite(message.event.oIDCConnectorCreate, writer.tag(32, WireType.LengthDelimited).fork(), options).join();
        /* events.OIDCConnectorDelete OIDCConnectorDelete = 33 [json_name = "OIDCConnectorDelete"]; */
        if (message.event.oneofKind === "oIDCConnectorDelete")
            OIDCConnectorDelete.internalBinaryWrite(message.event.oIDCConnectorDelete, writer.tag(33, WireType.LengthDelimited).fork(), options).join();
        /* events.SAMLConnectorCreate SAMLConnectorCreate = 34 [json_name = "SAMLConnectorCreate"]; */
        if (message.event.oneofKind === "sAMLConnectorCreate")
            SAMLConnectorCreate.internalBinaryWrite(message.event.sAMLConnectorCreate, writer.tag(34, WireType.LengthDelimited).fork(), options).join();
        /* events.SAMLConnectorDelete SAMLConnectorDelete = 35 [json_name = "SAMLConnectorDelete"]; */
        if (message.event.oneofKind === "sAMLConnectorDelete")
            SAMLConnectorDelete.internalBinaryWrite(message.event.sAMLConnectorDelete, writer.tag(35, WireType.LengthDelimited).fork(), options).join();
        /* events.KubeRequest KubeRequest = 36 [json_name = "KubeRequest"]; */
        if (message.event.oneofKind === "kubeRequest")
            KubeRequest.internalBinaryWrite(message.event.kubeRequest, writer.tag(36, WireType.LengthDelimited).fork(), options).join();
        /* events.AppSessionStart AppSessionStart = 37 [json_name = "AppSessionStart"]; */
        if (message.event.oneofKind === "appSessionStart")
            AppSessionStart.internalBinaryWrite(message.event.appSessionStart, writer.tag(37, WireType.LengthDelimited).fork(), options).join();
        /* events.AppSessionChunk AppSessionChunk = 38 [json_name = "AppSessionChunk"]; */
        if (message.event.oneofKind === "appSessionChunk")
            AppSessionChunk.internalBinaryWrite(message.event.appSessionChunk, writer.tag(38, WireType.LengthDelimited).fork(), options).join();
        /* events.AppSessionRequest AppSessionRequest = 39 [json_name = "AppSessionRequest"]; */
        if (message.event.oneofKind === "appSessionRequest")
            AppSessionRequest.internalBinaryWrite(message.event.appSessionRequest, writer.tag(39, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseSessionStart DatabaseSessionStart = 40 [json_name = "DatabaseSessionStart"]; */
        if (message.event.oneofKind === "databaseSessionStart")
            DatabaseSessionStart.internalBinaryWrite(message.event.databaseSessionStart, writer.tag(40, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseSessionEnd DatabaseSessionEnd = 41 [json_name = "DatabaseSessionEnd"]; */
        if (message.event.oneofKind === "databaseSessionEnd")
            DatabaseSessionEnd.internalBinaryWrite(message.event.databaseSessionEnd, writer.tag(41, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseSessionQuery DatabaseSessionQuery = 42 [json_name = "DatabaseSessionQuery"]; */
        if (message.event.oneofKind === "databaseSessionQuery")
            DatabaseSessionQuery.internalBinaryWrite(message.event.databaseSessionQuery, writer.tag(42, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionUpload SessionUpload = 43 [json_name = "SessionUpload"]; */
        if (message.event.oneofKind === "sessionUpload")
            SessionUpload.internalBinaryWrite(message.event.sessionUpload, writer.tag(43, WireType.LengthDelimited).fork(), options).join();
        /* events.MFADeviceAdd MFADeviceAdd = 44 [json_name = "MFADeviceAdd"]; */
        if (message.event.oneofKind === "mFADeviceAdd")
            MFADeviceAdd.internalBinaryWrite(message.event.mFADeviceAdd, writer.tag(44, WireType.LengthDelimited).fork(), options).join();
        /* events.MFADeviceDelete MFADeviceDelete = 45 [json_name = "MFADeviceDelete"]; */
        if (message.event.oneofKind === "mFADeviceDelete")
            MFADeviceDelete.internalBinaryWrite(message.event.mFADeviceDelete, writer.tag(45, WireType.LengthDelimited).fork(), options).join();
        /* events.BillingInformationUpdate BillingInformationUpdate = 46 [json_name = "BillingInformationUpdate"]; */
        if (message.event.oneofKind === "billingInformationUpdate")
            BillingInformationUpdate.internalBinaryWrite(message.event.billingInformationUpdate, writer.tag(46, WireType.LengthDelimited).fork(), options).join();
        /* events.BillingCardCreate BillingCardCreate = 47 [json_name = "BillingCardCreate"]; */
        if (message.event.oneofKind === "billingCardCreate")
            BillingCardCreate.internalBinaryWrite(message.event.billingCardCreate, writer.tag(47, WireType.LengthDelimited).fork(), options).join();
        /* events.BillingCardDelete BillingCardDelete = 48 [json_name = "BillingCardDelete"]; */
        if (message.event.oneofKind === "billingCardDelete")
            BillingCardDelete.internalBinaryWrite(message.event.billingCardDelete, writer.tag(48, WireType.LengthDelimited).fork(), options).join();
        /* events.LockCreate LockCreate = 49 [json_name = "LockCreate"]; */
        if (message.event.oneofKind === "lockCreate")
            LockCreate.internalBinaryWrite(message.event.lockCreate, writer.tag(49, WireType.LengthDelimited).fork(), options).join();
        /* events.LockDelete LockDelete = 50 [json_name = "LockDelete"]; */
        if (message.event.oneofKind === "lockDelete")
            LockDelete.internalBinaryWrite(message.event.lockDelete, writer.tag(50, WireType.LengthDelimited).fork(), options).join();
        /* events.RecoveryCodeGenerate RecoveryCodeGenerate = 51 [json_name = "RecoveryCodeGenerate"]; */
        if (message.event.oneofKind === "recoveryCodeGenerate")
            RecoveryCodeGenerate.internalBinaryWrite(message.event.recoveryCodeGenerate, writer.tag(51, WireType.LengthDelimited).fork(), options).join();
        /* events.RecoveryCodeUsed RecoveryCodeUsed = 52 [json_name = "RecoveryCodeUsed"]; */
        if (message.event.oneofKind === "recoveryCodeUsed")
            RecoveryCodeUsed.internalBinaryWrite(message.event.recoveryCodeUsed, writer.tag(52, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseCreate DatabaseCreate = 53 [json_name = "DatabaseCreate"]; */
        if (message.event.oneofKind === "databaseCreate")
            DatabaseCreate.internalBinaryWrite(message.event.databaseCreate, writer.tag(53, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseUpdate DatabaseUpdate = 54 [json_name = "DatabaseUpdate"]; */
        if (message.event.oneofKind === "databaseUpdate")
            DatabaseUpdate.internalBinaryWrite(message.event.databaseUpdate, writer.tag(54, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseDelete DatabaseDelete = 55 [json_name = "DatabaseDelete"]; */
        if (message.event.oneofKind === "databaseDelete")
            DatabaseDelete.internalBinaryWrite(message.event.databaseDelete, writer.tag(55, WireType.LengthDelimited).fork(), options).join();
        /* events.AppCreate AppCreate = 56 [json_name = "AppCreate"]; */
        if (message.event.oneofKind === "appCreate")
            AppCreate.internalBinaryWrite(message.event.appCreate, writer.tag(56, WireType.LengthDelimited).fork(), options).join();
        /* events.AppUpdate AppUpdate = 57 [json_name = "AppUpdate"]; */
        if (message.event.oneofKind === "appUpdate")
            AppUpdate.internalBinaryWrite(message.event.appUpdate, writer.tag(57, WireType.LengthDelimited).fork(), options).join();
        /* events.AppDelete AppDelete = 58 [json_name = "AppDelete"]; */
        if (message.event.oneofKind === "appDelete")
            AppDelete.internalBinaryWrite(message.event.appDelete, writer.tag(58, WireType.LengthDelimited).fork(), options).join();
        /* events.WindowsDesktopSessionStart WindowsDesktopSessionStart = 59 [json_name = "WindowsDesktopSessionStart"]; */
        if (message.event.oneofKind === "windowsDesktopSessionStart")
            WindowsDesktopSessionStart.internalBinaryWrite(message.event.windowsDesktopSessionStart, writer.tag(59, WireType.LengthDelimited).fork(), options).join();
        /* events.WindowsDesktopSessionEnd WindowsDesktopSessionEnd = 60 [json_name = "WindowsDesktopSessionEnd"]; */
        if (message.event.oneofKind === "windowsDesktopSessionEnd")
            WindowsDesktopSessionEnd.internalBinaryWrite(message.event.windowsDesktopSessionEnd, writer.tag(60, WireType.LengthDelimited).fork(), options).join();
        /* events.PostgresParse PostgresParse = 61 [json_name = "PostgresParse"]; */
        if (message.event.oneofKind === "postgresParse")
            PostgresParse.internalBinaryWrite(message.event.postgresParse, writer.tag(61, WireType.LengthDelimited).fork(), options).join();
        /* events.PostgresBind PostgresBind = 62 [json_name = "PostgresBind"]; */
        if (message.event.oneofKind === "postgresBind")
            PostgresBind.internalBinaryWrite(message.event.postgresBind, writer.tag(62, WireType.LengthDelimited).fork(), options).join();
        /* events.PostgresExecute PostgresExecute = 63 [json_name = "PostgresExecute"]; */
        if (message.event.oneofKind === "postgresExecute")
            PostgresExecute.internalBinaryWrite(message.event.postgresExecute, writer.tag(63, WireType.LengthDelimited).fork(), options).join();
        /* events.PostgresClose PostgresClose = 64 [json_name = "PostgresClose"]; */
        if (message.event.oneofKind === "postgresClose")
            PostgresClose.internalBinaryWrite(message.event.postgresClose, writer.tag(64, WireType.LengthDelimited).fork(), options).join();
        /* events.PostgresFunctionCall PostgresFunctionCall = 65 [json_name = "PostgresFunctionCall"]; */
        if (message.event.oneofKind === "postgresFunctionCall")
            PostgresFunctionCall.internalBinaryWrite(message.event.postgresFunctionCall, writer.tag(65, WireType.LengthDelimited).fork(), options).join();
        /* events.AccessRequestDelete AccessRequestDelete = 66 [json_name = "AccessRequestDelete"]; */
        if (message.event.oneofKind === "accessRequestDelete")
            AccessRequestDelete.internalBinaryWrite(message.event.accessRequestDelete, writer.tag(66, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionConnect SessionConnect = 67 [json_name = "SessionConnect"]; */
        if (message.event.oneofKind === "sessionConnect")
            SessionConnect.internalBinaryWrite(message.event.sessionConnect, writer.tag(67, WireType.LengthDelimited).fork(), options).join();
        /* events.CertificateCreate CertificateCreate = 68 [json_name = "CertificateCreate"]; */
        if (message.event.oneofKind === "certificateCreate")
            CertificateCreate.internalBinaryWrite(message.event.certificateCreate, writer.tag(68, WireType.LengthDelimited).fork(), options).join();
        /* events.DesktopRecording DesktopRecording = 69 [json_name = "DesktopRecording"]; */
        if (message.event.oneofKind === "desktopRecording")
            DesktopRecording.internalBinaryWrite(message.event.desktopRecording, writer.tag(69, WireType.LengthDelimited).fork(), options).join();
        /* events.DesktopClipboardSend DesktopClipboardSend = 70 [json_name = "DesktopClipboardSend"]; */
        if (message.event.oneofKind === "desktopClipboardSend")
            DesktopClipboardSend.internalBinaryWrite(message.event.desktopClipboardSend, writer.tag(70, WireType.LengthDelimited).fork(), options).join();
        /* events.DesktopClipboardReceive DesktopClipboardReceive = 71 [json_name = "DesktopClipboardReceive"]; */
        if (message.event.oneofKind === "desktopClipboardReceive")
            DesktopClipboardReceive.internalBinaryWrite(message.event.desktopClipboardReceive, writer.tag(71, WireType.LengthDelimited).fork(), options).join();
        /* events.MySQLStatementPrepare MySQLStatementPrepare = 72 [json_name = "MySQLStatementPrepare"]; */
        if (message.event.oneofKind === "mySQLStatementPrepare")
            MySQLStatementPrepare.internalBinaryWrite(message.event.mySQLStatementPrepare, writer.tag(72, WireType.LengthDelimited).fork(), options).join();
        /* events.MySQLStatementExecute MySQLStatementExecute = 73 [json_name = "MySQLStatementExecute"]; */
        if (message.event.oneofKind === "mySQLStatementExecute")
            MySQLStatementExecute.internalBinaryWrite(message.event.mySQLStatementExecute, writer.tag(73, WireType.LengthDelimited).fork(), options).join();
        /* events.MySQLStatementSendLongData MySQLStatementSendLongData = 74 [json_name = "MySQLStatementSendLongData"]; */
        if (message.event.oneofKind === "mySQLStatementSendLongData")
            MySQLStatementSendLongData.internalBinaryWrite(message.event.mySQLStatementSendLongData, writer.tag(74, WireType.LengthDelimited).fork(), options).join();
        /* events.MySQLStatementClose MySQLStatementClose = 75 [json_name = "MySQLStatementClose"]; */
        if (message.event.oneofKind === "mySQLStatementClose")
            MySQLStatementClose.internalBinaryWrite(message.event.mySQLStatementClose, writer.tag(75, WireType.LengthDelimited).fork(), options).join();
        /* events.MySQLStatementReset MySQLStatementReset = 76 [json_name = "MySQLStatementReset"]; */
        if (message.event.oneofKind === "mySQLStatementReset")
            MySQLStatementReset.internalBinaryWrite(message.event.mySQLStatementReset, writer.tag(76, WireType.LengthDelimited).fork(), options).join();
        /* events.MySQLStatementFetch MySQLStatementFetch = 77 [json_name = "MySQLStatementFetch"]; */
        if (message.event.oneofKind === "mySQLStatementFetch")
            MySQLStatementFetch.internalBinaryWrite(message.event.mySQLStatementFetch, writer.tag(77, WireType.LengthDelimited).fork(), options).join();
        /* events.MySQLStatementBulkExecute MySQLStatementBulkExecute = 78 [json_name = "MySQLStatementBulkExecute"]; */
        if (message.event.oneofKind === "mySQLStatementBulkExecute")
            MySQLStatementBulkExecute.internalBinaryWrite(message.event.mySQLStatementBulkExecute, writer.tag(78, WireType.LengthDelimited).fork(), options).join();
        /* events.RenewableCertificateGenerationMismatch RenewableCertificateGenerationMismatch = 79 [json_name = "RenewableCertificateGenerationMismatch"]; */
        if (message.event.oneofKind === "renewableCertificateGenerationMismatch")
            RenewableCertificateGenerationMismatch.internalBinaryWrite(message.event.renewableCertificateGenerationMismatch, writer.tag(79, WireType.LengthDelimited).fork(), options).join();
        /* events.Unknown Unknown = 80 [json_name = "Unknown"]; */
        if (message.event.oneofKind === "unknown")
            Unknown.internalBinaryWrite(message.event.unknown, writer.tag(80, WireType.LengthDelimited).fork(), options).join();
        /* events.MySQLInitDB MySQLInitDB = 81 [json_name = "MySQLInitDB"]; */
        if (message.event.oneofKind === "mySQLInitDB")
            MySQLInitDB.internalBinaryWrite(message.event.mySQLInitDB, writer.tag(81, WireType.LengthDelimited).fork(), options).join();
        /* events.MySQLCreateDB MySQLCreateDB = 82 [json_name = "MySQLCreateDB"]; */
        if (message.event.oneofKind === "mySQLCreateDB")
            MySQLCreateDB.internalBinaryWrite(message.event.mySQLCreateDB, writer.tag(82, WireType.LengthDelimited).fork(), options).join();
        /* events.MySQLDropDB MySQLDropDB = 83 [json_name = "MySQLDropDB"]; */
        if (message.event.oneofKind === "mySQLDropDB")
            MySQLDropDB.internalBinaryWrite(message.event.mySQLDropDB, writer.tag(83, WireType.LengthDelimited).fork(), options).join();
        /* events.MySQLShutDown MySQLShutDown = 84 [json_name = "MySQLShutDown"]; */
        if (message.event.oneofKind === "mySQLShutDown")
            MySQLShutDown.internalBinaryWrite(message.event.mySQLShutDown, writer.tag(84, WireType.LengthDelimited).fork(), options).join();
        /* events.MySQLProcessKill MySQLProcessKill = 85 [json_name = "MySQLProcessKill"]; */
        if (message.event.oneofKind === "mySQLProcessKill")
            MySQLProcessKill.internalBinaryWrite(message.event.mySQLProcessKill, writer.tag(85, WireType.LengthDelimited).fork(), options).join();
        /* events.MySQLDebug MySQLDebug = 86 [json_name = "MySQLDebug"]; */
        if (message.event.oneofKind === "mySQLDebug")
            MySQLDebug.internalBinaryWrite(message.event.mySQLDebug, writer.tag(86, WireType.LengthDelimited).fork(), options).join();
        /* events.MySQLRefresh MySQLRefresh = 87 [json_name = "MySQLRefresh"]; */
        if (message.event.oneofKind === "mySQLRefresh")
            MySQLRefresh.internalBinaryWrite(message.event.mySQLRefresh, writer.tag(87, WireType.LengthDelimited).fork(), options).join();
        /* events.AccessRequestResourceSearch AccessRequestResourceSearch = 88 [json_name = "AccessRequestResourceSearch"]; */
        if (message.event.oneofKind === "accessRequestResourceSearch")
            AccessRequestResourceSearch.internalBinaryWrite(message.event.accessRequestResourceSearch, writer.tag(88, WireType.LengthDelimited).fork(), options).join();
        /* events.SQLServerRPCRequest SQLServerRPCRequest = 89 [json_name = "SQLServerRPCRequest"]; */
        if (message.event.oneofKind === "sQLServerRPCRequest")
            SQLServerRPCRequest.internalBinaryWrite(message.event.sQLServerRPCRequest, writer.tag(89, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseSessionMalformedPacket DatabaseSessionMalformedPacket = 90 [json_name = "DatabaseSessionMalformedPacket"]; */
        if (message.event.oneofKind === "databaseSessionMalformedPacket")
            DatabaseSessionMalformedPacket.internalBinaryWrite(message.event.databaseSessionMalformedPacket, writer.tag(90, WireType.LengthDelimited).fork(), options).join();
        /* events.SFTP SFTP = 91 [json_name = "SFTP"]; */
        if (message.event.oneofKind === "sFTP")
            SFTP.internalBinaryWrite(message.event.sFTP, writer.tag(91, WireType.LengthDelimited).fork(), options).join();
        /* events.UpgradeWindowStartUpdate UpgradeWindowStartUpdate = 92 [json_name = "UpgradeWindowStartUpdate"]; */
        if (message.event.oneofKind === "upgradeWindowStartUpdate")
            UpgradeWindowStartUpdate.internalBinaryWrite(message.event.upgradeWindowStartUpdate, writer.tag(92, WireType.LengthDelimited).fork(), options).join();
        /* events.AppSessionEnd AppSessionEnd = 93 [json_name = "AppSessionEnd"]; */
        if (message.event.oneofKind === "appSessionEnd")
            AppSessionEnd.internalBinaryWrite(message.event.appSessionEnd, writer.tag(93, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionRecordingAccess SessionRecordingAccess = 94 [json_name = "SessionRecordingAccess"]; */
        if (message.event.oneofKind === "sessionRecordingAccess")
            SessionRecordingAccess.internalBinaryWrite(message.event.sessionRecordingAccess, writer.tag(94, WireType.LengthDelimited).fork(), options).join();
        /* events.KubernetesClusterCreate KubernetesClusterCreate = 96 [json_name = "KubernetesClusterCreate"]; */
        if (message.event.oneofKind === "kubernetesClusterCreate")
            KubernetesClusterCreate.internalBinaryWrite(message.event.kubernetesClusterCreate, writer.tag(96, WireType.LengthDelimited).fork(), options).join();
        /* events.KubernetesClusterUpdate KubernetesClusterUpdate = 97 [json_name = "KubernetesClusterUpdate"]; */
        if (message.event.oneofKind === "kubernetesClusterUpdate")
            KubernetesClusterUpdate.internalBinaryWrite(message.event.kubernetesClusterUpdate, writer.tag(97, WireType.LengthDelimited).fork(), options).join();
        /* events.KubernetesClusterDelete KubernetesClusterDelete = 98 [json_name = "KubernetesClusterDelete"]; */
        if (message.event.oneofKind === "kubernetesClusterDelete")
            KubernetesClusterDelete.internalBinaryWrite(message.event.kubernetesClusterDelete, writer.tag(98, WireType.LengthDelimited).fork(), options).join();
        /* events.SSMRun SSMRun = 99 [json_name = "SSMRun"]; */
        if (message.event.oneofKind === "sSMRun")
            SSMRun.internalBinaryWrite(message.event.sSMRun, writer.tag(99, WireType.LengthDelimited).fork(), options).join();
        /* events.ElasticsearchRequest ElasticsearchRequest = 100 [json_name = "ElasticsearchRequest"]; */
        if (message.event.oneofKind === "elasticsearchRequest")
            ElasticsearchRequest.internalBinaryWrite(message.event.elasticsearchRequest, writer.tag(100, WireType.LengthDelimited).fork(), options).join();
        /* events.CassandraBatch CassandraBatch = 101 [json_name = "CassandraBatch"]; */
        if (message.event.oneofKind === "cassandraBatch")
            CassandraBatch.internalBinaryWrite(message.event.cassandraBatch, writer.tag(101, WireType.LengthDelimited).fork(), options).join();
        /* events.CassandraPrepare CassandraPrepare = 102 [json_name = "CassandraPrepare"]; */
        if (message.event.oneofKind === "cassandraPrepare")
            CassandraPrepare.internalBinaryWrite(message.event.cassandraPrepare, writer.tag(102, WireType.LengthDelimited).fork(), options).join();
        /* events.CassandraRegister CassandraRegister = 103 [json_name = "CassandraRegister"]; */
        if (message.event.oneofKind === "cassandraRegister")
            CassandraRegister.internalBinaryWrite(message.event.cassandraRegister, writer.tag(103, WireType.LengthDelimited).fork(), options).join();
        /* events.CassandraExecute CassandraExecute = 104 [json_name = "CassandraExecute"]; */
        if (message.event.oneofKind === "cassandraExecute")
            CassandraExecute.internalBinaryWrite(message.event.cassandraExecute, writer.tag(104, WireType.LengthDelimited).fork(), options).join();
        /* events.AppSessionDynamoDBRequest AppSessionDynamoDBRequest = 105 [json_name = "AppSessionDynamoDBRequest"]; */
        if (message.event.oneofKind === "appSessionDynamoDBRequest")
            AppSessionDynamoDBRequest.internalBinaryWrite(message.event.appSessionDynamoDBRequest, writer.tag(105, WireType.LengthDelimited).fork(), options).join();
        /* events.DesktopSharedDirectoryStart DesktopSharedDirectoryStart = 106 [json_name = "DesktopSharedDirectoryStart"]; */
        if (message.event.oneofKind === "desktopSharedDirectoryStart")
            DesktopSharedDirectoryStart.internalBinaryWrite(message.event.desktopSharedDirectoryStart, writer.tag(106, WireType.LengthDelimited).fork(), options).join();
        /* events.DesktopSharedDirectoryRead DesktopSharedDirectoryRead = 107 [json_name = "DesktopSharedDirectoryRead"]; */
        if (message.event.oneofKind === "desktopSharedDirectoryRead")
            DesktopSharedDirectoryRead.internalBinaryWrite(message.event.desktopSharedDirectoryRead, writer.tag(107, WireType.LengthDelimited).fork(), options).join();
        /* events.DesktopSharedDirectoryWrite DesktopSharedDirectoryWrite = 108 [json_name = "DesktopSharedDirectoryWrite"]; */
        if (message.event.oneofKind === "desktopSharedDirectoryWrite")
            DesktopSharedDirectoryWrite.internalBinaryWrite(message.event.desktopSharedDirectoryWrite, writer.tag(108, WireType.LengthDelimited).fork(), options).join();
        /* events.DynamoDBRequest DynamoDBRequest = 109 [json_name = "DynamoDBRequest"]; */
        if (message.event.oneofKind === "dynamoDBRequest")
            DynamoDBRequest.internalBinaryWrite(message.event.dynamoDBRequest, writer.tag(109, WireType.LengthDelimited).fork(), options).join();
        /* events.BotJoin BotJoin = 110 [json_name = "BotJoin"]; */
        if (message.event.oneofKind === "botJoin")
            BotJoin.internalBinaryWrite(message.event.botJoin, writer.tag(110, WireType.LengthDelimited).fork(), options).join();
        /* events.InstanceJoin InstanceJoin = 111 [json_name = "InstanceJoin"]; */
        if (message.event.oneofKind === "instanceJoin")
            InstanceJoin.internalBinaryWrite(message.event.instanceJoin, writer.tag(111, WireType.LengthDelimited).fork(), options).join();
        /* events.DeviceEvent DeviceEvent = 112 [json_name = "DeviceEvent"]; */
        if (message.event.oneofKind === "deviceEvent")
            DeviceEvent.internalBinaryWrite(message.event.deviceEvent, writer.tag(112, WireType.LengthDelimited).fork(), options).join();
        /* events.LoginRuleCreate LoginRuleCreate = 113 [json_name = "LoginRuleCreate"]; */
        if (message.event.oneofKind === "loginRuleCreate")
            LoginRuleCreate.internalBinaryWrite(message.event.loginRuleCreate, writer.tag(113, WireType.LengthDelimited).fork(), options).join();
        /* events.LoginRuleDelete LoginRuleDelete = 114 [json_name = "LoginRuleDelete"]; */
        if (message.event.oneofKind === "loginRuleDelete")
            LoginRuleDelete.internalBinaryWrite(message.event.loginRuleDelete, writer.tag(114, WireType.LengthDelimited).fork(), options).join();
        /* events.SAMLIdPAuthAttempt SAMLIdPAuthAttempt = 115 [json_name = "SAMLIdPAuthAttempt"]; */
        if (message.event.oneofKind === "sAMLIdPAuthAttempt")
            SAMLIdPAuthAttempt.internalBinaryWrite(message.event.sAMLIdPAuthAttempt, writer.tag(115, WireType.LengthDelimited).fork(), options).join();
        /* events.SAMLIdPServiceProviderCreate SAMLIdPServiceProviderCreate = 116 [json_name = "SAMLIdPServiceProviderCreate"]; */
        if (message.event.oneofKind === "sAMLIdPServiceProviderCreate")
            SAMLIdPServiceProviderCreate.internalBinaryWrite(message.event.sAMLIdPServiceProviderCreate, writer.tag(116, WireType.LengthDelimited).fork(), options).join();
        /* events.SAMLIdPServiceProviderUpdate SAMLIdPServiceProviderUpdate = 117 [json_name = "SAMLIdPServiceProviderUpdate"]; */
        if (message.event.oneofKind === "sAMLIdPServiceProviderUpdate")
            SAMLIdPServiceProviderUpdate.internalBinaryWrite(message.event.sAMLIdPServiceProviderUpdate, writer.tag(117, WireType.LengthDelimited).fork(), options).join();
        /* events.SAMLIdPServiceProviderDelete SAMLIdPServiceProviderDelete = 118 [json_name = "SAMLIdPServiceProviderDelete"]; */
        if (message.event.oneofKind === "sAMLIdPServiceProviderDelete")
            SAMLIdPServiceProviderDelete.internalBinaryWrite(message.event.sAMLIdPServiceProviderDelete, writer.tag(118, WireType.LengthDelimited).fork(), options).join();
        /* events.SAMLIdPServiceProviderDeleteAll SAMLIdPServiceProviderDeleteAll = 119 [json_name = "SAMLIdPServiceProviderDeleteAll"]; */
        if (message.event.oneofKind === "sAMLIdPServiceProviderDeleteAll")
            SAMLIdPServiceProviderDeleteAll.internalBinaryWrite(message.event.sAMLIdPServiceProviderDeleteAll, writer.tag(119, WireType.LengthDelimited).fork(), options).join();
        /* events.OpenSearchRequest OpenSearchRequest = 120 [json_name = "OpenSearchRequest"]; */
        if (message.event.oneofKind === "openSearchRequest")
            OpenSearchRequest.internalBinaryWrite(message.event.openSearchRequest, writer.tag(120, WireType.LengthDelimited).fork(), options).join();
        /* events.DeviceEvent2 DeviceEvent2 = 121 [json_name = "DeviceEvent2"]; */
        if (message.event.oneofKind === "deviceEvent2")
            DeviceEvent2.internalBinaryWrite(message.event.deviceEvent2, writer.tag(121, WireType.LengthDelimited).fork(), options).join();
        /* events.OktaResourcesUpdate OktaResourcesUpdate = 122 [json_name = "OktaResourcesUpdate"]; */
        if (message.event.oneofKind === "oktaResourcesUpdate")
            OktaResourcesUpdate.internalBinaryWrite(message.event.oktaResourcesUpdate, writer.tag(122, WireType.LengthDelimited).fork(), options).join();
        /* events.OktaSyncFailure OktaSyncFailure = 123 [json_name = "OktaSyncFailure"]; */
        if (message.event.oneofKind === "oktaSyncFailure")
            OktaSyncFailure.internalBinaryWrite(message.event.oktaSyncFailure, writer.tag(123, WireType.LengthDelimited).fork(), options).join();
        /* events.OktaAssignmentResult OktaAssignmentResult = 124 [json_name = "OktaAssignmentResult"]; */
        if (message.event.oneofKind === "oktaAssignmentResult")
            OktaAssignmentResult.internalBinaryWrite(message.event.oktaAssignmentResult, writer.tag(124, WireType.LengthDelimited).fork(), options).join();
        /* events.ProvisionTokenCreate ProvisionTokenCreate = 125 [json_name = "ProvisionTokenCreate"]; */
        if (message.event.oneofKind === "provisionTokenCreate")
            ProvisionTokenCreate.internalBinaryWrite(message.event.provisionTokenCreate, writer.tag(125, WireType.LengthDelimited).fork(), options).join();
        /* events.AccessListCreate AccessListCreate = 126 [json_name = "AccessListCreate"]; */
        if (message.event.oneofKind === "accessListCreate")
            AccessListCreate.internalBinaryWrite(message.event.accessListCreate, writer.tag(126, WireType.LengthDelimited).fork(), options).join();
        /* events.AccessListUpdate AccessListUpdate = 127 [json_name = "AccessListUpdate"]; */
        if (message.event.oneofKind === "accessListUpdate")
            AccessListUpdate.internalBinaryWrite(message.event.accessListUpdate, writer.tag(127, WireType.LengthDelimited).fork(), options).join();
        /* events.AccessListDelete AccessListDelete = 128 [json_name = "AccessListDelete"]; */
        if (message.event.oneofKind === "accessListDelete")
            AccessListDelete.internalBinaryWrite(message.event.accessListDelete, writer.tag(128, WireType.LengthDelimited).fork(), options).join();
        /* events.AccessListReview AccessListReview = 129 [json_name = "AccessListReview"]; */
        if (message.event.oneofKind === "accessListReview")
            AccessListReview.internalBinaryWrite(message.event.accessListReview, writer.tag(129, WireType.LengthDelimited).fork(), options).join();
        /* events.AccessListMemberCreate AccessListMemberCreate = 130 [json_name = "AccessListMemberCreate"]; */
        if (message.event.oneofKind === "accessListMemberCreate")
            AccessListMemberCreate.internalBinaryWrite(message.event.accessListMemberCreate, writer.tag(130, WireType.LengthDelimited).fork(), options).join();
        /* events.AccessListMemberUpdate AccessListMemberUpdate = 131 [json_name = "AccessListMemberUpdate"]; */
        if (message.event.oneofKind === "accessListMemberUpdate")
            AccessListMemberUpdate.internalBinaryWrite(message.event.accessListMemberUpdate, writer.tag(131, WireType.LengthDelimited).fork(), options).join();
        /* events.AccessListMemberDelete AccessListMemberDelete = 132 [json_name = "AccessListMemberDelete"]; */
        if (message.event.oneofKind === "accessListMemberDelete")
            AccessListMemberDelete.internalBinaryWrite(message.event.accessListMemberDelete, writer.tag(132, WireType.LengthDelimited).fork(), options).join();
        /* events.AccessListMemberDeleteAllForAccessList AccessListMemberDeleteAllForAccessList = 133 [json_name = "AccessListMemberDeleteAllForAccessList"]; */
        if (message.event.oneofKind === "accessListMemberDeleteAllForAccessList")
            AccessListMemberDeleteAllForAccessList.internalBinaryWrite(message.event.accessListMemberDeleteAllForAccessList, writer.tag(133, WireType.LengthDelimited).fork(), options).join();
        /* events.AuditQueryRun AuditQueryRun = 134 [json_name = "AuditQueryRun"]; */
        if (message.event.oneofKind === "auditQueryRun")
            AuditQueryRun.internalBinaryWrite(message.event.auditQueryRun, writer.tag(134, WireType.LengthDelimited).fork(), options).join();
        /* events.SecurityReportRun SecurityReportRun = 135 [json_name = "SecurityReportRun"]; */
        if (message.event.oneofKind === "securityReportRun")
            SecurityReportRun.internalBinaryWrite(message.event.securityReportRun, writer.tag(135, WireType.LengthDelimited).fork(), options).join();
        /* events.GithubConnectorUpdate GithubConnectorUpdate = 136 [json_name = "GithubConnectorUpdate"]; */
        if (message.event.oneofKind === "githubConnectorUpdate")
            GithubConnectorUpdate.internalBinaryWrite(message.event.githubConnectorUpdate, writer.tag(136, WireType.LengthDelimited).fork(), options).join();
        /* events.OIDCConnectorUpdate OIDCConnectorUpdate = 137 [json_name = "OIDCConnectorUpdate"]; */
        if (message.event.oneofKind === "oIDCConnectorUpdate")
            OIDCConnectorUpdate.internalBinaryWrite(message.event.oIDCConnectorUpdate, writer.tag(137, WireType.LengthDelimited).fork(), options).join();
        /* events.SAMLConnectorUpdate SAMLConnectorUpdate = 138 [json_name = "SAMLConnectorUpdate"]; */
        if (message.event.oneofKind === "sAMLConnectorUpdate")
            SAMLConnectorUpdate.internalBinaryWrite(message.event.sAMLConnectorUpdate, writer.tag(138, WireType.LengthDelimited).fork(), options).join();
        /* events.RoleUpdate RoleUpdate = 139 [json_name = "RoleUpdate"]; */
        if (message.event.oneofKind === "roleUpdate")
            RoleUpdate.internalBinaryWrite(message.event.roleUpdate, writer.tag(139, WireType.LengthDelimited).fork(), options).join();
        /* events.UserUpdate UserUpdate = 140 [json_name = "UserUpdate"]; */
        if (message.event.oneofKind === "userUpdate")
            UserUpdate.internalBinaryWrite(message.event.userUpdate, writer.tag(140, WireType.LengthDelimited).fork(), options).join();
        /* events.ExternalAuditStorageEnable ExternalAuditStorageEnable = 141 [json_name = "ExternalAuditStorageEnable"]; */
        if (message.event.oneofKind === "externalAuditStorageEnable")
            ExternalAuditStorageEnable.internalBinaryWrite(message.event.externalAuditStorageEnable, writer.tag(141, WireType.LengthDelimited).fork(), options).join();
        /* events.ExternalAuditStorageDisable ExternalAuditStorageDisable = 142 [json_name = "ExternalAuditStorageDisable"]; */
        if (message.event.oneofKind === "externalAuditStorageDisable")
            ExternalAuditStorageDisable.internalBinaryWrite(message.event.externalAuditStorageDisable, writer.tag(142, WireType.LengthDelimited).fork(), options).join();
        /* events.BotCreate BotCreate = 143 [json_name = "BotCreate"]; */
        if (message.event.oneofKind === "botCreate")
            BotCreate.internalBinaryWrite(message.event.botCreate, writer.tag(143, WireType.LengthDelimited).fork(), options).join();
        /* events.BotDelete BotDelete = 144 [json_name = "BotDelete"]; */
        if (message.event.oneofKind === "botDelete")
            BotDelete.internalBinaryWrite(message.event.botDelete, writer.tag(144, WireType.LengthDelimited).fork(), options).join();
        /* events.BotUpdate BotUpdate = 145 [json_name = "BotUpdate"]; */
        if (message.event.oneofKind === "botUpdate")
            BotUpdate.internalBinaryWrite(message.event.botUpdate, writer.tag(145, WireType.LengthDelimited).fork(), options).join();
        /* events.CreateMFAAuthChallenge CreateMFAAuthChallenge = 146 [json_name = "CreateMFAAuthChallenge"]; */
        if (message.event.oneofKind === "createMFAAuthChallenge")
            CreateMFAAuthChallenge.internalBinaryWrite(message.event.createMFAAuthChallenge, writer.tag(146, WireType.LengthDelimited).fork(), options).join();
        /* events.ValidateMFAAuthResponse ValidateMFAAuthResponse = 147 [json_name = "ValidateMFAAuthResponse"]; */
        if (message.event.oneofKind === "validateMFAAuthResponse")
            ValidateMFAAuthResponse.internalBinaryWrite(message.event.validateMFAAuthResponse, writer.tag(147, WireType.LengthDelimited).fork(), options).join();
        /* events.OktaAccessListSync OktaAccessListSync = 148 [json_name = "OktaAccessListSync"]; */
        if (message.event.oneofKind === "oktaAccessListSync")
            OktaAccessListSync.internalBinaryWrite(message.event.oktaAccessListSync, writer.tag(148, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabasePermissionUpdate DatabasePermissionUpdate = 149 [json_name = "DatabasePermissionUpdate"]; */
        if (message.event.oneofKind === "databasePermissionUpdate")
            DatabasePermissionUpdate.internalBinaryWrite(message.event.databasePermissionUpdate, writer.tag(149, WireType.LengthDelimited).fork(), options).join();
        /* events.SPIFFESVIDIssued SPIFFESVIDIssued = 150 [json_name = "SPIFFESVIDIssued"]; */
        if (message.event.oneofKind === "sPIFFESVIDIssued")
            SPIFFESVIDIssued.internalBinaryWrite(message.event.sPIFFESVIDIssued, writer.tag(150, WireType.LengthDelimited).fork(), options).join();
        /* events.OktaUserSync OktaUserSync = 151 [json_name = "OktaUserSync"]; */
        if (message.event.oneofKind === "oktaUserSync")
            OktaUserSync.internalBinaryWrite(message.event.oktaUserSync, writer.tag(151, WireType.LengthDelimited).fork(), options).join();
        /* events.AuthPreferenceUpdate AuthPreferenceUpdate = 152 [json_name = "AuthPreferenceUpdate"]; */
        if (message.event.oneofKind === "authPreferenceUpdate")
            AuthPreferenceUpdate.internalBinaryWrite(message.event.authPreferenceUpdate, writer.tag(152, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionRecordingConfigUpdate SessionRecordingConfigUpdate = 153 [json_name = "SessionRecordingConfigUpdate"]; */
        if (message.event.oneofKind === "sessionRecordingConfigUpdate")
            SessionRecordingConfigUpdate.internalBinaryWrite(message.event.sessionRecordingConfigUpdate, writer.tag(153, WireType.LengthDelimited).fork(), options).join();
        /* events.ClusterNetworkingConfigUpdate ClusterNetworkingConfigUpdate = 154 [json_name = "ClusterNetworkingConfigUpdate"]; */
        if (message.event.oneofKind === "clusterNetworkingConfigUpdate")
            ClusterNetworkingConfigUpdate.internalBinaryWrite(message.event.clusterNetworkingConfigUpdate, writer.tag(154, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseUserCreate DatabaseUserCreate = 155 [json_name = "DatabaseUserCreate"]; */
        if (message.event.oneofKind === "databaseUserCreate")
            DatabaseUserCreate.internalBinaryWrite(message.event.databaseUserCreate, writer.tag(155, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseUserDeactivate DatabaseUserDeactivate = 156 [json_name = "DatabaseUserDeactivate"]; */
        if (message.event.oneofKind === "databaseUserDeactivate")
            DatabaseUserDeactivate.internalBinaryWrite(message.event.databaseUserDeactivate, writer.tag(156, WireType.LengthDelimited).fork(), options).join();
        /* events.AccessPathChanged AccessPathChanged = 157 [json_name = "AccessPathChanged"]; */
        if (message.event.oneofKind === "accessPathChanged")
            AccessPathChanged.internalBinaryWrite(message.event.accessPathChanged, writer.tag(157, WireType.LengthDelimited).fork(), options).join();
        /* events.SpannerRPC SpannerRPC = 158 [json_name = "SpannerRPC"]; */
        if (message.event.oneofKind === "spannerRPC")
            SpannerRPC.internalBinaryWrite(message.event.spannerRPC, writer.tag(158, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseSessionCommandResult DatabaseSessionCommandResult = 159 [json_name = "DatabaseSessionCommandResult"]; */
        if (message.event.oneofKind === "databaseSessionCommandResult")
            DatabaseSessionCommandResult.internalBinaryWrite(message.event.databaseSessionCommandResult, writer.tag(159, WireType.LengthDelimited).fork(), options).join();
        /* events.DiscoveryConfigCreate DiscoveryConfigCreate = 160 [json_name = "DiscoveryConfigCreate"]; */
        if (message.event.oneofKind === "discoveryConfigCreate")
            DiscoveryConfigCreate.internalBinaryWrite(message.event.discoveryConfigCreate, writer.tag(160, WireType.LengthDelimited).fork(), options).join();
        /* events.DiscoveryConfigUpdate DiscoveryConfigUpdate = 161 [json_name = "DiscoveryConfigUpdate"]; */
        if (message.event.oneofKind === "discoveryConfigUpdate")
            DiscoveryConfigUpdate.internalBinaryWrite(message.event.discoveryConfigUpdate, writer.tag(161, WireType.LengthDelimited).fork(), options).join();
        /* events.DiscoveryConfigDelete DiscoveryConfigDelete = 162 [json_name = "DiscoveryConfigDelete"]; */
        if (message.event.oneofKind === "discoveryConfigDelete")
            DiscoveryConfigDelete.internalBinaryWrite(message.event.discoveryConfigDelete, writer.tag(162, WireType.LengthDelimited).fork(), options).join();
        /* events.DiscoveryConfigDeleteAll DiscoveryConfigDeleteAll = 163 [json_name = "DiscoveryConfigDeleteAll"]; */
        if (message.event.oneofKind === "discoveryConfigDeleteAll")
            DiscoveryConfigDeleteAll.internalBinaryWrite(message.event.discoveryConfigDeleteAll, writer.tag(163, WireType.LengthDelimited).fork(), options).join();
        /* events.AccessGraphSettingsUpdate AccessGraphSettingsUpdate = 164 [json_name = "AccessGraphSettingsUpdate"]; */
        if (message.event.oneofKind === "accessGraphSettingsUpdate")
            AccessGraphSettingsUpdate.internalBinaryWrite(message.event.accessGraphSettingsUpdate, writer.tag(164, WireType.LengthDelimited).fork(), options).join();
        /* events.IntegrationCreate IntegrationCreate = 165 [json_name = "IntegrationCreate"]; */
        if (message.event.oneofKind === "integrationCreate")
            IntegrationCreate.internalBinaryWrite(message.event.integrationCreate, writer.tag(165, WireType.LengthDelimited).fork(), options).join();
        /* events.IntegrationUpdate IntegrationUpdate = 166 [json_name = "IntegrationUpdate"]; */
        if (message.event.oneofKind === "integrationUpdate")
            IntegrationUpdate.internalBinaryWrite(message.event.integrationUpdate, writer.tag(166, WireType.LengthDelimited).fork(), options).join();
        /* events.IntegrationDelete IntegrationDelete = 167 [json_name = "IntegrationDelete"]; */
        if (message.event.oneofKind === "integrationDelete")
            IntegrationDelete.internalBinaryWrite(message.event.integrationDelete, writer.tag(167, WireType.LengthDelimited).fork(), options).join();
        /* events.SPIFFEFederationCreate SPIFFEFederationCreate = 168 [json_name = "SPIFFEFederationCreate"]; */
        if (message.event.oneofKind === "sPIFFEFederationCreate")
            SPIFFEFederationCreate.internalBinaryWrite(message.event.sPIFFEFederationCreate, writer.tag(168, WireType.LengthDelimited).fork(), options).join();
        /* events.SPIFFEFederationDelete SPIFFEFederationDelete = 169 [json_name = "SPIFFEFederationDelete"]; */
        if (message.event.oneofKind === "sPIFFEFederationDelete")
            SPIFFEFederationDelete.internalBinaryWrite(message.event.sPIFFEFederationDelete, writer.tag(169, WireType.LengthDelimited).fork(), options).join();
        /* events.PluginCreate PluginCreate = 170 [json_name = "PluginCreate"]; */
        if (message.event.oneofKind === "pluginCreate")
            PluginCreate.internalBinaryWrite(message.event.pluginCreate, writer.tag(170, WireType.LengthDelimited).fork(), options).join();
        /* events.PluginUpdate PluginUpdate = 171 [json_name = "PluginUpdate"]; */
        if (message.event.oneofKind === "pluginUpdate")
            PluginUpdate.internalBinaryWrite(message.event.pluginUpdate, writer.tag(171, WireType.LengthDelimited).fork(), options).join();
        /* events.PluginDelete PluginDelete = 172 [json_name = "PluginDelete"]; */
        if (message.event.oneofKind === "pluginDelete")
            PluginDelete.internalBinaryWrite(message.event.pluginDelete, writer.tag(172, WireType.LengthDelimited).fork(), options).join();
        /* events.AutoUpdateConfigCreate AutoUpdateConfigCreate = 173 [json_name = "AutoUpdateConfigCreate"]; */
        if (message.event.oneofKind === "autoUpdateConfigCreate")
            AutoUpdateConfigCreate.internalBinaryWrite(message.event.autoUpdateConfigCreate, writer.tag(173, WireType.LengthDelimited).fork(), options).join();
        /* events.AutoUpdateConfigUpdate AutoUpdateConfigUpdate = 174 [json_name = "AutoUpdateConfigUpdate"]; */
        if (message.event.oneofKind === "autoUpdateConfigUpdate")
            AutoUpdateConfigUpdate.internalBinaryWrite(message.event.autoUpdateConfigUpdate, writer.tag(174, WireType.LengthDelimited).fork(), options).join();
        /* events.AutoUpdateConfigDelete AutoUpdateConfigDelete = 175 [json_name = "AutoUpdateConfigDelete"]; */
        if (message.event.oneofKind === "autoUpdateConfigDelete")
            AutoUpdateConfigDelete.internalBinaryWrite(message.event.autoUpdateConfigDelete, writer.tag(175, WireType.LengthDelimited).fork(), options).join();
        /* events.AutoUpdateVersionCreate AutoUpdateVersionCreate = 176 [json_name = "AutoUpdateVersionCreate"]; */
        if (message.event.oneofKind === "autoUpdateVersionCreate")
            AutoUpdateVersionCreate.internalBinaryWrite(message.event.autoUpdateVersionCreate, writer.tag(176, WireType.LengthDelimited).fork(), options).join();
        /* events.AutoUpdateVersionUpdate AutoUpdateVersionUpdate = 177 [json_name = "AutoUpdateVersionUpdate"]; */
        if (message.event.oneofKind === "autoUpdateVersionUpdate")
            AutoUpdateVersionUpdate.internalBinaryWrite(message.event.autoUpdateVersionUpdate, writer.tag(177, WireType.LengthDelimited).fork(), options).join();
        /* events.AutoUpdateVersionDelete AutoUpdateVersionDelete = 178 [json_name = "AutoUpdateVersionDelete"]; */
        if (message.event.oneofKind === "autoUpdateVersionDelete")
            AutoUpdateVersionDelete.internalBinaryWrite(message.event.autoUpdateVersionDelete, writer.tag(178, WireType.LengthDelimited).fork(), options).join();
        /* events.StaticHostUserCreate StaticHostUserCreate = 179 [json_name = "StaticHostUserCreate"]; */
        if (message.event.oneofKind === "staticHostUserCreate")
            StaticHostUserCreate.internalBinaryWrite(message.event.staticHostUserCreate, writer.tag(179, WireType.LengthDelimited).fork(), options).join();
        /* events.StaticHostUserUpdate StaticHostUserUpdate = 180 [json_name = "StaticHostUserUpdate"]; */
        if (message.event.oneofKind === "staticHostUserUpdate")
            StaticHostUserUpdate.internalBinaryWrite(message.event.staticHostUserUpdate, writer.tag(180, WireType.LengthDelimited).fork(), options).join();
        /* events.StaticHostUserDelete StaticHostUserDelete = 181 [json_name = "StaticHostUserDelete"]; */
        if (message.event.oneofKind === "staticHostUserDelete")
            StaticHostUserDelete.internalBinaryWrite(message.event.staticHostUserDelete, writer.tag(181, WireType.LengthDelimited).fork(), options).join();
        /* events.CrownJewelCreate CrownJewelCreate = 182 [json_name = "CrownJewelCreate"]; */
        if (message.event.oneofKind === "crownJewelCreate")
            CrownJewelCreate.internalBinaryWrite(message.event.crownJewelCreate, writer.tag(182, WireType.LengthDelimited).fork(), options).join();
        /* events.CrownJewelUpdate CrownJewelUpdate = 183 [json_name = "CrownJewelUpdate"]; */
        if (message.event.oneofKind === "crownJewelUpdate")
            CrownJewelUpdate.internalBinaryWrite(message.event.crownJewelUpdate, writer.tag(183, WireType.LengthDelimited).fork(), options).join();
        /* events.CrownJewelDelete CrownJewelDelete = 184 [json_name = "CrownJewelDelete"]; */
        if (message.event.oneofKind === "crownJewelDelete")
            CrownJewelDelete.internalBinaryWrite(message.event.crownJewelDelete, writer.tag(184, WireType.LengthDelimited).fork(), options).join();
        /* events.UserTaskCreate UserTaskCreate = 188 [json_name = "UserTaskCreate"]; */
        if (message.event.oneofKind === "userTaskCreate")
            UserTaskCreate.internalBinaryWrite(message.event.userTaskCreate, writer.tag(188, WireType.LengthDelimited).fork(), options).join();
        /* events.UserTaskUpdate UserTaskUpdate = 189 [json_name = "UserTaskUpdate"]; */
        if (message.event.oneofKind === "userTaskUpdate")
            UserTaskUpdate.internalBinaryWrite(message.event.userTaskUpdate, writer.tag(189, WireType.LengthDelimited).fork(), options).join();
        /* events.UserTaskDelete UserTaskDelete = 190 [json_name = "UserTaskDelete"]; */
        if (message.event.oneofKind === "userTaskDelete")
            UserTaskDelete.internalBinaryWrite(message.event.userTaskDelete, writer.tag(190, WireType.LengthDelimited).fork(), options).join();
        /* events.SFTPSummary SFTPSummary = 191 [json_name = "SFTPSummary"]; */
        if (message.event.oneofKind === "sFTPSummary")
            SFTPSummary.internalBinaryWrite(message.event.sFTPSummary, writer.tag(191, WireType.LengthDelimited).fork(), options).join();
        /* events.ContactCreate ContactCreate = 192 [json_name = "ContactCreate"]; */
        if (message.event.oneofKind === "contactCreate")
            ContactCreate.internalBinaryWrite(message.event.contactCreate, writer.tag(192, WireType.LengthDelimited).fork(), options).join();
        /* events.ContactDelete ContactDelete = 193 [json_name = "ContactDelete"]; */
        if (message.event.oneofKind === "contactDelete")
            ContactDelete.internalBinaryWrite(message.event.contactDelete, writer.tag(193, WireType.LengthDelimited).fork(), options).join();
        /* events.WorkloadIdentityCreate WorkloadIdentityCreate = 194 [json_name = "WorkloadIdentityCreate"]; */
        if (message.event.oneofKind === "workloadIdentityCreate")
            WorkloadIdentityCreate.internalBinaryWrite(message.event.workloadIdentityCreate, writer.tag(194, WireType.LengthDelimited).fork(), options).join();
        /* events.WorkloadIdentityUpdate WorkloadIdentityUpdate = 195 [json_name = "WorkloadIdentityUpdate"]; */
        if (message.event.oneofKind === "workloadIdentityUpdate")
            WorkloadIdentityUpdate.internalBinaryWrite(message.event.workloadIdentityUpdate, writer.tag(195, WireType.LengthDelimited).fork(), options).join();
        /* events.WorkloadIdentityDelete WorkloadIdentityDelete = 196 [json_name = "WorkloadIdentityDelete"]; */
        if (message.event.oneofKind === "workloadIdentityDelete")
            WorkloadIdentityDelete.internalBinaryWrite(message.event.workloadIdentityDelete, writer.tag(196, WireType.LengthDelimited).fork(), options).join();
        /* events.GitCommand GitCommand = 197 [json_name = "GitCommand"]; */
        if (message.event.oneofKind === "gitCommand")
            GitCommand.internalBinaryWrite(message.event.gitCommand, writer.tag(197, WireType.LengthDelimited).fork(), options).join();
        /* events.UserLoginAccessListInvalid UserLoginAccessListInvalid = 198 [json_name = "UserLoginAccessListInvalid"]; */
        if (message.event.oneofKind === "userLoginAccessListInvalid")
            UserLoginAccessListInvalid.internalBinaryWrite(message.event.userLoginAccessListInvalid, writer.tag(198, WireType.LengthDelimited).fork(), options).join();
        /* events.AccessRequestExpire AccessRequestExpire = 199 [json_name = "AccessRequestExpire"]; */
        if (message.event.oneofKind === "accessRequestExpire")
            AccessRequestExpire.internalBinaryWrite(message.event.accessRequestExpire, writer.tag(199, WireType.LengthDelimited).fork(), options).join();
        /* events.StableUNIXUserCreate StableUNIXUserCreate = 200 [json_name = "StableUNIXUserCreate"]; */
        if (message.event.oneofKind === "stableUNIXUserCreate")
            StableUNIXUserCreate.internalBinaryWrite(message.event.stableUNIXUserCreate, writer.tag(200, WireType.LengthDelimited).fork(), options).join();
        /* events.WorkloadIdentityX509RevocationCreate WorkloadIdentityX509RevocationCreate = 201 [json_name = "WorkloadIdentityX509RevocationCreate"]; */
        if (message.event.oneofKind === "workloadIdentityX509RevocationCreate")
            WorkloadIdentityX509RevocationCreate.internalBinaryWrite(message.event.workloadIdentityX509RevocationCreate, writer.tag(201, WireType.LengthDelimited).fork(), options).join();
        /* events.WorkloadIdentityX509RevocationDelete WorkloadIdentityX509RevocationDelete = 202 [json_name = "WorkloadIdentityX509RevocationDelete"]; */
        if (message.event.oneofKind === "workloadIdentityX509RevocationDelete")
            WorkloadIdentityX509RevocationDelete.internalBinaryWrite(message.event.workloadIdentityX509RevocationDelete, writer.tag(202, WireType.LengthDelimited).fork(), options).join();
        /* events.WorkloadIdentityX509RevocationUpdate WorkloadIdentityX509RevocationUpdate = 203 [json_name = "WorkloadIdentityX509RevocationUpdate"]; */
        if (message.event.oneofKind === "workloadIdentityX509RevocationUpdate")
            WorkloadIdentityX509RevocationUpdate.internalBinaryWrite(message.event.workloadIdentityX509RevocationUpdate, writer.tag(203, WireType.LengthDelimited).fork(), options).join();
        /* events.AWSICResourceSync AWSICResourceSync = 204 [json_name = "AWSICResourceSync"]; */
        if (message.event.oneofKind === "aWSICResourceSync")
            AWSICResourceSync.internalBinaryWrite(message.event.aWSICResourceSync, writer.tag(204, WireType.LengthDelimited).fork(), options).join();
        /* events.HealthCheckConfigCreate HealthCheckConfigCreate = 205 [json_name = "HealthCheckConfigCreate"]; */
        if (message.event.oneofKind === "healthCheckConfigCreate")
            HealthCheckConfigCreate.internalBinaryWrite(message.event.healthCheckConfigCreate, writer.tag(205, WireType.LengthDelimited).fork(), options).join();
        /* events.HealthCheckConfigUpdate HealthCheckConfigUpdate = 206 [json_name = "HealthCheckConfigUpdate"]; */
        if (message.event.oneofKind === "healthCheckConfigUpdate")
            HealthCheckConfigUpdate.internalBinaryWrite(message.event.healthCheckConfigUpdate, writer.tag(206, WireType.LengthDelimited).fork(), options).join();
        /* events.HealthCheckConfigDelete HealthCheckConfigDelete = 207 [json_name = "HealthCheckConfigDelete"]; */
        if (message.event.oneofKind === "healthCheckConfigDelete")
            HealthCheckConfigDelete.internalBinaryWrite(message.event.healthCheckConfigDelete, writer.tag(207, WireType.LengthDelimited).fork(), options).join();
        /* events.WorkloadIdentityX509IssuerOverrideCreate WorkloadIdentityX509IssuerOverrideCreate = 208 [json_name = "WorkloadIdentityX509IssuerOverrideCreate"]; */
        if (message.event.oneofKind === "workloadIdentityX509IssuerOverrideCreate")
            WorkloadIdentityX509IssuerOverrideCreate.internalBinaryWrite(message.event.workloadIdentityX509IssuerOverrideCreate, writer.tag(208, WireType.LengthDelimited).fork(), options).join();
        /* events.WorkloadIdentityX509IssuerOverrideDelete WorkloadIdentityX509IssuerOverrideDelete = 209 [json_name = "WorkloadIdentityX509IssuerOverrideDelete"]; */
        if (message.event.oneofKind === "workloadIdentityX509IssuerOverrideDelete")
            WorkloadIdentityX509IssuerOverrideDelete.internalBinaryWrite(message.event.workloadIdentityX509IssuerOverrideDelete, writer.tag(209, WireType.LengthDelimited).fork(), options).join();
        /* events.SigstorePolicyCreate SigstorePolicyCreate = 210 [json_name = "SigstorePolicyCreate"]; */
        if (message.event.oneofKind === "sigstorePolicyCreate")
            SigstorePolicyCreate.internalBinaryWrite(message.event.sigstorePolicyCreate, writer.tag(210, WireType.LengthDelimited).fork(), options).join();
        /* events.SigstorePolicyUpdate SigstorePolicyUpdate = 211 [json_name = "SigstorePolicyUpdate"]; */
        if (message.event.oneofKind === "sigstorePolicyUpdate")
            SigstorePolicyUpdate.internalBinaryWrite(message.event.sigstorePolicyUpdate, writer.tag(211, WireType.LengthDelimited).fork(), options).join();
        /* events.SigstorePolicyDelete SigstorePolicyDelete = 212 [json_name = "SigstorePolicyDelete"]; */
        if (message.event.oneofKind === "sigstorePolicyDelete")
            SigstorePolicyDelete.internalBinaryWrite(message.event.sigstorePolicyDelete, writer.tag(212, WireType.LengthDelimited).fork(), options).join();
        /* events.AutoUpdateAgentRolloutTrigger AutoUpdateAgentRolloutTrigger = 213 [json_name = "AutoUpdateAgentRolloutTrigger"]; */
        if (message.event.oneofKind === "autoUpdateAgentRolloutTrigger")
            AutoUpdateAgentRolloutTrigger.internalBinaryWrite(message.event.autoUpdateAgentRolloutTrigger, writer.tag(213, WireType.LengthDelimited).fork(), options).join();
        /* events.AutoUpdateAgentRolloutForceDone AutoUpdateAgentRolloutForceDone = 214 [json_name = "AutoUpdateAgentRolloutForceDone"]; */
        if (message.event.oneofKind === "autoUpdateAgentRolloutForceDone")
            AutoUpdateAgentRolloutForceDone.internalBinaryWrite(message.event.autoUpdateAgentRolloutForceDone, writer.tag(214, WireType.LengthDelimited).fork(), options).join();
        /* events.AutoUpdateAgentRolloutRollback AutoUpdateAgentRolloutRollback = 215 [json_name = "AutoUpdateAgentRolloutRollback"]; */
        if (message.event.oneofKind === "autoUpdateAgentRolloutRollback")
            AutoUpdateAgentRolloutRollback.internalBinaryWrite(message.event.autoUpdateAgentRolloutRollback, writer.tag(215, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.OneOf
 */
export const OneOf = new OneOf$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamStatus$Type extends MessageType<StreamStatus> {
    constructor() {
        super("events.StreamStatus", [
            { no: 1, name: "UploadID", kind: "scalar", jsonName: "UploadID", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "LastEventIndex", kind: "scalar", jsonName: "LastEventIndex", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "LastUploadTime", kind: "message", jsonName: "LastUploadTime", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.stdtime": true } }
        ]);
    }
    create(value?: PartialMessage<StreamStatus>): StreamStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uploadID = "";
        message.lastEventIndex = 0n;
        if (value !== undefined)
            reflectionMergePartial<StreamStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamStatus): StreamStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string UploadID = 1 [json_name = "UploadID"];*/ 1:
                    message.uploadID = reader.string();
                    break;
                case /* int64 LastEventIndex = 2 [json_name = "LastEventIndex"];*/ 2:
                    message.lastEventIndex = reader.int64().toBigInt();
                    break;
                case /* google.protobuf.Timestamp LastUploadTime = 3 [json_name = "LastUploadTime"];*/ 3:
                    message.lastUploadTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastUploadTime);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string UploadID = 1 [json_name = "UploadID"]; */
        if (message.uploadID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uploadID);
        /* int64 LastEventIndex = 2 [json_name = "LastEventIndex"]; */
        if (message.lastEventIndex !== 0n)
            writer.tag(2, WireType.Varint).int64(message.lastEventIndex);
        /* google.protobuf.Timestamp LastUploadTime = 3 [json_name = "LastUploadTime"]; */
        if (message.lastUploadTime)
            Timestamp.internalBinaryWrite(message.lastUploadTime, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.StreamStatus
 */
export const StreamStatus = new StreamStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SessionUpload$Type extends MessageType<SessionUpload> {
    constructor() {
        super("events.SessionUpload", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "SessionMetadata", kind: "message", jsonName: "SessionMetadata", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "SessionURL", kind: "scalar", jsonName: "SessionURL", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "url" } }
        ]);
    }
    create(value?: PartialMessage<SessionUpload>): SessionUpload {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sessionURL = "";
        if (value !== undefined)
            reflectionMergePartial<SessionUpload>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SessionUpload): SessionUpload {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.SessionMetadata SessionMetadata = 2 [json_name = "SessionMetadata"];*/ 2:
                    message.sessionMetadata = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.sessionMetadata);
                    break;
                case /* string SessionURL = 5 [json_name = "SessionURL"];*/ 5:
                    message.sessionURL = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SessionUpload, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata SessionMetadata = 2 [json_name = "SessionMetadata"]; */
        if (message.sessionMetadata)
            SessionMetadata.internalBinaryWrite(message.sessionMetadata, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string SessionURL = 5 [json_name = "SessionURL"]; */
        if (message.sessionURL !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.sessionURL);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.SessionUpload
 */
export const SessionUpload = new SessionUpload$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Identity$Type extends MessageType<Identity> {
    constructor() {
        super("events.Identity", [
            { no: 1, name: "User", kind: "scalar", jsonName: "User", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "user,omitempty" } },
            { no: 2, name: "Impersonator", kind: "scalar", jsonName: "Impersonator", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "impersonator,omitempty" } },
            { no: 3, name: "Roles", kind: "scalar", jsonName: "Roles", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "roles,omitempty" } },
            { no: 4, name: "Usage", kind: "scalar", jsonName: "Usage", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "usage,omitempty" } },
            { no: 5, name: "Logins", kind: "scalar", jsonName: "Logins", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "logins,omitempty" } },
            { no: 6, name: "KubernetesGroups", kind: "scalar", jsonName: "KubernetesGroups", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kubernetes_groups,omitempty" } },
            { no: 7, name: "KubernetesUsers", kind: "scalar", jsonName: "KubernetesUsers", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kubernetes_users,omitempty" } },
            { no: 8, name: "Expires", kind: "message", jsonName: "Expires", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "expires", "gogoproto.stdtime": true } },
            { no: 9, name: "RouteToCluster", kind: "scalar", jsonName: "RouteToCluster", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "route_to_cluster,omitempty" } },
            { no: 10, name: "KubernetesCluster", kind: "scalar", jsonName: "KubernetesCluster", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kubernetes_cluster,omitempty" } },
            { no: 11, name: "Traits", kind: "message", jsonName: "Traits", T: () => LabelValues, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/gravitational/teleport/api/types/wrappers.Traits", "gogoproto.jsontag": "traits,omitempty" } },
            { no: 12, name: "RouteToApp", kind: "message", jsonName: "RouteToApp", T: () => RouteToApp, options: { "gogoproto.jsontag": "route_to_app,omitempty" } },
            { no: 13, name: "TeleportCluster", kind: "scalar", jsonName: "TeleportCluster", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "teleport_cluster,omitempty" } },
            { no: 14, name: "RouteToDatabase", kind: "message", jsonName: "RouteToDatabase", T: () => RouteToDatabase, options: { "gogoproto.jsontag": "route_to_database,omitempty" } },
            { no: 15, name: "DatabaseNames", kind: "scalar", jsonName: "DatabaseNames", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "database_names,omitempty" } },
            { no: 16, name: "DatabaseUsers", kind: "scalar", jsonName: "DatabaseUsers", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "database_users,omitempty" } },
            { no: 17, name: "MFADeviceUUID", kind: "scalar", jsonName: "MFADeviceUUID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "mfa_device_uuid,omitempty" } },
            { no: 18, name: "ClientIP", kind: "scalar", jsonName: "ClientIP", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "client_ip,omitempty" } },
            { no: 19, name: "AWSRoleARNs", kind: "scalar", jsonName: "AWSRoleARNs", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "aws_role_arns,omitempty" } },
            { no: 20, name: "AccessRequests", kind: "scalar", jsonName: "AccessRequests", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "access_requests,omitempty" } },
            { no: 21, name: "DisallowReissue", kind: "scalar", jsonName: "DisallowReissue", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "disallow_reissue,omitempty" } },
            { no: 22, name: "AllowedResourceIDs", kind: "message", jsonName: "AllowedResourceIDs", repeat: 1 /*RepeatType.PACKED*/, T: () => ResourceID, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "allowed_resource_ids,omitempty" } },
            { no: 23, name: "PreviousIdentityExpires", kind: "message", jsonName: "PreviousIdentityExpires", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "prev_identity_expires", "gogoproto.stdtime": true } },
            { no: 24, name: "AzureIdentities", kind: "scalar", jsonName: "AzureIdentities", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "azure_identities,omitempty" } },
            { no: 25, name: "GCPServiceAccounts", kind: "scalar", jsonName: "GCPServiceAccounts", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "gcp_service_accounts,omitempty" } },
            { no: 26, name: "PrivateKeyPolicy", kind: "scalar", jsonName: "PrivateKeyPolicy", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "private_key_policy,omitempty" } },
            { no: 27, name: "BotName", kind: "scalar", jsonName: "BotName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "bot_name,omitempty" } },
            { no: 28, name: "DeviceExtensions", kind: "message", jsonName: "DeviceExtensions", T: () => DeviceExtensions, options: { "gogoproto.jsontag": "device_extensions,omitempty" } },
            { no: 29, name: "BotInstanceID", kind: "scalar", jsonName: "BotInstanceID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "bot_instance_id,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<Identity>): Identity {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.user = "";
        message.impersonator = "";
        message.roles = [];
        message.usage = [];
        message.logins = [];
        message.kubernetesGroups = [];
        message.kubernetesUsers = [];
        message.routeToCluster = "";
        message.kubernetesCluster = "";
        message.teleportCluster = "";
        message.databaseNames = [];
        message.databaseUsers = [];
        message.mFADeviceUUID = "";
        message.clientIP = "";
        message.aWSRoleARNs = [];
        message.accessRequests = [];
        message.disallowReissue = false;
        message.allowedResourceIDs = [];
        message.azureIdentities = [];
        message.gCPServiceAccounts = [];
        message.privateKeyPolicy = "";
        message.botName = "";
        message.botInstanceID = "";
        if (value !== undefined)
            reflectionMergePartial<Identity>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Identity): Identity {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string User = 1 [json_name = "User"];*/ 1:
                    message.user = reader.string();
                    break;
                case /* string Impersonator = 2 [json_name = "Impersonator"];*/ 2:
                    message.impersonator = reader.string();
                    break;
                case /* repeated string Roles = 3 [json_name = "Roles"];*/ 3:
                    message.roles.push(reader.string());
                    break;
                case /* repeated string Usage = 4 [json_name = "Usage"];*/ 4:
                    message.usage.push(reader.string());
                    break;
                case /* repeated string Logins = 5 [json_name = "Logins"];*/ 5:
                    message.logins.push(reader.string());
                    break;
                case /* repeated string KubernetesGroups = 6 [json_name = "KubernetesGroups"];*/ 6:
                    message.kubernetesGroups.push(reader.string());
                    break;
                case /* repeated string KubernetesUsers = 7 [json_name = "KubernetesUsers"];*/ 7:
                    message.kubernetesUsers.push(reader.string());
                    break;
                case /* google.protobuf.Timestamp Expires = 8 [json_name = "Expires"];*/ 8:
                    message.expires = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expires);
                    break;
                case /* string RouteToCluster = 9 [json_name = "RouteToCluster"];*/ 9:
                    message.routeToCluster = reader.string();
                    break;
                case /* string KubernetesCluster = 10 [json_name = "KubernetesCluster"];*/ 10:
                    message.kubernetesCluster = reader.string();
                    break;
                case /* wrappers.LabelValues Traits = 11 [json_name = "Traits"];*/ 11:
                    message.traits = LabelValues.internalBinaryRead(reader, reader.uint32(), options, message.traits);
                    break;
                case /* events.RouteToApp RouteToApp = 12 [json_name = "RouteToApp"];*/ 12:
                    message.routeToApp = RouteToApp.internalBinaryRead(reader, reader.uint32(), options, message.routeToApp);
                    break;
                case /* string TeleportCluster = 13 [json_name = "TeleportCluster"];*/ 13:
                    message.teleportCluster = reader.string();
                    break;
                case /* events.RouteToDatabase RouteToDatabase = 14 [json_name = "RouteToDatabase"];*/ 14:
                    message.routeToDatabase = RouteToDatabase.internalBinaryRead(reader, reader.uint32(), options, message.routeToDatabase);
                    break;
                case /* repeated string DatabaseNames = 15 [json_name = "DatabaseNames"];*/ 15:
                    message.databaseNames.push(reader.string());
                    break;
                case /* repeated string DatabaseUsers = 16 [json_name = "DatabaseUsers"];*/ 16:
                    message.databaseUsers.push(reader.string());
                    break;
                case /* string MFADeviceUUID = 17 [json_name = "MFADeviceUUID"];*/ 17:
                    message.mFADeviceUUID = reader.string();
                    break;
                case /* string ClientIP = 18 [json_name = "ClientIP"];*/ 18:
                    message.clientIP = reader.string();
                    break;
                case /* repeated string AWSRoleARNs = 19 [json_name = "AWSRoleARNs"];*/ 19:
                    message.aWSRoleARNs.push(reader.string());
                    break;
                case /* repeated string AccessRequests = 20 [json_name = "AccessRequests"];*/ 20:
                    message.accessRequests.push(reader.string());
                    break;
                case /* bool DisallowReissue = 21 [json_name = "DisallowReissue"];*/ 21:
                    message.disallowReissue = reader.bool();
                    break;
                case /* repeated events.ResourceID AllowedResourceIDs = 22 [json_name = "AllowedResourceIDs"];*/ 22:
                    message.allowedResourceIDs.push(ResourceID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.Timestamp PreviousIdentityExpires = 23 [json_name = "PreviousIdentityExpires"];*/ 23:
                    message.previousIdentityExpires = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.previousIdentityExpires);
                    break;
                case /* repeated string AzureIdentities = 24 [json_name = "AzureIdentities"];*/ 24:
                    message.azureIdentities.push(reader.string());
                    break;
                case /* repeated string GCPServiceAccounts = 25 [json_name = "GCPServiceAccounts"];*/ 25:
                    message.gCPServiceAccounts.push(reader.string());
                    break;
                case /* string PrivateKeyPolicy = 26 [json_name = "PrivateKeyPolicy"];*/ 26:
                    message.privateKeyPolicy = reader.string();
                    break;
                case /* string BotName = 27 [json_name = "BotName"];*/ 27:
                    message.botName = reader.string();
                    break;
                case /* events.DeviceExtensions DeviceExtensions = 28 [json_name = "DeviceExtensions"];*/ 28:
                    message.deviceExtensions = DeviceExtensions.internalBinaryRead(reader, reader.uint32(), options, message.deviceExtensions);
                    break;
                case /* string BotInstanceID = 29 [json_name = "BotInstanceID"];*/ 29:
                    message.botInstanceID = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Identity, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string User = 1 [json_name = "User"]; */
        if (message.user !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.user);
        /* string Impersonator = 2 [json_name = "Impersonator"]; */
        if (message.impersonator !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.impersonator);
        /* repeated string Roles = 3 [json_name = "Roles"]; */
        for (let i = 0; i < message.roles.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.roles[i]);
        /* repeated string Usage = 4 [json_name = "Usage"]; */
        for (let i = 0; i < message.usage.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.usage[i]);
        /* repeated string Logins = 5 [json_name = "Logins"]; */
        for (let i = 0; i < message.logins.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.logins[i]);
        /* repeated string KubernetesGroups = 6 [json_name = "KubernetesGroups"]; */
        for (let i = 0; i < message.kubernetesGroups.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.kubernetesGroups[i]);
        /* repeated string KubernetesUsers = 7 [json_name = "KubernetesUsers"]; */
        for (let i = 0; i < message.kubernetesUsers.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.kubernetesUsers[i]);
        /* google.protobuf.Timestamp Expires = 8 [json_name = "Expires"]; */
        if (message.expires)
            Timestamp.internalBinaryWrite(message.expires, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* string RouteToCluster = 9 [json_name = "RouteToCluster"]; */
        if (message.routeToCluster !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.routeToCluster);
        /* string KubernetesCluster = 10 [json_name = "KubernetesCluster"]; */
        if (message.kubernetesCluster !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.kubernetesCluster);
        /* wrappers.LabelValues Traits = 11 [json_name = "Traits"]; */
        if (message.traits)
            LabelValues.internalBinaryWrite(message.traits, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* events.RouteToApp RouteToApp = 12 [json_name = "RouteToApp"]; */
        if (message.routeToApp)
            RouteToApp.internalBinaryWrite(message.routeToApp, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* string TeleportCluster = 13 [json_name = "TeleportCluster"]; */
        if (message.teleportCluster !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.teleportCluster);
        /* events.RouteToDatabase RouteToDatabase = 14 [json_name = "RouteToDatabase"]; */
        if (message.routeToDatabase)
            RouteToDatabase.internalBinaryWrite(message.routeToDatabase, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* repeated string DatabaseNames = 15 [json_name = "DatabaseNames"]; */
        for (let i = 0; i < message.databaseNames.length; i++)
            writer.tag(15, WireType.LengthDelimited).string(message.databaseNames[i]);
        /* repeated string DatabaseUsers = 16 [json_name = "DatabaseUsers"]; */
        for (let i = 0; i < message.databaseUsers.length; i++)
            writer.tag(16, WireType.LengthDelimited).string(message.databaseUsers[i]);
        /* string MFADeviceUUID = 17 [json_name = "MFADeviceUUID"]; */
        if (message.mFADeviceUUID !== "")
            writer.tag(17, WireType.LengthDelimited).string(message.mFADeviceUUID);
        /* string ClientIP = 18 [json_name = "ClientIP"]; */
        if (message.clientIP !== "")
            writer.tag(18, WireType.LengthDelimited).string(message.clientIP);
        /* repeated string AWSRoleARNs = 19 [json_name = "AWSRoleARNs"]; */
        for (let i = 0; i < message.aWSRoleARNs.length; i++)
            writer.tag(19, WireType.LengthDelimited).string(message.aWSRoleARNs[i]);
        /* repeated string AccessRequests = 20 [json_name = "AccessRequests"]; */
        for (let i = 0; i < message.accessRequests.length; i++)
            writer.tag(20, WireType.LengthDelimited).string(message.accessRequests[i]);
        /* bool DisallowReissue = 21 [json_name = "DisallowReissue"]; */
        if (message.disallowReissue !== false)
            writer.tag(21, WireType.Varint).bool(message.disallowReissue);
        /* repeated events.ResourceID AllowedResourceIDs = 22 [json_name = "AllowedResourceIDs"]; */
        for (let i = 0; i < message.allowedResourceIDs.length; i++)
            ResourceID.internalBinaryWrite(message.allowedResourceIDs[i], writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp PreviousIdentityExpires = 23 [json_name = "PreviousIdentityExpires"]; */
        if (message.previousIdentityExpires)
            Timestamp.internalBinaryWrite(message.previousIdentityExpires, writer.tag(23, WireType.LengthDelimited).fork(), options).join();
        /* repeated string AzureIdentities = 24 [json_name = "AzureIdentities"]; */
        for (let i = 0; i < message.azureIdentities.length; i++)
            writer.tag(24, WireType.LengthDelimited).string(message.azureIdentities[i]);
        /* repeated string GCPServiceAccounts = 25 [json_name = "GCPServiceAccounts"]; */
        for (let i = 0; i < message.gCPServiceAccounts.length; i++)
            writer.tag(25, WireType.LengthDelimited).string(message.gCPServiceAccounts[i]);
        /* string PrivateKeyPolicy = 26 [json_name = "PrivateKeyPolicy"]; */
        if (message.privateKeyPolicy !== "")
            writer.tag(26, WireType.LengthDelimited).string(message.privateKeyPolicy);
        /* string BotName = 27 [json_name = "BotName"]; */
        if (message.botName !== "")
            writer.tag(27, WireType.LengthDelimited).string(message.botName);
        /* events.DeviceExtensions DeviceExtensions = 28 [json_name = "DeviceExtensions"]; */
        if (message.deviceExtensions)
            DeviceExtensions.internalBinaryWrite(message.deviceExtensions, writer.tag(28, WireType.LengthDelimited).fork(), options).join();
        /* string BotInstanceID = 29 [json_name = "BotInstanceID"]; */
        if (message.botInstanceID !== "")
            writer.tag(29, WireType.LengthDelimited).string(message.botInstanceID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.Identity
 */
export const Identity = new Identity$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteToApp$Type extends MessageType<RouteToApp> {
    constructor() {
        super("events.RouteToApp", [
            { no: 1, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "name" } },
            { no: 2, name: "SessionID", kind: "scalar", jsonName: "SessionID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "session_id" } },
            { no: 3, name: "PublicAddr", kind: "scalar", jsonName: "PublicAddr", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "public_addr" } },
            { no: 4, name: "ClusterName", kind: "scalar", jsonName: "ClusterName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "cluster_name" } },
            { no: 5, name: "AWSRoleARN", kind: "scalar", jsonName: "AWSRoleARN", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "aws_role_arn,omitempty" } },
            { no: 6, name: "AzureIdentity", kind: "scalar", jsonName: "AzureIdentity", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "azure_identity,omitempty" } },
            { no: 7, name: "GCPServiceAccount", kind: "scalar", jsonName: "GCPServiceAccount", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "gcp_service_account,omitempty" } },
            { no: 8, name: "URI", kind: "scalar", jsonName: "URI", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "uri,omitempty" } },
            { no: 9, name: "TargetPort", kind: "scalar", jsonName: "TargetPort", T: 13 /*ScalarType.UINT32*/, options: { "gogoproto.jsontag": "target_port,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<RouteToApp>): RouteToApp {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.sessionID = "";
        message.publicAddr = "";
        message.clusterName = "";
        message.aWSRoleARN = "";
        message.azureIdentity = "";
        message.gCPServiceAccount = "";
        message.uRI = "";
        message.targetPort = 0;
        if (value !== undefined)
            reflectionMergePartial<RouteToApp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RouteToApp): RouteToApp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Name = 1 [json_name = "Name"];*/ 1:
                    message.name = reader.string();
                    break;
                case /* string SessionID = 2 [json_name = "SessionID"];*/ 2:
                    message.sessionID = reader.string();
                    break;
                case /* string PublicAddr = 3 [json_name = "PublicAddr"];*/ 3:
                    message.publicAddr = reader.string();
                    break;
                case /* string ClusterName = 4 [json_name = "ClusterName"];*/ 4:
                    message.clusterName = reader.string();
                    break;
                case /* string AWSRoleARN = 5 [json_name = "AWSRoleARN"];*/ 5:
                    message.aWSRoleARN = reader.string();
                    break;
                case /* string AzureIdentity = 6 [json_name = "AzureIdentity"];*/ 6:
                    message.azureIdentity = reader.string();
                    break;
                case /* string GCPServiceAccount = 7 [json_name = "GCPServiceAccount"];*/ 7:
                    message.gCPServiceAccount = reader.string();
                    break;
                case /* string URI = 8 [json_name = "URI"];*/ 8:
                    message.uRI = reader.string();
                    break;
                case /* uint32 TargetPort = 9 [json_name = "TargetPort"];*/ 9:
                    message.targetPort = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RouteToApp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Name = 1 [json_name = "Name"]; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string SessionID = 2 [json_name = "SessionID"]; */
        if (message.sessionID !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sessionID);
        /* string PublicAddr = 3 [json_name = "PublicAddr"]; */
        if (message.publicAddr !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.publicAddr);
        /* string ClusterName = 4 [json_name = "ClusterName"]; */
        if (message.clusterName !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.clusterName);
        /* string AWSRoleARN = 5 [json_name = "AWSRoleARN"]; */
        if (message.aWSRoleARN !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.aWSRoleARN);
        /* string AzureIdentity = 6 [json_name = "AzureIdentity"]; */
        if (message.azureIdentity !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.azureIdentity);
        /* string GCPServiceAccount = 7 [json_name = "GCPServiceAccount"]; */
        if (message.gCPServiceAccount !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.gCPServiceAccount);
        /* string URI = 8 [json_name = "URI"]; */
        if (message.uRI !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.uRI);
        /* uint32 TargetPort = 9 [json_name = "TargetPort"]; */
        if (message.targetPort !== 0)
            writer.tag(9, WireType.Varint).uint32(message.targetPort);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.RouteToApp
 */
export const RouteToApp = new RouteToApp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteToDatabase$Type extends MessageType<RouteToDatabase> {
    constructor() {
        super("events.RouteToDatabase", [
            { no: 1, name: "ServiceName", kind: "scalar", jsonName: "ServiceName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "service_name" } },
            { no: 2, name: "Protocol", kind: "scalar", jsonName: "Protocol", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "protocol" } },
            { no: 3, name: "Username", kind: "scalar", jsonName: "Username", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "username,omitempty" } },
            { no: 4, name: "Database", kind: "scalar", jsonName: "Database", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "database,omitempty" } },
            { no: 5, name: "Roles", kind: "scalar", jsonName: "Roles", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "roles,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<RouteToDatabase>): RouteToDatabase {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.serviceName = "";
        message.protocol = "";
        message.username = "";
        message.database = "";
        message.roles = [];
        if (value !== undefined)
            reflectionMergePartial<RouteToDatabase>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RouteToDatabase): RouteToDatabase {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ServiceName = 1 [json_name = "ServiceName"];*/ 1:
                    message.serviceName = reader.string();
                    break;
                case /* string Protocol = 2 [json_name = "Protocol"];*/ 2:
                    message.protocol = reader.string();
                    break;
                case /* string Username = 3 [json_name = "Username"];*/ 3:
                    message.username = reader.string();
                    break;
                case /* string Database = 4 [json_name = "Database"];*/ 4:
                    message.database = reader.string();
                    break;
                case /* repeated string Roles = 5 [json_name = "Roles"];*/ 5:
                    message.roles.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RouteToDatabase, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ServiceName = 1 [json_name = "ServiceName"]; */
        if (message.serviceName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.serviceName);
        /* string Protocol = 2 [json_name = "Protocol"]; */
        if (message.protocol !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.protocol);
        /* string Username = 3 [json_name = "Username"]; */
        if (message.username !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.username);
        /* string Database = 4 [json_name = "Database"]; */
        if (message.database !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.database);
        /* repeated string Roles = 5 [json_name = "Roles"]; */
        for (let i = 0; i < message.roles.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.roles[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.RouteToDatabase
 */
export const RouteToDatabase = new RouteToDatabase$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeviceExtensions$Type extends MessageType<DeviceExtensions> {
    constructor() {
        super("events.DeviceExtensions", [
            { no: 1, name: "device_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "device_id,omitempty" } },
            { no: 2, name: "asset_tag", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "asset_tag,omitempty" } },
            { no: 3, name: "credential_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "credential_id,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<DeviceExtensions>): DeviceExtensions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.deviceId = "";
        message.assetTag = "";
        message.credentialId = "";
        if (value !== undefined)
            reflectionMergePartial<DeviceExtensions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeviceExtensions): DeviceExtensions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string device_id */ 1:
                    message.deviceId = reader.string();
                    break;
                case /* string asset_tag */ 2:
                    message.assetTag = reader.string();
                    break;
                case /* string credential_id */ 3:
                    message.credentialId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeviceExtensions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string device_id = 1; */
        if (message.deviceId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.deviceId);
        /* string asset_tag = 2; */
        if (message.assetTag !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.assetTag);
        /* string credential_id = 3; */
        if (message.credentialId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.credentialId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.DeviceExtensions
 */
export const DeviceExtensions = new DeviceExtensions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessRequestResourceSearch$Type extends MessageType<AccessRequestResourceSearch> {
    constructor() {
        super("events.AccessRequestResourceSearch", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "SearchAsRoles", kind: "scalar", jsonName: "SearchAsRoles", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "search_as_roles" } },
            { no: 4, name: "ResourceType", kind: "scalar", jsonName: "ResourceType", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "resource_type,omitempty" } },
            { no: 5, name: "Namespace", kind: "scalar", jsonName: "Namespace", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "namespace,omitempty" } },
            { no: 6, name: "Labels", kind: "map", jsonName: "Labels", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ }, options: { "gogoproto.jsontag": "labels,omitempty" } },
            { no: 7, name: "PredicateExpression", kind: "scalar", jsonName: "PredicateExpression", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "predicate_expression,omitempty" } },
            { no: 8, name: "SearchKeywords", kind: "scalar", jsonName: "SearchKeywords", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "search_keywords,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<AccessRequestResourceSearch>): AccessRequestResourceSearch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.searchAsRoles = [];
        message.resourceType = "";
        message.namespace = "";
        message.labels = {};
        message.predicateExpression = "";
        message.searchKeywords = [];
        if (value !== undefined)
            reflectionMergePartial<AccessRequestResourceSearch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessRequestResourceSearch): AccessRequestResourceSearch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* repeated string SearchAsRoles = 3 [json_name = "SearchAsRoles"];*/ 3:
                    message.searchAsRoles.push(reader.string());
                    break;
                case /* string ResourceType = 4 [json_name = "ResourceType"];*/ 4:
                    message.resourceType = reader.string();
                    break;
                case /* string Namespace = 5 [json_name = "Namespace"];*/ 5:
                    message.namespace = reader.string();
                    break;
                case /* map<string, string> Labels = 6 [json_name = "Labels"];*/ 6:
                    this.binaryReadMap6(message.labels, reader, options);
                    break;
                case /* string PredicateExpression = 7 [json_name = "PredicateExpression"];*/ 7:
                    message.predicateExpression = reader.string();
                    break;
                case /* repeated string SearchKeywords = 8 [json_name = "SearchKeywords"];*/ 8:
                    message.searchKeywords.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap6(map: AccessRequestResourceSearch["labels"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AccessRequestResourceSearch["labels"] | undefined, val: AccessRequestResourceSearch["labels"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field events.AccessRequestResourceSearch.Labels");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: AccessRequestResourceSearch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated string SearchAsRoles = 3 [json_name = "SearchAsRoles"]; */
        for (let i = 0; i < message.searchAsRoles.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.searchAsRoles[i]);
        /* string ResourceType = 4 [json_name = "ResourceType"]; */
        if (message.resourceType !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.resourceType);
        /* string Namespace = 5 [json_name = "Namespace"]; */
        if (message.namespace !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.namespace);
        /* map<string, string> Labels = 6 [json_name = "Labels"]; */
        for (let k of globalThis.Object.keys(message.labels))
            writer.tag(6, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.labels[k]).join();
        /* string PredicateExpression = 7 [json_name = "PredicateExpression"]; */
        if (message.predicateExpression !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.predicateExpression);
        /* repeated string SearchKeywords = 8 [json_name = "SearchKeywords"]; */
        for (let i = 0; i < message.searchKeywords.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.searchKeywords[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.AccessRequestResourceSearch
 */
export const AccessRequestResourceSearch = new AccessRequestResourceSearch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MySQLStatementPrepare$Type extends MessageType<MySQLStatementPrepare> {
    constructor() {
        super("events.MySQLStatementPrepare", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Database", kind: "message", jsonName: "Database", T: () => DatabaseMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Query", kind: "scalar", jsonName: "Query", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "query" } }
        ]);
    }
    create(value?: PartialMessage<MySQLStatementPrepare>): MySQLStatementPrepare {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.query = "";
        if (value !== undefined)
            reflectionMergePartial<MySQLStatementPrepare>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MySQLStatementPrepare): MySQLStatementPrepare {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.DatabaseMetadata Database = 4 [json_name = "Database"];*/ 4:
                    message.database = DatabaseMetadata.internalBinaryRead(reader, reader.uint32(), options, message.database);
                    break;
                case /* string Query = 5 [json_name = "Query"];*/ 5:
                    message.query = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MySQLStatementPrepare, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseMetadata Database = 4 [json_name = "Database"]; */
        if (message.database)
            DatabaseMetadata.internalBinaryWrite(message.database, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string Query = 5 [json_name = "Query"]; */
        if (message.query !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.query);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.MySQLStatementPrepare
 */
export const MySQLStatementPrepare = new MySQLStatementPrepare$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MySQLStatementExecute$Type extends MessageType<MySQLStatementExecute> {
    constructor() {
        super("events.MySQLStatementExecute", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Database", kind: "message", jsonName: "Database", T: () => DatabaseMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "StatementID", kind: "scalar", jsonName: "StatementID", T: 13 /*ScalarType.UINT32*/, options: { "gogoproto.jsontag": "statement_id" } },
            { no: 6, name: "Parameters", kind: "scalar", jsonName: "Parameters", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "parameters" } }
        ]);
    }
    create(value?: PartialMessage<MySQLStatementExecute>): MySQLStatementExecute {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statementID = 0;
        message.parameters = [];
        if (value !== undefined)
            reflectionMergePartial<MySQLStatementExecute>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MySQLStatementExecute): MySQLStatementExecute {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.DatabaseMetadata Database = 4 [json_name = "Database"];*/ 4:
                    message.database = DatabaseMetadata.internalBinaryRead(reader, reader.uint32(), options, message.database);
                    break;
                case /* uint32 StatementID = 5 [json_name = "StatementID"];*/ 5:
                    message.statementID = reader.uint32();
                    break;
                case /* repeated string Parameters = 6 [json_name = "Parameters"];*/ 6:
                    message.parameters.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MySQLStatementExecute, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseMetadata Database = 4 [json_name = "Database"]; */
        if (message.database)
            DatabaseMetadata.internalBinaryWrite(message.database, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* uint32 StatementID = 5 [json_name = "StatementID"]; */
        if (message.statementID !== 0)
            writer.tag(5, WireType.Varint).uint32(message.statementID);
        /* repeated string Parameters = 6 [json_name = "Parameters"]; */
        for (let i = 0; i < message.parameters.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.parameters[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.MySQLStatementExecute
 */
export const MySQLStatementExecute = new MySQLStatementExecute$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MySQLStatementSendLongData$Type extends MessageType<MySQLStatementSendLongData> {
    constructor() {
        super("events.MySQLStatementSendLongData", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Database", kind: "message", jsonName: "Database", T: () => DatabaseMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "StatementID", kind: "scalar", jsonName: "StatementID", T: 13 /*ScalarType.UINT32*/, options: { "gogoproto.jsontag": "statement_id" } },
            { no: 6, name: "ParameterID", kind: "scalar", jsonName: "ParameterID", T: 13 /*ScalarType.UINT32*/, options: { "gogoproto.jsontag": "parameter_id" } },
            { no: 7, name: "DataSize", kind: "scalar", jsonName: "DataSize", T: 13 /*ScalarType.UINT32*/, options: { "gogoproto.jsontag": "data_size" } }
        ]);
    }
    create(value?: PartialMessage<MySQLStatementSendLongData>): MySQLStatementSendLongData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statementID = 0;
        message.parameterID = 0;
        message.dataSize = 0;
        if (value !== undefined)
            reflectionMergePartial<MySQLStatementSendLongData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MySQLStatementSendLongData): MySQLStatementSendLongData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.DatabaseMetadata Database = 4 [json_name = "Database"];*/ 4:
                    message.database = DatabaseMetadata.internalBinaryRead(reader, reader.uint32(), options, message.database);
                    break;
                case /* uint32 StatementID = 5 [json_name = "StatementID"];*/ 5:
                    message.statementID = reader.uint32();
                    break;
                case /* uint32 ParameterID = 6 [json_name = "ParameterID"];*/ 6:
                    message.parameterID = reader.uint32();
                    break;
                case /* uint32 DataSize = 7 [json_name = "DataSize"];*/ 7:
                    message.dataSize = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MySQLStatementSendLongData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseMetadata Database = 4 [json_name = "Database"]; */
        if (message.database)
            DatabaseMetadata.internalBinaryWrite(message.database, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* uint32 StatementID = 5 [json_name = "StatementID"]; */
        if (message.statementID !== 0)
            writer.tag(5, WireType.Varint).uint32(message.statementID);
        /* uint32 ParameterID = 6 [json_name = "ParameterID"]; */
        if (message.parameterID !== 0)
            writer.tag(6, WireType.Varint).uint32(message.parameterID);
        /* uint32 DataSize = 7 [json_name = "DataSize"]; */
        if (message.dataSize !== 0)
            writer.tag(7, WireType.Varint).uint32(message.dataSize);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.MySQLStatementSendLongData
 */
export const MySQLStatementSendLongData = new MySQLStatementSendLongData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MySQLStatementClose$Type extends MessageType<MySQLStatementClose> {
    constructor() {
        super("events.MySQLStatementClose", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Database", kind: "message", jsonName: "Database", T: () => DatabaseMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "StatementID", kind: "scalar", jsonName: "StatementID", T: 13 /*ScalarType.UINT32*/, options: { "gogoproto.jsontag": "statement_id" } }
        ]);
    }
    create(value?: PartialMessage<MySQLStatementClose>): MySQLStatementClose {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statementID = 0;
        if (value !== undefined)
            reflectionMergePartial<MySQLStatementClose>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MySQLStatementClose): MySQLStatementClose {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.DatabaseMetadata Database = 4 [json_name = "Database"];*/ 4:
                    message.database = DatabaseMetadata.internalBinaryRead(reader, reader.uint32(), options, message.database);
                    break;
                case /* uint32 StatementID = 5 [json_name = "StatementID"];*/ 5:
                    message.statementID = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MySQLStatementClose, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseMetadata Database = 4 [json_name = "Database"]; */
        if (message.database)
            DatabaseMetadata.internalBinaryWrite(message.database, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* uint32 StatementID = 5 [json_name = "StatementID"]; */
        if (message.statementID !== 0)
            writer.tag(5, WireType.Varint).uint32(message.statementID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.MySQLStatementClose
 */
export const MySQLStatementClose = new MySQLStatementClose$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MySQLStatementReset$Type extends MessageType<MySQLStatementReset> {
    constructor() {
        super("events.MySQLStatementReset", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Database", kind: "message", jsonName: "Database", T: () => DatabaseMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "StatementID", kind: "scalar", jsonName: "StatementID", T: 13 /*ScalarType.UINT32*/, options: { "gogoproto.jsontag": "statement_id" } }
        ]);
    }
    create(value?: PartialMessage<MySQLStatementReset>): MySQLStatementReset {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statementID = 0;
        if (value !== undefined)
            reflectionMergePartial<MySQLStatementReset>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MySQLStatementReset): MySQLStatementReset {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.DatabaseMetadata Database = 4 [json_name = "Database"];*/ 4:
                    message.database = DatabaseMetadata.internalBinaryRead(reader, reader.uint32(), options, message.database);
                    break;
                case /* uint32 StatementID = 5 [json_name = "StatementID"];*/ 5:
                    message.statementID = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MySQLStatementReset, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseMetadata Database = 4 [json_name = "Database"]; */
        if (message.database)
            DatabaseMetadata.internalBinaryWrite(message.database, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* uint32 StatementID = 5 [json_name = "StatementID"]; */
        if (message.statementID !== 0)
            writer.tag(5, WireType.Varint).uint32(message.statementID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.MySQLStatementReset
 */
export const MySQLStatementReset = new MySQLStatementReset$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MySQLStatementFetch$Type extends MessageType<MySQLStatementFetch> {
    constructor() {
        super("events.MySQLStatementFetch", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Database", kind: "message", jsonName: "Database", T: () => DatabaseMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "StatementID", kind: "scalar", jsonName: "StatementID", T: 13 /*ScalarType.UINT32*/, options: { "gogoproto.jsontag": "statement_id" } },
            { no: 6, name: "RowsCount", kind: "scalar", jsonName: "RowsCount", T: 13 /*ScalarType.UINT32*/, options: { "gogoproto.jsontag": "rows_count" } }
        ]);
    }
    create(value?: PartialMessage<MySQLStatementFetch>): MySQLStatementFetch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statementID = 0;
        message.rowsCount = 0;
        if (value !== undefined)
            reflectionMergePartial<MySQLStatementFetch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MySQLStatementFetch): MySQLStatementFetch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.DatabaseMetadata Database = 4 [json_name = "Database"];*/ 4:
                    message.database = DatabaseMetadata.internalBinaryRead(reader, reader.uint32(), options, message.database);
                    break;
                case /* uint32 StatementID = 5 [json_name = "StatementID"];*/ 5:
                    message.statementID = reader.uint32();
                    break;
                case /* uint32 RowsCount = 6 [json_name = "RowsCount"];*/ 6:
                    message.rowsCount = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MySQLStatementFetch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseMetadata Database = 4 [json_name = "Database"]; */
        if (message.database)
            DatabaseMetadata.internalBinaryWrite(message.database, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* uint32 StatementID = 5 [json_name = "StatementID"]; */
        if (message.statementID !== 0)
            writer.tag(5, WireType.Varint).uint32(message.statementID);
        /* uint32 RowsCount = 6 [json_name = "RowsCount"]; */
        if (message.rowsCount !== 0)
            writer.tag(6, WireType.Varint).uint32(message.rowsCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.MySQLStatementFetch
 */
export const MySQLStatementFetch = new MySQLStatementFetch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MySQLStatementBulkExecute$Type extends MessageType<MySQLStatementBulkExecute> {
    constructor() {
        super("events.MySQLStatementBulkExecute", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Database", kind: "message", jsonName: "Database", T: () => DatabaseMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "StatementID", kind: "scalar", jsonName: "StatementID", T: 13 /*ScalarType.UINT32*/, options: { "gogoproto.jsontag": "statement_id" } },
            { no: 6, name: "Parameters", kind: "scalar", jsonName: "Parameters", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "parameters" } }
        ]);
    }
    create(value?: PartialMessage<MySQLStatementBulkExecute>): MySQLStatementBulkExecute {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statementID = 0;
        message.parameters = [];
        if (value !== undefined)
            reflectionMergePartial<MySQLStatementBulkExecute>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MySQLStatementBulkExecute): MySQLStatementBulkExecute {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.DatabaseMetadata Database = 4 [json_name = "Database"];*/ 4:
                    message.database = DatabaseMetadata.internalBinaryRead(reader, reader.uint32(), options, message.database);
                    break;
                case /* uint32 StatementID = 5 [json_name = "StatementID"];*/ 5:
                    message.statementID = reader.uint32();
                    break;
                case /* repeated string Parameters = 6 [json_name = "Parameters"];*/ 6:
                    message.parameters.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MySQLStatementBulkExecute, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseMetadata Database = 4 [json_name = "Database"]; */
        if (message.database)
            DatabaseMetadata.internalBinaryWrite(message.database, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* uint32 StatementID = 5 [json_name = "StatementID"]; */
        if (message.statementID !== 0)
            writer.tag(5, WireType.Varint).uint32(message.statementID);
        /* repeated string Parameters = 6 [json_name = "Parameters"]; */
        for (let i = 0; i < message.parameters.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.parameters[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.MySQLStatementBulkExecute
 */
export const MySQLStatementBulkExecute = new MySQLStatementBulkExecute$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MySQLInitDB$Type extends MessageType<MySQLInitDB> {
    constructor() {
        super("events.MySQLInitDB", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Database", kind: "message", jsonName: "Database", T: () => DatabaseMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "SchemaName", kind: "scalar", jsonName: "SchemaName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "schema_name" } }
        ]);
    }
    create(value?: PartialMessage<MySQLInitDB>): MySQLInitDB {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.schemaName = "";
        if (value !== undefined)
            reflectionMergePartial<MySQLInitDB>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MySQLInitDB): MySQLInitDB {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.DatabaseMetadata Database = 4 [json_name = "Database"];*/ 4:
                    message.database = DatabaseMetadata.internalBinaryRead(reader, reader.uint32(), options, message.database);
                    break;
                case /* string SchemaName = 5 [json_name = "SchemaName"];*/ 5:
                    message.schemaName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MySQLInitDB, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseMetadata Database = 4 [json_name = "Database"]; */
        if (message.database)
            DatabaseMetadata.internalBinaryWrite(message.database, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string SchemaName = 5 [json_name = "SchemaName"]; */
        if (message.schemaName !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.schemaName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.MySQLInitDB
 */
export const MySQLInitDB = new MySQLInitDB$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MySQLCreateDB$Type extends MessageType<MySQLCreateDB> {
    constructor() {
        super("events.MySQLCreateDB", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Database", kind: "message", jsonName: "Database", T: () => DatabaseMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "SchemaName", kind: "scalar", jsonName: "SchemaName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "schema_name" } }
        ]);
    }
    create(value?: PartialMessage<MySQLCreateDB>): MySQLCreateDB {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.schemaName = "";
        if (value !== undefined)
            reflectionMergePartial<MySQLCreateDB>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MySQLCreateDB): MySQLCreateDB {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.DatabaseMetadata Database = 4 [json_name = "Database"];*/ 4:
                    message.database = DatabaseMetadata.internalBinaryRead(reader, reader.uint32(), options, message.database);
                    break;
                case /* string SchemaName = 5 [json_name = "SchemaName"];*/ 5:
                    message.schemaName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MySQLCreateDB, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseMetadata Database = 4 [json_name = "Database"]; */
        if (message.database)
            DatabaseMetadata.internalBinaryWrite(message.database, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string SchemaName = 5 [json_name = "SchemaName"]; */
        if (message.schemaName !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.schemaName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.MySQLCreateDB
 */
export const MySQLCreateDB = new MySQLCreateDB$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MySQLDropDB$Type extends MessageType<MySQLDropDB> {
    constructor() {
        super("events.MySQLDropDB", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Database", kind: "message", jsonName: "Database", T: () => DatabaseMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "SchemaName", kind: "scalar", jsonName: "SchemaName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "schema_name" } }
        ]);
    }
    create(value?: PartialMessage<MySQLDropDB>): MySQLDropDB {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.schemaName = "";
        if (value !== undefined)
            reflectionMergePartial<MySQLDropDB>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MySQLDropDB): MySQLDropDB {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.DatabaseMetadata Database = 4 [json_name = "Database"];*/ 4:
                    message.database = DatabaseMetadata.internalBinaryRead(reader, reader.uint32(), options, message.database);
                    break;
                case /* string SchemaName = 5 [json_name = "SchemaName"];*/ 5:
                    message.schemaName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MySQLDropDB, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseMetadata Database = 4 [json_name = "Database"]; */
        if (message.database)
            DatabaseMetadata.internalBinaryWrite(message.database, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string SchemaName = 5 [json_name = "SchemaName"]; */
        if (message.schemaName !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.schemaName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.MySQLDropDB
 */
export const MySQLDropDB = new MySQLDropDB$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MySQLShutDown$Type extends MessageType<MySQLShutDown> {
    constructor() {
        super("events.MySQLShutDown", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Database", kind: "message", jsonName: "Database", T: () => DatabaseMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<MySQLShutDown>): MySQLShutDown {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MySQLShutDown>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MySQLShutDown): MySQLShutDown {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.DatabaseMetadata Database = 4 [json_name = "Database"];*/ 4:
                    message.database = DatabaseMetadata.internalBinaryRead(reader, reader.uint32(), options, message.database);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MySQLShutDown, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseMetadata Database = 4 [json_name = "Database"]; */
        if (message.database)
            DatabaseMetadata.internalBinaryWrite(message.database, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.MySQLShutDown
 */
export const MySQLShutDown = new MySQLShutDown$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MySQLProcessKill$Type extends MessageType<MySQLProcessKill> {
    constructor() {
        super("events.MySQLProcessKill", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Database", kind: "message", jsonName: "Database", T: () => DatabaseMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "ProcessID", kind: "scalar", jsonName: "ProcessID", T: 13 /*ScalarType.UINT32*/, options: { "gogoproto.jsontag": "process_id" } }
        ]);
    }
    create(value?: PartialMessage<MySQLProcessKill>): MySQLProcessKill {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.processID = 0;
        if (value !== undefined)
            reflectionMergePartial<MySQLProcessKill>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MySQLProcessKill): MySQLProcessKill {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.DatabaseMetadata Database = 4 [json_name = "Database"];*/ 4:
                    message.database = DatabaseMetadata.internalBinaryRead(reader, reader.uint32(), options, message.database);
                    break;
                case /* uint32 ProcessID = 5 [json_name = "ProcessID"];*/ 5:
                    message.processID = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MySQLProcessKill, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseMetadata Database = 4 [json_name = "Database"]; */
        if (message.database)
            DatabaseMetadata.internalBinaryWrite(message.database, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* uint32 ProcessID = 5 [json_name = "ProcessID"]; */
        if (message.processID !== 0)
            writer.tag(5, WireType.Varint).uint32(message.processID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.MySQLProcessKill
 */
export const MySQLProcessKill = new MySQLProcessKill$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MySQLDebug$Type extends MessageType<MySQLDebug> {
    constructor() {
        super("events.MySQLDebug", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Database", kind: "message", jsonName: "Database", T: () => DatabaseMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<MySQLDebug>): MySQLDebug {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MySQLDebug>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MySQLDebug): MySQLDebug {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.DatabaseMetadata Database = 4 [json_name = "Database"];*/ 4:
                    message.database = DatabaseMetadata.internalBinaryRead(reader, reader.uint32(), options, message.database);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MySQLDebug, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseMetadata Database = 4 [json_name = "Database"]; */
        if (message.database)
            DatabaseMetadata.internalBinaryWrite(message.database, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.MySQLDebug
 */
export const MySQLDebug = new MySQLDebug$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MySQLRefresh$Type extends MessageType<MySQLRefresh> {
    constructor() {
        super("events.MySQLRefresh", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Database", kind: "message", jsonName: "Database", T: () => DatabaseMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Subcommand", kind: "scalar", jsonName: "Subcommand", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "subcommand" } }
        ]);
    }
    create(value?: PartialMessage<MySQLRefresh>): MySQLRefresh {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subcommand = "";
        if (value !== undefined)
            reflectionMergePartial<MySQLRefresh>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MySQLRefresh): MySQLRefresh {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.DatabaseMetadata Database = 4 [json_name = "Database"];*/ 4:
                    message.database = DatabaseMetadata.internalBinaryRead(reader, reader.uint32(), options, message.database);
                    break;
                case /* string Subcommand = 5 [json_name = "Subcommand"];*/ 5:
                    message.subcommand = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MySQLRefresh, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseMetadata Database = 4 [json_name = "Database"]; */
        if (message.database)
            DatabaseMetadata.internalBinaryWrite(message.database, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string Subcommand = 5 [json_name = "Subcommand"]; */
        if (message.subcommand !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.subcommand);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.MySQLRefresh
 */
export const MySQLRefresh = new MySQLRefresh$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SQLServerRPCRequest$Type extends MessageType<SQLServerRPCRequest> {
    constructor() {
        super("events.SQLServerRPCRequest", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Database", kind: "message", jsonName: "Database", T: () => DatabaseMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Procname", kind: "scalar", jsonName: "Procname", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "proc_name,omitempty" } },
            { no: 6, name: "Parameters", kind: "scalar", jsonName: "Parameters", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "parameters,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<SQLServerRPCRequest>): SQLServerRPCRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.procname = "";
        message.parameters = [];
        if (value !== undefined)
            reflectionMergePartial<SQLServerRPCRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SQLServerRPCRequest): SQLServerRPCRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.DatabaseMetadata Database = 4 [json_name = "Database"];*/ 4:
                    message.database = DatabaseMetadata.internalBinaryRead(reader, reader.uint32(), options, message.database);
                    break;
                case /* string Procname = 5 [json_name = "Procname"];*/ 5:
                    message.procname = reader.string();
                    break;
                case /* repeated string Parameters = 6 [json_name = "Parameters"];*/ 6:
                    message.parameters.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SQLServerRPCRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseMetadata Database = 4 [json_name = "Database"]; */
        if (message.database)
            DatabaseMetadata.internalBinaryWrite(message.database, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string Procname = 5 [json_name = "Procname"]; */
        if (message.procname !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.procname);
        /* repeated string Parameters = 6 [json_name = "Parameters"]; */
        for (let i = 0; i < message.parameters.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.parameters[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.SQLServerRPCRequest
 */
export const SQLServerRPCRequest = new SQLServerRPCRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DatabaseSessionMalformedPacket$Type extends MessageType<DatabaseSessionMalformedPacket> {
    constructor() {
        super("events.DatabaseSessionMalformedPacket", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Database", kind: "message", jsonName: "Database", T: () => DatabaseMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Payload", kind: "scalar", jsonName: "Payload", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.jsontag": "payload,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<DatabaseSessionMalformedPacket>): DatabaseSessionMalformedPacket {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.payload = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<DatabaseSessionMalformedPacket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DatabaseSessionMalformedPacket): DatabaseSessionMalformedPacket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.DatabaseMetadata Database = 4 [json_name = "Database"];*/ 4:
                    message.database = DatabaseMetadata.internalBinaryRead(reader, reader.uint32(), options, message.database);
                    break;
                case /* bytes Payload = 5 [json_name = "Payload"];*/ 5:
                    message.payload = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DatabaseSessionMalformedPacket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseMetadata Database = 4 [json_name = "Database"]; */
        if (message.database)
            DatabaseMetadata.internalBinaryWrite(message.database, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bytes Payload = 5 [json_name = "Payload"]; */
        if (message.payload.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.payload);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.DatabaseSessionMalformedPacket
 */
export const DatabaseSessionMalformedPacket = new DatabaseSessionMalformedPacket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ElasticsearchRequest$Type extends MessageType<ElasticsearchRequest> {
    constructor() {
        super("events.ElasticsearchRequest", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Database", kind: "message", jsonName: "Database", T: () => DatabaseMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Path", kind: "scalar", jsonName: "Path", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "path" } },
            { no: 6, name: "RawQuery", kind: "scalar", jsonName: "RawQuery", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "raw_query" } },
            { no: 7, name: "Method", kind: "scalar", jsonName: "Method", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "method" } },
            { no: 8, name: "Body", kind: "scalar", jsonName: "Body", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.jsontag": "body" } },
            { no: 9, name: "Headers", kind: "message", jsonName: "Headers", T: () => LabelValues, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/gravitational/teleport/api/types/wrappers.Traits", "gogoproto.jsontag": "headers,omitempty" } },
            { no: 10, name: "Category", kind: "enum", jsonName: "Category", T: () => ["events.ElasticsearchCategory", ElasticsearchCategory, "ELASTICSEARCH_CATEGORY_"], options: { "gogoproto.jsontag": "category" } },
            { no: 11, name: "Target", kind: "scalar", jsonName: "Target", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "target" } },
            { no: 12, name: "Query", kind: "scalar", jsonName: "Query", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "query" } },
            { no: 13, name: "StatusCode", kind: "scalar", jsonName: "StatusCode", T: 13 /*ScalarType.UINT32*/, options: { "gogoproto.jsontag": "status_code" } }
        ]);
    }
    create(value?: PartialMessage<ElasticsearchRequest>): ElasticsearchRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.path = "";
        message.rawQuery = "";
        message.method = "";
        message.body = new Uint8Array(0);
        message.category = 0;
        message.target = "";
        message.query = "";
        message.statusCode = 0;
        if (value !== undefined)
            reflectionMergePartial<ElasticsearchRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ElasticsearchRequest): ElasticsearchRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.DatabaseMetadata Database = 4 [json_name = "Database"];*/ 4:
                    message.database = DatabaseMetadata.internalBinaryRead(reader, reader.uint32(), options, message.database);
                    break;
                case /* string Path = 5 [json_name = "Path"];*/ 5:
                    message.path = reader.string();
                    break;
                case /* string RawQuery = 6 [json_name = "RawQuery"];*/ 6:
                    message.rawQuery = reader.string();
                    break;
                case /* string Method = 7 [json_name = "Method"];*/ 7:
                    message.method = reader.string();
                    break;
                case /* bytes Body = 8 [json_name = "Body"];*/ 8:
                    message.body = reader.bytes();
                    break;
                case /* wrappers.LabelValues Headers = 9 [json_name = "Headers"];*/ 9:
                    message.headers = LabelValues.internalBinaryRead(reader, reader.uint32(), options, message.headers);
                    break;
                case /* events.ElasticsearchCategory Category = 10 [json_name = "Category"];*/ 10:
                    message.category = reader.int32();
                    break;
                case /* string Target = 11 [json_name = "Target"];*/ 11:
                    message.target = reader.string();
                    break;
                case /* string Query = 12 [json_name = "Query"];*/ 12:
                    message.query = reader.string();
                    break;
                case /* uint32 StatusCode = 13 [json_name = "StatusCode"];*/ 13:
                    message.statusCode = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ElasticsearchRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseMetadata Database = 4 [json_name = "Database"]; */
        if (message.database)
            DatabaseMetadata.internalBinaryWrite(message.database, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string Path = 5 [json_name = "Path"]; */
        if (message.path !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.path);
        /* string RawQuery = 6 [json_name = "RawQuery"]; */
        if (message.rawQuery !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.rawQuery);
        /* string Method = 7 [json_name = "Method"]; */
        if (message.method !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.method);
        /* bytes Body = 8 [json_name = "Body"]; */
        if (message.body.length)
            writer.tag(8, WireType.LengthDelimited).bytes(message.body);
        /* wrappers.LabelValues Headers = 9 [json_name = "Headers"]; */
        if (message.headers)
            LabelValues.internalBinaryWrite(message.headers, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* events.ElasticsearchCategory Category = 10 [json_name = "Category"]; */
        if (message.category !== 0)
            writer.tag(10, WireType.Varint).int32(message.category);
        /* string Target = 11 [json_name = "Target"]; */
        if (message.target !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.target);
        /* string Query = 12 [json_name = "Query"]; */
        if (message.query !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.query);
        /* uint32 StatusCode = 13 [json_name = "StatusCode"]; */
        if (message.statusCode !== 0)
            writer.tag(13, WireType.Varint).uint32(message.statusCode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.ElasticsearchRequest
 */
export const ElasticsearchRequest = new ElasticsearchRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OpenSearchRequest$Type extends MessageType<OpenSearchRequest> {
    constructor() {
        super("events.OpenSearchRequest", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Database", kind: "message", jsonName: "Database", T: () => DatabaseMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Path", kind: "scalar", jsonName: "Path", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "path" } },
            { no: 6, name: "RawQuery", kind: "scalar", jsonName: "RawQuery", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "raw_query" } },
            { no: 7, name: "Method", kind: "scalar", jsonName: "Method", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "method" } },
            { no: 8, name: "Body", kind: "scalar", jsonName: "Body", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.jsontag": "body" } },
            { no: 9, name: "Headers", kind: "message", jsonName: "Headers", T: () => LabelValues, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/gravitational/teleport/api/types/wrappers.Traits", "gogoproto.jsontag": "headers,omitempty" } },
            { no: 10, name: "Category", kind: "enum", jsonName: "Category", T: () => ["events.OpenSearchCategory", OpenSearchCategory, "OPEN_SEARCH_CATEGORY_"], options: { "gogoproto.jsontag": "category" } },
            { no: 11, name: "Target", kind: "scalar", jsonName: "Target", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "target" } },
            { no: 12, name: "Query", kind: "scalar", jsonName: "Query", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "query" } },
            { no: 13, name: "StatusCode", kind: "scalar", jsonName: "StatusCode", T: 13 /*ScalarType.UINT32*/, options: { "gogoproto.jsontag": "status_code" } }
        ]);
    }
    create(value?: PartialMessage<OpenSearchRequest>): OpenSearchRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.path = "";
        message.rawQuery = "";
        message.method = "";
        message.body = new Uint8Array(0);
        message.category = 0;
        message.target = "";
        message.query = "";
        message.statusCode = 0;
        if (value !== undefined)
            reflectionMergePartial<OpenSearchRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OpenSearchRequest): OpenSearchRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.DatabaseMetadata Database = 4 [json_name = "Database"];*/ 4:
                    message.database = DatabaseMetadata.internalBinaryRead(reader, reader.uint32(), options, message.database);
                    break;
                case /* string Path = 5 [json_name = "Path"];*/ 5:
                    message.path = reader.string();
                    break;
                case /* string RawQuery = 6 [json_name = "RawQuery"];*/ 6:
                    message.rawQuery = reader.string();
                    break;
                case /* string Method = 7 [json_name = "Method"];*/ 7:
                    message.method = reader.string();
                    break;
                case /* bytes Body = 8 [json_name = "Body"];*/ 8:
                    message.body = reader.bytes();
                    break;
                case /* wrappers.LabelValues Headers = 9 [json_name = "Headers"];*/ 9:
                    message.headers = LabelValues.internalBinaryRead(reader, reader.uint32(), options, message.headers);
                    break;
                case /* events.OpenSearchCategory Category = 10 [json_name = "Category"];*/ 10:
                    message.category = reader.int32();
                    break;
                case /* string Target = 11 [json_name = "Target"];*/ 11:
                    message.target = reader.string();
                    break;
                case /* string Query = 12 [json_name = "Query"];*/ 12:
                    message.query = reader.string();
                    break;
                case /* uint32 StatusCode = 13 [json_name = "StatusCode"];*/ 13:
                    message.statusCode = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OpenSearchRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseMetadata Database = 4 [json_name = "Database"]; */
        if (message.database)
            DatabaseMetadata.internalBinaryWrite(message.database, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string Path = 5 [json_name = "Path"]; */
        if (message.path !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.path);
        /* string RawQuery = 6 [json_name = "RawQuery"]; */
        if (message.rawQuery !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.rawQuery);
        /* string Method = 7 [json_name = "Method"]; */
        if (message.method !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.method);
        /* bytes Body = 8 [json_name = "Body"]; */
        if (message.body.length)
            writer.tag(8, WireType.LengthDelimited).bytes(message.body);
        /* wrappers.LabelValues Headers = 9 [json_name = "Headers"]; */
        if (message.headers)
            LabelValues.internalBinaryWrite(message.headers, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* events.OpenSearchCategory Category = 10 [json_name = "Category"]; */
        if (message.category !== 0)
            writer.tag(10, WireType.Varint).int32(message.category);
        /* string Target = 11 [json_name = "Target"]; */
        if (message.target !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.target);
        /* string Query = 12 [json_name = "Query"]; */
        if (message.query !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.query);
        /* uint32 StatusCode = 13 [json_name = "StatusCode"]; */
        if (message.statusCode !== 0)
            writer.tag(13, WireType.Varint).uint32(message.statusCode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.OpenSearchRequest
 */
export const OpenSearchRequest = new OpenSearchRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DynamoDBRequest$Type extends MessageType<DynamoDBRequest> {
    constructor() {
        super("events.DynamoDBRequest", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Database", kind: "message", jsonName: "Database", T: () => DatabaseMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "StatusCode", kind: "scalar", jsonName: "StatusCode", T: 13 /*ScalarType.UINT32*/, options: { "gogoproto.jsontag": "status_code" } },
            { no: 6, name: "Path", kind: "scalar", jsonName: "Path", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "path" } },
            { no: 7, name: "RawQuery", kind: "scalar", jsonName: "RawQuery", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "raw_query" } },
            { no: 8, name: "Method", kind: "scalar", jsonName: "Method", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "method" } },
            { no: 9, name: "Target", kind: "scalar", jsonName: "Target", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "target" } },
            { no: 10, name: "Body", kind: "message", jsonName: "Body", T: () => Struct, options: { "gogoproto.jsontag": "body,omitempty", "gogoproto.casttype": "Struct" } }
        ]);
    }
    create(value?: PartialMessage<DynamoDBRequest>): DynamoDBRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statusCode = 0;
        message.path = "";
        message.rawQuery = "";
        message.method = "";
        message.target = "";
        if (value !== undefined)
            reflectionMergePartial<DynamoDBRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DynamoDBRequest): DynamoDBRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.DatabaseMetadata Database = 4 [json_name = "Database"];*/ 4:
                    message.database = DatabaseMetadata.internalBinaryRead(reader, reader.uint32(), options, message.database);
                    break;
                case /* uint32 StatusCode = 5 [json_name = "StatusCode"];*/ 5:
                    message.statusCode = reader.uint32();
                    break;
                case /* string Path = 6 [json_name = "Path"];*/ 6:
                    message.path = reader.string();
                    break;
                case /* string RawQuery = 7 [json_name = "RawQuery"];*/ 7:
                    message.rawQuery = reader.string();
                    break;
                case /* string Method = 8 [json_name = "Method"];*/ 8:
                    message.method = reader.string();
                    break;
                case /* string Target = 9 [json_name = "Target"];*/ 9:
                    message.target = reader.string();
                    break;
                case /* google.protobuf.Struct Body = 10 [json_name = "Body"];*/ 10:
                    message.body = Struct.internalBinaryRead(reader, reader.uint32(), options, message.body);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DynamoDBRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseMetadata Database = 4 [json_name = "Database"]; */
        if (message.database)
            DatabaseMetadata.internalBinaryWrite(message.database, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* uint32 StatusCode = 5 [json_name = "StatusCode"]; */
        if (message.statusCode !== 0)
            writer.tag(5, WireType.Varint).uint32(message.statusCode);
        /* string Path = 6 [json_name = "Path"]; */
        if (message.path !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.path);
        /* string RawQuery = 7 [json_name = "RawQuery"]; */
        if (message.rawQuery !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.rawQuery);
        /* string Method = 8 [json_name = "Method"]; */
        if (message.method !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.method);
        /* string Target = 9 [json_name = "Target"]; */
        if (message.target !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.target);
        /* google.protobuf.Struct Body = 10 [json_name = "Body"]; */
        if (message.body)
            Struct.internalBinaryWrite(message.body, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.DynamoDBRequest
 */
export const DynamoDBRequest = new DynamoDBRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppSessionDynamoDBRequest$Type extends MessageType<AppSessionDynamoDBRequest> {
    constructor() {
        super("events.AppSessionDynamoDBRequest", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "App", kind: "message", jsonName: "App", T: () => AppMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "AWS", kind: "message", jsonName: "AWS", T: () => AWSRequestMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "SessionChunkID", kind: "scalar", jsonName: "SessionChunkID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "session_chunk_id" } },
            { no: 6, name: "StatusCode", kind: "scalar", jsonName: "StatusCode", T: 13 /*ScalarType.UINT32*/, options: { "gogoproto.jsontag": "status_code" } },
            { no: 7, name: "Path", kind: "scalar", jsonName: "Path", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "path" } },
            { no: 8, name: "RawQuery", kind: "scalar", jsonName: "RawQuery", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "raw_query" } },
            { no: 9, name: "Method", kind: "scalar", jsonName: "Method", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "method" } },
            { no: 10, name: "Target", kind: "scalar", jsonName: "Target", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "target" } },
            { no: 11, name: "Body", kind: "message", jsonName: "Body", T: () => Struct, options: { "gogoproto.jsontag": "body,omitempty", "gogoproto.casttype": "Struct" } }
        ]);
    }
    create(value?: PartialMessage<AppSessionDynamoDBRequest>): AppSessionDynamoDBRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sessionChunkID = "";
        message.statusCode = 0;
        message.path = "";
        message.rawQuery = "";
        message.method = "";
        message.target = "";
        if (value !== undefined)
            reflectionMergePartial<AppSessionDynamoDBRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppSessionDynamoDBRequest): AppSessionDynamoDBRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.AppMetadata App = 3 [json_name = "App"];*/ 3:
                    message.app = AppMetadata.internalBinaryRead(reader, reader.uint32(), options, message.app);
                    break;
                case /* events.AWSRequestMetadata AWS = 4 [json_name = "AWS"];*/ 4:
                    message.aWS = AWSRequestMetadata.internalBinaryRead(reader, reader.uint32(), options, message.aWS);
                    break;
                case /* string SessionChunkID = 5 [json_name = "SessionChunkID"];*/ 5:
                    message.sessionChunkID = reader.string();
                    break;
                case /* uint32 StatusCode = 6 [json_name = "StatusCode"];*/ 6:
                    message.statusCode = reader.uint32();
                    break;
                case /* string Path = 7 [json_name = "Path"];*/ 7:
                    message.path = reader.string();
                    break;
                case /* string RawQuery = 8 [json_name = "RawQuery"];*/ 8:
                    message.rawQuery = reader.string();
                    break;
                case /* string Method = 9 [json_name = "Method"];*/ 9:
                    message.method = reader.string();
                    break;
                case /* string Target = 10 [json_name = "Target"];*/ 10:
                    message.target = reader.string();
                    break;
                case /* google.protobuf.Struct Body = 11 [json_name = "Body"];*/ 11:
                    message.body = Struct.internalBinaryRead(reader, reader.uint32(), options, message.body);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppSessionDynamoDBRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.AppMetadata App = 3 [json_name = "App"]; */
        if (message.app)
            AppMetadata.internalBinaryWrite(message.app, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.AWSRequestMetadata AWS = 4 [json_name = "AWS"]; */
        if (message.aWS)
            AWSRequestMetadata.internalBinaryWrite(message.aWS, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string SessionChunkID = 5 [json_name = "SessionChunkID"]; */
        if (message.sessionChunkID !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.sessionChunkID);
        /* uint32 StatusCode = 6 [json_name = "StatusCode"]; */
        if (message.statusCode !== 0)
            writer.tag(6, WireType.Varint).uint32(message.statusCode);
        /* string Path = 7 [json_name = "Path"]; */
        if (message.path !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.path);
        /* string RawQuery = 8 [json_name = "RawQuery"]; */
        if (message.rawQuery !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.rawQuery);
        /* string Method = 9 [json_name = "Method"]; */
        if (message.method !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.method);
        /* string Target = 10 [json_name = "Target"]; */
        if (message.target !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.target);
        /* google.protobuf.Struct Body = 11 [json_name = "Body"]; */
        if (message.body)
            Struct.internalBinaryWrite(message.body, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.AppSessionDynamoDBRequest
 */
export const AppSessionDynamoDBRequest = new AppSessionDynamoDBRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpgradeWindowStartMetadata$Type extends MessageType<UpgradeWindowStartMetadata> {
    constructor() {
        super("events.UpgradeWindowStartMetadata", [
            { no: 1, name: "UpgradeWindowStart", kind: "scalar", jsonName: "UpgradeWindowStart", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "upgrade_window_start,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<UpgradeWindowStartMetadata>): UpgradeWindowStartMetadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.upgradeWindowStart = "";
        if (value !== undefined)
            reflectionMergePartial<UpgradeWindowStartMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpgradeWindowStartMetadata): UpgradeWindowStartMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string UpgradeWindowStart = 1 [json_name = "UpgradeWindowStart"];*/ 1:
                    message.upgradeWindowStart = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpgradeWindowStartMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string UpgradeWindowStart = 1 [json_name = "UpgradeWindowStart"]; */
        if (message.upgradeWindowStart !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.upgradeWindowStart);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.UpgradeWindowStartMetadata
 */
export const UpgradeWindowStartMetadata = new UpgradeWindowStartMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpgradeWindowStartUpdate$Type extends MessageType<UpgradeWindowStartUpdate> {
    constructor() {
        super("events.UpgradeWindowStartUpdate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "UpgradeWindowStart", kind: "message", jsonName: "UpgradeWindowStart", T: () => UpgradeWindowStartMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<UpgradeWindowStartUpdate>): UpgradeWindowStartUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpgradeWindowStartUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpgradeWindowStartUpdate): UpgradeWindowStartUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.UpgradeWindowStartMetadata UpgradeWindowStart = 4 [json_name = "UpgradeWindowStart"];*/ 4:
                    message.upgradeWindowStart = UpgradeWindowStartMetadata.internalBinaryRead(reader, reader.uint32(), options, message.upgradeWindowStart);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpgradeWindowStartUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.UpgradeWindowStartMetadata UpgradeWindowStart = 4 [json_name = "UpgradeWindowStart"]; */
        if (message.upgradeWindowStart)
            UpgradeWindowStartMetadata.internalBinaryWrite(message.upgradeWindowStart, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.UpgradeWindowStartUpdate
 */
export const UpgradeWindowStartUpdate = new UpgradeWindowStartUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SessionRecordingAccess$Type extends MessageType<SessionRecordingAccess> {
    constructor() {
        super("events.SessionRecordingAccess", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "SessionID", kind: "scalar", jsonName: "SessionID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sid" } },
            { no: 3, name: "UserMetadata", kind: "message", jsonName: "UserMetadata", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "SessionType", kind: "scalar", jsonName: "SessionType", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "session_type,omitempty" } },
            { no: 5, name: "Format", kind: "scalar", jsonName: "Format", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "format,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<SessionRecordingAccess>): SessionRecordingAccess {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sessionID = "";
        message.sessionType = "";
        message.format = "";
        if (value !== undefined)
            reflectionMergePartial<SessionRecordingAccess>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SessionRecordingAccess): SessionRecordingAccess {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* string SessionID = 2 [json_name = "SessionID"];*/ 2:
                    message.sessionID = reader.string();
                    break;
                case /* events.UserMetadata UserMetadata = 3 [json_name = "UserMetadata"];*/ 3:
                    message.userMetadata = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.userMetadata);
                    break;
                case /* string SessionType = 4 [json_name = "SessionType"];*/ 4:
                    message.sessionType = reader.string();
                    break;
                case /* string Format = 5 [json_name = "Format"];*/ 5:
                    message.format = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SessionRecordingAccess, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string SessionID = 2 [json_name = "SessionID"]; */
        if (message.sessionID !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sessionID);
        /* events.UserMetadata UserMetadata = 3 [json_name = "UserMetadata"]; */
        if (message.userMetadata)
            UserMetadata.internalBinaryWrite(message.userMetadata, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string SessionType = 4 [json_name = "SessionType"]; */
        if (message.sessionType !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.sessionType);
        /* string Format = 5 [json_name = "Format"]; */
        if (message.format !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.format);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.SessionRecordingAccess
 */
export const SessionRecordingAccess = new SessionRecordingAccess$Type();
// @generated message type with reflection information, may provide speed optimized methods
class KubeClusterMetadata$Type extends MessageType<KubeClusterMetadata> {
    constructor() {
        super("events.KubeClusterMetadata", [
            { no: 1, name: "KubeLabels", kind: "map", jsonName: "KubeLabels", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ }, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "kube_labels,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<KubeClusterMetadata>): KubeClusterMetadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kubeLabels = {};
        if (value !== undefined)
            reflectionMergePartial<KubeClusterMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KubeClusterMetadata): KubeClusterMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, string> KubeLabels = 1 [json_name = "KubeLabels"];*/ 1:
                    this.binaryReadMap1(message.kubeLabels, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: KubeClusterMetadata["kubeLabels"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof KubeClusterMetadata["kubeLabels"] | undefined, val: KubeClusterMetadata["kubeLabels"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field events.KubeClusterMetadata.KubeLabels");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: KubeClusterMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, string> KubeLabels = 1 [json_name = "KubeLabels"]; */
        for (let k of globalThis.Object.keys(message.kubeLabels))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.kubeLabels[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.KubeClusterMetadata
 */
export const KubeClusterMetadata = new KubeClusterMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class KubernetesClusterCreate$Type extends MessageType<KubernetesClusterCreate> {
    constructor() {
        super("events.KubernetesClusterCreate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "KubeClusterMetadata", kind: "message", jsonName: "KubeClusterMetadata", T: () => KubeClusterMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<KubernetesClusterCreate>): KubernetesClusterCreate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<KubernetesClusterCreate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KubernetesClusterCreate): KubernetesClusterCreate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ResourceMetadata Resource = 3 [json_name = "Resource"];*/ 3:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.KubeClusterMetadata KubeClusterMetadata = 4 [json_name = "KubeClusterMetadata"];*/ 4:
                    message.kubeClusterMetadata = KubeClusterMetadata.internalBinaryRead(reader, reader.uint32(), options, message.kubeClusterMetadata);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: KubernetesClusterCreate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 3 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.KubeClusterMetadata KubeClusterMetadata = 4 [json_name = "KubeClusterMetadata"]; */
        if (message.kubeClusterMetadata)
            KubeClusterMetadata.internalBinaryWrite(message.kubeClusterMetadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.KubernetesClusterCreate
 */
export const KubernetesClusterCreate = new KubernetesClusterCreate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class KubernetesClusterUpdate$Type extends MessageType<KubernetesClusterUpdate> {
    constructor() {
        super("events.KubernetesClusterUpdate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "KubeClusterMetadata", kind: "message", jsonName: "KubeClusterMetadata", T: () => KubeClusterMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<KubernetesClusterUpdate>): KubernetesClusterUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<KubernetesClusterUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KubernetesClusterUpdate): KubernetesClusterUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ResourceMetadata Resource = 3 [json_name = "Resource"];*/ 3:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.KubeClusterMetadata KubeClusterMetadata = 4 [json_name = "KubeClusterMetadata"];*/ 4:
                    message.kubeClusterMetadata = KubeClusterMetadata.internalBinaryRead(reader, reader.uint32(), options, message.kubeClusterMetadata);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: KubernetesClusterUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 3 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.KubeClusterMetadata KubeClusterMetadata = 4 [json_name = "KubeClusterMetadata"]; */
        if (message.kubeClusterMetadata)
            KubeClusterMetadata.internalBinaryWrite(message.kubeClusterMetadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.KubernetesClusterUpdate
 */
export const KubernetesClusterUpdate = new KubernetesClusterUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class KubernetesClusterDelete$Type extends MessageType<KubernetesClusterDelete> {
    constructor() {
        super("events.KubernetesClusterDelete", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<KubernetesClusterDelete>): KubernetesClusterDelete {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<KubernetesClusterDelete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KubernetesClusterDelete): KubernetesClusterDelete {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ResourceMetadata Resource = 3 [json_name = "Resource"];*/ 3:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: KubernetesClusterDelete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 3 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.KubernetesClusterDelete
 */
export const KubernetesClusterDelete = new KubernetesClusterDelete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SSMRun$Type extends MessageType<SSMRun> {
    constructor() {
        super("events.SSMRun", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "CommandID", kind: "scalar", jsonName: "CommandID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "command_id" } },
            { no: 3, name: "InstanceID", kind: "scalar", jsonName: "InstanceID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "instance_id" } },
            { no: 4, name: "ExitCode", kind: "scalar", jsonName: "ExitCode", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "exit_code" } },
            { no: 5, name: "Status", kind: "scalar", jsonName: "Status", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "status" } },
            { no: 6, name: "AccountID", kind: "scalar", jsonName: "AccountID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "account_id" } },
            { no: 7, name: "Region", kind: "scalar", jsonName: "Region", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "region" } },
            { no: 8, name: "StandardOutput", kind: "scalar", jsonName: "StandardOutput", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "stdout" } },
            { no: 9, name: "StandardError", kind: "scalar", jsonName: "StandardError", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "stderr" } },
            { no: 10, name: "InvocationURL", kind: "scalar", jsonName: "InvocationURL", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "invocation_url" } }
        ]);
    }
    create(value?: PartialMessage<SSMRun>): SSMRun {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.commandID = "";
        message.instanceID = "";
        message.exitCode = 0n;
        message.status = "";
        message.accountID = "";
        message.region = "";
        message.standardOutput = "";
        message.standardError = "";
        message.invocationURL = "";
        if (value !== undefined)
            reflectionMergePartial<SSMRun>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SSMRun): SSMRun {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* string CommandID = 2 [json_name = "CommandID"];*/ 2:
                    message.commandID = reader.string();
                    break;
                case /* string InstanceID = 3 [json_name = "InstanceID"];*/ 3:
                    message.instanceID = reader.string();
                    break;
                case /* int64 ExitCode = 4 [json_name = "ExitCode"];*/ 4:
                    message.exitCode = reader.int64().toBigInt();
                    break;
                case /* string Status = 5 [json_name = "Status"];*/ 5:
                    message.status = reader.string();
                    break;
                case /* string AccountID = 6 [json_name = "AccountID"];*/ 6:
                    message.accountID = reader.string();
                    break;
                case /* string Region = 7 [json_name = "Region"];*/ 7:
                    message.region = reader.string();
                    break;
                case /* string StandardOutput = 8 [json_name = "StandardOutput"];*/ 8:
                    message.standardOutput = reader.string();
                    break;
                case /* string StandardError = 9 [json_name = "StandardError"];*/ 9:
                    message.standardError = reader.string();
                    break;
                case /* string InvocationURL = 10 [json_name = "InvocationURL"];*/ 10:
                    message.invocationURL = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SSMRun, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string CommandID = 2 [json_name = "CommandID"]; */
        if (message.commandID !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.commandID);
        /* string InstanceID = 3 [json_name = "InstanceID"]; */
        if (message.instanceID !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.instanceID);
        /* int64 ExitCode = 4 [json_name = "ExitCode"]; */
        if (message.exitCode !== 0n)
            writer.tag(4, WireType.Varint).int64(message.exitCode);
        /* string Status = 5 [json_name = "Status"]; */
        if (message.status !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.status);
        /* string AccountID = 6 [json_name = "AccountID"]; */
        if (message.accountID !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.accountID);
        /* string Region = 7 [json_name = "Region"]; */
        if (message.region !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.region);
        /* string StandardOutput = 8 [json_name = "StandardOutput"]; */
        if (message.standardOutput !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.standardOutput);
        /* string StandardError = 9 [json_name = "StandardError"]; */
        if (message.standardError !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.standardError);
        /* string InvocationURL = 10 [json_name = "InvocationURL"]; */
        if (message.invocationURL !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.invocationURL);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.SSMRun
 */
export const SSMRun = new SSMRun$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CassandraPrepare$Type extends MessageType<CassandraPrepare> {
    constructor() {
        super("events.CassandraPrepare", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Database", kind: "message", jsonName: "Database", T: () => DatabaseMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Query", kind: "scalar", jsonName: "Query", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "query,omitempty" } },
            { no: 6, name: "Keyspace", kind: "scalar", jsonName: "Keyspace", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "keyspace,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<CassandraPrepare>): CassandraPrepare {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.query = "";
        message.keyspace = "";
        if (value !== undefined)
            reflectionMergePartial<CassandraPrepare>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CassandraPrepare): CassandraPrepare {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.DatabaseMetadata Database = 4 [json_name = "Database"];*/ 4:
                    message.database = DatabaseMetadata.internalBinaryRead(reader, reader.uint32(), options, message.database);
                    break;
                case /* string Query = 5 [json_name = "Query"];*/ 5:
                    message.query = reader.string();
                    break;
                case /* string Keyspace = 6 [json_name = "Keyspace"];*/ 6:
                    message.keyspace = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CassandraPrepare, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseMetadata Database = 4 [json_name = "Database"]; */
        if (message.database)
            DatabaseMetadata.internalBinaryWrite(message.database, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string Query = 5 [json_name = "Query"]; */
        if (message.query !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.query);
        /* string Keyspace = 6 [json_name = "Keyspace"]; */
        if (message.keyspace !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.keyspace);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.CassandraPrepare
 */
export const CassandraPrepare = new CassandraPrepare$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CassandraExecute$Type extends MessageType<CassandraExecute> {
    constructor() {
        super("events.CassandraExecute", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Database", kind: "message", jsonName: "Database", T: () => DatabaseMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "QueryId", kind: "scalar", jsonName: "QueryId", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "query_id,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<CassandraExecute>): CassandraExecute {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.queryId = "";
        if (value !== undefined)
            reflectionMergePartial<CassandraExecute>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CassandraExecute): CassandraExecute {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.DatabaseMetadata Database = 4 [json_name = "Database"];*/ 4:
                    message.database = DatabaseMetadata.internalBinaryRead(reader, reader.uint32(), options, message.database);
                    break;
                case /* string QueryId = 5 [json_name = "QueryId"];*/ 5:
                    message.queryId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CassandraExecute, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseMetadata Database = 4 [json_name = "Database"]; */
        if (message.database)
            DatabaseMetadata.internalBinaryWrite(message.database, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string QueryId = 5 [json_name = "QueryId"]; */
        if (message.queryId !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.queryId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.CassandraExecute
 */
export const CassandraExecute = new CassandraExecute$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CassandraBatch$Type extends MessageType<CassandraBatch> {
    constructor() {
        super("events.CassandraBatch", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Database", kind: "message", jsonName: "Database", T: () => DatabaseMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Consistency", kind: "scalar", jsonName: "Consistency", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "consistency,omitempty" } },
            { no: 6, name: "Keyspace", kind: "scalar", jsonName: "Keyspace", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "keyspace,omitempty" } },
            { no: 7, name: "BatchType", kind: "scalar", jsonName: "BatchType", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "batch_type,omitempty" } },
            { no: 8, name: "Children", kind: "message", jsonName: "Children", repeat: 1 /*RepeatType.PACKED*/, T: () => CassandraBatch_BatchChild, options: { "gogoproto.jsontag": "children,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<CassandraBatch>): CassandraBatch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.consistency = "";
        message.keyspace = "";
        message.batchType = "";
        message.children = [];
        if (value !== undefined)
            reflectionMergePartial<CassandraBatch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CassandraBatch): CassandraBatch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.DatabaseMetadata Database = 4 [json_name = "Database"];*/ 4:
                    message.database = DatabaseMetadata.internalBinaryRead(reader, reader.uint32(), options, message.database);
                    break;
                case /* string Consistency = 5 [json_name = "Consistency"];*/ 5:
                    message.consistency = reader.string();
                    break;
                case /* string Keyspace = 6 [json_name = "Keyspace"];*/ 6:
                    message.keyspace = reader.string();
                    break;
                case /* string BatchType = 7 [json_name = "BatchType"];*/ 7:
                    message.batchType = reader.string();
                    break;
                case /* repeated events.CassandraBatch.BatchChild Children = 8 [json_name = "Children"];*/ 8:
                    message.children.push(CassandraBatch_BatchChild.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CassandraBatch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseMetadata Database = 4 [json_name = "Database"]; */
        if (message.database)
            DatabaseMetadata.internalBinaryWrite(message.database, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string Consistency = 5 [json_name = "Consistency"]; */
        if (message.consistency !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.consistency);
        /* string Keyspace = 6 [json_name = "Keyspace"]; */
        if (message.keyspace !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.keyspace);
        /* string BatchType = 7 [json_name = "BatchType"]; */
        if (message.batchType !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.batchType);
        /* repeated events.CassandraBatch.BatchChild Children = 8 [json_name = "Children"]; */
        for (let i = 0; i < message.children.length; i++)
            CassandraBatch_BatchChild.internalBinaryWrite(message.children[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.CassandraBatch
 */
export const CassandraBatch = new CassandraBatch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CassandraBatch_BatchChild$Type extends MessageType<CassandraBatch_BatchChild> {
    constructor() {
        super("events.CassandraBatch.BatchChild", [
            { no: 1, name: "ID", kind: "scalar", jsonName: "ID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "id,omitempty" } },
            { no: 2, name: "Query", kind: "scalar", jsonName: "Query", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "query,omitempty" } },
            { no: 3, name: "Values", kind: "message", jsonName: "Values", repeat: 1 /*RepeatType.PACKED*/, T: () => CassandraBatch_BatchChild_Value, options: { "gogoproto.jsontag": "values,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<CassandraBatch_BatchChild>): CassandraBatch_BatchChild {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.iD = "";
        message.query = "";
        message.values = [];
        if (value !== undefined)
            reflectionMergePartial<CassandraBatch_BatchChild>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CassandraBatch_BatchChild): CassandraBatch_BatchChild {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ID = 1 [json_name = "ID"];*/ 1:
                    message.iD = reader.string();
                    break;
                case /* string Query = 2 [json_name = "Query"];*/ 2:
                    message.query = reader.string();
                    break;
                case /* repeated events.CassandraBatch.BatchChild.Value Values = 3 [json_name = "Values"];*/ 3:
                    message.values.push(CassandraBatch_BatchChild_Value.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CassandraBatch_BatchChild, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ID = 1 [json_name = "ID"]; */
        if (message.iD !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.iD);
        /* string Query = 2 [json_name = "Query"]; */
        if (message.query !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.query);
        /* repeated events.CassandraBatch.BatchChild.Value Values = 3 [json_name = "Values"]; */
        for (let i = 0; i < message.values.length; i++)
            CassandraBatch_BatchChild_Value.internalBinaryWrite(message.values[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.CassandraBatch.BatchChild
 */
export const CassandraBatch_BatchChild = new CassandraBatch_BatchChild$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CassandraBatch_BatchChild_Value$Type extends MessageType<CassandraBatch_BatchChild_Value> {
    constructor() {
        super("events.CassandraBatch.BatchChild.Value", [
            { no: 1, name: "Type", kind: "scalar", jsonName: "Type", T: 13 /*ScalarType.UINT32*/, options: { "gogoproto.jsontag": "type,omitempty" } },
            { no: 2, name: "Contents", kind: "scalar", jsonName: "Contents", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.jsontag": "contents,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<CassandraBatch_BatchChild_Value>): CassandraBatch_BatchChild_Value {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.contents = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<CassandraBatch_BatchChild_Value>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CassandraBatch_BatchChild_Value): CassandraBatch_BatchChild_Value {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 Type = 1 [json_name = "Type"];*/ 1:
                    message.type = reader.uint32();
                    break;
                case /* bytes Contents = 2 [json_name = "Contents"];*/ 2:
                    message.contents = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CassandraBatch_BatchChild_Value, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 Type = 1 [json_name = "Type"]; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).uint32(message.type);
        /* bytes Contents = 2 [json_name = "Contents"]; */
        if (message.contents.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.contents);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.CassandraBatch.BatchChild.Value
 */
export const CassandraBatch_BatchChild_Value = new CassandraBatch_BatchChild_Value$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CassandraRegister$Type extends MessageType<CassandraRegister> {
    constructor() {
        super("events.CassandraRegister", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Database", kind: "message", jsonName: "Database", T: () => DatabaseMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "EventTypes", kind: "scalar", jsonName: "EventTypes", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "event_types,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<CassandraRegister>): CassandraRegister {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.eventTypes = [];
        if (value !== undefined)
            reflectionMergePartial<CassandraRegister>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CassandraRegister): CassandraRegister {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.DatabaseMetadata Database = 4 [json_name = "Database"];*/ 4:
                    message.database = DatabaseMetadata.internalBinaryRead(reader, reader.uint32(), options, message.database);
                    break;
                case /* repeated string EventTypes = 5 [json_name = "EventTypes"];*/ 5:
                    message.eventTypes.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CassandraRegister, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseMetadata Database = 4 [json_name = "Database"]; */
        if (message.database)
            DatabaseMetadata.internalBinaryWrite(message.database, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated string EventTypes = 5 [json_name = "EventTypes"]; */
        for (let i = 0; i < message.eventTypes.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.eventTypes[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.CassandraRegister
 */
export const CassandraRegister = new CassandraRegister$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoginRuleCreate$Type extends MessageType<LoginRuleCreate> {
    constructor() {
        super("events.LoginRuleCreate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<LoginRuleCreate>): LoginRuleCreate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<LoginRuleCreate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoginRuleCreate): LoginRuleCreate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoginRuleCreate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.LoginRuleCreate
 */
export const LoginRuleCreate = new LoginRuleCreate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoginRuleDelete$Type extends MessageType<LoginRuleDelete> {
    constructor() {
        super("events.LoginRuleDelete", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<LoginRuleDelete>): LoginRuleDelete {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<LoginRuleDelete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoginRuleDelete): LoginRuleDelete {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoginRuleDelete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.LoginRuleDelete
 */
export const LoginRuleDelete = new LoginRuleDelete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SAMLIdPAuthAttempt$Type extends MessageType<SAMLIdPAuthAttempt> {
    constructor() {
        super("events.SAMLIdPAuthAttempt", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "ServiceProvider", kind: "message", jsonName: "ServiceProvider", T: () => SAMLIdPServiceProviderMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<SAMLIdPAuthAttempt>): SAMLIdPAuthAttempt {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SAMLIdPAuthAttempt>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SAMLIdPAuthAttempt): SAMLIdPAuthAttempt {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.Status Status = 4 [json_name = "Status"];*/ 4:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* events.SAMLIdPServiceProviderMetadata ServiceProvider = 5 [json_name = "ServiceProvider"];*/ 5:
                    message.serviceProvider = SAMLIdPServiceProviderMetadata.internalBinaryRead(reader, reader.uint32(), options, message.serviceProvider);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SAMLIdPAuthAttempt, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 4 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.SAMLIdPServiceProviderMetadata ServiceProvider = 5 [json_name = "ServiceProvider"]; */
        if (message.serviceProvider)
            SAMLIdPServiceProviderMetadata.internalBinaryWrite(message.serviceProvider, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.SAMLIdPAuthAttempt
 */
export const SAMLIdPAuthAttempt = new SAMLIdPAuthAttempt$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SAMLIdPServiceProviderCreate$Type extends MessageType<SAMLIdPServiceProviderCreate> {
    constructor() {
        super("events.SAMLIdPServiceProviderCreate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "ServiceProvider", kind: "message", jsonName: "ServiceProvider", T: () => SAMLIdPServiceProviderMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<SAMLIdPServiceProviderCreate>): SAMLIdPServiceProviderCreate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SAMLIdPServiceProviderCreate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SAMLIdPServiceProviderCreate): SAMLIdPServiceProviderCreate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.SAMLIdPServiceProviderMetadata ServiceProvider = 3 [json_name = "ServiceProvider"];*/ 3:
                    message.serviceProvider = SAMLIdPServiceProviderMetadata.internalBinaryRead(reader, reader.uint32(), options, message.serviceProvider);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SAMLIdPServiceProviderCreate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SAMLIdPServiceProviderMetadata ServiceProvider = 3 [json_name = "ServiceProvider"]; */
        if (message.serviceProvider)
            SAMLIdPServiceProviderMetadata.internalBinaryWrite(message.serviceProvider, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.SAMLIdPServiceProviderCreate
 */
export const SAMLIdPServiceProviderCreate = new SAMLIdPServiceProviderCreate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SAMLIdPServiceProviderUpdate$Type extends MessageType<SAMLIdPServiceProviderUpdate> {
    constructor() {
        super("events.SAMLIdPServiceProviderUpdate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "ServiceProvider", kind: "message", jsonName: "ServiceProvider", T: () => SAMLIdPServiceProviderMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<SAMLIdPServiceProviderUpdate>): SAMLIdPServiceProviderUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SAMLIdPServiceProviderUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SAMLIdPServiceProviderUpdate): SAMLIdPServiceProviderUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.SAMLIdPServiceProviderMetadata ServiceProvider = 3 [json_name = "ServiceProvider"];*/ 3:
                    message.serviceProvider = SAMLIdPServiceProviderMetadata.internalBinaryRead(reader, reader.uint32(), options, message.serviceProvider);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SAMLIdPServiceProviderUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SAMLIdPServiceProviderMetadata ServiceProvider = 3 [json_name = "ServiceProvider"]; */
        if (message.serviceProvider)
            SAMLIdPServiceProviderMetadata.internalBinaryWrite(message.serviceProvider, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.SAMLIdPServiceProviderUpdate
 */
export const SAMLIdPServiceProviderUpdate = new SAMLIdPServiceProviderUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SAMLIdPServiceProviderDelete$Type extends MessageType<SAMLIdPServiceProviderDelete> {
    constructor() {
        super("events.SAMLIdPServiceProviderDelete", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "ServiceProvider", kind: "message", jsonName: "ServiceProvider", T: () => SAMLIdPServiceProviderMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<SAMLIdPServiceProviderDelete>): SAMLIdPServiceProviderDelete {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SAMLIdPServiceProviderDelete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SAMLIdPServiceProviderDelete): SAMLIdPServiceProviderDelete {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.SAMLIdPServiceProviderMetadata ServiceProvider = 3 [json_name = "ServiceProvider"];*/ 3:
                    message.serviceProvider = SAMLIdPServiceProviderMetadata.internalBinaryRead(reader, reader.uint32(), options, message.serviceProvider);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SAMLIdPServiceProviderDelete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SAMLIdPServiceProviderMetadata ServiceProvider = 3 [json_name = "ServiceProvider"]; */
        if (message.serviceProvider)
            SAMLIdPServiceProviderMetadata.internalBinaryWrite(message.serviceProvider, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.SAMLIdPServiceProviderDelete
 */
export const SAMLIdPServiceProviderDelete = new SAMLIdPServiceProviderDelete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SAMLIdPServiceProviderDeleteAll$Type extends MessageType<SAMLIdPServiceProviderDeleteAll> {
    constructor() {
        super("events.SAMLIdPServiceProviderDeleteAll", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<SAMLIdPServiceProviderDeleteAll>): SAMLIdPServiceProviderDeleteAll {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SAMLIdPServiceProviderDeleteAll>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SAMLIdPServiceProviderDeleteAll): SAMLIdPServiceProviderDeleteAll {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SAMLIdPServiceProviderDeleteAll, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.SAMLIdPServiceProviderDeleteAll
 */
export const SAMLIdPServiceProviderDeleteAll = new SAMLIdPServiceProviderDeleteAll$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OktaResourcesUpdate$Type extends MessageType<OktaResourcesUpdate> {
    constructor() {
        super("events.OktaResourcesUpdate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Server", kind: "message", jsonName: "Server", T: () => ServerMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Updated", kind: "message", jsonName: "Updated", T: () => OktaResourcesUpdatedMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<OktaResourcesUpdate>): OktaResourcesUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<OktaResourcesUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OktaResourcesUpdate): OktaResourcesUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ServerMetadata Server = 2 [json_name = "Server"];*/ 2:
                    message.server = ServerMetadata.internalBinaryRead(reader, reader.uint32(), options, message.server);
                    break;
                case /* events.OktaResourcesUpdatedMetadata Updated = 3 [json_name = "Updated"];*/ 3:
                    message.updated = OktaResourcesUpdatedMetadata.internalBinaryRead(reader, reader.uint32(), options, message.updated);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OktaResourcesUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ServerMetadata Server = 2 [json_name = "Server"]; */
        if (message.server)
            ServerMetadata.internalBinaryWrite(message.server, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.OktaResourcesUpdatedMetadata Updated = 3 [json_name = "Updated"]; */
        if (message.updated)
            OktaResourcesUpdatedMetadata.internalBinaryWrite(message.updated, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.OktaResourcesUpdate
 */
export const OktaResourcesUpdate = new OktaResourcesUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OktaSyncFailure$Type extends MessageType<OktaSyncFailure> {
    constructor() {
        super("events.OktaSyncFailure", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Server", kind: "message", jsonName: "Server", T: () => ServerMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<OktaSyncFailure>): OktaSyncFailure {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<OktaSyncFailure>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OktaSyncFailure): OktaSyncFailure {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ServerMetadata Server = 2 [json_name = "Server"];*/ 2:
                    message.server = ServerMetadata.internalBinaryRead(reader, reader.uint32(), options, message.server);
                    break;
                case /* events.Status Status = 3 [json_name = "Status"];*/ 3:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OktaSyncFailure, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ServerMetadata Server = 2 [json_name = "Server"]; */
        if (message.server)
            ServerMetadata.internalBinaryWrite(message.server, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 3 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.OktaSyncFailure
 */
export const OktaSyncFailure = new OktaSyncFailure$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OktaAssignmentResult$Type extends MessageType<OktaAssignmentResult> {
    constructor() {
        super("events.OktaAssignmentResult", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Server", kind: "message", jsonName: "Server", T: () => ServerMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "OktaAssignment", kind: "message", jsonName: "OktaAssignment", T: () => OktaAssignmentMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<OktaAssignmentResult>): OktaAssignmentResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<OktaAssignmentResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OktaAssignmentResult): OktaAssignmentResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ServerMetadata Server = 2 [json_name = "Server"];*/ 2:
                    message.server = ServerMetadata.internalBinaryRead(reader, reader.uint32(), options, message.server);
                    break;
                case /* events.ResourceMetadata Resource = 3 [json_name = "Resource"];*/ 3:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.Status Status = 4 [json_name = "Status"];*/ 4:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* events.OktaAssignmentMetadata OktaAssignment = 5 [json_name = "OktaAssignment"];*/ 5:
                    message.oktaAssignment = OktaAssignmentMetadata.internalBinaryRead(reader, reader.uint32(), options, message.oktaAssignment);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OktaAssignmentResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ServerMetadata Server = 2 [json_name = "Server"]; */
        if (message.server)
            ServerMetadata.internalBinaryWrite(message.server, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 3 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 4 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.OktaAssignmentMetadata OktaAssignment = 5 [json_name = "OktaAssignment"]; */
        if (message.oktaAssignment)
            OktaAssignmentMetadata.internalBinaryWrite(message.oktaAssignment, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.OktaAssignmentResult
 */
export const OktaAssignmentResult = new OktaAssignmentResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessListCreate$Type extends MessageType<AccessListCreate> {
    constructor() {
        super("events.AccessListCreate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "AccessListTitle", kind: "scalar", jsonName: "AccessListTitle", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "access_list_title,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<AccessListCreate>): AccessListCreate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accessListTitle = "";
        if (value !== undefined)
            reflectionMergePartial<AccessListCreate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessListCreate): AccessListCreate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.Status Status = 3 [json_name = "Status"];*/ 3:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* string AccessListTitle = 4 [json_name = "AccessListTitle"];*/ 4:
                    message.accessListTitle = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessListCreate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 3 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string AccessListTitle = 4 [json_name = "AccessListTitle"]; */
        if (message.accessListTitle !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.accessListTitle);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.AccessListCreate
 */
export const AccessListCreate = new AccessListCreate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessListUpdate$Type extends MessageType<AccessListUpdate> {
    constructor() {
        super("events.AccessListUpdate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "AccessListTitle", kind: "scalar", jsonName: "AccessListTitle", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "access_list_title,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<AccessListUpdate>): AccessListUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accessListTitle = "";
        if (value !== undefined)
            reflectionMergePartial<AccessListUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessListUpdate): AccessListUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.Status Status = 3 [json_name = "Status"];*/ 3:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* string AccessListTitle = 4 [json_name = "AccessListTitle"];*/ 4:
                    message.accessListTitle = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessListUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 3 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string AccessListTitle = 4 [json_name = "AccessListTitle"]; */
        if (message.accessListTitle !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.accessListTitle);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.AccessListUpdate
 */
export const AccessListUpdate = new AccessListUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessListDelete$Type extends MessageType<AccessListDelete> {
    constructor() {
        super("events.AccessListDelete", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "AccessListTitle", kind: "scalar", jsonName: "AccessListTitle", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "access_list_title,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<AccessListDelete>): AccessListDelete {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accessListTitle = "";
        if (value !== undefined)
            reflectionMergePartial<AccessListDelete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessListDelete): AccessListDelete {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.Status Status = 3 [json_name = "Status"];*/ 3:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* string AccessListTitle = 4 [json_name = "AccessListTitle"];*/ 4:
                    message.accessListTitle = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessListDelete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 3 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string AccessListTitle = 4 [json_name = "AccessListTitle"]; */
        if (message.accessListTitle !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.accessListTitle);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.AccessListDelete
 */
export const AccessListDelete = new AccessListDelete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessListMemberCreate$Type extends MessageType<AccessListMemberCreate> {
    constructor() {
        super("events.AccessListMemberCreate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "AccessListMember", kind: "message", jsonName: "AccessListMember", T: () => AccessListMemberMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<AccessListMemberCreate>): AccessListMemberCreate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AccessListMemberCreate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessListMemberCreate): AccessListMemberCreate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.AccessListMemberMetadata AccessListMember = 3 [json_name = "AccessListMember"];*/ 3:
                    message.accessListMember = AccessListMemberMetadata.internalBinaryRead(reader, reader.uint32(), options, message.accessListMember);
                    break;
                case /* events.Status Status = 4 [json_name = "Status"];*/ 4:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessListMemberCreate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.AccessListMemberMetadata AccessListMember = 3 [json_name = "AccessListMember"]; */
        if (message.accessListMember)
            AccessListMemberMetadata.internalBinaryWrite(message.accessListMember, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 4 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.AccessListMemberCreate
 */
export const AccessListMemberCreate = new AccessListMemberCreate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessListMemberUpdate$Type extends MessageType<AccessListMemberUpdate> {
    constructor() {
        super("events.AccessListMemberUpdate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "AccessListMember", kind: "message", jsonName: "AccessListMember", T: () => AccessListMemberMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<AccessListMemberUpdate>): AccessListMemberUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AccessListMemberUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessListMemberUpdate): AccessListMemberUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.AccessListMemberMetadata AccessListMember = 3 [json_name = "AccessListMember"];*/ 3:
                    message.accessListMember = AccessListMemberMetadata.internalBinaryRead(reader, reader.uint32(), options, message.accessListMember);
                    break;
                case /* events.Status Status = 4 [json_name = "Status"];*/ 4:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessListMemberUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.AccessListMemberMetadata AccessListMember = 3 [json_name = "AccessListMember"]; */
        if (message.accessListMember)
            AccessListMemberMetadata.internalBinaryWrite(message.accessListMember, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 4 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.AccessListMemberUpdate
 */
export const AccessListMemberUpdate = new AccessListMemberUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessListMemberDelete$Type extends MessageType<AccessListMemberDelete> {
    constructor() {
        super("events.AccessListMemberDelete", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "AccessListMember", kind: "message", jsonName: "AccessListMember", T: () => AccessListMemberMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<AccessListMemberDelete>): AccessListMemberDelete {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AccessListMemberDelete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessListMemberDelete): AccessListMemberDelete {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.AccessListMemberMetadata AccessListMember = 3 [json_name = "AccessListMember"];*/ 3:
                    message.accessListMember = AccessListMemberMetadata.internalBinaryRead(reader, reader.uint32(), options, message.accessListMember);
                    break;
                case /* events.Status Status = 4 [json_name = "Status"];*/ 4:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessListMemberDelete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.AccessListMemberMetadata AccessListMember = 3 [json_name = "AccessListMember"]; */
        if (message.accessListMember)
            AccessListMemberMetadata.internalBinaryWrite(message.accessListMember, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 4 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.AccessListMemberDelete
 */
export const AccessListMemberDelete = new AccessListMemberDelete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessListMemberDeleteAllForAccessList$Type extends MessageType<AccessListMemberDeleteAllForAccessList> {
    constructor() {
        super("events.AccessListMemberDeleteAllForAccessList", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "AccessListMember", kind: "message", jsonName: "AccessListMember", T: () => AccessListMemberMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<AccessListMemberDeleteAllForAccessList>): AccessListMemberDeleteAllForAccessList {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AccessListMemberDeleteAllForAccessList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessListMemberDeleteAllForAccessList): AccessListMemberDeleteAllForAccessList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.AccessListMemberMetadata AccessListMember = 3 [json_name = "AccessListMember"];*/ 3:
                    message.accessListMember = AccessListMemberMetadata.internalBinaryRead(reader, reader.uint32(), options, message.accessListMember);
                    break;
                case /* events.Status Status = 4 [json_name = "Status"];*/ 4:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessListMemberDeleteAllForAccessList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.AccessListMemberMetadata AccessListMember = 3 [json_name = "AccessListMember"]; */
        if (message.accessListMember)
            AccessListMemberMetadata.internalBinaryWrite(message.accessListMember, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 4 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.AccessListMemberDeleteAllForAccessList
 */
export const AccessListMemberDeleteAllForAccessList = new AccessListMemberDeleteAllForAccessList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessListReview$Type extends MessageType<AccessListReview> {
    constructor() {
        super("events.AccessListReview", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Review", kind: "message", jsonName: "Review", T: () => AccessListReviewMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "status", kind: "message", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<AccessListReview>): AccessListReview {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AccessListReview>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessListReview): AccessListReview {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.AccessListReviewMetadata Review = 3 [json_name = "Review"];*/ 3:
                    message.review = AccessListReviewMetadata.internalBinaryRead(reader, reader.uint32(), options, message.review);
                    break;
                case /* events.Status status */ 4:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessListReview, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.AccessListReviewMetadata Review = 3 [json_name = "Review"]; */
        if (message.review)
            AccessListReviewMetadata.internalBinaryWrite(message.review, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.Status status = 4; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.AccessListReview
 */
export const AccessListReview = new AccessListReview$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuditQueryRun$Type extends MessageType<AuditQueryRun> {
    constructor() {
        super("events.AuditQueryRun", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Query", kind: "message", jsonName: "Query", T: () => AuditQueryDetails, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<AuditQueryRun>): AuditQueryRun {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AuditQueryRun>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuditQueryRun): AuditQueryRun {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.Status Status = 3 [json_name = "Status"];*/ 3:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* events.AuditQueryDetails Query = 4 [json_name = "Query"];*/ 4:
                    message.query = AuditQueryDetails.internalBinaryRead(reader, reader.uint32(), options, message.query);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuditQueryRun, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 3 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.AuditQueryDetails Query = 4 [json_name = "Query"]; */
        if (message.query)
            AuditQueryDetails.internalBinaryWrite(message.query, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.AuditQueryRun
 */
export const AuditQueryRun = new AuditQueryRun$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuditQueryDetails$Type extends MessageType<AuditQueryDetails> {
    constructor() {
        super("events.AuditQueryDetails", [
            { no: 1, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "name,omitempty" } },
            { no: 2, name: "Query", kind: "scalar", jsonName: "Query", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "query,omitempty" } },
            { no: 3, name: "Days", kind: "scalar", jsonName: "Days", T: 5 /*ScalarType.INT32*/, options: { "gogoproto.jsontag": "days,omitempty" } },
            { no: 4, name: "ExecutionTimeInMillis", kind: "scalar", jsonName: "ExecutionTimeInMillis", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "total_execution_time_in_millis,omitempty" } },
            { no: 5, name: "DataScannedInBytes", kind: "scalar", jsonName: "DataScannedInBytes", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "data_scanned_in_bytes" } }
        ]);
    }
    create(value?: PartialMessage<AuditQueryDetails>): AuditQueryDetails {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.query = "";
        message.days = 0;
        message.executionTimeInMillis = 0n;
        message.dataScannedInBytes = 0n;
        if (value !== undefined)
            reflectionMergePartial<AuditQueryDetails>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuditQueryDetails): AuditQueryDetails {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Name = 1 [json_name = "Name"];*/ 1:
                    message.name = reader.string();
                    break;
                case /* string Query = 2 [json_name = "Query"];*/ 2:
                    message.query = reader.string();
                    break;
                case /* int32 Days = 3 [json_name = "Days"];*/ 3:
                    message.days = reader.int32();
                    break;
                case /* int64 ExecutionTimeInMillis = 4 [json_name = "ExecutionTimeInMillis"];*/ 4:
                    message.executionTimeInMillis = reader.int64().toBigInt();
                    break;
                case /* int64 DataScannedInBytes = 5 [json_name = "DataScannedInBytes"];*/ 5:
                    message.dataScannedInBytes = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuditQueryDetails, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Name = 1 [json_name = "Name"]; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string Query = 2 [json_name = "Query"]; */
        if (message.query !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.query);
        /* int32 Days = 3 [json_name = "Days"]; */
        if (message.days !== 0)
            writer.tag(3, WireType.Varint).int32(message.days);
        /* int64 ExecutionTimeInMillis = 4 [json_name = "ExecutionTimeInMillis"]; */
        if (message.executionTimeInMillis !== 0n)
            writer.tag(4, WireType.Varint).int64(message.executionTimeInMillis);
        /* int64 DataScannedInBytes = 5 [json_name = "DataScannedInBytes"]; */
        if (message.dataScannedInBytes !== 0n)
            writer.tag(5, WireType.Varint).int64(message.dataScannedInBytes);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.AuditQueryDetails
 */
export const AuditQueryDetails = new AuditQueryDetails$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SecurityReportRun$Type extends MessageType<SecurityReportRun> {
    constructor() {
        super("events.SecurityReportRun", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "name,omitempty" } },
            { no: 5, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version,omitempty" } },
            { no: 6, name: "TotalExecutionTimeInMillis", kind: "scalar", jsonName: "TotalExecutionTimeInMillis", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "total_execution_time_in_millis,omitempty" } },
            { no: 7, name: "TotalDataScannedInBytes", kind: "scalar", jsonName: "TotalDataScannedInBytes", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "total_data_scanned_in_bytes" } },
            { no: 8, name: "AuditQueries", kind: "message", jsonName: "AuditQueries", repeat: 1 /*RepeatType.PACKED*/, T: () => AuditQueryDetails, options: { "gogoproto.jsontag": "audit_queries,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<SecurityReportRun>): SecurityReportRun {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.version = "";
        message.totalExecutionTimeInMillis = 0n;
        message.totalDataScannedInBytes = 0n;
        message.auditQueries = [];
        if (value !== undefined)
            reflectionMergePartial<SecurityReportRun>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SecurityReportRun): SecurityReportRun {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.Status Status = 3 [json_name = "Status"];*/ 3:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* string Name = 4 [json_name = "Name"];*/ 4:
                    message.name = reader.string();
                    break;
                case /* string Version = 5 [json_name = "Version"];*/ 5:
                    message.version = reader.string();
                    break;
                case /* int64 TotalExecutionTimeInMillis = 6 [json_name = "TotalExecutionTimeInMillis"];*/ 6:
                    message.totalExecutionTimeInMillis = reader.int64().toBigInt();
                    break;
                case /* int64 TotalDataScannedInBytes = 7 [json_name = "TotalDataScannedInBytes"];*/ 7:
                    message.totalDataScannedInBytes = reader.int64().toBigInt();
                    break;
                case /* repeated events.AuditQueryDetails AuditQueries = 8 [json_name = "AuditQueries"];*/ 8:
                    message.auditQueries.push(AuditQueryDetails.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SecurityReportRun, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 3 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string Name = 4 [json_name = "Name"]; */
        if (message.name !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.name);
        /* string Version = 5 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.version);
        /* int64 TotalExecutionTimeInMillis = 6 [json_name = "TotalExecutionTimeInMillis"]; */
        if (message.totalExecutionTimeInMillis !== 0n)
            writer.tag(6, WireType.Varint).int64(message.totalExecutionTimeInMillis);
        /* int64 TotalDataScannedInBytes = 7 [json_name = "TotalDataScannedInBytes"]; */
        if (message.totalDataScannedInBytes !== 0n)
            writer.tag(7, WireType.Varint).int64(message.totalDataScannedInBytes);
        /* repeated events.AuditQueryDetails AuditQueries = 8 [json_name = "AuditQueries"]; */
        for (let i = 0; i < message.auditQueries.length; i++)
            AuditQueryDetails.internalBinaryWrite(message.auditQueries[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.SecurityReportRun
 */
export const SecurityReportRun = new SecurityReportRun$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExternalAuditStorageEnable$Type extends MessageType<ExternalAuditStorageEnable> {
    constructor() {
        super("events.ExternalAuditStorageEnable", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "details", kind: "message", T: () => ExternalAuditStorageDetails }
        ]);
    }
    create(value?: PartialMessage<ExternalAuditStorageEnable>): ExternalAuditStorageEnable {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ExternalAuditStorageEnable>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExternalAuditStorageEnable): ExternalAuditStorageEnable {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.ExternalAuditStorageDetails details */ 3:
                    message.details = ExternalAuditStorageDetails.internalBinaryRead(reader, reader.uint32(), options, message.details);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExternalAuditStorageEnable, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ExternalAuditStorageDetails details = 3; */
        if (message.details)
            ExternalAuditStorageDetails.internalBinaryWrite(message.details, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.ExternalAuditStorageEnable
 */
export const ExternalAuditStorageEnable = new ExternalAuditStorageEnable$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExternalAuditStorageDisable$Type extends MessageType<ExternalAuditStorageDisable> {
    constructor() {
        super("events.ExternalAuditStorageDisable", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "details", kind: "message", T: () => ExternalAuditStorageDetails }
        ]);
    }
    create(value?: PartialMessage<ExternalAuditStorageDisable>): ExternalAuditStorageDisable {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ExternalAuditStorageDisable>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExternalAuditStorageDisable): ExternalAuditStorageDisable {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.ExternalAuditStorageDetails details */ 3:
                    message.details = ExternalAuditStorageDetails.internalBinaryRead(reader, reader.uint32(), options, message.details);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExternalAuditStorageDisable, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ExternalAuditStorageDetails details = 3; */
        if (message.details)
            ExternalAuditStorageDetails.internalBinaryWrite(message.details, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.ExternalAuditStorageDisable
 */
export const ExternalAuditStorageDisable = new ExternalAuditStorageDisable$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExternalAuditStorageDetails$Type extends MessageType<ExternalAuditStorageDetails> {
    constructor() {
        super("events.ExternalAuditStorageDetails", [
            { no: 3, name: "integration_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "session_recordings_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "athena_workgroup", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "glue_database", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "glue_table", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "audit_events_long_term_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "athena_results_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "policy_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "region", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ExternalAuditStorageDetails>): ExternalAuditStorageDetails {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.integrationName = "";
        message.sessionRecordingsUri = "";
        message.athenaWorkgroup = "";
        message.glueDatabase = "";
        message.glueTable = "";
        message.auditEventsLongTermUri = "";
        message.athenaResultsUri = "";
        message.policyName = "";
        message.region = "";
        if (value !== undefined)
            reflectionMergePartial<ExternalAuditStorageDetails>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExternalAuditStorageDetails): ExternalAuditStorageDetails {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string integration_name */ 3:
                    message.integrationName = reader.string();
                    break;
                case /* string session_recordings_uri */ 4:
                    message.sessionRecordingsUri = reader.string();
                    break;
                case /* string athena_workgroup */ 5:
                    message.athenaWorkgroup = reader.string();
                    break;
                case /* string glue_database */ 6:
                    message.glueDatabase = reader.string();
                    break;
                case /* string glue_table */ 7:
                    message.glueTable = reader.string();
                    break;
                case /* string audit_events_long_term_uri */ 8:
                    message.auditEventsLongTermUri = reader.string();
                    break;
                case /* string athena_results_uri */ 9:
                    message.athenaResultsUri = reader.string();
                    break;
                case /* string policy_name */ 10:
                    message.policyName = reader.string();
                    break;
                case /* string region */ 11:
                    message.region = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExternalAuditStorageDetails, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string integration_name = 3; */
        if (message.integrationName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.integrationName);
        /* string session_recordings_uri = 4; */
        if (message.sessionRecordingsUri !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.sessionRecordingsUri);
        /* string athena_workgroup = 5; */
        if (message.athenaWorkgroup !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.athenaWorkgroup);
        /* string glue_database = 6; */
        if (message.glueDatabase !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.glueDatabase);
        /* string glue_table = 7; */
        if (message.glueTable !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.glueTable);
        /* string audit_events_long_term_uri = 8; */
        if (message.auditEventsLongTermUri !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.auditEventsLongTermUri);
        /* string athena_results_uri = 9; */
        if (message.athenaResultsUri !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.athenaResultsUri);
        /* string policy_name = 10; */
        if (message.policyName !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.policyName);
        /* string region = 11; */
        if (message.region !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.region);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.ExternalAuditStorageDetails
 */
export const ExternalAuditStorageDetails = new ExternalAuditStorageDetails$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OktaAccessListSync$Type extends MessageType<OktaAccessListSync> {
    constructor() {
        super("events.OktaAccessListSync", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "num_app_filters", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "num_group_filters", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "num_apps", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "num_groups", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "numRoles", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "numAccessLists", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "numAccessListMembers", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<OktaAccessListSync>): OktaAccessListSync {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.numAppFilters = 0;
        message.numGroupFilters = 0;
        message.numApps = 0;
        message.numGroups = 0;
        message.numRoles = 0;
        message.numAccessLists = 0;
        message.numAccessListMembers = 0;
        if (value !== undefined)
            reflectionMergePartial<OktaAccessListSync>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OktaAccessListSync): OktaAccessListSync {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.Status Status = 2 [json_name = "Status"];*/ 2:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* int32 num_app_filters */ 3:
                    message.numAppFilters = reader.int32();
                    break;
                case /* int32 num_group_filters */ 4:
                    message.numGroupFilters = reader.int32();
                    break;
                case /* int32 num_apps */ 5:
                    message.numApps = reader.int32();
                    break;
                case /* int32 num_groups */ 6:
                    message.numGroups = reader.int32();
                    break;
                case /* int32 numRoles */ 7:
                    message.numRoles = reader.int32();
                    break;
                case /* int32 numAccessLists */ 8:
                    message.numAccessLists = reader.int32();
                    break;
                case /* int32 numAccessListMembers */ 9:
                    message.numAccessListMembers = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OktaAccessListSync, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 2 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int32 num_app_filters = 3; */
        if (message.numAppFilters !== 0)
            writer.tag(3, WireType.Varint).int32(message.numAppFilters);
        /* int32 num_group_filters = 4; */
        if (message.numGroupFilters !== 0)
            writer.tag(4, WireType.Varint).int32(message.numGroupFilters);
        /* int32 num_apps = 5; */
        if (message.numApps !== 0)
            writer.tag(5, WireType.Varint).int32(message.numApps);
        /* int32 num_groups = 6; */
        if (message.numGroups !== 0)
            writer.tag(6, WireType.Varint).int32(message.numGroups);
        /* int32 numRoles = 7; */
        if (message.numRoles !== 0)
            writer.tag(7, WireType.Varint).int32(message.numRoles);
        /* int32 numAccessLists = 8; */
        if (message.numAccessLists !== 0)
            writer.tag(8, WireType.Varint).int32(message.numAccessLists);
        /* int32 numAccessListMembers = 9; */
        if (message.numAccessListMembers !== 0)
            writer.tag(9, WireType.Varint).int32(message.numAccessListMembers);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.OktaAccessListSync
 */
export const OktaAccessListSync = new OktaAccessListSync$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OktaUserSync$Type extends MessageType<OktaUserSync> {
    constructor() {
        super("events.OktaUserSync", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "org_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "app_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "num_users_created", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "gogoproto.jsontag": "num_users_created" } },
            { no: 6, name: "num_users_deleted", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "gogoproto.jsontag": "num_users_deleted" } },
            { no: 7, name: "num_users_modified", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "gogoproto.jsontag": "num_users_modified" } },
            { no: 8, name: "num_users_total", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "gogoproto.jsontag": "num_users_total" } }
        ]);
    }
    create(value?: PartialMessage<OktaUserSync>): OktaUserSync {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orgUrl = "";
        message.appId = "";
        message.numUsersCreated = 0;
        message.numUsersDeleted = 0;
        message.numUsersModified = 0;
        message.numUsersTotal = 0;
        if (value !== undefined)
            reflectionMergePartial<OktaUserSync>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OktaUserSync): OktaUserSync {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.Status Status = 2 [json_name = "Status"];*/ 2:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* string org_url */ 3:
                    message.orgUrl = reader.string();
                    break;
                case /* string app_id */ 4:
                    message.appId = reader.string();
                    break;
                case /* int32 num_users_created */ 5:
                    message.numUsersCreated = reader.int32();
                    break;
                case /* int32 num_users_deleted */ 6:
                    message.numUsersDeleted = reader.int32();
                    break;
                case /* int32 num_users_modified */ 7:
                    message.numUsersModified = reader.int32();
                    break;
                case /* int32 num_users_total */ 8:
                    message.numUsersTotal = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OktaUserSync, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 2 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string org_url = 3; */
        if (message.orgUrl !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.orgUrl);
        /* string app_id = 4; */
        if (message.appId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.appId);
        /* int32 num_users_created = 5; */
        if (message.numUsersCreated !== 0)
            writer.tag(5, WireType.Varint).int32(message.numUsersCreated);
        /* int32 num_users_deleted = 6; */
        if (message.numUsersDeleted !== 0)
            writer.tag(6, WireType.Varint).int32(message.numUsersDeleted);
        /* int32 num_users_modified = 7; */
        if (message.numUsersModified !== 0)
            writer.tag(7, WireType.Varint).int32(message.numUsersModified);
        /* int32 num_users_total = 8; */
        if (message.numUsersTotal !== 0)
            writer.tag(8, WireType.Varint).int32(message.numUsersTotal);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.OktaUserSync
 */
export const OktaUserSync = new OktaUserSync$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SPIFFESVIDIssued$Type extends MessageType<SPIFFESVIDIssued> {
    constructor() {
        super("events.SPIFFESVIDIssued", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "SPIFFEID", kind: "scalar", jsonName: "SPIFFEID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "spiffe_id" } },
            { no: 5, name: "DNSSANs", kind: "scalar", jsonName: "DNSSANs", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "dns_sans" } },
            { no: 6, name: "IPSANs", kind: "scalar", jsonName: "IPSANs", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "ip_sans" } },
            { no: 7, name: "SVIDType", kind: "scalar", jsonName: "SVIDType", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "svid_type" } },
            { no: 8, name: "SerialNumber", kind: "scalar", jsonName: "SerialNumber", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "serial_number" } },
            { no: 9, name: "Hint", kind: "scalar", jsonName: "Hint", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "hint" } },
            { no: 10, name: "JTI", kind: "scalar", jsonName: "JTI", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "jti,omitempty" } },
            { no: 11, name: "Audiences", kind: "scalar", jsonName: "Audiences", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "audiences,omitempty" } },
            { no: 12, name: "WorkloadIdentity", kind: "scalar", jsonName: "WorkloadIdentity", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "workload_identity,omitempty" } },
            { no: 13, name: "WorkloadIdentityRevision", kind: "scalar", jsonName: "WorkloadIdentityRevision", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "workload_identity_revision,omitempty" } },
            { no: 14, name: "Attributes", kind: "message", jsonName: "Attributes", T: () => Struct, options: { "gogoproto.jsontag": "attributes,omitempty", "gogoproto.casttype": "Struct" } }
        ]);
    }
    create(value?: PartialMessage<SPIFFESVIDIssued>): SPIFFESVIDIssued {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sPIFFEID = "";
        message.dNSSANs = [];
        message.iPSANs = [];
        message.sVIDType = "";
        message.serialNumber = "";
        message.hint = "";
        message.jTI = "";
        message.audiences = [];
        message.workloadIdentity = "";
        message.workloadIdentityRevision = "";
        if (value !== undefined)
            reflectionMergePartial<SPIFFESVIDIssued>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SPIFFESVIDIssued): SPIFFESVIDIssued {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 3 [json_name = "Connection"];*/ 3:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* string SPIFFEID = 4 [json_name = "SPIFFEID"];*/ 4:
                    message.sPIFFEID = reader.string();
                    break;
                case /* repeated string DNSSANs = 5 [json_name = "DNSSANs"];*/ 5:
                    message.dNSSANs.push(reader.string());
                    break;
                case /* repeated string IPSANs = 6 [json_name = "IPSANs"];*/ 6:
                    message.iPSANs.push(reader.string());
                    break;
                case /* string SVIDType = 7 [json_name = "SVIDType"];*/ 7:
                    message.sVIDType = reader.string();
                    break;
                case /* string SerialNumber = 8 [json_name = "SerialNumber"];*/ 8:
                    message.serialNumber = reader.string();
                    break;
                case /* string Hint = 9 [json_name = "Hint"];*/ 9:
                    message.hint = reader.string();
                    break;
                case /* string JTI = 10 [json_name = "JTI"];*/ 10:
                    message.jTI = reader.string();
                    break;
                case /* repeated string Audiences = 11 [json_name = "Audiences"];*/ 11:
                    message.audiences.push(reader.string());
                    break;
                case /* string WorkloadIdentity = 12 [json_name = "WorkloadIdentity"];*/ 12:
                    message.workloadIdentity = reader.string();
                    break;
                case /* string WorkloadIdentityRevision = 13 [json_name = "WorkloadIdentityRevision"];*/ 13:
                    message.workloadIdentityRevision = reader.string();
                    break;
                case /* google.protobuf.Struct Attributes = 14 [json_name = "Attributes"];*/ 14:
                    message.attributes = Struct.internalBinaryRead(reader, reader.uint32(), options, message.attributes);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SPIFFESVIDIssued, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 3 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string SPIFFEID = 4 [json_name = "SPIFFEID"]; */
        if (message.sPIFFEID !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.sPIFFEID);
        /* repeated string DNSSANs = 5 [json_name = "DNSSANs"]; */
        for (let i = 0; i < message.dNSSANs.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.dNSSANs[i]);
        /* repeated string IPSANs = 6 [json_name = "IPSANs"]; */
        for (let i = 0; i < message.iPSANs.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.iPSANs[i]);
        /* string SVIDType = 7 [json_name = "SVIDType"]; */
        if (message.sVIDType !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.sVIDType);
        /* string SerialNumber = 8 [json_name = "SerialNumber"]; */
        if (message.serialNumber !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.serialNumber);
        /* string Hint = 9 [json_name = "Hint"]; */
        if (message.hint !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.hint);
        /* string JTI = 10 [json_name = "JTI"]; */
        if (message.jTI !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.jTI);
        /* repeated string Audiences = 11 [json_name = "Audiences"]; */
        for (let i = 0; i < message.audiences.length; i++)
            writer.tag(11, WireType.LengthDelimited).string(message.audiences[i]);
        /* string WorkloadIdentity = 12 [json_name = "WorkloadIdentity"]; */
        if (message.workloadIdentity !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.workloadIdentity);
        /* string WorkloadIdentityRevision = 13 [json_name = "WorkloadIdentityRevision"]; */
        if (message.workloadIdentityRevision !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.workloadIdentityRevision);
        /* google.protobuf.Struct Attributes = 14 [json_name = "Attributes"]; */
        if (message.attributes)
            Struct.internalBinaryWrite(message.attributes, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.SPIFFESVIDIssued
 */
export const SPIFFESVIDIssued = new SPIFFESVIDIssued$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthPreferenceUpdate$Type extends MessageType<AuthPreferenceUpdate> {
    constructor() {
        super("events.AuthPreferenceUpdate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "AdminActionsMFA", kind: "enum", jsonName: "AdminActionsMFA", T: () => ["events.AdminActionsMFAStatus", AdminActionsMFAStatus], options: { "gogoproto.jsontag": "admin_actions_mfa_changed" } }
        ]);
    }
    create(value?: PartialMessage<AuthPreferenceUpdate>): AuthPreferenceUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.adminActionsMFA = 0;
        if (value !== undefined)
            reflectionMergePartial<AuthPreferenceUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthPreferenceUpdate): AuthPreferenceUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.Status Status = 2 [json_name = "Status"];*/ 2:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* events.AdminActionsMFAStatus AdminActionsMFA = 5 [json_name = "AdminActionsMFA"];*/ 5:
                    message.adminActionsMFA = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthPreferenceUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 2 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.AdminActionsMFAStatus AdminActionsMFA = 5 [json_name = "AdminActionsMFA"]; */
        if (message.adminActionsMFA !== 0)
            writer.tag(5, WireType.Varint).int32(message.adminActionsMFA);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.AuthPreferenceUpdate
 */
export const AuthPreferenceUpdate = new AuthPreferenceUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClusterNetworkingConfigUpdate$Type extends MessageType<ClusterNetworkingConfigUpdate> {
    constructor() {
        super("events.ClusterNetworkingConfigUpdate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<ClusterNetworkingConfigUpdate>): ClusterNetworkingConfigUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ClusterNetworkingConfigUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClusterNetworkingConfigUpdate): ClusterNetworkingConfigUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.Status Status = 2 [json_name = "Status"];*/ 2:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClusterNetworkingConfigUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 2 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.ClusterNetworkingConfigUpdate
 */
export const ClusterNetworkingConfigUpdate = new ClusterNetworkingConfigUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SessionRecordingConfigUpdate$Type extends MessageType<SessionRecordingConfigUpdate> {
    constructor() {
        super("events.SessionRecordingConfigUpdate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<SessionRecordingConfigUpdate>): SessionRecordingConfigUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SessionRecordingConfigUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SessionRecordingConfigUpdate): SessionRecordingConfigUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.Status Status = 2 [json_name = "Status"];*/ 2:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SessionRecordingConfigUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 2 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.SessionRecordingConfigUpdate
 */
export const SessionRecordingConfigUpdate = new SessionRecordingConfigUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessPathChanged$Type extends MessageType<AccessPathChanged> {
    constructor() {
        super("events.AccessPathChanged", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "ChangeID", kind: "scalar", jsonName: "ChangeID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "change_id" } },
            { no: 3, name: "AffectedResourceName", kind: "scalar", jsonName: "AffectedResourceName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "affected_resource_name" } },
            { no: 4, name: "AffectedResourceSource", kind: "scalar", jsonName: "AffectedResourceSource", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "affected_resource_source" } },
            { no: 5, name: "AffectedResourceType", kind: "scalar", jsonName: "AffectedResourceType", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "affected_resource_type" } }
        ]);
    }
    create(value?: PartialMessage<AccessPathChanged>): AccessPathChanged {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.changeID = "";
        message.affectedResourceName = "";
        message.affectedResourceSource = "";
        message.affectedResourceType = "";
        if (value !== undefined)
            reflectionMergePartial<AccessPathChanged>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessPathChanged): AccessPathChanged {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* string ChangeID = 2 [json_name = "ChangeID"];*/ 2:
                    message.changeID = reader.string();
                    break;
                case /* string AffectedResourceName = 3 [json_name = "AffectedResourceName"];*/ 3:
                    message.affectedResourceName = reader.string();
                    break;
                case /* string AffectedResourceSource = 4 [json_name = "AffectedResourceSource"];*/ 4:
                    message.affectedResourceSource = reader.string();
                    break;
                case /* string AffectedResourceType = 5 [json_name = "AffectedResourceType"];*/ 5:
                    message.affectedResourceType = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessPathChanged, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string ChangeID = 2 [json_name = "ChangeID"]; */
        if (message.changeID !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.changeID);
        /* string AffectedResourceName = 3 [json_name = "AffectedResourceName"]; */
        if (message.affectedResourceName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.affectedResourceName);
        /* string AffectedResourceSource = 4 [json_name = "AffectedResourceSource"]; */
        if (message.affectedResourceSource !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.affectedResourceSource);
        /* string AffectedResourceType = 5 [json_name = "AffectedResourceType"]; */
        if (message.affectedResourceType !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.affectedResourceType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.AccessPathChanged
 */
export const AccessPathChanged = new AccessPathChanged$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpannerRPC$Type extends MessageType<SpannerRPC> {
    constructor() {
        super("events.SpannerRPC", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Database", kind: "message", jsonName: "Database", T: () => DatabaseMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 6, name: "Procedure", kind: "scalar", jsonName: "Procedure", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "procedure,omitempty" } },
            { no: 7, name: "Args", kind: "message", jsonName: "Args", T: () => Struct, options: { "gogoproto.jsontag": "args,omitempty", "gogoproto.casttype": "Struct" } }
        ]);
    }
    create(value?: PartialMessage<SpannerRPC>): SpannerRPC {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.procedure = "";
        if (value !== undefined)
            reflectionMergePartial<SpannerRPC>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SpannerRPC): SpannerRPC {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.SessionMetadata Session = 3 [json_name = "Session"];*/ 3:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.DatabaseMetadata Database = 4 [json_name = "Database"];*/ 4:
                    message.database = DatabaseMetadata.internalBinaryRead(reader, reader.uint32(), options, message.database);
                    break;
                case /* events.Status Status = 5 [json_name = "Status"];*/ 5:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* string Procedure = 6 [json_name = "Procedure"];*/ 6:
                    message.procedure = reader.string();
                    break;
                case /* google.protobuf.Struct Args = 7 [json_name = "Args"];*/ 7:
                    message.args = Struct.internalBinaryRead(reader, reader.uint32(), options, message.args);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SpannerRPC, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 3 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.DatabaseMetadata Database = 4 [json_name = "Database"]; */
        if (message.database)
            DatabaseMetadata.internalBinaryWrite(message.database, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 5 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string Procedure = 6 [json_name = "Procedure"]; */
        if (message.procedure !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.procedure);
        /* google.protobuf.Struct Args = 7 [json_name = "Args"]; */
        if (message.args)
            Struct.internalBinaryWrite(message.args, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.SpannerRPC
 */
export const SpannerRPC = new SpannerRPC$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessGraphSettingsUpdate$Type extends MessageType<AccessGraphSettingsUpdate> {
    constructor() {
        super("events.AccessGraphSettingsUpdate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<AccessGraphSettingsUpdate>): AccessGraphSettingsUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AccessGraphSettingsUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessGraphSettingsUpdate): AccessGraphSettingsUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.Status Status = 2 [json_name = "Status"];*/ 2:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessGraphSettingsUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 2 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.AccessGraphSettingsUpdate
 */
export const AccessGraphSettingsUpdate = new AccessGraphSettingsUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SPIFFEFederationCreate$Type extends MessageType<SPIFFEFederationCreate> {
    constructor() {
        super("events.SPIFFEFederationCreate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<SPIFFEFederationCreate>): SPIFFEFederationCreate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SPIFFEFederationCreate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SPIFFEFederationCreate): SPIFFEFederationCreate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SPIFFEFederationCreate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.SPIFFEFederationCreate
 */
export const SPIFFEFederationCreate = new SPIFFEFederationCreate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SPIFFEFederationDelete$Type extends MessageType<SPIFFEFederationDelete> {
    constructor() {
        super("events.SPIFFEFederationDelete", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<SPIFFEFederationDelete>): SPIFFEFederationDelete {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SPIFFEFederationDelete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SPIFFEFederationDelete): SPIFFEFederationDelete {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SPIFFEFederationDelete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.SPIFFEFederationDelete
 */
export const SPIFFEFederationDelete = new SPIFFEFederationDelete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AutoUpdateConfigCreate$Type extends MessageType<AutoUpdateConfigCreate> {
    constructor() {
        super("events.AutoUpdateConfigCreate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<AutoUpdateConfigCreate>): AutoUpdateConfigCreate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AutoUpdateConfigCreate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AutoUpdateConfigCreate): AutoUpdateConfigCreate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* events.Status Status = 5 [json_name = "Status"];*/ 5:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AutoUpdateConfigCreate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 5 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.AutoUpdateConfigCreate
 */
export const AutoUpdateConfigCreate = new AutoUpdateConfigCreate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AutoUpdateConfigUpdate$Type extends MessageType<AutoUpdateConfigUpdate> {
    constructor() {
        super("events.AutoUpdateConfigUpdate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<AutoUpdateConfigUpdate>): AutoUpdateConfigUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AutoUpdateConfigUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AutoUpdateConfigUpdate): AutoUpdateConfigUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.Status Status = 2 [json_name = "Status"];*/ 2:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* events.ResourceMetadata Resource = 5 [json_name = "Resource"];*/ 5:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AutoUpdateConfigUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 2 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 5 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.AutoUpdateConfigUpdate
 */
export const AutoUpdateConfigUpdate = new AutoUpdateConfigUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AutoUpdateConfigDelete$Type extends MessageType<AutoUpdateConfigDelete> {
    constructor() {
        super("events.AutoUpdateConfigDelete", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<AutoUpdateConfigDelete>): AutoUpdateConfigDelete {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AutoUpdateConfigDelete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AutoUpdateConfigDelete): AutoUpdateConfigDelete {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* events.Status Status = 5 [json_name = "Status"];*/ 5:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AutoUpdateConfigDelete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 5 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.AutoUpdateConfigDelete
 */
export const AutoUpdateConfigDelete = new AutoUpdateConfigDelete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AutoUpdateVersionCreate$Type extends MessageType<AutoUpdateVersionCreate> {
    constructor() {
        super("events.AutoUpdateVersionCreate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<AutoUpdateVersionCreate>): AutoUpdateVersionCreate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AutoUpdateVersionCreate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AutoUpdateVersionCreate): AutoUpdateVersionCreate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* events.Status Status = 5 [json_name = "Status"];*/ 5:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AutoUpdateVersionCreate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 5 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.AutoUpdateVersionCreate
 */
export const AutoUpdateVersionCreate = new AutoUpdateVersionCreate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AutoUpdateVersionUpdate$Type extends MessageType<AutoUpdateVersionUpdate> {
    constructor() {
        super("events.AutoUpdateVersionUpdate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<AutoUpdateVersionUpdate>): AutoUpdateVersionUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AutoUpdateVersionUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AutoUpdateVersionUpdate): AutoUpdateVersionUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.Status Status = 2 [json_name = "Status"];*/ 2:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* events.ResourceMetadata Resource = 5 [json_name = "Resource"];*/ 5:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AutoUpdateVersionUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 2 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 5 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.AutoUpdateVersionUpdate
 */
export const AutoUpdateVersionUpdate = new AutoUpdateVersionUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AutoUpdateVersionDelete$Type extends MessageType<AutoUpdateVersionDelete> {
    constructor() {
        super("events.AutoUpdateVersionDelete", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<AutoUpdateVersionDelete>): AutoUpdateVersionDelete {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AutoUpdateVersionDelete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AutoUpdateVersionDelete): AutoUpdateVersionDelete {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* events.Status Status = 5 [json_name = "Status"];*/ 5:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AutoUpdateVersionDelete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 5 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.AutoUpdateVersionDelete
 */
export const AutoUpdateVersionDelete = new AutoUpdateVersionDelete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AutoUpdateAgentRolloutTrigger$Type extends MessageType<AutoUpdateAgentRolloutTrigger> {
    constructor() {
        super("events.AutoUpdateAgentRolloutTrigger", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "groups", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<AutoUpdateAgentRolloutTrigger>): AutoUpdateAgentRolloutTrigger {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.groups = [];
        if (value !== undefined)
            reflectionMergePartial<AutoUpdateAgentRolloutTrigger>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AutoUpdateAgentRolloutTrigger): AutoUpdateAgentRolloutTrigger {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 3 [json_name = "Connection"];*/ 3:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* repeated string groups */ 4:
                    message.groups.push(reader.string());
                    break;
                case /* events.Status Status = 5 [json_name = "Status"];*/ 5:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AutoUpdateAgentRolloutTrigger, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 3 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated string groups = 4; */
        for (let i = 0; i < message.groups.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.groups[i]);
        /* events.Status Status = 5 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.AutoUpdateAgentRolloutTrigger
 */
export const AutoUpdateAgentRolloutTrigger = new AutoUpdateAgentRolloutTrigger$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AutoUpdateAgentRolloutForceDone$Type extends MessageType<AutoUpdateAgentRolloutForceDone> {
    constructor() {
        super("events.AutoUpdateAgentRolloutForceDone", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "groups", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<AutoUpdateAgentRolloutForceDone>): AutoUpdateAgentRolloutForceDone {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.groups = [];
        if (value !== undefined)
            reflectionMergePartial<AutoUpdateAgentRolloutForceDone>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AutoUpdateAgentRolloutForceDone): AutoUpdateAgentRolloutForceDone {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 3 [json_name = "Connection"];*/ 3:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* repeated string groups */ 4:
                    message.groups.push(reader.string());
                    break;
                case /* events.Status Status = 5 [json_name = "Status"];*/ 5:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AutoUpdateAgentRolloutForceDone, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 3 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated string groups = 4; */
        for (let i = 0; i < message.groups.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.groups[i]);
        /* events.Status Status = 5 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.AutoUpdateAgentRolloutForceDone
 */
export const AutoUpdateAgentRolloutForceDone = new AutoUpdateAgentRolloutForceDone$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AutoUpdateAgentRolloutRollback$Type extends MessageType<AutoUpdateAgentRolloutRollback> {
    constructor() {
        super("events.AutoUpdateAgentRolloutRollback", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "groups", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<AutoUpdateAgentRolloutRollback>): AutoUpdateAgentRolloutRollback {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.groups = [];
        if (value !== undefined)
            reflectionMergePartial<AutoUpdateAgentRolloutRollback>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AutoUpdateAgentRolloutRollback): AutoUpdateAgentRolloutRollback {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 3 [json_name = "Connection"];*/ 3:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* repeated string groups */ 4:
                    message.groups.push(reader.string());
                    break;
                case /* events.Status Status = 5 [json_name = "Status"];*/ 5:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AutoUpdateAgentRolloutRollback, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 3 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated string groups = 4; */
        for (let i = 0; i < message.groups.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.groups[i]);
        /* events.Status Status = 5 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.AutoUpdateAgentRolloutRollback
 */
export const AutoUpdateAgentRolloutRollback = new AutoUpdateAgentRolloutRollback$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StaticHostUserCreate$Type extends MessageType<StaticHostUserCreate> {
    constructor() {
        super("events.StaticHostUserCreate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<StaticHostUserCreate>): StaticHostUserCreate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StaticHostUserCreate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StaticHostUserCreate): StaticHostUserCreate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.Status Status = 2 [json_name = "Status"];*/ 2:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* events.ResourceMetadata Resource = 3 [json_name = "Resource"];*/ 3:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 4 [json_name = "User"];*/ 4:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 5 [json_name = "Connection"];*/ 5:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StaticHostUserCreate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 2 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 3 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 4 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 5 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.StaticHostUserCreate
 */
export const StaticHostUserCreate = new StaticHostUserCreate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StaticHostUserUpdate$Type extends MessageType<StaticHostUserUpdate> {
    constructor() {
        super("events.StaticHostUserUpdate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<StaticHostUserUpdate>): StaticHostUserUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StaticHostUserUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StaticHostUserUpdate): StaticHostUserUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.Status Status = 2 [json_name = "Status"];*/ 2:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* events.ResourceMetadata Resource = 3 [json_name = "Resource"];*/ 3:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 4 [json_name = "User"];*/ 4:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 5 [json_name = "Connection"];*/ 5:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StaticHostUserUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 2 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 3 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 4 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 5 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.StaticHostUserUpdate
 */
export const StaticHostUserUpdate = new StaticHostUserUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StaticHostUserDelete$Type extends MessageType<StaticHostUserDelete> {
    constructor() {
        super("events.StaticHostUserDelete", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<StaticHostUserDelete>): StaticHostUserDelete {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StaticHostUserDelete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StaticHostUserDelete): StaticHostUserDelete {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.Status Status = 2 [json_name = "Status"];*/ 2:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* events.ResourceMetadata Resource = 3 [json_name = "Resource"];*/ 3:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 4 [json_name = "User"];*/ 4:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 5 [json_name = "Connection"];*/ 5:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StaticHostUserDelete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 2 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 3 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 4 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 5 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.StaticHostUserDelete
 */
export const StaticHostUserDelete = new StaticHostUserDelete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CrownJewelCreate$Type extends MessageType<CrownJewelCreate> {
    constructor() {
        super("events.CrownJewelCreate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "resource", kind: "message", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 6, name: "CrownJewelQuery", kind: "scalar", jsonName: "CrownJewelQuery", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "crown_jewel_query" } }
        ]);
    }
    create(value?: PartialMessage<CrownJewelCreate>): CrownJewelCreate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.crownJewelQuery = "";
        if (value !== undefined)
            reflectionMergePartial<CrownJewelCreate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CrownJewelCreate): CrownJewelCreate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.Status Status = 2 [json_name = "Status"];*/ 2:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* events.ResourceMetadata resource */ 5:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* string CrownJewelQuery = 6 [json_name = "CrownJewelQuery"];*/ 6:
                    message.crownJewelQuery = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CrownJewelCreate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 2 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata resource = 5; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string CrownJewelQuery = 6 [json_name = "CrownJewelQuery"]; */
        if (message.crownJewelQuery !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.crownJewelQuery);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.CrownJewelCreate
 */
export const CrownJewelCreate = new CrownJewelCreate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CrownJewelUpdate$Type extends MessageType<CrownJewelUpdate> {
    constructor() {
        super("events.CrownJewelUpdate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "resource", kind: "message", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 6, name: "CurrentCrownJewelQuery", kind: "scalar", jsonName: "CurrentCrownJewelQuery", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "current_crown_jewel_query" } },
            { no: 7, name: "UpdatedCrownJewelQuery", kind: "scalar", jsonName: "UpdatedCrownJewelQuery", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "updated_crown_jewel_query" } }
        ]);
    }
    create(value?: PartialMessage<CrownJewelUpdate>): CrownJewelUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.currentCrownJewelQuery = "";
        message.updatedCrownJewelQuery = "";
        if (value !== undefined)
            reflectionMergePartial<CrownJewelUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CrownJewelUpdate): CrownJewelUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.Status Status = 2 [json_name = "Status"];*/ 2:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* events.ResourceMetadata resource */ 5:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* string CurrentCrownJewelQuery = 6 [json_name = "CurrentCrownJewelQuery"];*/ 6:
                    message.currentCrownJewelQuery = reader.string();
                    break;
                case /* string UpdatedCrownJewelQuery = 7 [json_name = "UpdatedCrownJewelQuery"];*/ 7:
                    message.updatedCrownJewelQuery = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CrownJewelUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 2 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata resource = 5; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string CurrentCrownJewelQuery = 6 [json_name = "CurrentCrownJewelQuery"]; */
        if (message.currentCrownJewelQuery !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.currentCrownJewelQuery);
        /* string UpdatedCrownJewelQuery = 7 [json_name = "UpdatedCrownJewelQuery"]; */
        if (message.updatedCrownJewelQuery !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.updatedCrownJewelQuery);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.CrownJewelUpdate
 */
export const CrownJewelUpdate = new CrownJewelUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CrownJewelDelete$Type extends MessageType<CrownJewelDelete> {
    constructor() {
        super("events.CrownJewelDelete", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "resource", kind: "message", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<CrownJewelDelete>): CrownJewelDelete {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CrownJewelDelete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CrownJewelDelete): CrownJewelDelete {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.Status Status = 2 [json_name = "Status"];*/ 2:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* events.ResourceMetadata resource */ 5:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CrownJewelDelete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 2 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata resource = 5; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.CrownJewelDelete
 */
export const CrownJewelDelete = new CrownJewelDelete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserTaskCreate$Type extends MessageType<UserTaskCreate> {
    constructor() {
        super("events.UserTaskCreate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 6, name: "UserTask", kind: "message", jsonName: "UserTask", T: () => UserTaskMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<UserTaskCreate>): UserTaskCreate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UserTaskCreate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserTaskCreate): UserTaskCreate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.Status Status = 2 [json_name = "Status"];*/ 2:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* events.ResourceMetadata Resource = 3 [json_name = "Resource"];*/ 3:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 4 [json_name = "User"];*/ 4:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 5 [json_name = "Connection"];*/ 5:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* events.UserTaskMetadata UserTask = 6 [json_name = "UserTask"];*/ 6:
                    message.userTask = UserTaskMetadata.internalBinaryRead(reader, reader.uint32(), options, message.userTask);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserTaskCreate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 2 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 3 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 4 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 5 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* events.UserTaskMetadata UserTask = 6 [json_name = "UserTask"]; */
        if (message.userTask)
            UserTaskMetadata.internalBinaryWrite(message.userTask, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.UserTaskCreate
 */
export const UserTaskCreate = new UserTaskCreate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserTaskUpdate$Type extends MessageType<UserTaskUpdate> {
    constructor() {
        super("events.UserTaskUpdate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 6, name: "UserTask", kind: "message", jsonName: "UserTask", T: () => UserTaskMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 7, name: "CurrentUserTaskState", kind: "scalar", jsonName: "CurrentUserTaskState", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "current_user_task_state" } },
            { no: 8, name: "UpdatedUserTaskState", kind: "scalar", jsonName: "UpdatedUserTaskState", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "updated_user_task_state" } }
        ]);
    }
    create(value?: PartialMessage<UserTaskUpdate>): UserTaskUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.currentUserTaskState = "";
        message.updatedUserTaskState = "";
        if (value !== undefined)
            reflectionMergePartial<UserTaskUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserTaskUpdate): UserTaskUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.Status Status = 2 [json_name = "Status"];*/ 2:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* events.ResourceMetadata Resource = 3 [json_name = "Resource"];*/ 3:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 4 [json_name = "User"];*/ 4:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 5 [json_name = "Connection"];*/ 5:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* events.UserTaskMetadata UserTask = 6 [json_name = "UserTask"];*/ 6:
                    message.userTask = UserTaskMetadata.internalBinaryRead(reader, reader.uint32(), options, message.userTask);
                    break;
                case /* string CurrentUserTaskState = 7 [json_name = "CurrentUserTaskState"];*/ 7:
                    message.currentUserTaskState = reader.string();
                    break;
                case /* string UpdatedUserTaskState = 8 [json_name = "UpdatedUserTaskState"];*/ 8:
                    message.updatedUserTaskState = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserTaskUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 2 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 3 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 4 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 5 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* events.UserTaskMetadata UserTask = 6 [json_name = "UserTask"]; */
        if (message.userTask)
            UserTaskMetadata.internalBinaryWrite(message.userTask, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* string CurrentUserTaskState = 7 [json_name = "CurrentUserTaskState"]; */
        if (message.currentUserTaskState !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.currentUserTaskState);
        /* string UpdatedUserTaskState = 8 [json_name = "UpdatedUserTaskState"]; */
        if (message.updatedUserTaskState !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.updatedUserTaskState);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.UserTaskUpdate
 */
export const UserTaskUpdate = new UserTaskUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserTaskMetadata$Type extends MessageType<UserTaskMetadata> {
    constructor() {
        super("events.UserTaskMetadata", [
            { no: 1, name: "TaskType", kind: "scalar", jsonName: "TaskType", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "user_task_type" } },
            { no: 2, name: "IssueType", kind: "scalar", jsonName: "IssueType", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "user_task_issue_type" } },
            { no: 3, name: "Integration", kind: "scalar", jsonName: "Integration", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "user_task_integration" } }
        ]);
    }
    create(value?: PartialMessage<UserTaskMetadata>): UserTaskMetadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.taskType = "";
        message.issueType = "";
        message.integration = "";
        if (value !== undefined)
            reflectionMergePartial<UserTaskMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserTaskMetadata): UserTaskMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string TaskType = 1 [json_name = "TaskType"];*/ 1:
                    message.taskType = reader.string();
                    break;
                case /* string IssueType = 2 [json_name = "IssueType"];*/ 2:
                    message.issueType = reader.string();
                    break;
                case /* string Integration = 3 [json_name = "Integration"];*/ 3:
                    message.integration = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserTaskMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string TaskType = 1 [json_name = "TaskType"]; */
        if (message.taskType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.taskType);
        /* string IssueType = 2 [json_name = "IssueType"]; */
        if (message.issueType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.issueType);
        /* string Integration = 3 [json_name = "Integration"]; */
        if (message.integration !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.integration);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.UserTaskMetadata
 */
export const UserTaskMetadata = new UserTaskMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserTaskDelete$Type extends MessageType<UserTaskDelete> {
    constructor() {
        super("events.UserTaskDelete", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<UserTaskDelete>): UserTaskDelete {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UserTaskDelete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserTaskDelete): UserTaskDelete {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.Status Status = 2 [json_name = "Status"];*/ 2:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* events.ResourceMetadata Resource = 3 [json_name = "Resource"];*/ 3:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 4 [json_name = "User"];*/ 4:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 5 [json_name = "Connection"];*/ 5:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserTaskDelete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 2 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 3 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 4 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 5 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.UserTaskDelete
 */
export const UserTaskDelete = new UserTaskDelete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ContactCreate$Type extends MessageType<ContactCreate> {
    constructor() {
        super("events.ContactCreate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 6, name: "Email", kind: "scalar", jsonName: "Email", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "email" } },
            { no: 7, name: "ContactType", kind: "enum", jsonName: "ContactType", T: () => ["events.ContactType", ContactType, "CONTACT_TYPE_"], options: { "gogoproto.jsontag": "contact_type" } }
        ]);
    }
    create(value?: PartialMessage<ContactCreate>): ContactCreate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.email = "";
        message.contactType = 0;
        if (value !== undefined)
            reflectionMergePartial<ContactCreate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ContactCreate): ContactCreate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* events.Status Status = 5 [json_name = "Status"];*/ 5:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* string Email = 6 [json_name = "Email"];*/ 6:
                    message.email = reader.string();
                    break;
                case /* events.ContactType ContactType = 7 [json_name = "ContactType"];*/ 7:
                    message.contactType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ContactCreate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 5 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string Email = 6 [json_name = "Email"]; */
        if (message.email !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.email);
        /* events.ContactType ContactType = 7 [json_name = "ContactType"]; */
        if (message.contactType !== 0)
            writer.tag(7, WireType.Varint).int32(message.contactType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.ContactCreate
 */
export const ContactCreate = new ContactCreate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ContactDelete$Type extends MessageType<ContactDelete> {
    constructor() {
        super("events.ContactDelete", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 6, name: "Email", kind: "scalar", jsonName: "Email", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "email" } },
            { no: 7, name: "ContactType", kind: "enum", jsonName: "ContactType", T: () => ["events.ContactType", ContactType, "CONTACT_TYPE_"], options: { "gogoproto.jsontag": "contact_type" } }
        ]);
    }
    create(value?: PartialMessage<ContactDelete>): ContactDelete {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.email = "";
        message.contactType = 0;
        if (value !== undefined)
            reflectionMergePartial<ContactDelete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ContactDelete): ContactDelete {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* events.Status Status = 5 [json_name = "Status"];*/ 5:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* string Email = 6 [json_name = "Email"];*/ 6:
                    message.email = reader.string();
                    break;
                case /* events.ContactType ContactType = 7 [json_name = "ContactType"];*/ 7:
                    message.contactType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ContactDelete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 5 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string Email = 6 [json_name = "Email"]; */
        if (message.email !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.email);
        /* events.ContactType ContactType = 7 [json_name = "ContactType"]; */
        if (message.contactType !== 0)
            writer.tag(7, WireType.Varint).int32(message.contactType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.ContactDelete
 */
export const ContactDelete = new ContactDelete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkloadIdentityCreate$Type extends MessageType<WorkloadIdentityCreate> {
    constructor() {
        super("events.WorkloadIdentityCreate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "WorkloadIdentityData", kind: "message", jsonName: "WorkloadIdentityData", T: () => Struct, options: { "gogoproto.jsontag": "workload_identity_data,omitempty", "gogoproto.casttype": "Struct" } }
        ]);
    }
    create(value?: PartialMessage<WorkloadIdentityCreate>): WorkloadIdentityCreate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<WorkloadIdentityCreate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkloadIdentityCreate): WorkloadIdentityCreate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* google.protobuf.Struct WorkloadIdentityData = 5 [json_name = "WorkloadIdentityData"];*/ 5:
                    message.workloadIdentityData = Struct.internalBinaryRead(reader, reader.uint32(), options, message.workloadIdentityData);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkloadIdentityCreate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Struct WorkloadIdentityData = 5 [json_name = "WorkloadIdentityData"]; */
        if (message.workloadIdentityData)
            Struct.internalBinaryWrite(message.workloadIdentityData, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.WorkloadIdentityCreate
 */
export const WorkloadIdentityCreate = new WorkloadIdentityCreate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkloadIdentityUpdate$Type extends MessageType<WorkloadIdentityUpdate> {
    constructor() {
        super("events.WorkloadIdentityUpdate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "WorkloadIdentityData", kind: "message", jsonName: "WorkloadIdentityData", T: () => Struct, options: { "gogoproto.jsontag": "workload_identity_data,omitempty", "gogoproto.casttype": "Struct" } }
        ]);
    }
    create(value?: PartialMessage<WorkloadIdentityUpdate>): WorkloadIdentityUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<WorkloadIdentityUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkloadIdentityUpdate): WorkloadIdentityUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* google.protobuf.Struct WorkloadIdentityData = 5 [json_name = "WorkloadIdentityData"];*/ 5:
                    message.workloadIdentityData = Struct.internalBinaryRead(reader, reader.uint32(), options, message.workloadIdentityData);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkloadIdentityUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Struct WorkloadIdentityData = 5 [json_name = "WorkloadIdentityData"]; */
        if (message.workloadIdentityData)
            Struct.internalBinaryWrite(message.workloadIdentityData, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.WorkloadIdentityUpdate
 */
export const WorkloadIdentityUpdate = new WorkloadIdentityUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkloadIdentityDelete$Type extends MessageType<WorkloadIdentityDelete> {
    constructor() {
        super("events.WorkloadIdentityDelete", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<WorkloadIdentityDelete>): WorkloadIdentityDelete {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<WorkloadIdentityDelete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkloadIdentityDelete): WorkloadIdentityDelete {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkloadIdentityDelete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.WorkloadIdentityDelete
 */
export const WorkloadIdentityDelete = new WorkloadIdentityDelete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkloadIdentityX509RevocationCreate$Type extends MessageType<WorkloadIdentityX509RevocationCreate> {
    constructor() {
        super("events.WorkloadIdentityX509RevocationCreate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Reason", kind: "scalar", jsonName: "Reason", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "reason" } }
        ]);
    }
    create(value?: PartialMessage<WorkloadIdentityX509RevocationCreate>): WorkloadIdentityX509RevocationCreate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.reason = "";
        if (value !== undefined)
            reflectionMergePartial<WorkloadIdentityX509RevocationCreate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkloadIdentityX509RevocationCreate): WorkloadIdentityX509RevocationCreate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* string Reason = 5 [json_name = "Reason"];*/ 5:
                    message.reason = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkloadIdentityX509RevocationCreate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string Reason = 5 [json_name = "Reason"]; */
        if (message.reason !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.reason);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.WorkloadIdentityX509RevocationCreate
 */
export const WorkloadIdentityX509RevocationCreate = new WorkloadIdentityX509RevocationCreate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkloadIdentityX509RevocationUpdate$Type extends MessageType<WorkloadIdentityX509RevocationUpdate> {
    constructor() {
        super("events.WorkloadIdentityX509RevocationUpdate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Reason", kind: "scalar", jsonName: "Reason", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "reason" } }
        ]);
    }
    create(value?: PartialMessage<WorkloadIdentityX509RevocationUpdate>): WorkloadIdentityX509RevocationUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.reason = "";
        if (value !== undefined)
            reflectionMergePartial<WorkloadIdentityX509RevocationUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkloadIdentityX509RevocationUpdate): WorkloadIdentityX509RevocationUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* string Reason = 5 [json_name = "Reason"];*/ 5:
                    message.reason = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkloadIdentityX509RevocationUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string Reason = 5 [json_name = "Reason"]; */
        if (message.reason !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.reason);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.WorkloadIdentityX509RevocationUpdate
 */
export const WorkloadIdentityX509RevocationUpdate = new WorkloadIdentityX509RevocationUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkloadIdentityX509RevocationDelete$Type extends MessageType<WorkloadIdentityX509RevocationDelete> {
    constructor() {
        super("events.WorkloadIdentityX509RevocationDelete", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<WorkloadIdentityX509RevocationDelete>): WorkloadIdentityX509RevocationDelete {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<WorkloadIdentityX509RevocationDelete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkloadIdentityX509RevocationDelete): WorkloadIdentityX509RevocationDelete {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkloadIdentityX509RevocationDelete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.WorkloadIdentityX509RevocationDelete
 */
export const WorkloadIdentityX509RevocationDelete = new WorkloadIdentityX509RevocationDelete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GitCommand$Type extends MessageType<GitCommand> {
    constructor() {
        super("events.GitCommand", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Session", kind: "message", jsonName: "Session", T: () => SessionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Server", kind: "message", jsonName: "Server", T: () => ServerMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 6, name: "Command", kind: "message", jsonName: "Command", T: () => CommandMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 8, name: "service", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "service" } },
            { no: 9, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "path" } },
            { no: 10, name: "actions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GitCommandAction, options: { "gogoproto.jsontag": "actions,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<GitCommand>): GitCommand {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.service = "";
        message.path = "";
        message.actions = [];
        if (value !== undefined)
            reflectionMergePartial<GitCommand>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GitCommand): GitCommand {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 3 [json_name = "Connection"];*/ 3:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* events.SessionMetadata Session = 4 [json_name = "Session"];*/ 4:
                    message.session = SessionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* events.ServerMetadata Server = 5 [json_name = "Server"];*/ 5:
                    message.server = ServerMetadata.internalBinaryRead(reader, reader.uint32(), options, message.server);
                    break;
                case /* events.CommandMetadata Command = 6 [json_name = "Command"];*/ 6:
                    message.command = CommandMetadata.internalBinaryRead(reader, reader.uint32(), options, message.command);
                    break;
                case /* string service */ 8:
                    message.service = reader.string();
                    break;
                case /* string path */ 9:
                    message.path = reader.string();
                    break;
                case /* repeated events.GitCommandAction actions */ 10:
                    message.actions.push(GitCommandAction.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GitCommand, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 3 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.SessionMetadata Session = 4 [json_name = "Session"]; */
        if (message.session)
            SessionMetadata.internalBinaryWrite(message.session, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* events.ServerMetadata Server = 5 [json_name = "Server"]; */
        if (message.server)
            ServerMetadata.internalBinaryWrite(message.server, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* events.CommandMetadata Command = 6 [json_name = "Command"]; */
        if (message.command)
            CommandMetadata.internalBinaryWrite(message.command, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* string service = 8; */
        if (message.service !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.service);
        /* string path = 9; */
        if (message.path !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.path);
        /* repeated events.GitCommandAction actions = 10; */
        for (let i = 0; i < message.actions.length; i++)
            GitCommandAction.internalBinaryWrite(message.actions[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.GitCommand
 */
export const GitCommand = new GitCommand$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GitCommandAction$Type extends MessageType<GitCommandAction> {
    constructor() {
        super("events.GitCommandAction", [
            { no: 1, name: "Action", kind: "scalar", jsonName: "Action", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "action,omitempty" } },
            { no: 2, name: "Reference", kind: "scalar", jsonName: "Reference", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "reference,omitempty" } },
            { no: 3, name: "Old", kind: "scalar", jsonName: "Old", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "old,omitempty" } },
            { no: 4, name: "New", kind: "scalar", jsonName: "New", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "new,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<GitCommandAction>): GitCommandAction {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.action = "";
        message.reference = "";
        message.old = "";
        message.new = "";
        if (value !== undefined)
            reflectionMergePartial<GitCommandAction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GitCommandAction): GitCommandAction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Action = 1 [json_name = "Action"];*/ 1:
                    message.action = reader.string();
                    break;
                case /* string Reference = 2 [json_name = "Reference"];*/ 2:
                    message.reference = reader.string();
                    break;
                case /* string Old = 3 [json_name = "Old"];*/ 3:
                    message.old = reader.string();
                    break;
                case /* string New = 4 [json_name = "New"];*/ 4:
                    message.new = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GitCommandAction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Action = 1 [json_name = "Action"]; */
        if (message.action !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.action);
        /* string Reference = 2 [json_name = "Reference"]; */
        if (message.reference !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.reference);
        /* string Old = 3 [json_name = "Old"]; */
        if (message.old !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.old);
        /* string New = 4 [json_name = "New"]; */
        if (message.new !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.new);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.GitCommandAction
 */
export const GitCommandAction = new GitCommandAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessListInvalidMetadata$Type extends MessageType<AccessListInvalidMetadata> {
    constructor() {
        super("events.AccessListInvalidMetadata", [
            { no: 1, name: "AccessListName", kind: "scalar", jsonName: "AccessListName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "access_list_name, omitempty" } },
            { no: 2, name: "User", kind: "scalar", jsonName: "User", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "user,omitempty" } },
            { no: 3, name: "MissingRoles", kind: "scalar", jsonName: "MissingRoles", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "missing_roles,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<AccessListInvalidMetadata>): AccessListInvalidMetadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accessListName = "";
        message.user = "";
        message.missingRoles = [];
        if (value !== undefined)
            reflectionMergePartial<AccessListInvalidMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessListInvalidMetadata): AccessListInvalidMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string AccessListName = 1 [json_name = "AccessListName"];*/ 1:
                    message.accessListName = reader.string();
                    break;
                case /* string User = 2 [json_name = "User"];*/ 2:
                    message.user = reader.string();
                    break;
                case /* repeated string MissingRoles = 3 [json_name = "MissingRoles"];*/ 3:
                    message.missingRoles.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessListInvalidMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string AccessListName = 1 [json_name = "AccessListName"]; */
        if (message.accessListName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accessListName);
        /* string User = 2 [json_name = "User"]; */
        if (message.user !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.user);
        /* repeated string MissingRoles = 3 [json_name = "MissingRoles"]; */
        for (let i = 0; i < message.missingRoles.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.missingRoles[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.AccessListInvalidMetadata
 */
export const AccessListInvalidMetadata = new AccessListInvalidMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserLoginAccessListInvalid$Type extends MessageType<UserLoginAccessListInvalid> {
    constructor() {
        super("events.UserLoginAccessListInvalid", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "AccessListInvalidMetadata", kind: "message", jsonName: "AccessListInvalidMetadata", T: () => AccessListInvalidMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<UserLoginAccessListInvalid>): UserLoginAccessListInvalid {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UserLoginAccessListInvalid>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserLoginAccessListInvalid): UserLoginAccessListInvalid {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.AccessListInvalidMetadata AccessListInvalidMetadata = 2 [json_name = "AccessListInvalidMetadata"];*/ 2:
                    message.accessListInvalidMetadata = AccessListInvalidMetadata.internalBinaryRead(reader, reader.uint32(), options, message.accessListInvalidMetadata);
                    break;
                case /* events.Status Status = 3 [json_name = "Status"];*/ 3:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserLoginAccessListInvalid, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.AccessListInvalidMetadata AccessListInvalidMetadata = 2 [json_name = "AccessListInvalidMetadata"]; */
        if (message.accessListInvalidMetadata)
            AccessListInvalidMetadata.internalBinaryWrite(message.accessListInvalidMetadata, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.Status Status = 3 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.UserLoginAccessListInvalid
 */
export const UserLoginAccessListInvalid = new UserLoginAccessListInvalid$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StableUNIXUserCreate$Type extends MessageType<StableUNIXUserCreate> {
    constructor() {
        super("events.StableUNIXUserCreate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "stable_unix_user", kind: "message", T: () => StableUNIXUser }
        ]);
    }
    create(value?: PartialMessage<StableUNIXUserCreate>): StableUNIXUserCreate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StableUNIXUserCreate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StableUNIXUserCreate): StableUNIXUserCreate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.StableUNIXUser stable_unix_user */ 3:
                    message.stableUnixUser = StableUNIXUser.internalBinaryRead(reader, reader.uint32(), options, message.stableUnixUser);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StableUNIXUserCreate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.StableUNIXUser stable_unix_user = 3; */
        if (message.stableUnixUser)
            StableUNIXUser.internalBinaryWrite(message.stableUnixUser, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.StableUNIXUserCreate
 */
export const StableUNIXUserCreate = new StableUNIXUserCreate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StableUNIXUser$Type extends MessageType<StableUNIXUser> {
    constructor() {
        super("events.StableUNIXUser", [
            { no: 1, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "uid", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<StableUNIXUser>): StableUNIXUser {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.username = "";
        message.uid = 0;
        if (value !== undefined)
            reflectionMergePartial<StableUNIXUser>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StableUNIXUser): StableUNIXUser {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string username */ 1:
                    message.username = reader.string();
                    break;
                case /* int32 uid */ 2:
                    message.uid = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StableUNIXUser, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string username = 1; */
        if (message.username !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.username);
        /* int32 uid = 2; */
        if (message.uid !== 0)
            writer.tag(2, WireType.Varint).int32(message.uid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.StableUNIXUser
 */
export const StableUNIXUser = new StableUNIXUser$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AWSICResourceSync$Type extends MessageType<AWSICResourceSync> {
    constructor() {
        super("events.AWSICResourceSync", [
            { no: 1, name: "metadata", kind: "message", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "total_accounts", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "gogoproto.jsontag": "total_accounts,omitempty" } },
            { no: 3, name: "total_account_assignments", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "gogoproto.jsontag": "total_account_assignments,omitempty" } },
            { no: 4, name: "total_user_groups", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "gogoproto.jsontag": "total_user_groups,omitempty" } },
            { no: 5, name: "total_permission_sets", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "gogoproto.jsontag": "total_permission_sets,omitempty" } },
            { no: 6, name: "Status", kind: "message", jsonName: "Status", T: () => Status, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<AWSICResourceSync>): AWSICResourceSync {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.totalAccounts = 0;
        message.totalAccountAssignments = 0;
        message.totalUserGroups = 0;
        message.totalPermissionSets = 0;
        if (value !== undefined)
            reflectionMergePartial<AWSICResourceSync>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AWSICResourceSync): AWSICResourceSync {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata metadata */ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* int32 total_accounts */ 2:
                    message.totalAccounts = reader.int32();
                    break;
                case /* int32 total_account_assignments */ 3:
                    message.totalAccountAssignments = reader.int32();
                    break;
                case /* int32 total_user_groups */ 4:
                    message.totalUserGroups = reader.int32();
                    break;
                case /* int32 total_permission_sets */ 5:
                    message.totalPermissionSets = reader.int32();
                    break;
                case /* events.Status Status = 6 [json_name = "Status"];*/ 6:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AWSICResourceSync, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata metadata = 1; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int32 total_accounts = 2; */
        if (message.totalAccounts !== 0)
            writer.tag(2, WireType.Varint).int32(message.totalAccounts);
        /* int32 total_account_assignments = 3; */
        if (message.totalAccountAssignments !== 0)
            writer.tag(3, WireType.Varint).int32(message.totalAccountAssignments);
        /* int32 total_user_groups = 4; */
        if (message.totalUserGroups !== 0)
            writer.tag(4, WireType.Varint).int32(message.totalUserGroups);
        /* int32 total_permission_sets = 5; */
        if (message.totalPermissionSets !== 0)
            writer.tag(5, WireType.Varint).int32(message.totalPermissionSets);
        /* events.Status Status = 6 [json_name = "Status"]; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.AWSICResourceSync
 */
export const AWSICResourceSync = new AWSICResourceSync$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HealthCheckConfigCreate$Type extends MessageType<HealthCheckConfigCreate> {
    constructor() {
        super("events.HealthCheckConfigCreate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<HealthCheckConfigCreate>): HealthCheckConfigCreate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<HealthCheckConfigCreate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HealthCheckConfigCreate): HealthCheckConfigCreate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HealthCheckConfigCreate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.HealthCheckConfigCreate
 */
export const HealthCheckConfigCreate = new HealthCheckConfigCreate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HealthCheckConfigUpdate$Type extends MessageType<HealthCheckConfigUpdate> {
    constructor() {
        super("events.HealthCheckConfigUpdate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<HealthCheckConfigUpdate>): HealthCheckConfigUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<HealthCheckConfigUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HealthCheckConfigUpdate): HealthCheckConfigUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HealthCheckConfigUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.HealthCheckConfigUpdate
 */
export const HealthCheckConfigUpdate = new HealthCheckConfigUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HealthCheckConfigDelete$Type extends MessageType<HealthCheckConfigDelete> {
    constructor() {
        super("events.HealthCheckConfigDelete", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<HealthCheckConfigDelete>): HealthCheckConfigDelete {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<HealthCheckConfigDelete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HealthCheckConfigDelete): HealthCheckConfigDelete {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.ResourceMetadata Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* events.UserMetadata User = 3 [json_name = "User"];*/ 3:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"];*/ 4:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HealthCheckConfigDelete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 2 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 3 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 4 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.HealthCheckConfigDelete
 */
export const HealthCheckConfigDelete = new HealthCheckConfigDelete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkloadIdentityX509IssuerOverrideCreate$Type extends MessageType<WorkloadIdentityX509IssuerOverrideCreate> {
    constructor() {
        super("events.WorkloadIdentityX509IssuerOverrideCreate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<WorkloadIdentityX509IssuerOverrideCreate>): WorkloadIdentityX509IssuerOverrideCreate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<WorkloadIdentityX509IssuerOverrideCreate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkloadIdentityX509IssuerOverrideCreate): WorkloadIdentityX509IssuerOverrideCreate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 3 [json_name = "Connection"];*/ 3:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* events.ResourceMetadata Resource = 4 [json_name = "Resource"];*/ 4:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkloadIdentityX509IssuerOverrideCreate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 3 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 4 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.WorkloadIdentityX509IssuerOverrideCreate
 */
export const WorkloadIdentityX509IssuerOverrideCreate = new WorkloadIdentityX509IssuerOverrideCreate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkloadIdentityX509IssuerOverrideDelete$Type extends MessageType<WorkloadIdentityX509IssuerOverrideDelete> {
    constructor() {
        super("events.WorkloadIdentityX509IssuerOverrideDelete", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<WorkloadIdentityX509IssuerOverrideDelete>): WorkloadIdentityX509IssuerOverrideDelete {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<WorkloadIdentityX509IssuerOverrideDelete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkloadIdentityX509IssuerOverrideDelete): WorkloadIdentityX509IssuerOverrideDelete {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 3 [json_name = "Connection"];*/ 3:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* events.ResourceMetadata Resource = 4 [json_name = "Resource"];*/ 4:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkloadIdentityX509IssuerOverrideDelete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 3 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 4 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.WorkloadIdentityX509IssuerOverrideDelete
 */
export const WorkloadIdentityX509IssuerOverrideDelete = new WorkloadIdentityX509IssuerOverrideDelete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SigstorePolicyCreate$Type extends MessageType<SigstorePolicyCreate> {
    constructor() {
        super("events.SigstorePolicyCreate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<SigstorePolicyCreate>): SigstorePolicyCreate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SigstorePolicyCreate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SigstorePolicyCreate): SigstorePolicyCreate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 3 [json_name = "Connection"];*/ 3:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* events.ResourceMetadata Resource = 4 [json_name = "Resource"];*/ 4:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SigstorePolicyCreate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 3 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 4 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.SigstorePolicyCreate
 */
export const SigstorePolicyCreate = new SigstorePolicyCreate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SigstorePolicyUpdate$Type extends MessageType<SigstorePolicyUpdate> {
    constructor() {
        super("events.SigstorePolicyUpdate", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<SigstorePolicyUpdate>): SigstorePolicyUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SigstorePolicyUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SigstorePolicyUpdate): SigstorePolicyUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 3 [json_name = "Connection"];*/ 3:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* events.ResourceMetadata Resource = 4 [json_name = "Resource"];*/ 4:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SigstorePolicyUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 3 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 4 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.SigstorePolicyUpdate
 */
export const SigstorePolicyUpdate = new SigstorePolicyUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SigstorePolicyDelete$Type extends MessageType<SigstorePolicyDelete> {
    constructor() {
        super("events.SigstorePolicyDelete", [
            { no: 1, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "User", kind: "message", jsonName: "User", T: () => UserMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 3, name: "Connection", kind: "message", jsonName: "Connection", T: () => ConnectionMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 4, name: "Resource", kind: "message", jsonName: "Resource", T: () => ResourceMetadata, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ]);
    }
    create(value?: PartialMessage<SigstorePolicyDelete>): SigstorePolicyDelete {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SigstorePolicyDelete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SigstorePolicyDelete): SigstorePolicyDelete {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* events.Metadata Metadata = 1 [json_name = "Metadata"];*/ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* events.UserMetadata User = 2 [json_name = "User"];*/ 2:
                    message.user = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* events.ConnectionMetadata Connection = 3 [json_name = "Connection"];*/ 3:
                    message.connection = ConnectionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* events.ResourceMetadata Resource = 4 [json_name = "Resource"];*/ 4:
                    message.resource = ResourceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SigstorePolicyDelete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* events.Metadata Metadata = 1 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* events.UserMetadata User = 2 [json_name = "User"]; */
        if (message.user)
            UserMetadata.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* events.ConnectionMetadata Connection = 3 [json_name = "Connection"]; */
        if (message.connection)
            ConnectionMetadata.internalBinaryWrite(message.connection, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* events.ResourceMetadata Resource = 4 [json_name = "Resource"]; */
        if (message.resource)
            ResourceMetadata.internalBinaryWrite(message.resource, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message events.SigstorePolicyDelete
 */
export const SigstorePolicyDelete = new SigstorePolicyDelete$Type();
