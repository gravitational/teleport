/* eslint-disable */
// @generated by protobuf-ts 2.9.3 with parameter add_pb_suffix,eslint_disable,generate_dependencies,server_grpc1,ts_nocheck
// @generated from protobuf file "teleport/legacy/types/mfa_device.proto" (package "types", syntax proto3)
// tslint:disable
// @ts-nocheck
//
// Copyright 2025 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { BoolValue } from "../../../google/protobuf/wrappers_pb";
import { Timestamp } from "../../../google/protobuf/timestamp_pb";
import { Metadata } from "./metadata_pb";
/**
 * MFADevice is a multi-factor authentication device, such as a security key or
 * an OTP app.
 *
 * @generated from protobuf message types.MFADevice
 */
export interface MFADevice {
    /**
     * Boilerplate for implementing the Resource interface.
     *
     * @generated from protobuf field: string kind = 1;
     */
    kind: string;
    /**
     * @generated from protobuf field: string sub_kind = 2;
     */
    subKind: string;
    /**
     * @generated from protobuf field: string version = 3;
     */
    version: string;
    /**
     * @generated from protobuf field: types.Metadata metadata = 4;
     */
    metadata?: Metadata;
    /**
     * ID is a UUID of this device.
     *
     * @generated from protobuf field: string id = 5;
     */
    id: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp added_at = 6;
     */
    addedAt?: Timestamp;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp last_used = 7;
     */
    lastUsed?: Timestamp;
    /**
     * @generated from protobuf oneof: device
     */
    device: {
        oneofKind: "totp";
        /**
         * @generated from protobuf field: types.TOTPDevice totp = 8;
         */
        totp: TOTPDevice;
    } | {
        oneofKind: "u2F";
        /**
         * @generated from protobuf field: types.U2FDevice u2f = 9 [json_name = "u2f"];
         */
        u2F: U2FDevice;
    } | {
        oneofKind: "webauthn";
        /**
         * @generated from protobuf field: types.WebauthnDevice webauthn = 10;
         */
        webauthn: WebauthnDevice;
    } | {
        oneofKind: "sso";
        /**
         * @generated from protobuf field: types.SSOMFADevice sso = 11;
         */
        sso: SSOMFADevice;
    } | {
        oneofKind: undefined;
    };
}
/**
 * TOTPDevice holds the TOTP-specific fields of MFADevice.
 *
 * @generated from protobuf message types.TOTPDevice
 */
export interface TOTPDevice {
    /**
     * @generated from protobuf field: string key = 1;
     */
    key: string;
}
/**
 * U2FDevice holds the U2F-specific fields of MFADevice.
 *
 * @generated from protobuf message types.U2FDevice
 */
export interface U2FDevice {
    /**
     * KeyHandle uniquely identifies a key on a device
     *
     * @generated from protobuf field: bytes key_handle = 1;
     */
    keyHandle: Uint8Array;
    /**
     * PubKey is an DER encoded ecdsa public key
     *
     * @generated from protobuf field: bytes pub_key = 2;
     */
    pubKey: Uint8Array;
    /**
     * Counter is the latest seen value of the U2F usage counter.
     *
     * @generated from protobuf field: uint32 counter = 3;
     */
    counter: number;
}
/**
 * WebauthnDevice holds Webauthn-specific fields of MFADevice.
 *
 * @generated from protobuf message types.WebauthnDevice
 */
export interface WebauthnDevice {
    /**
     * Credential ID for the authenticator.
     *
     * @generated from protobuf field: bytes credential_id = 1;
     */
    credentialId: Uint8Array;
    /**
     * Public key encoded in CBOR format.
     * Webauthn support various key algorithms; CBOR encoding is used to reflect
     * those choices.
     * See https://w3c.github.io/webauthn/#sctn-alg-identifier for a starter
     * reference.
     *
     * @generated from protobuf field: bytes public_key_cbor = 2;
     */
    publicKeyCbor: Uint8Array;
    /**
     * Attestation format used by the authenticator, if any.
     *
     * @generated from protobuf field: string attestation_type = 3;
     */
    attestationType: string;
    /**
     * AAGUID is the globally unique identifier of the authenticator model.
     * Zeroed for U2F devices.
     *
     * @generated from protobuf field: bytes aaguid = 4;
     */
    aaguid: Uint8Array;
    /**
     * Signature counter for login operations.
     * Actual counter values received from the authenticator are expected to be
     * higher than the previously-stored value.
     *
     * @generated from protobuf field: uint32 signature_counter = 5;
     */
    signatureCounter: number;
    /**
     * Raw attestation object, as returned by the authentication during
     * registration.
     * Absent for legacy entries (Teleport 8.x).
     *
     * @generated from protobuf field: bytes attestation_object = 6;
     */
    attestationObject: Uint8Array;
    /**
     * True if a resident key was requested during registration.
     * Marks passwordless-capable devices.
     * (Note that resident_key=true represents the server-side / Relying Party
     * view of the registration process; the authenticator alone can determine
     * if a key is truly resident.)
     *
     * @generated from protobuf field: bool resident_key = 7;
     */
    residentKey: boolean;
    /**
     * Relying Party ID used by the credential.
     * Recorded on registration for new credentials, or on first successful
     * authentication for "old" credentials (created before the field existed).
     * Ideally, this is always the same as the configured RPID.
     * If an RPID change does happen, this helps Teleport detect it and react
     * accordingly.
     *
     * @generated from protobuf field: string credential_rp_id = 8;
     */
    credentialRpId: string;
    /**
     * Authenticator Backup Eligibility (BE) bit, recorded during registration or
     * backfill (for older authenticators).
     * https://w3c.github.io/webauthn/#authdata-flags-be
     *
     * @generated from protobuf field: google.protobuf.BoolValue credential_backup_eligible = 9;
     */
    credentialBackupEligible?: BoolValue;
    /**
     * Authenticator Backup State (BS) bit, recorded during registration or
     * backfill (for older authenticators).
     * https://w3c.github.io/webauthn/#authdata-flags-bs
     *
     * @generated from protobuf field: google.protobuf.BoolValue credential_backed_up = 10;
     */
    credentialBackedUp?: BoolValue;
}
/**
 * SSOMFADevice contains details of an SSO MFA method.
 *
 * @generated from protobuf message types.SSOMFADevice
 */
export interface SSOMFADevice {
    /**
     * connector_id is the ID of the SSO connector.
     *
     * @generated from protobuf field: string connector_id = 1;
     */
    connectorId: string;
    /**
     * connector_type is the type of the SSO connector.
     *
     * @generated from protobuf field: string connector_type = 2;
     */
    connectorType: string;
    /**
     * display_name is the display name of the SSO connector
     *
     * @generated from protobuf field: string display_name = 3;
     */
    displayName: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class MFADevice$Type extends MessageType<MFADevice> {
    constructor() {
        super("types.MFADevice", [
            { no: 1, name: "kind", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "sub_kind", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "metadata", kind: "message", T: () => Metadata, options: { "gogoproto.nullable": false } },
            { no: 5, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "added_at", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.stdtime": true } },
            { no: 7, name: "last_used", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.stdtime": true } },
            { no: 8, name: "totp", kind: "message", oneof: "device", T: () => TOTPDevice },
            { no: 9, name: "u2f", kind: "message", jsonName: "u2f", oneof: "device", T: () => U2FDevice },
            { no: 10, name: "webauthn", kind: "message", oneof: "device", T: () => WebauthnDevice },
            { no: 11, name: "sso", kind: "message", oneof: "device", T: () => SSOMFADevice }
        ]);
    }
    create(value?: PartialMessage<MFADevice>): MFADevice {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.subKind = "";
        message.version = "";
        message.id = "";
        message.device = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<MFADevice>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MFADevice): MFADevice {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string kind */ 1:
                    message.kind = reader.string();
                    break;
                case /* string sub_kind */ 2:
                    message.subKind = reader.string();
                    break;
                case /* string version */ 3:
                    message.version = reader.string();
                    break;
                case /* types.Metadata metadata */ 4:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* string id */ 5:
                    message.id = reader.string();
                    break;
                case /* google.protobuf.Timestamp added_at */ 6:
                    message.addedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.addedAt);
                    break;
                case /* google.protobuf.Timestamp last_used */ 7:
                    message.lastUsed = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastUsed);
                    break;
                case /* types.TOTPDevice totp */ 8:
                    message.device = {
                        oneofKind: "totp",
                        totp: TOTPDevice.internalBinaryRead(reader, reader.uint32(), options, (message.device as any).totp)
                    };
                    break;
                case /* types.U2FDevice u2f = 9 [json_name = "u2f"];*/ 9:
                    message.device = {
                        oneofKind: "u2F",
                        u2F: U2FDevice.internalBinaryRead(reader, reader.uint32(), options, (message.device as any).u2F)
                    };
                    break;
                case /* types.WebauthnDevice webauthn */ 10:
                    message.device = {
                        oneofKind: "webauthn",
                        webauthn: WebauthnDevice.internalBinaryRead(reader, reader.uint32(), options, (message.device as any).webauthn)
                    };
                    break;
                case /* types.SSOMFADevice sso */ 11:
                    message.device = {
                        oneofKind: "sso",
                        sso: SSOMFADevice.internalBinaryRead(reader, reader.uint32(), options, (message.device as any).sso)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MFADevice, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string kind = 1; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string sub_kind = 2; */
        if (message.subKind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subKind);
        /* string version = 3; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* types.Metadata metadata = 4; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string id = 5; */
        if (message.id !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.id);
        /* google.protobuf.Timestamp added_at = 6; */
        if (message.addedAt)
            Timestamp.internalBinaryWrite(message.addedAt, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp last_used = 7; */
        if (message.lastUsed)
            Timestamp.internalBinaryWrite(message.lastUsed, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* types.TOTPDevice totp = 8; */
        if (message.device.oneofKind === "totp")
            TOTPDevice.internalBinaryWrite(message.device.totp, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* types.U2FDevice u2f = 9 [json_name = "u2f"]; */
        if (message.device.oneofKind === "u2F")
            U2FDevice.internalBinaryWrite(message.device.u2F, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* types.WebauthnDevice webauthn = 10; */
        if (message.device.oneofKind === "webauthn")
            WebauthnDevice.internalBinaryWrite(message.device.webauthn, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* types.SSOMFADevice sso = 11; */
        if (message.device.oneofKind === "sso")
            SSOMFADevice.internalBinaryWrite(message.device.sso, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.MFADevice
 */
export const MFADevice = new MFADevice$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TOTPDevice$Type extends MessageType<TOTPDevice> {
    constructor() {
        super("types.TOTPDevice", [
            { no: 1, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TOTPDevice>): TOTPDevice {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.key = "";
        if (value !== undefined)
            reflectionMergePartial<TOTPDevice>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TOTPDevice): TOTPDevice {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string key */ 1:
                    message.key = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TOTPDevice, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string key = 1; */
        if (message.key !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.key);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.TOTPDevice
 */
export const TOTPDevice = new TOTPDevice$Type();
// @generated message type with reflection information, may provide speed optimized methods
class U2FDevice$Type extends MessageType<U2FDevice> {
    constructor() {
        super("types.U2FDevice", [
            { no: 1, name: "key_handle", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "pub_key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "counter", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<U2FDevice>): U2FDevice {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyHandle = new Uint8Array(0);
        message.pubKey = new Uint8Array(0);
        message.counter = 0;
        if (value !== undefined)
            reflectionMergePartial<U2FDevice>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: U2FDevice): U2FDevice {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes key_handle */ 1:
                    message.keyHandle = reader.bytes();
                    break;
                case /* bytes pub_key */ 2:
                    message.pubKey = reader.bytes();
                    break;
                case /* uint32 counter */ 3:
                    message.counter = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: U2FDevice, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes key_handle = 1; */
        if (message.keyHandle.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.keyHandle);
        /* bytes pub_key = 2; */
        if (message.pubKey.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.pubKey);
        /* uint32 counter = 3; */
        if (message.counter !== 0)
            writer.tag(3, WireType.Varint).uint32(message.counter);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.U2FDevice
 */
export const U2FDevice = new U2FDevice$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WebauthnDevice$Type extends MessageType<WebauthnDevice> {
    constructor() {
        super("types.WebauthnDevice", [
            { no: 1, name: "credential_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "public_key_cbor", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "attestation_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "aaguid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "signature_counter", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "attestation_object", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "resident_key", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "credential_rp_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "credential_backup_eligible", kind: "message", T: () => BoolValue },
            { no: 10, name: "credential_backed_up", kind: "message", T: () => BoolValue }
        ]);
    }
    create(value?: PartialMessage<WebauthnDevice>): WebauthnDevice {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.credentialId = new Uint8Array(0);
        message.publicKeyCbor = new Uint8Array(0);
        message.attestationType = "";
        message.aaguid = new Uint8Array(0);
        message.signatureCounter = 0;
        message.attestationObject = new Uint8Array(0);
        message.residentKey = false;
        message.credentialRpId = "";
        if (value !== undefined)
            reflectionMergePartial<WebauthnDevice>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WebauthnDevice): WebauthnDevice {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes credential_id */ 1:
                    message.credentialId = reader.bytes();
                    break;
                case /* bytes public_key_cbor */ 2:
                    message.publicKeyCbor = reader.bytes();
                    break;
                case /* string attestation_type */ 3:
                    message.attestationType = reader.string();
                    break;
                case /* bytes aaguid */ 4:
                    message.aaguid = reader.bytes();
                    break;
                case /* uint32 signature_counter */ 5:
                    message.signatureCounter = reader.uint32();
                    break;
                case /* bytes attestation_object */ 6:
                    message.attestationObject = reader.bytes();
                    break;
                case /* bool resident_key */ 7:
                    message.residentKey = reader.bool();
                    break;
                case /* string credential_rp_id */ 8:
                    message.credentialRpId = reader.string();
                    break;
                case /* google.protobuf.BoolValue credential_backup_eligible */ 9:
                    message.credentialBackupEligible = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.credentialBackupEligible);
                    break;
                case /* google.protobuf.BoolValue credential_backed_up */ 10:
                    message.credentialBackedUp = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.credentialBackedUp);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WebauthnDevice, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes credential_id = 1; */
        if (message.credentialId.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.credentialId);
        /* bytes public_key_cbor = 2; */
        if (message.publicKeyCbor.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.publicKeyCbor);
        /* string attestation_type = 3; */
        if (message.attestationType !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.attestationType);
        /* bytes aaguid = 4; */
        if (message.aaguid.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.aaguid);
        /* uint32 signature_counter = 5; */
        if (message.signatureCounter !== 0)
            writer.tag(5, WireType.Varint).uint32(message.signatureCounter);
        /* bytes attestation_object = 6; */
        if (message.attestationObject.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.attestationObject);
        /* bool resident_key = 7; */
        if (message.residentKey !== false)
            writer.tag(7, WireType.Varint).bool(message.residentKey);
        /* string credential_rp_id = 8; */
        if (message.credentialRpId !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.credentialRpId);
        /* google.protobuf.BoolValue credential_backup_eligible = 9; */
        if (message.credentialBackupEligible)
            BoolValue.internalBinaryWrite(message.credentialBackupEligible, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.BoolValue credential_backed_up = 10; */
        if (message.credentialBackedUp)
            BoolValue.internalBinaryWrite(message.credentialBackedUp, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.WebauthnDevice
 */
export const WebauthnDevice = new WebauthnDevice$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SSOMFADevice$Type extends MessageType<SSOMFADevice> {
    constructor() {
        super("types.SSOMFADevice", [
            { no: 1, name: "connector_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "connector_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "display_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SSOMFADevice>): SSOMFADevice {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.connectorId = "";
        message.connectorType = "";
        message.displayName = "";
        if (value !== undefined)
            reflectionMergePartial<SSOMFADevice>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SSOMFADevice): SSOMFADevice {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string connector_id */ 1:
                    message.connectorId = reader.string();
                    break;
                case /* string connector_type */ 2:
                    message.connectorType = reader.string();
                    break;
                case /* string display_name */ 3:
                    message.displayName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SSOMFADevice, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string connector_id = 1; */
        if (message.connectorId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.connectorId);
        /* string connector_type = 2; */
        if (message.connectorType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.connectorType);
        /* string display_name = 3; */
        if (message.displayName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.displayName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.SSOMFADevice
 */
export const SSOMFADevice = new SSOMFADevice$Type();
