/* eslint-disable */
// @generated by protobuf-ts 2.9.3 with parameter eslint_disable,add_pb_suffix,server_grpc1,ts_nocheck
// @generated from protobuf file "teleport/legacy/types/webauthn/webauthn.proto" (package "webauthn", syntax proto3)
// tslint:disable
// @ts-nocheck
//
// Copyright 2021 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
// -----------------------------------------------------------------------------
// Assertion (aka login).
// -----------------------------------------------------------------------------

/**
 * Credential assertion used for login ceremonies.
 *
 * @generated from protobuf message webauthn.CredentialAssertion
 */
export interface CredentialAssertion {
    /**
     * @generated from protobuf field: webauthn.PublicKeyCredentialRequestOptions public_key = 1;
     */
    publicKey?: PublicKeyCredentialRequestOptions;
}
/**
 * Request options necessary for credential assertions, aka login ceremonies.
 * See https://www.w3.org/TR/webauthn-2/#dictionary-assertion-options or
 * refer to navigator.credentials.get in your browser.
 *
 * @generated from protobuf message webauthn.PublicKeyCredentialRequestOptions
 */
export interface PublicKeyCredentialRequestOptions {
    /**
     * Raw challenge used for assertion.
     *
     * @generated from protobuf field: bytes challenge = 1;
     */
    challenge: Uint8Array;
    /**
     * Timeout in milliseconds.
     *
     * @generated from protobuf field: int64 timeout_ms = 2;
     */
    timeoutMs: bigint;
    /**
     * Relying Party ID.
     *
     * @generated from protobuf field: string rp_id = 3;
     */
    rpId: string;
    /**
     * Allowed credentials for assertion.
     *
     * @generated from protobuf field: repeated webauthn.CredentialDescriptor allow_credentials = 4;
     */
    allowCredentials: CredentialDescriptor[];
    /**
     * Extensions supplied by the Relying Party.
     *
     * @generated from protobuf field: webauthn.AuthenticationExtensionsClientInputs extensions = 5;
     */
    extensions?: AuthenticationExtensionsClientInputs;
    /**
     * User verification requirement.
     *
     * @generated from protobuf field: string user_verification = 6;
     */
    userVerification: string;
}
/**
 * Assertion response returned by the authenticator.
 * Refer to navigator.credentials.get in your browser.
 *
 * Note: assertion responses return both "rawId" and "id" (RawURLEncoding of
 * "id"), but it seemed pointless to have both here.
 *
 * @generated from protobuf message webauthn.CredentialAssertionResponse
 */
export interface CredentialAssertionResponse {
    /**
     * Type of the credential, usually "public-key".
     *
     * @generated from protobuf field: string type = 1;
     */
    type: string;
    /**
     * Raw Credential ID.
     *
     * @generated from protobuf field: bytes raw_id = 2;
     */
    rawId: Uint8Array;
    /**
     * Assertion response from the authenticator.
     *
     * @generated from protobuf field: webauthn.AuthenticatorAssertionResponse response = 3;
     */
    response?: AuthenticatorAssertionResponse;
    /**
     * Extensions supplied by the authenticator.
     *
     * @generated from protobuf field: webauthn.AuthenticationExtensionsClientOutputs extensions = 4;
     */
    extensions?: AuthenticationExtensionsClientOutputs;
}
/**
 * Authenticator assertion response.
 * https://www.w3.org/TR/webauthn-2/#authenticatorassertionresponse
 *
 * @generated from protobuf message webauthn.AuthenticatorAssertionResponse
 */
export interface AuthenticatorAssertionResponse {
    /**
     * Raw client data JSON, exactly as signed by the authenticator.
     * https://www.w3.org/TR/webauthn-2/#dictdef-collectedclientdata.
     *
     * @generated from protobuf field: bytes client_data_json = 1;
     */
    clientDataJson: Uint8Array;
    /**
     * Raw authenticator data, exactly as signed by the authenticator.
     * https://www.w3.org/TR/webauthn-2/#sctn-authenticator-data.
     *
     * @generated from protobuf field: bytes authenticator_data = 2;
     */
    authenticatorData: Uint8Array;
    /**
     * Raw assertion signature performed authenticatorData|clientDataJSON.
     * https://www.w3.org/TR/webauthn-2/#assertion-signature.
     *
     * @generated from protobuf field: bytes signature = 3;
     */
    signature: Uint8Array;
    /**
     * Raw user handle returned by the authenticator, if any.
     *
     * @generated from protobuf field: bytes user_handle = 4;
     */
    userHandle: Uint8Array;
}
// -----------------------------------------------------------------------------
// Creation (aka registration).
// -----------------------------------------------------------------------------

/**
 * Credential creation used for registration ceremonies.
 *
 * @generated from protobuf message webauthn.CredentialCreation
 */
export interface CredentialCreation {
    /**
     * @generated from protobuf field: webauthn.PublicKeyCredentialCreationOptions public_key = 1;
     */
    publicKey?: PublicKeyCredentialCreationOptions;
}
/**
 * Request options necessary for credential creation, aka registration
 * ceremonies.
 * See
 * https://www.w3.org/TR/webauthn-2/#dictdef-publickeycredentialcreationoptions
 * or refer to navigator.credentials.create in your browser.
 *
 * @generated from protobuf message webauthn.PublicKeyCredentialCreationOptions
 */
export interface PublicKeyCredentialCreationOptions {
    /**
     * Raw challenge used for creation.
     *
     * @generated from protobuf field: bytes challenge = 1;
     */
    challenge: Uint8Array;
    /**
     * Relying party information.
     *
     * @generated from protobuf field: webauthn.RelyingPartyEntity rp = 2;
     */
    rp?: RelyingPartyEntity;
    /**
     * User information.
     *
     * @generated from protobuf field: webauthn.UserEntity user = 3;
     */
    user?: UserEntity;
    /**
     * Desired properties for the credential to be created, from most to least
     * preferred.
     *
     * @generated from protobuf field: repeated webauthn.CredentialParameter credential_parameters = 4;
     */
    credentialParameters: CredentialParameter[];
    /**
     * Timeout in milliseconds.
     *
     * @generated from protobuf field: int64 timeout_ms = 5;
     */
    timeoutMs: bigint;
    /**
     * Credentials excluded from the ceremony.
     *
     * @generated from protobuf field: repeated webauthn.CredentialDescriptor exclude_credentials = 6;
     */
    excludeCredentials: CredentialDescriptor[];
    /**
     * Attestation requested, defaulting to "none".
     * https://www.w3.org/TR/webauthn-2/#enumdef-attestationconveyancepreference.
     *
     * @generated from protobuf field: string attestation = 7;
     */
    attestation: string;
    /**
     * Extensions supplied by the Relying Party.
     *
     * @generated from protobuf field: webauthn.AuthenticationExtensionsClientInputs extensions = 8;
     */
    extensions?: AuthenticationExtensionsClientInputs;
    /**
     * Authenticator selection criteria for the new credential.
     *
     * @generated from protobuf field: webauthn.AuthenticatorSelection authenticator_selection = 9;
     */
    authenticatorSelection?: AuthenticatorSelection;
}
/**
 * Credential creation response returned by the authenticator.
 * Refer to navigator.credentials.create in your browser.
 *
 * Note: creation responses return both "rawId" and "id" (RawURLEncoding of
 * "id"), but it seemed pointless to have both here.
 *
 * @generated from protobuf message webauthn.CredentialCreationResponse
 */
export interface CredentialCreationResponse {
    /**
     * Type of the credential, usually "public-key".
     *
     * @generated from protobuf field: string type = 1;
     */
    type: string;
    /**
     * Raw Credential ID.
     *
     * @generated from protobuf field: bytes raw_id = 2;
     */
    rawId: Uint8Array;
    /**
     * Attestation response from the authenticator.
     *
     * @generated from protobuf field: webauthn.AuthenticatorAttestationResponse response = 3;
     */
    response?: AuthenticatorAttestationResponse;
    /**
     * Extensions supplied by the authenticator.
     *
     * @generated from protobuf field: webauthn.AuthenticationExtensionsClientOutputs extensions = 4;
     */
    extensions?: AuthenticationExtensionsClientOutputs;
}
/**
 * Attestation response from the authentication, ie, the response to a
 * credential creation request.
 * https://www.w3.org/TR/webauthn-2/#authenticatorattestationresponse.
 *
 * @generated from protobuf message webauthn.AuthenticatorAttestationResponse
 */
export interface AuthenticatorAttestationResponse {
    /**
     * Raw client data JSON, exactly as signed by the authenticator.
     * https://www.w3.org/TR/webauthn-2/#dictdef-collectedclientdata.
     *
     * @generated from protobuf field: bytes client_data_json = 1;
     */
    clientDataJson: Uint8Array;
    /**
     * Raw attestation object.
     * https://www.w3.org/TR/webauthn-2/#attestation-object
     *
     * @generated from protobuf field: bytes attestation_object = 2;
     */
    attestationObject: Uint8Array;
}
// -----------------------------------------------------------------------------
// Common WebAuthn objects.
// -----------------------------------------------------------------------------

/**
 * Extensions supplied by the Relying Party during credential assertion or
 * creation.
 * https://www.w3.org/TR/webauthn-2/#client-extension-input
 *
 * @generated from protobuf message webauthn.AuthenticationExtensionsClientInputs
 */
export interface AuthenticationExtensionsClientInputs {
    /**
     * U2F application ID to be used by the authenticator, if any.
     * Only available if using U2F compatibility mode.
     * https://www.w3.org/TR/webauthn-2/#sctn-appid-extension.
     *
     * @generated from protobuf field: string app_id = 1;
     */
    appId: string;
    /**
     * Enables the credProps extension.
     * https://w3c.github.io/webauthn/#sctn-authenticator-credential-properties-extension
     *
     * @generated from protobuf field: bool cred_props = 2;
     */
    credProps: boolean;
}
/**
 * Extensions supplied by the authenticator to the Relying Party, during
 * credential assertion or creation.
 * https://www.w3.org/TR/webauthn-2/#client-extension-output.
 *
 * @generated from protobuf message webauthn.AuthenticationExtensionsClientOutputs
 */
export interface AuthenticationExtensionsClientOutputs {
    /**
     * If true, the AppID extension was used by the authenticator, which changes
     * the rpIdHash accordingly.
     * https://www.w3.org/TR/webauthn-2/#sctn-appid-extension.
     *
     * @generated from protobuf field: bool app_id = 1;
     */
    appId: boolean;
    /**
     * Credential properties per credProps extension.
     * https://w3c.github.io/webauthn/#sctn-authenticator-credential-properties-extension.
     *
     * @generated from protobuf field: webauthn.CredentialPropertiesOutput cred_props = 2;
     */
    credProps?: CredentialPropertiesOutput;
}
/**
 * CredentialPropertiesOutput is the output of the credProps extension.
 *
 * @generated from protobuf message webauthn.CredentialPropertiesOutput
 */
export interface CredentialPropertiesOutput {
    /**
     * If true, the created credential is a resident key (regardless of the
     * AuthenticatorSelection.require_resident_key value).
     * OPTIONAL by specification.
     *
     * @generated from protobuf field: bool rk = 1;
     */
    rk: boolean;
}
/**
 * Authenticator selection criteria.
 * Restricts the choice of authenticator for credential creation.
 *
 * @generated from protobuf message webauthn.AuthenticatorSelection
 */
export interface AuthenticatorSelection {
    /**
     * Authenticator attachment, empty means no particular attachment is
     * required.
     *
     * @generated from protobuf field: string authenticator_attachment = 1;
     */
    authenticatorAttachment: string;
    /**
     * Resident key requirement, if true the authenticator must create a resident
     * key.
     *
     * @generated from protobuf field: bool require_resident_key = 2;
     */
    requireResidentKey: boolean;
    /**
     * User verification requirement for authenticators.
     *
     * @generated from protobuf field: string user_verification = 3;
     */
    userVerification: string;
}
/**
 * Public key credential descriptor.
 * https://www.w3.org/TR/webauthn-2/#dictdef-publickeycredentialdescriptor.
 *
 * @generated from protobuf message webauthn.CredentialDescriptor
 */
export interface CredentialDescriptor {
    /**
     * Type of the credential, usually "public-key".
     *
     * @generated from protobuf field: string type = 1;
     */
    type: string;
    /**
     * Raw Credential ID.
     *
     * @generated from protobuf field: bytes id = 2;
     */
    id: Uint8Array;
}
/**
 * Parameters for credential creation.
 * https://www.w3.org/TR/webauthn-2/#dictdef-publickeycredentialparameters.
 *
 * @generated from protobuf message webauthn.CredentialParameter
 */
export interface CredentialParameter {
    /**
     * Credential type, usually "public-key".
     * https://www.w3.org/TR/webauthn-2/#enumdef-publickeycredentialtype.
     *
     * @generated from protobuf field: string type = 1;
     */
    type: string;
    /**
     * COSE algorithm specifier.
     * Most authenticators support exclusively ES256(-7).
     * https://www.w3.org/TR/webauthn-2/#typedefdef-cosealgorithmidentifier.
     *
     * @generated from protobuf field: int32 alg = 2;
     */
    alg: number;
}
/**
 * Relying Party information.
 * See https://www.w3.org/TR/webauthn-2/#dictdef-publickeycredentialrpentity and
 * https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialCreationOptions/rp.
 *
 * @generated from protobuf message webauthn.RelyingPartyEntity
 */
export interface RelyingPartyEntity {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
}
/**
 * User information.
 * See https://www.w3.org/TR/webauthn-2/#dictdef-publickeycredentialuserentity
 * and
 * https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialCreationOptions/user.
 *
 * @generated from protobuf message webauthn.UserEntity
 */
export interface UserEntity {
    /**
     * Raw ID of the user.
     *
     * @generated from protobuf field: bytes id = 1;
     */
    id: Uint8Array;
    /**
     * Human-palatable name for a user account.
     * The Relying Party _may_ let the user choose this value.
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * Human-palatable name for the user account, intended only for display.
     * The Relying Party _should_ let the user choose this value.
     *
     * @generated from protobuf field: string display_name = 3;
     */
    displayName: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class CredentialAssertion$Type extends MessageType<CredentialAssertion> {
    constructor() {
        super("webauthn.CredentialAssertion", [
            { no: 1, name: "public_key", kind: "message", T: () => PublicKeyCredentialRequestOptions }
        ]);
    }
    create(value?: PartialMessage<CredentialAssertion>): CredentialAssertion {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CredentialAssertion>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CredentialAssertion): CredentialAssertion {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* webauthn.PublicKeyCredentialRequestOptions public_key */ 1:
                    message.publicKey = PublicKeyCredentialRequestOptions.internalBinaryRead(reader, reader.uint32(), options, message.publicKey);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CredentialAssertion, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* webauthn.PublicKeyCredentialRequestOptions public_key = 1; */
        if (message.publicKey)
            PublicKeyCredentialRequestOptions.internalBinaryWrite(message.publicKey, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message webauthn.CredentialAssertion
 */
export const CredentialAssertion = new CredentialAssertion$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublicKeyCredentialRequestOptions$Type extends MessageType<PublicKeyCredentialRequestOptions> {
    constructor() {
        super("webauthn.PublicKeyCredentialRequestOptions", [
            { no: 1, name: "challenge", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "timeout_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "rp_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "allow_credentials", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CredentialDescriptor },
            { no: 5, name: "extensions", kind: "message", T: () => AuthenticationExtensionsClientInputs },
            { no: 6, name: "user_verification", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PublicKeyCredentialRequestOptions>): PublicKeyCredentialRequestOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.challenge = new Uint8Array(0);
        message.timeoutMs = 0n;
        message.rpId = "";
        message.allowCredentials = [];
        message.userVerification = "";
        if (value !== undefined)
            reflectionMergePartial<PublicKeyCredentialRequestOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublicKeyCredentialRequestOptions): PublicKeyCredentialRequestOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes challenge */ 1:
                    message.challenge = reader.bytes();
                    break;
                case /* int64 timeout_ms */ 2:
                    message.timeoutMs = reader.int64().toBigInt();
                    break;
                case /* string rp_id */ 3:
                    message.rpId = reader.string();
                    break;
                case /* repeated webauthn.CredentialDescriptor allow_credentials */ 4:
                    message.allowCredentials.push(CredentialDescriptor.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* webauthn.AuthenticationExtensionsClientInputs extensions */ 5:
                    message.extensions = AuthenticationExtensionsClientInputs.internalBinaryRead(reader, reader.uint32(), options, message.extensions);
                    break;
                case /* string user_verification */ 6:
                    message.userVerification = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublicKeyCredentialRequestOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes challenge = 1; */
        if (message.challenge.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.challenge);
        /* int64 timeout_ms = 2; */
        if (message.timeoutMs !== 0n)
            writer.tag(2, WireType.Varint).int64(message.timeoutMs);
        /* string rp_id = 3; */
        if (message.rpId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.rpId);
        /* repeated webauthn.CredentialDescriptor allow_credentials = 4; */
        for (let i = 0; i < message.allowCredentials.length; i++)
            CredentialDescriptor.internalBinaryWrite(message.allowCredentials[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* webauthn.AuthenticationExtensionsClientInputs extensions = 5; */
        if (message.extensions)
            AuthenticationExtensionsClientInputs.internalBinaryWrite(message.extensions, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string user_verification = 6; */
        if (message.userVerification !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.userVerification);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message webauthn.PublicKeyCredentialRequestOptions
 */
export const PublicKeyCredentialRequestOptions = new PublicKeyCredentialRequestOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CredentialAssertionResponse$Type extends MessageType<CredentialAssertionResponse> {
    constructor() {
        super("webauthn.CredentialAssertionResponse", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "raw_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "response", kind: "message", T: () => AuthenticatorAssertionResponse },
            { no: 4, name: "extensions", kind: "message", T: () => AuthenticationExtensionsClientOutputs }
        ]);
    }
    create(value?: PartialMessage<CredentialAssertionResponse>): CredentialAssertionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        message.rawId = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<CredentialAssertionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CredentialAssertionResponse): CredentialAssertionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* bytes raw_id */ 2:
                    message.rawId = reader.bytes();
                    break;
                case /* webauthn.AuthenticatorAssertionResponse response */ 3:
                    message.response = AuthenticatorAssertionResponse.internalBinaryRead(reader, reader.uint32(), options, message.response);
                    break;
                case /* webauthn.AuthenticationExtensionsClientOutputs extensions */ 4:
                    message.extensions = AuthenticationExtensionsClientOutputs.internalBinaryRead(reader, reader.uint32(), options, message.extensions);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CredentialAssertionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* bytes raw_id = 2; */
        if (message.rawId.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.rawId);
        /* webauthn.AuthenticatorAssertionResponse response = 3; */
        if (message.response)
            AuthenticatorAssertionResponse.internalBinaryWrite(message.response, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* webauthn.AuthenticationExtensionsClientOutputs extensions = 4; */
        if (message.extensions)
            AuthenticationExtensionsClientOutputs.internalBinaryWrite(message.extensions, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message webauthn.CredentialAssertionResponse
 */
export const CredentialAssertionResponse = new CredentialAssertionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthenticatorAssertionResponse$Type extends MessageType<AuthenticatorAssertionResponse> {
    constructor() {
        super("webauthn.AuthenticatorAssertionResponse", [
            { no: 1, name: "client_data_json", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "authenticator_data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "signature", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "user_handle", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<AuthenticatorAssertionResponse>): AuthenticatorAssertionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clientDataJson = new Uint8Array(0);
        message.authenticatorData = new Uint8Array(0);
        message.signature = new Uint8Array(0);
        message.userHandle = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<AuthenticatorAssertionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthenticatorAssertionResponse): AuthenticatorAssertionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes client_data_json */ 1:
                    message.clientDataJson = reader.bytes();
                    break;
                case /* bytes authenticator_data */ 2:
                    message.authenticatorData = reader.bytes();
                    break;
                case /* bytes signature */ 3:
                    message.signature = reader.bytes();
                    break;
                case /* bytes user_handle */ 4:
                    message.userHandle = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthenticatorAssertionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes client_data_json = 1; */
        if (message.clientDataJson.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.clientDataJson);
        /* bytes authenticator_data = 2; */
        if (message.authenticatorData.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.authenticatorData);
        /* bytes signature = 3; */
        if (message.signature.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.signature);
        /* bytes user_handle = 4; */
        if (message.userHandle.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.userHandle);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message webauthn.AuthenticatorAssertionResponse
 */
export const AuthenticatorAssertionResponse = new AuthenticatorAssertionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CredentialCreation$Type extends MessageType<CredentialCreation> {
    constructor() {
        super("webauthn.CredentialCreation", [
            { no: 1, name: "public_key", kind: "message", T: () => PublicKeyCredentialCreationOptions }
        ]);
    }
    create(value?: PartialMessage<CredentialCreation>): CredentialCreation {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CredentialCreation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CredentialCreation): CredentialCreation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* webauthn.PublicKeyCredentialCreationOptions public_key */ 1:
                    message.publicKey = PublicKeyCredentialCreationOptions.internalBinaryRead(reader, reader.uint32(), options, message.publicKey);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CredentialCreation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* webauthn.PublicKeyCredentialCreationOptions public_key = 1; */
        if (message.publicKey)
            PublicKeyCredentialCreationOptions.internalBinaryWrite(message.publicKey, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message webauthn.CredentialCreation
 */
export const CredentialCreation = new CredentialCreation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublicKeyCredentialCreationOptions$Type extends MessageType<PublicKeyCredentialCreationOptions> {
    constructor() {
        super("webauthn.PublicKeyCredentialCreationOptions", [
            { no: 1, name: "challenge", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "rp", kind: "message", T: () => RelyingPartyEntity },
            { no: 3, name: "user", kind: "message", T: () => UserEntity },
            { no: 4, name: "credential_parameters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CredentialParameter },
            { no: 5, name: "timeout_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "exclude_credentials", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CredentialDescriptor },
            { no: 7, name: "attestation", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "extensions", kind: "message", T: () => AuthenticationExtensionsClientInputs },
            { no: 9, name: "authenticator_selection", kind: "message", T: () => AuthenticatorSelection }
        ]);
    }
    create(value?: PartialMessage<PublicKeyCredentialCreationOptions>): PublicKeyCredentialCreationOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.challenge = new Uint8Array(0);
        message.credentialParameters = [];
        message.timeoutMs = 0n;
        message.excludeCredentials = [];
        message.attestation = "";
        if (value !== undefined)
            reflectionMergePartial<PublicKeyCredentialCreationOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublicKeyCredentialCreationOptions): PublicKeyCredentialCreationOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes challenge */ 1:
                    message.challenge = reader.bytes();
                    break;
                case /* webauthn.RelyingPartyEntity rp */ 2:
                    message.rp = RelyingPartyEntity.internalBinaryRead(reader, reader.uint32(), options, message.rp);
                    break;
                case /* webauthn.UserEntity user */ 3:
                    message.user = UserEntity.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* repeated webauthn.CredentialParameter credential_parameters */ 4:
                    message.credentialParameters.push(CredentialParameter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int64 timeout_ms */ 5:
                    message.timeoutMs = reader.int64().toBigInt();
                    break;
                case /* repeated webauthn.CredentialDescriptor exclude_credentials */ 6:
                    message.excludeCredentials.push(CredentialDescriptor.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string attestation */ 7:
                    message.attestation = reader.string();
                    break;
                case /* webauthn.AuthenticationExtensionsClientInputs extensions */ 8:
                    message.extensions = AuthenticationExtensionsClientInputs.internalBinaryRead(reader, reader.uint32(), options, message.extensions);
                    break;
                case /* webauthn.AuthenticatorSelection authenticator_selection */ 9:
                    message.authenticatorSelection = AuthenticatorSelection.internalBinaryRead(reader, reader.uint32(), options, message.authenticatorSelection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublicKeyCredentialCreationOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes challenge = 1; */
        if (message.challenge.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.challenge);
        /* webauthn.RelyingPartyEntity rp = 2; */
        if (message.rp)
            RelyingPartyEntity.internalBinaryWrite(message.rp, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* webauthn.UserEntity user = 3; */
        if (message.user)
            UserEntity.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated webauthn.CredentialParameter credential_parameters = 4; */
        for (let i = 0; i < message.credentialParameters.length; i++)
            CredentialParameter.internalBinaryWrite(message.credentialParameters[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* int64 timeout_ms = 5; */
        if (message.timeoutMs !== 0n)
            writer.tag(5, WireType.Varint).int64(message.timeoutMs);
        /* repeated webauthn.CredentialDescriptor exclude_credentials = 6; */
        for (let i = 0; i < message.excludeCredentials.length; i++)
            CredentialDescriptor.internalBinaryWrite(message.excludeCredentials[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* string attestation = 7; */
        if (message.attestation !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.attestation);
        /* webauthn.AuthenticationExtensionsClientInputs extensions = 8; */
        if (message.extensions)
            AuthenticationExtensionsClientInputs.internalBinaryWrite(message.extensions, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* webauthn.AuthenticatorSelection authenticator_selection = 9; */
        if (message.authenticatorSelection)
            AuthenticatorSelection.internalBinaryWrite(message.authenticatorSelection, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message webauthn.PublicKeyCredentialCreationOptions
 */
export const PublicKeyCredentialCreationOptions = new PublicKeyCredentialCreationOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CredentialCreationResponse$Type extends MessageType<CredentialCreationResponse> {
    constructor() {
        super("webauthn.CredentialCreationResponse", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "raw_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "response", kind: "message", T: () => AuthenticatorAttestationResponse },
            { no: 4, name: "extensions", kind: "message", T: () => AuthenticationExtensionsClientOutputs }
        ]);
    }
    create(value?: PartialMessage<CredentialCreationResponse>): CredentialCreationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        message.rawId = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<CredentialCreationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CredentialCreationResponse): CredentialCreationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* bytes raw_id */ 2:
                    message.rawId = reader.bytes();
                    break;
                case /* webauthn.AuthenticatorAttestationResponse response */ 3:
                    message.response = AuthenticatorAttestationResponse.internalBinaryRead(reader, reader.uint32(), options, message.response);
                    break;
                case /* webauthn.AuthenticationExtensionsClientOutputs extensions */ 4:
                    message.extensions = AuthenticationExtensionsClientOutputs.internalBinaryRead(reader, reader.uint32(), options, message.extensions);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CredentialCreationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* bytes raw_id = 2; */
        if (message.rawId.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.rawId);
        /* webauthn.AuthenticatorAttestationResponse response = 3; */
        if (message.response)
            AuthenticatorAttestationResponse.internalBinaryWrite(message.response, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* webauthn.AuthenticationExtensionsClientOutputs extensions = 4; */
        if (message.extensions)
            AuthenticationExtensionsClientOutputs.internalBinaryWrite(message.extensions, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message webauthn.CredentialCreationResponse
 */
export const CredentialCreationResponse = new CredentialCreationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthenticatorAttestationResponse$Type extends MessageType<AuthenticatorAttestationResponse> {
    constructor() {
        super("webauthn.AuthenticatorAttestationResponse", [
            { no: 1, name: "client_data_json", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "attestation_object", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<AuthenticatorAttestationResponse>): AuthenticatorAttestationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clientDataJson = new Uint8Array(0);
        message.attestationObject = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<AuthenticatorAttestationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthenticatorAttestationResponse): AuthenticatorAttestationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes client_data_json */ 1:
                    message.clientDataJson = reader.bytes();
                    break;
                case /* bytes attestation_object */ 2:
                    message.attestationObject = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthenticatorAttestationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes client_data_json = 1; */
        if (message.clientDataJson.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.clientDataJson);
        /* bytes attestation_object = 2; */
        if (message.attestationObject.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.attestationObject);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message webauthn.AuthenticatorAttestationResponse
 */
export const AuthenticatorAttestationResponse = new AuthenticatorAttestationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthenticationExtensionsClientInputs$Type extends MessageType<AuthenticationExtensionsClientInputs> {
    constructor() {
        super("webauthn.AuthenticationExtensionsClientInputs", [
            { no: 1, name: "app_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cred_props", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<AuthenticationExtensionsClientInputs>): AuthenticationExtensionsClientInputs {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.appId = "";
        message.credProps = false;
        if (value !== undefined)
            reflectionMergePartial<AuthenticationExtensionsClientInputs>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthenticationExtensionsClientInputs): AuthenticationExtensionsClientInputs {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string app_id */ 1:
                    message.appId = reader.string();
                    break;
                case /* bool cred_props */ 2:
                    message.credProps = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthenticationExtensionsClientInputs, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string app_id = 1; */
        if (message.appId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.appId);
        /* bool cred_props = 2; */
        if (message.credProps !== false)
            writer.tag(2, WireType.Varint).bool(message.credProps);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message webauthn.AuthenticationExtensionsClientInputs
 */
export const AuthenticationExtensionsClientInputs = new AuthenticationExtensionsClientInputs$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthenticationExtensionsClientOutputs$Type extends MessageType<AuthenticationExtensionsClientOutputs> {
    constructor() {
        super("webauthn.AuthenticationExtensionsClientOutputs", [
            { no: 1, name: "app_id", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "cred_props", kind: "message", T: () => CredentialPropertiesOutput }
        ]);
    }
    create(value?: PartialMessage<AuthenticationExtensionsClientOutputs>): AuthenticationExtensionsClientOutputs {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.appId = false;
        if (value !== undefined)
            reflectionMergePartial<AuthenticationExtensionsClientOutputs>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthenticationExtensionsClientOutputs): AuthenticationExtensionsClientOutputs {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool app_id */ 1:
                    message.appId = reader.bool();
                    break;
                case /* webauthn.CredentialPropertiesOutput cred_props */ 2:
                    message.credProps = CredentialPropertiesOutput.internalBinaryRead(reader, reader.uint32(), options, message.credProps);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthenticationExtensionsClientOutputs, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool app_id = 1; */
        if (message.appId !== false)
            writer.tag(1, WireType.Varint).bool(message.appId);
        /* webauthn.CredentialPropertiesOutput cred_props = 2; */
        if (message.credProps)
            CredentialPropertiesOutput.internalBinaryWrite(message.credProps, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message webauthn.AuthenticationExtensionsClientOutputs
 */
export const AuthenticationExtensionsClientOutputs = new AuthenticationExtensionsClientOutputs$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CredentialPropertiesOutput$Type extends MessageType<CredentialPropertiesOutput> {
    constructor() {
        super("webauthn.CredentialPropertiesOutput", [
            { no: 1, name: "rk", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CredentialPropertiesOutput>): CredentialPropertiesOutput {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rk = false;
        if (value !== undefined)
            reflectionMergePartial<CredentialPropertiesOutput>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CredentialPropertiesOutput): CredentialPropertiesOutput {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool rk */ 1:
                    message.rk = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CredentialPropertiesOutput, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool rk = 1; */
        if (message.rk !== false)
            writer.tag(1, WireType.Varint).bool(message.rk);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message webauthn.CredentialPropertiesOutput
 */
export const CredentialPropertiesOutput = new CredentialPropertiesOutput$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthenticatorSelection$Type extends MessageType<AuthenticatorSelection> {
    constructor() {
        super("webauthn.AuthenticatorSelection", [
            { no: 1, name: "authenticator_attachment", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "require_resident_key", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "user_verification", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AuthenticatorSelection>): AuthenticatorSelection {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.authenticatorAttachment = "";
        message.requireResidentKey = false;
        message.userVerification = "";
        if (value !== undefined)
            reflectionMergePartial<AuthenticatorSelection>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthenticatorSelection): AuthenticatorSelection {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string authenticator_attachment */ 1:
                    message.authenticatorAttachment = reader.string();
                    break;
                case /* bool require_resident_key */ 2:
                    message.requireResidentKey = reader.bool();
                    break;
                case /* string user_verification */ 3:
                    message.userVerification = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthenticatorSelection, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string authenticator_attachment = 1; */
        if (message.authenticatorAttachment !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.authenticatorAttachment);
        /* bool require_resident_key = 2; */
        if (message.requireResidentKey !== false)
            writer.tag(2, WireType.Varint).bool(message.requireResidentKey);
        /* string user_verification = 3; */
        if (message.userVerification !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.userVerification);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message webauthn.AuthenticatorSelection
 */
export const AuthenticatorSelection = new AuthenticatorSelection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CredentialDescriptor$Type extends MessageType<CredentialDescriptor> {
    constructor() {
        super("webauthn.CredentialDescriptor", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CredentialDescriptor>): CredentialDescriptor {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        message.id = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<CredentialDescriptor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CredentialDescriptor): CredentialDescriptor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* bytes id */ 2:
                    message.id = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CredentialDescriptor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* bytes id = 2; */
        if (message.id.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message webauthn.CredentialDescriptor
 */
export const CredentialDescriptor = new CredentialDescriptor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CredentialParameter$Type extends MessageType<CredentialParameter> {
    constructor() {
        super("webauthn.CredentialParameter", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "alg", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CredentialParameter>): CredentialParameter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        message.alg = 0;
        if (value !== undefined)
            reflectionMergePartial<CredentialParameter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CredentialParameter): CredentialParameter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* int32 alg */ 2:
                    message.alg = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CredentialParameter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* int32 alg = 2; */
        if (message.alg !== 0)
            writer.tag(2, WireType.Varint).int32(message.alg);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message webauthn.CredentialParameter
 */
export const CredentialParameter = new CredentialParameter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RelyingPartyEntity$Type extends MessageType<RelyingPartyEntity> {
    constructor() {
        super("webauthn.RelyingPartyEntity", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RelyingPartyEntity>): RelyingPartyEntity {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<RelyingPartyEntity>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RelyingPartyEntity): RelyingPartyEntity {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RelyingPartyEntity, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message webauthn.RelyingPartyEntity
 */
export const RelyingPartyEntity = new RelyingPartyEntity$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserEntity$Type extends MessageType<UserEntity> {
    constructor() {
        super("webauthn.UserEntity", [
            { no: 1, name: "id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "display_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UserEntity>): UserEntity {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = new Uint8Array(0);
        message.name = "";
        message.displayName = "";
        if (value !== undefined)
            reflectionMergePartial<UserEntity>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserEntity): UserEntity {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes id */ 1:
                    message.id = reader.bytes();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string display_name */ 3:
                    message.displayName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserEntity, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes id = 1; */
        if (message.id.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string display_name = 3; */
        if (message.displayName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.displayName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message webauthn.UserEntity
 */
export const UserEntity = new UserEntity$Type();
