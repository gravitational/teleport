/* eslint-disable */
// @generated by protobuf-ts 2.9.3 with parameter eslint_disable,add_pb_suffix,server_grpc1,ts_nocheck
// @generated from protobuf file "teleport/legacy/types/types.proto" (package "types", syntax proto3)
// tslint:disable
// @ts-nocheck
//
// Copyright 2021 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { CustomType } from "./wrappers/wrappers_pb";
import { AttestationStatement } from "../../attestation/v1/attestation_pb";
import { TrustedDeviceRequirement } from "./trusted_device_requirement_pb";
import { BoolValue as BoolValue$ } from "../../../google/protobuf/wrappers_pb";
import { StringValues } from "./wrappers/wrappers_pb";
import { LabelValues } from "./wrappers/wrappers_pb";
import { Duration } from "../../../google/protobuf/duration_pb";
import { Timestamp } from "../../../google/protobuf/timestamp_pb";
/**
 * @generated from protobuf message types.KeepAlive
 */
export interface KeepAlive {
    /**
     * Name of the resource to keep alive.
     *
     * @generated from protobuf field: string Name = 1 [json_name = "Name"];
     */
    name: string;
    /**
     * Namespace is the namespace of the resource.
     *
     * @generated from protobuf field: string Namespace = 2 [json_name = "Namespace"];
     */
    namespace: string;
    /**
     * Expires is set to update expiry time of the resource.
     *
     * @generated from protobuf field: google.protobuf.Timestamp Expires = 4 [json_name = "Expires"];
     */
    expires?: Timestamp;
    /**
     * Type is the type (or kind) of the resource that's being kept alive.
     *
     * @generated from protobuf field: types.KeepAlive.KeepAliveType Type = 9 [json_name = "Type"];
     */
    type: KeepAlive_KeepAliveType;
    /**
     * HostID is an optional UUID of the host the resource belongs to.
     *
     * @generated from protobuf field: string HostID = 10 [json_name = "HostID"];
     */
    hostID: string;
}
/**
 * The type of a KeepAlive. When adding a new type, please double-check
 * lib/usagereporter/teleport to see if we need any change in the resource
 * heartbeat event.
 *
 * @generated from protobuf enum types.KeepAlive.KeepAliveType
 */
export enum KeepAlive_KeepAliveType {
    /**
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * "node", KindNode. For the sake of correct usage reporting, it shouldn't
     * be used for OpenSSH nodes.
     *
     * @generated from protobuf enum value: NODE = 1;
     */
    NODE = 1,
    /**
     * "app_server", KindAppServer
     *
     * @generated from protobuf enum value: APP = 2;
     */
    APP = 2,
    /**
     * "db_server", KindDatabaseServer
     *
     * @generated from protobuf enum value: DATABASE = 3;
     */
    DATABASE = 3,
    /**
     * "windows_desktop_service", KindWindowsDesktopService
     *
     * @generated from protobuf enum value: WINDOWS_DESKTOP = 4;
     */
    WINDOWS_DESKTOP = 4,
    /**
     * "kube_server", KindKubeServer
     *
     * @generated from protobuf enum value: KUBERNETES = 5;
     */
    KUBERNETES = 5,
    /**
     * "db_service", KindDatabaseService
     *
     * @generated from protobuf enum value: DATABASE_SERVICE = 6;
     */
    DATABASE_SERVICE = 6
}
/**
 * Metadata is resource metadata
 *
 * @generated from protobuf message types.Metadata
 */
export interface Metadata {
    /**
     * Name is an object name
     *
     * @generated from protobuf field: string Name = 1 [json_name = "Name"];
     */
    name: string;
    /**
     * Namespace is object namespace. The field should be called "namespace"
     * when it returns in Teleport 2.4.
     *
     * @generated from protobuf field: string Namespace = 2 [json_name = "Namespace"];
     */
    namespace: string;
    /**
     * Description is object description
     *
     * @generated from protobuf field: string Description = 3 [json_name = "Description"];
     */
    description: string;
    /**
     * Labels is a set of labels
     *
     * @generated from protobuf field: map<string, string> Labels = 5 [json_name = "Labels"];
     */
    labels: {
        [key: string]: string;
    };
    /**
     * Expires is a global expiry time header can be set on any resource in the
     * system.
     *
     * @generated from protobuf field: google.protobuf.Timestamp Expires = 6 [json_name = "Expires"];
     */
    expires?: Timestamp;
    /**
     * Revision is an opaque identifier which tracks the versions of a resource
     * over time. Clients should ignore and not alter its value but must return
     * the revision in any updates of a resource.
     *
     * @generated from protobuf field: string Revision = 8 [json_name = "Revision"];
     */
    revision: string;
}
/**
 * Rotation is a status of the rotation of the certificate authority
 *
 * @generated from protobuf message types.Rotation
 */
export interface Rotation {
    /**
     * State could be one of "init" or "in_progress".
     *
     * @generated from protobuf field: string State = 1 [json_name = "State"];
     */
    state: string;
    /**
     * Phase is the current rotation phase.
     *
     * @generated from protobuf field: string Phase = 2 [json_name = "Phase"];
     */
    phase: string;
    /**
     * Mode sets manual or automatic rotation mode.
     *
     * @generated from protobuf field: string Mode = 3 [json_name = "Mode"];
     */
    mode: string;
    /**
     * CurrentID is the ID of the rotation operation
     * to differentiate between rotation attempts.
     *
     * @generated from protobuf field: string CurrentID = 4 [json_name = "CurrentID"];
     */
    currentID: string;
    /**
     * Started is set to the time when rotation has been started
     * in case if the state of the rotation is "in_progress".
     *
     * @generated from protobuf field: google.protobuf.Timestamp Started = 5 [json_name = "Started"];
     */
    started?: Timestamp;
    /**
     * GracePeriod is a period during which old and new CA
     * are valid for checking purposes, but only new CA is issuing certificates.
     *
     * @generated from protobuf field: int64 GracePeriod = 6 [json_name = "GracePeriod"];
     */
    gracePeriod: bigint;
    /**
     * LastRotated specifies the last time of the completed rotation.
     *
     * @generated from protobuf field: google.protobuf.Timestamp LastRotated = 7 [json_name = "LastRotated"];
     */
    lastRotated?: Timestamp;
    /**
     * Schedule is a rotation schedule - used in
     * automatic mode to switch between phases.
     *
     * @generated from protobuf field: types.RotationSchedule Schedule = 8 [json_name = "Schedule"];
     */
    schedule?: RotationSchedule;
}
/**
 * RotationSchedule is a rotation schedule setting time switches
 * for different phases.
 *
 * @generated from protobuf message types.RotationSchedule
 */
export interface RotationSchedule {
    /**
     * UpdateClients specifies time to switch to the "Update clients" phase
     *
     * @generated from protobuf field: google.protobuf.Timestamp UpdateClients = 1 [json_name = "UpdateClients"];
     */
    updateClients?: Timestamp;
    /**
     * UpdateServers specifies time to switch to the "Update servers" phase.
     *
     * @generated from protobuf field: google.protobuf.Timestamp UpdateServers = 2 [json_name = "UpdateServers"];
     */
    updateServers?: Timestamp;
    /**
     * Standby specifies time to switch to the "Standby" phase.
     *
     * @generated from protobuf field: google.protobuf.Timestamp Standby = 3 [json_name = "Standby"];
     */
    standby?: Timestamp;
}
/**
 * ResourceHeader is a shared resource header
 * used in cases when only type and name is known
 *
 * @generated from protobuf message types.ResourceHeader
 */
export interface ResourceHeader {
    /**
     * Kind is a resource kind
     *
     * @generated from protobuf field: string Kind = 1 [json_name = "Kind"];
     */
    kind: string;
    /**
     * SubKind is an optional resource sub kind, used in some resources
     *
     * @generated from protobuf field: string SubKind = 2 [json_name = "SubKind"];
     */
    subKind: string;
    /**
     * Version is the API version used to create the resource. It must be
     * specified. Based on this version, Teleport will apply different defaults on
     * resource creation or deletion. It must be an integer prefixed by "v".
     * For example: `v1`
     *
     * @generated from protobuf field: string Version = 3 [json_name = "Version"];
     */
    version: string;
    /**
     * Metadata is resource metadata
     *
     * @generated from protobuf field: types.Metadata Metadata = 4 [json_name = "Metadata"];
     */
    metadata?: Metadata;
}
/**
 * DatabaseServerV3 represents a database access server.
 *
 * @generated from protobuf message types.DatabaseServerV3
 */
export interface DatabaseServerV3 {
    /**
     * Kind is the database server resource kind.
     *
     * @generated from protobuf field: string Kind = 1 [json_name = "Kind"];
     */
    kind: string;
    /**
     * SubKind is an optional resource subkind.
     *
     * @generated from protobuf field: string SubKind = 2 [json_name = "SubKind"];
     */
    subKind: string;
    /**
     * Version is the resource version.
     *
     * @generated from protobuf field: string Version = 3 [json_name = "Version"];
     */
    version: string;
    /**
     * Metadata is the database server metadata.
     *
     * @generated from protobuf field: types.Metadata Metadata = 4 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Spec is the database server spec.
     *
     * @generated from protobuf field: types.DatabaseServerSpecV3 Spec = 5 [json_name = "Spec"];
     */
    spec?: DatabaseServerSpecV3;
    /**
     * Status is the database server status.
     *
     * @generated from protobuf field: types.DatabaseServerStatusV3 Status = 6 [json_name = "Status"];
     */
    status?: DatabaseServerStatusV3;
}
/**
 * DatabaseServerSpecV3 is the database server spec.
 *
 * @generated from protobuf message types.DatabaseServerSpecV3
 */
export interface DatabaseServerSpecV3 {
    /**
     * Version is the Teleport version that the server is running.
     *
     * @generated from protobuf field: string Version = 6 [json_name = "Version"];
     */
    version: string;
    /**
     * Hostname is the database server hostname.
     *
     * @generated from protobuf field: string Hostname = 7 [json_name = "Hostname"];
     */
    hostname: string;
    /**
     * HostID is the ID of the host the database server is running on.
     *
     * @generated from protobuf field: string HostID = 8 [json_name = "HostID"];
     */
    hostID: string;
    /**
     * Rotation contains the server CA rotation information.
     *
     * @generated from protobuf field: types.Rotation Rotation = 10 [json_name = "Rotation"];
     */
    rotation?: Rotation;
    /**
     * Database is the database proxied by this database server.
     *
     * @generated from protobuf field: types.DatabaseV3 Database = 12 [json_name = "Database"];
     */
    database?: DatabaseV3;
    /**
     * ProxyIDs is a list of proxy IDs this server is expected to be connected to.
     *
     * @generated from protobuf field: repeated string ProxyIDs = 13 [json_name = "ProxyIDs"];
     */
    proxyIDs: string[];
}
/**
 * DatabaseServerStatusV3 is the database server status.
 *
 * @generated from protobuf message types.DatabaseServerStatusV3
 */
export interface DatabaseServerStatusV3 {
    /**
     * TargetHealth is the health status of network connectivity between
     * the agent and the database.
     *
     * @generated from protobuf field: types.TargetHealth TargetHealth = 14 [json_name = "TargetHealth"];
     */
    targetHealth?: TargetHealth;
}
/**
 * DatabaseV3List represents a list of databases.
 *
 * @generated from protobuf message types.DatabaseV3List
 */
export interface DatabaseV3List {
    /**
     * Databases is a list of database resources.
     *
     * @generated from protobuf field: repeated types.DatabaseV3 Databases = 1 [json_name = "Databases"];
     */
    databases: DatabaseV3[];
}
/**
 * DatabaseV3 represents a single proxied database.
 *
 * @generated from protobuf message types.DatabaseV3
 */
export interface DatabaseV3 {
    /**
     * Kind is the database resource kind.
     *
     * @generated from protobuf field: string Kind = 1 [json_name = "Kind"];
     */
    kind: string;
    /**
     * SubKind is an optional resource subkind.
     *
     * @generated from protobuf field: string SubKind = 2 [json_name = "SubKind"];
     */
    subKind: string;
    /**
     * Version is the resource version. It must be specified.
     * Supported values are: `v3`.
     *
     * @generated from protobuf field: string Version = 3 [json_name = "Version"];
     */
    version: string;
    /**
     * Metadata is the database metadata.
     *
     * @generated from protobuf field: types.Metadata Metadata = 4 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Spec is the database spec.
     *
     * @generated from protobuf field: types.DatabaseSpecV3 Spec = 5 [json_name = "Spec"];
     */
    spec?: DatabaseSpecV3;
    /**
     * Status is the database runtime information.
     *
     * @generated from protobuf field: types.DatabaseStatusV3 Status = 6 [json_name = "Status"];
     */
    status?: DatabaseStatusV3;
}
/**
 * DatabaseSpecV3 is the database spec.
 *
 * @generated from protobuf message types.DatabaseSpecV3
 */
export interface DatabaseSpecV3 {
    /**
     * Protocol is the database protocol: postgres, mysql, mongodb, etc.
     *
     * @generated from protobuf field: string Protocol = 1 [json_name = "Protocol"];
     */
    protocol: string;
    /**
     * URI is the database connection endpoint.
     *
     * @generated from protobuf field: string URI = 2 [json_name = "URI"];
     */
    uRI: string;
    /**
     * CACert is the PEM-encoded database CA certificate.
     *
     * DEPRECATED: Moved to TLS.CACert. DELETE IN 10.0.
     *
     * @deprecated
     * @generated from protobuf field: string CACert = 3 [deprecated = true, json_name = "CACert"];
     */
    cACert: string;
    /**
     * DynamicLabels is the database dynamic labels.
     *
     * @generated from protobuf field: map<string, types.CommandLabelV2> DynamicLabels = 4 [json_name = "DynamicLabels"];
     */
    dynamicLabels: {
        [key: string]: CommandLabelV2;
    };
    /**
     * AWS contains AWS specific settings for RDS/Aurora/Redshift databases.
     *
     * @generated from protobuf field: types.AWS AWS = 5 [json_name = "AWS"];
     */
    aWS?: AWS;
    /**
     * GCP contains parameters specific to GCP Cloud SQL databases.
     *
     * @generated from protobuf field: types.GCPCloudSQL GCP = 6 [json_name = "GCP"];
     */
    gCP?: GCPCloudSQL;
    /**
     * Azure contains Azure specific database metadata.
     *
     * @generated from protobuf field: types.Azure Azure = 7 [json_name = "Azure"];
     */
    azure?: Azure;
    /**
     * TLS is the TLS configuration used when establishing connection to target database.
     * Allows to provide custom CA cert or override server name.
     *
     * @generated from protobuf field: types.DatabaseTLS TLS = 8 [json_name = "TLS"];
     */
    tLS?: DatabaseTLS;
    /**
     * AD is the Active Directory configuration for the database.
     *
     * @generated from protobuf field: types.AD AD = 9 [json_name = "AD"];
     */
    aD?: AD;
    /**
     * MySQL is an additional section with MySQL database options.
     *
     * @generated from protobuf field: types.MySQLOptions MySQL = 10 [json_name = "MySQL"];
     */
    mySQL?: MySQLOptions;
    /**
     * AdminUser is the database admin user for automatic user provisioning.
     *
     * @generated from protobuf field: types.DatabaseAdminUser AdminUser = 11 [json_name = "AdminUser"];
     */
    adminUser?: DatabaseAdminUser;
    /**
     * MongoAtlas contains Atlas metadata about the database.
     *
     * @generated from protobuf field: types.MongoAtlas MongoAtlas = 12 [json_name = "MongoAtlas"];
     */
    mongoAtlas?: MongoAtlas;
    /**
     * Oracle is an additional Oracle configuration options.
     *
     * @generated from protobuf field: types.OracleOptions Oracle = 13 [json_name = "Oracle"];
     */
    oracle?: OracleOptions;
}
/**
 * DatabaseAdminUser contains information about privileged database user used
 * for automatic user provisioning.
 *
 * @generated from protobuf message types.DatabaseAdminUser
 */
export interface DatabaseAdminUser {
    /**
     * Name is the username of the privileged database user.
     *
     * @generated from protobuf field: string Name = 1 [json_name = "Name"];
     */
    name: string;
    /**
     * DefaultDatabase is the database that the privileged database user logs
     * into by default.
     *
     * Depending on the database type, this database may be used to store
     * procedures or data for managing database users.
     *
     * @generated from protobuf field: string DefaultDatabase = 2 [json_name = "DefaultDatabase"];
     */
    defaultDatabase: string;
}
/**
 * OracleOptions contains information about privileged database user used
 * for database audit.
 *
 * @generated from protobuf message types.OracleOptions
 */
export interface OracleOptions {
    /**
     * AuditUser is the Oracle database user privilege to access internal Oracle audit trail.
     *
     * @generated from protobuf field: string AuditUser = 1 [json_name = "AuditUser"];
     */
    auditUser: string;
}
/**
 * DatabaseStatusV3 contains runtime information about the database.
 *
 * @generated from protobuf message types.DatabaseStatusV3
 */
export interface DatabaseStatusV3 {
    /**
     * CACert is the auto-downloaded cloud database CA certificate.
     *
     * @generated from protobuf field: string CACert = 1 [json_name = "CACert"];
     */
    cACert: string;
    /**
     * AWS is the auto-discovered AWS cloud database metadata.
     *
     * @generated from protobuf field: types.AWS AWS = 2 [json_name = "AWS"];
     */
    aWS?: AWS;
    /**
     * MySQL is an additional section with MySQL runtime database information.
     *
     * @generated from protobuf field: types.MySQLOptions MySQL = 3 [json_name = "MySQL"];
     */
    mySQL?: MySQLOptions;
    /**
     * ManagedUsers is a list of database users that are managed by Teleport.
     *
     * @generated from protobuf field: repeated string ManagedUsers = 4 [json_name = "ManagedUsers"];
     */
    managedUsers: string[];
    /**
     * Azure is the auto-discovered Azure cloud database metadata.
     *
     * @generated from protobuf field: types.Azure Azure = 5 [json_name = "Azure"];
     */
    azure?: Azure;
}
/**
 * AWS contains AWS metadata about the database.
 *
 * @generated from protobuf message types.AWS
 */
export interface AWS {
    /**
     * Region is a AWS cloud region.
     *
     * @generated from protobuf field: string Region = 1 [json_name = "Region"];
     */
    region: string;
    /**
     * Redshift contains Redshift specific metadata.
     *
     * @generated from protobuf field: types.Redshift Redshift = 2 [json_name = "Redshift"];
     */
    redshift?: Redshift;
    /**
     * RDS contains RDS specific metadata.
     *
     * @generated from protobuf field: types.RDS RDS = 3 [json_name = "RDS"];
     */
    rDS?: RDS;
    /**
     * AccountID is the AWS account ID this database belongs to.
     *
     * @generated from protobuf field: string AccountID = 4 [json_name = "AccountID"];
     */
    accountID: string;
    /**
     * ElastiCache contains AWS ElastiCache Redis specific metadata.
     *
     * @generated from protobuf field: types.ElastiCache ElastiCache = 5 [json_name = "ElastiCache"];
     */
    elastiCache?: ElastiCache;
    /**
     * SecretStore contains secret store configurations.
     *
     * @generated from protobuf field: types.SecretStore SecretStore = 6 [json_name = "SecretStore"];
     */
    secretStore?: SecretStore;
    /**
     * MemoryDB contains AWS MemoryDB specific metadata.
     *
     * @generated from protobuf field: types.MemoryDB MemoryDB = 7 [json_name = "MemoryDB"];
     */
    memoryDB?: MemoryDB;
    /**
     * RDSProxy contains AWS Proxy specific metadata.
     *
     * @generated from protobuf field: types.RDSProxy RDSProxy = 8 [json_name = "RDSProxy"];
     */
    rDSProxy?: RDSProxy;
    /**
     * RedshiftServerless contains AWS Redshift Serverless specific metadata.
     *
     * @generated from protobuf field: types.RedshiftServerless RedshiftServerless = 9 [json_name = "RedshiftServerless"];
     */
    redshiftServerless?: RedshiftServerless;
    /**
     * ExternalID is an optional AWS external ID used to enable assuming an AWS role across accounts.
     *
     * @generated from protobuf field: string ExternalID = 10 [json_name = "ExternalID"];
     */
    externalID: string;
    /**
     * AssumeRoleARN is an optional AWS role ARN to assume when accessing a database.
     * Set this field and ExternalID to enable access across AWS accounts.
     *
     * @generated from protobuf field: string AssumeRoleARN = 11 [json_name = "AssumeRoleARN"];
     */
    assumeRoleARN: string;
    /**
     * OpenSearch contains AWS OpenSearch specific metadata.
     *
     * @generated from protobuf field: types.OpenSearch OpenSearch = 12 [json_name = "OpenSearch"];
     */
    openSearch?: OpenSearch;
    /**
     * IAMPolicyStatus indicates whether the IAM Policy is configured properly for database access.
     * If not, the user must update the AWS profile identity to allow access to the Database.
     * Eg for an RDS Database: the underlying AWS profile allows for `rds-db:connect` for the Database.
     *
     * @generated from protobuf field: types.IAMPolicyStatus IAMPolicyStatus = 14 [json_name = "IAMPolicyStatus"];
     */
    iAMPolicyStatus: IAMPolicyStatus;
    /**
     * SessionTags is a list of AWS STS session tags.
     *
     * @generated from protobuf field: map<string, string> SessionTags = 15 [json_name = "SessionTags"];
     */
    sessionTags: {
        [key: string]: string;
    };
    /**
     * DocumentDB contains AWS DocumentDB specific metadata.
     *
     * @generated from protobuf field: types.DocumentDB DocumentDB = 16 [json_name = "DocumentDB"];
     */
    documentDB?: DocumentDB;
}
/**
 * SecretStore contains secret store configurations.
 *
 * @generated from protobuf message types.SecretStore
 */
export interface SecretStore {
    /**
     * KeyPrefix specifies the secret key prefix.
     *
     * @generated from protobuf field: string KeyPrefix = 1 [json_name = "KeyPrefix"];
     */
    keyPrefix: string;
    /**
     * KMSKeyID specifies the AWS KMS key for encryption.
     *
     * @generated from protobuf field: string KMSKeyID = 2 [json_name = "KMSKeyID"];
     */
    kMSKeyID: string;
}
/**
 * Redshift contains AWS Redshift specific database metadata.
 *
 * @generated from protobuf message types.Redshift
 */
export interface Redshift {
    /**
     * ClusterID is the Redshift cluster identifier.
     *
     * @generated from protobuf field: string ClusterID = 1 [json_name = "ClusterID"];
     */
    clusterID: string;
}
/**
 * RDS contains AWS RDS specific database metadata.
 *
 * @generated from protobuf message types.RDS
 */
export interface RDS {
    /**
     * InstanceID is the RDS instance identifier.
     *
     * @generated from protobuf field: string InstanceID = 1 [json_name = "InstanceID"];
     */
    instanceID: string;
    /**
     * ClusterID is the RDS cluster (Aurora) identifier.
     *
     * @generated from protobuf field: string ClusterID = 2 [json_name = "ClusterID"];
     */
    clusterID: string;
    /**
     * ResourceID is the RDS instance resource identifier (db-xxx).
     *
     * @generated from protobuf field: string ResourceID = 3 [json_name = "ResourceID"];
     */
    resourceID: string;
    /**
     * IAMAuth indicates whether database IAM authentication is enabled.
     *
     * @generated from protobuf field: bool IAMAuth = 4 [json_name = "IAMAuth"];
     */
    iAMAuth: boolean;
    /**
     * Subnets is a list of subnets for the RDS instance.
     *
     * @generated from protobuf field: repeated string Subnets = 5 [json_name = "Subnets"];
     */
    subnets: string[];
    /**
     * VPCID is the VPC where the RDS is running.
     *
     * @generated from protobuf field: string VPCID = 6 [json_name = "VPCID"];
     */
    vPCID: string;
    /**
     * SecurityGroups is a list of attached security groups for the RDS instance.
     *
     * @generated from protobuf field: repeated string SecurityGroups = 7 [json_name = "SecurityGroups"];
     */
    securityGroups: string[];
}
/**
 * RDSProxy contains AWS RDS Proxy specific database metadata.
 *
 * @generated from protobuf message types.RDSProxy
 */
export interface RDSProxy {
    /**
     * Name is the identifier of an RDS Proxy.
     *
     * @generated from protobuf field: string Name = 1 [json_name = "Name"];
     */
    name: string;
    /**
     * CustomEndpointName is the identifier of an RDS Proxy custom endpoint.
     *
     * @generated from protobuf field: string CustomEndpointName = 2 [json_name = "CustomEndpointName"];
     */
    customEndpointName: string;
    /**
     * ResourceID is the RDS instance resource identifier (prx-xxx).
     *
     * @generated from protobuf field: string ResourceID = 3 [json_name = "ResourceID"];
     */
    resourceID: string;
}
/**
 * ElastiCache contains AWS ElastiCache Redis specific metadata.
 *
 * @generated from protobuf message types.ElastiCache
 */
export interface ElastiCache {
    /**
     * ReplicationGroupID is the Redis replication group ID.
     *
     * @generated from protobuf field: string ReplicationGroupID = 1 [json_name = "ReplicationGroupID"];
     */
    replicationGroupID: string;
    /**
     * UserGroupIDs is a list of user group IDs.
     *
     * @generated from protobuf field: repeated string UserGroupIDs = 2 [json_name = "UserGroupIDs"];
     */
    userGroupIDs: string[];
    /**
     * TransitEncryptionEnabled indicates whether in-transit encryption (TLS) is enabled.
     *
     * @generated from protobuf field: bool TransitEncryptionEnabled = 3 [json_name = "TransitEncryptionEnabled"];
     */
    transitEncryptionEnabled: boolean;
    /**
     * EndpointType is the type of the endpoint.
     *
     * @generated from protobuf field: string EndpointType = 4 [json_name = "EndpointType"];
     */
    endpointType: string;
}
/**
 * MemoryDB contains AWS MemoryDB specific metadata.
 *
 * @generated from protobuf message types.MemoryDB
 */
export interface MemoryDB {
    /**
     * ClusterName is the name of the MemoryDB cluster.
     *
     * @generated from protobuf field: string ClusterName = 1 [json_name = "ClusterName"];
     */
    clusterName: string;
    /**
     * ACLName is the name of the ACL associated with the cluster.
     *
     * @generated from protobuf field: string ACLName = 2 [json_name = "ACLName"];
     */
    aCLName: string;
    /**
     * TLSEnabled indicates whether in-transit encryption (TLS) is enabled.
     *
     * @generated from protobuf field: bool TLSEnabled = 3 [json_name = "TLSEnabled"];
     */
    tLSEnabled: boolean;
    /**
     * EndpointType is the type of the endpoint.
     *
     * @generated from protobuf field: string EndpointType = 4 [json_name = "EndpointType"];
     */
    endpointType: string;
}
/**
 * RedshiftServerless contains AWS Redshift Serverless specific metadata.
 *
 * @generated from protobuf message types.RedshiftServerless
 */
export interface RedshiftServerless {
    /**
     * WorkgroupName is the workgroup name.
     *
     * @generated from protobuf field: string WorkgroupName = 1 [json_name = "WorkgroupName"];
     */
    workgroupName: string;
    /**
     * EndpointName is the VPC endpoint name.
     *
     * @generated from protobuf field: string EndpointName = 2 [json_name = "EndpointName"];
     */
    endpointName: string;
    /**
     * WorkgroupID is the workgroup ID.
     *
     * @generated from protobuf field: string WorkgroupID = 3 [json_name = "WorkgroupID"];
     */
    workgroupID: string;
}
/**
 * OpenSearch contains AWS OpenSearch specific metadata.
 *
 * @generated from protobuf message types.OpenSearch
 */
export interface OpenSearch {
    /**
     * DomainName is the name of the domain.
     *
     * @generated from protobuf field: string DomainName = 1 [json_name = "DomainName"];
     */
    domainName: string;
    /**
     * DomainID is the ID of the domain.
     *
     * @generated from protobuf field: string DomainID = 2 [json_name = "DomainID"];
     */
    domainID: string;
    /**
     * EndpointType is the type of the endpoint.
     *
     * @generated from protobuf field: string EndpointType = 3 [json_name = "EndpointType"];
     */
    endpointType: string;
}
/**
 * DocumentDB contains AWS DocumentDB specific metadata.
 *
 * @generated from protobuf message types.DocumentDB
 */
export interface DocumentDB {
    /**
     * ClusterID is the cluster identifier.
     *
     * @generated from protobuf field: string ClusterID = 1 [json_name = "ClusterID"];
     */
    clusterID: string;
    /**
     * InstanceID is the instance identifier.
     *
     * @generated from protobuf field: string InstanceID = 2 [json_name = "InstanceID"];
     */
    instanceID: string;
    /**
     * EndpointType is the type of the endpoint.
     *
     * @generated from protobuf field: string EndpointType = 3 [json_name = "EndpointType"];
     */
    endpointType: string;
}
/**
 * GCPCloudSQL contains parameters specific to GCP Cloud SQL databases.
 *
 * @generated from protobuf message types.GCPCloudSQL
 */
export interface GCPCloudSQL {
    /**
     * ProjectID is the GCP project ID the Cloud SQL instance resides in.
     *
     * @generated from protobuf field: string ProjectID = 1 [json_name = "ProjectID"];
     */
    projectID: string;
    /**
     * InstanceID is the Cloud SQL instance ID.
     *
     * @generated from protobuf field: string InstanceID = 2 [json_name = "InstanceID"];
     */
    instanceID: string;
}
/**
 * Azure contains Azure specific database metadata.
 *
 * @generated from protobuf message types.Azure
 */
export interface Azure {
    /**
     * Name is the Azure database server name.
     *
     * @generated from protobuf field: string Name = 1 [json_name = "Name"];
     */
    name: string;
    /**
     * ResourceID is the Azure fully qualified ID for the resource.
     *
     * @generated from protobuf field: string ResourceID = 2 [json_name = "ResourceID"];
     */
    resourceID: string;
    /**
     * Redis contains Azure Cache for Redis specific database metadata.
     *
     * @generated from protobuf field: types.AzureRedis Redis = 3 [json_name = "Redis"];
     */
    redis?: AzureRedis;
    /**
     * IsFlexiServer is true if the database is an Azure Flexible server.
     *
     * @generated from protobuf field: bool IsFlexiServer = 4 [json_name = "IsFlexiServer"];
     */
    isFlexiServer: boolean;
}
/**
 * AzureRedis contains Azure Cache for Redis specific database metadata.
 *
 * @generated from protobuf message types.AzureRedis
 */
export interface AzureRedis {
    /**
     * ClusteringPolicy is the clustering policy for Redis Enterprise.
     *
     * @generated from protobuf field: string ClusteringPolicy = 1 [json_name = "ClusteringPolicy"];
     */
    clusteringPolicy: string;
}
/**
 * AD contains Active Directory specific database configuration.
 *
 * @generated from protobuf message types.AD
 */
export interface AD {
    /**
     * KeytabFile is the path to the Kerberos keytab file.
     *
     * @generated from protobuf field: string KeytabFile = 1 [json_name = "KeytabFile"];
     */
    keytabFile: string;
    /**
     * Krb5File is the path to the Kerberos configuration file. Defaults to /etc/krb5.conf.
     *
     * @generated from protobuf field: string Krb5File = 2 [json_name = "Krb5File"];
     */
    krb5File: string;
    /**
     * Domain is the Active Directory domain the database resides in.
     *
     * @generated from protobuf field: string Domain = 3 [json_name = "Domain"];
     */
    domain: string;
    /**
     * SPN is the service principal name for the database.
     *
     * @generated from protobuf field: string SPN = 4 [json_name = "SPN"];
     */
    sPN: string;
    /**
     * LDAPCert is a certificate from Windows LDAP/AD, optional; only for x509 Authentication.
     *
     * @generated from protobuf field: string LDAPCert = 5 [json_name = "LDAPCert"];
     */
    lDAPCert: string;
    /**
     * KDCHostName is the host name for a KDC for x509 Authentication.
     *
     * @generated from protobuf field: string KDCHostName = 6 [json_name = "KDCHostName"];
     */
    kDCHostName: string;
    /**
     * LDAPServiceAccountName is the name of service account for performing LDAP queries. Required for x509 Auth / PKINIT.
     *
     * @generated from protobuf field: string LDAPServiceAccountName = 7 [json_name = "LDAPServiceAccountName"];
     */
    lDAPServiceAccountName: string;
    /**
     * LDAPServiceAccountSID is the SID of service account for performing LDAP queries. Required for x509 Auth / PKINIT.
     *
     * @generated from protobuf field: string LDAPServiceAccountSID = 8 [json_name = "LDAPServiceAccountSID"];
     */
    lDAPServiceAccountSID: string;
}
/**
 * DatabaseTLS contains TLS configuration options.
 *
 * @generated from protobuf message types.DatabaseTLS
 */
export interface DatabaseTLS {
    /**
     * Mode is a TLS connection mode.
     * 0 is "verify-full"; 1 is "verify-ca", 2 is "insecure".
     *
     * @generated from protobuf field: types.DatabaseTLSMode Mode = 1 [json_name = "Mode"];
     */
    mode: DatabaseTLSMode;
    /**
     * CACert is an optional user provided CA certificate used for verifying
     * database TLS connection.
     *
     * @generated from protobuf field: string CACert = 2 [json_name = "CACert"];
     */
    cACert: string;
    /**
     * ServerName allows to provide custom hostname. This value will override the
     * servername/hostname on a certificate during validation.
     *
     * @generated from protobuf field: string ServerName = 3 [json_name = "ServerName"];
     */
    serverName: string;
    /**
     * TrustSystemCertPool allows Teleport to trust certificate authorities
     * available on the host system. If not set (by default), Teleport only
     * trusts self-signed databases with TLS certificates signed by Teleport's
     * Database Server CA or the ca_cert specified in this TLS setting. For
     * cloud-hosted databases, Teleport downloads the corresponding required CAs
     * for validation.
     *
     * @generated from protobuf field: bool TrustSystemCertPool = 4 [json_name = "TrustSystemCertPool"];
     */
    trustSystemCertPool: boolean;
}
/**
 * MySQLOptions are additional MySQL database options.
 *
 * @generated from protobuf message types.MySQLOptions
 */
export interface MySQLOptions {
    /**
     * ServerVersion is the server version reported by DB proxy if the runtime information is
     * not available.
     *
     * @generated from protobuf field: string ServerVersion = 1 [json_name = "ServerVersion"];
     */
    serverVersion: string;
}
/**
 * MongoAtlas contains Atlas metadata about the database.
 *
 * @generated from protobuf message types.MongoAtlas
 */
export interface MongoAtlas {
    /**
     * Name is the Atlas database instance name.
     *
     * @generated from protobuf field: string Name = 1 [json_name = "Name"];
     */
    name: string;
}
/**
 * InstanceV1 represents the state of a running teleport instance independent
 * of the specific services that instance exposes.
 *
 * @generated from protobuf message types.InstanceV1
 */
export interface InstanceV1 {
    /**
     * @generated from protobuf field: types.ResourceHeader Header = 1 [json_name = "Header"];
     */
    header?: ResourceHeader;
    /**
     * @generated from protobuf field: types.InstanceSpecV1 Spec = 2 [json_name = "Spec"];
     */
    spec?: InstanceSpecV1;
}
/**
 * @generated from protobuf message types.InstanceSpecV1
 */
export interface InstanceSpecV1 {
    /**
     * Version is the version of teleport this instance most recently advertised.
     *
     * @generated from protobuf field: string Version = 1 [json_name = "Version"];
     */
    version: string;
    /**
     * Services is the list of active services this instance most recently advertised.
     *
     * @generated from protobuf field: repeated string Services = 2 [json_name = "Services"];
     */
    services: string[];
    /**
     * Hostname is the hostname this instance most recently advertised.
     *
     * @generated from protobuf field: string Hostname = 3 [json_name = "Hostname"];
     */
    hostname: string;
    /**
     * AuthID is the ID of the Auth Service that most recently observed this instance.
     *
     * @generated from protobuf field: string AuthID = 4 [json_name = "AuthID"];
     */
    authID: string;
    /**
     * LastSeen is the last time an Auth Service server reported observing this instance.
     *
     * @generated from protobuf field: google.protobuf.Timestamp LastSeen = 5 [json_name = "LastSeen"];
     */
    lastSeen?: Timestamp;
    /**
     * ControlLog is the log of recent important instance control events related to this instance. See comments
     * on the InstanceControlLogEntry type for details.
     *
     * @generated from protobuf field: repeated types.InstanceControlLogEntry ControlLog = 6 [json_name = "ControlLog"];
     */
    controlLog: InstanceControlLogEntry[];
    /**
     * ExternalUpgrader identifies the external upgrader that the instance is configured to
     * export schedules to (e.g. 'kube'). Empty if no upgrader is defined.
     *
     * @generated from protobuf field: string ExternalUpgrader = 7 [json_name = "ExternalUpgrader"];
     */
    externalUpgrader: string;
    /**
     * ExternalUpgraderVersion identifies the external upgrader version. Empty if no upgrader is defined.
     *
     * @generated from protobuf field: string ExternalUpgraderVersion = 8 [json_name = "ExternalUpgraderVersion"];
     */
    externalUpgraderVersion: string;
    /**
     * LastMeasurement stores information about the latest measurement between services.
     *
     * @generated from protobuf field: types.SystemClockMeasurement LastMeasurement = 9 [json_name = "LastMeasurement"];
     */
    lastMeasurement?: SystemClockMeasurement;
    /**
     * UpdaterInfo stores information about how the Teleport updater is doing.
     *
     * @generated from protobuf field: types.UpdaterV2Info UpdaterInfo = 10 [json_name = "UpdaterInfo"];
     */
    updaterInfo?: UpdaterV2Info;
}
/**
 * SystemClockMeasurement represents the measurement state of the systems clock difference.
 *
 * @generated from protobuf message types.SystemClockMeasurement
 */
export interface SystemClockMeasurement {
    /**
     * ControllerSystemClock is the system clock of the inventory controller.
     *
     * @generated from protobuf field: google.protobuf.Timestamp ControllerSystemClock = 1 [json_name = "ControllerSystemClock"];
     */
    controllerSystemClock?: Timestamp;
    /**
     * SystemClock is the system clock of the upstream.
     *
     * @generated from protobuf field: google.protobuf.Timestamp SystemClock = 2 [json_name = "SystemClock"];
     */
    systemClock?: Timestamp;
    /**
     * RequestDuration stores information about the request duration between auth and remote service.
     *
     * @generated from protobuf field: google.protobuf.Duration RequestDuration = 3 [json_name = "RequestDuration"];
     */
    requestDuration?: Duration;
}
/**
 * InstanceControlLogEntry represents an entry in a given instance's control log. The control log of
 * an instance is protected by CompareAndSwap semantics, allowing entries to function as a means of
 * synchronization as well as recordkeeping. For example, an Auth Service instance intending to trigger an upgrade
 * for a given instance can check its control log for 'upgrade-attempt' entries. If no such entry exists,
 * it can attempt to write an 'upgrade-attempt' entry of its own. If that entry successfully writes without
 * hitting a CompareFailed, the Auth Service instance knows that no other Auth Service instances will make concurrent upgrade
 * attempts while that entry persists.
 *
 * NOTE: Due to resource size and backend throughput limitations, care should be taken to minimize the
 * use and size of instance control log entries.
 *
 *
 * @generated from protobuf message types.InstanceControlLogEntry
 */
export interface InstanceControlLogEntry {
    /**
     * Type represents the type of control log entry this is (e.g. 'upgrade-attempt').
     *
     * @generated from protobuf field: string Type = 1 [json_name = "Type"];
     */
    type: string;
    /**
     * ID is a random identifier used to assist in uniquely identifying entries. This value may
     * be unique, or it may be used to associate a collection of related entries (e.g. an upgrade
     * attempt entry may use the same ID as an associated upgrade failure entry if appropriate).
     *
     * @generated from protobuf field: uint64 ID = 2 [json_name = "ID"];
     */
    iD: bigint;
    /**
     * Time is the time at which the event represented by this entry occurred (used in determining
     * ordering and expiry).
     *
     * @generated from protobuf field: google.protobuf.Timestamp Time = 3 [json_name = "Time"];
     */
    time?: Timestamp;
    /**
     * TTL is an optional custom time to live for this control log entry. Some control log entries
     * (e.g. an upgrade failure) may require longer than normal TTLs in order to ensure visibility.
     * If a log entry's TTL results in it having an intended expiry further in the future than the
     * expiry of the enclosing Instance resource, the instance resource's expiry will be bumped
     * to accommodate preservation of the log. Because of this fact, custom entry TTLs should be
     * used sparingly, as excess usage could result in unexpected backend growth for high churn
     * clusters.
     *
     * @generated from protobuf field: int64 TTL = 4 [json_name = "TTL"];
     */
    tTL: bigint;
    /**
     * Labels is an arbitrary collection of key-value pairs. The expected labels are determined by the
     * type of the entry. Use of labels is preferable to adding new fields in some cases in order to
     * preserve fields across auth downgrades (this is mostly relevant for the version-control system).
     *
     * @generated from protobuf field: map<string, string> Labels = 5 [json_name = "Labels"];
     */
    labels: {
        [key: string]: string;
    };
}
/**
 * UpdaterV2Info is used by Teleport to send information about how the Teleport updater is doing.
 *
 * @generated from protobuf message types.UpdaterV2Info
 */
export interface UpdaterV2Info {
    /**
     * UpdateGroup is the update group the agent's updater is part of.
     * The autoupdate_agent_rollout resource controls when different groups update.
     * Reporting the update group in the Hello allows us to track the update progress per group.
     * See RFD 184 for more details.
     *
     * @generated from protobuf field: string UpdateGroup = 1 [json_name = "UpdateGroup"];
     */
    updateGroup: string;
    /**
     * UpdateUUID is the agent's updater UUID.
     * Each updater has a UUID, this can be used in two cases:
     * - To update individual agents when doing canary updates
     * - To track the lowest non-updated agent to avoid a deadlock when doing a progressive rollout
     *
     * @generated from protobuf field: bytes UpdateUUID = 2 [json_name = "UpdateUUID"];
     */
    updateUUID: Uint8Array;
    /**
     * UpdaterStatus represents any updater-related status information that the Teleport cluster
     * should be aware of. For example, the fact the updater got disabled, the version pinned,
     * or that the updater seems to not be running.
     *
     * @generated from protobuf field: types.UpdaterStatus UpdaterStatus = 3 [json_name = "UpdaterStatus"];
     */
    updaterStatus: UpdaterStatus;
}
/**
 * InstanceFilter matches instance resources.
 *
 * @generated from protobuf message types.InstanceFilter
 */
export interface InstanceFilter {
    /**
     * ServerID matches exactly one instance by server ID if specified.
     *
     * @generated from protobuf field: string ServerID = 1 [json_name = "ServerID"];
     */
    serverID: string;
    /**
     * Version matches instance version if specified.
     *
     * @generated from protobuf field: string Version = 2 [json_name = "Version"];
     */
    version: string;
    /**
     * Services matches the instance services if specified. Note that this field matches all instances which
     * expose *at least* one of the listed services. This is in contrast to service matching in version
     * directives which match instances that expose a *at most* the listed services.
     *
     * @generated from protobuf field: repeated string Services = 3 [json_name = "Services"];
     */
    services: string[];
    /**
     * ExternalUpgrader matches instance upgrader if specified.
     *
     * @generated from protobuf field: string ExternalUpgrader = 4 [json_name = "ExternalUpgrader"];
     */
    externalUpgrader: string;
    /**
     * NoExtUpgrader explicitly matches instances for which no upgrader is defined.
     *
     * @generated from protobuf field: bool NoExtUpgrader = 5 [json_name = "NoExtUpgrader"];
     */
    noExtUpgrader: boolean;
    /**
     * OlderThanVersion is an optional exclusive upper version bound.
     *
     * @generated from protobuf field: string OlderThanVersion = 6 [json_name = "OlderThanVersion"];
     */
    olderThanVersion: string;
    /**
     * NewerThanVersion is an optional exclusive lower version bound.
     *
     * @generated from protobuf field: string NewerThanVersion = 7 [json_name = "NewerThanVersion"];
     */
    newerThanVersion: string;
    /**
     * UpdateGroup matches instance update group if specified.
     *
     * @generated from protobuf field: string UpdateGroup = 8 [json_name = "UpdateGroup"];
     */
    updateGroup: string;
}
/**
 * ServerV2 represents a Node, App, Database, Proxy or Auth Service instance in a Teleport cluster.
 *
 * @generated from protobuf message types.ServerV2
 */
export interface ServerV2 {
    /**
     * Kind is a resource kind
     *
     * @generated from protobuf field: string Kind = 1 [json_name = "Kind"];
     */
    kind: string;
    /**
     * SubKind is an optional resource sub kind, used in some resources
     *
     * @generated from protobuf field: string SubKind = 2 [json_name = "SubKind"];
     */
    subKind: string;
    /**
     * Version is version
     *
     * @generated from protobuf field: string Version = 3 [json_name = "Version"];
     */
    version: string;
    /**
     * Metadata is resource metadata
     *
     * @generated from protobuf field: types.Metadata Metadata = 4 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Spec is a server spec
     *
     * @generated from protobuf field: types.ServerSpecV2 Spec = 5 [json_name = "Spec"];
     */
    spec?: ServerSpecV2;
}
/**
 * ServerSpecV2 is a specification for V2 Server
 *
 * @generated from protobuf message types.ServerSpecV2
 */
export interface ServerSpecV2 {
    /**
     * Addr is a host:port address where this server can be reached.
     *
     * @generated from protobuf field: string Addr = 1 [json_name = "Addr"];
     */
    addr: string;
    /**
     * Hostname is server hostname
     *
     * @generated from protobuf field: string Hostname = 3 [json_name = "Hostname"];
     */
    hostname: string;
    /**
     * CmdLabels is server dynamic labels
     *
     * @generated from protobuf field: map<string, types.CommandLabelV2> CmdLabels = 4 [json_name = "CmdLabels"];
     */
    cmdLabels: {
        [key: string]: CommandLabelV2;
    };
    /**
     * Rotation specifies server rotation
     *
     * @generated from protobuf field: types.Rotation Rotation = 5 [json_name = "Rotation"];
     */
    rotation?: Rotation;
    /**
     * UseTunnel indicates that connections to this server should occur over a
     * reverse tunnel.
     *
     * @generated from protobuf field: bool UseTunnel = 6 [json_name = "UseTunnel"];
     */
    useTunnel: boolean;
    /**
     * TeleportVersion is the teleport version that the server is running on
     *
     * @generated from protobuf field: string Version = 7 [json_name = "Version"];
     */
    version: string;
    /**
     * PeerAddr is the address a proxy server is reachable at by its peer proxies.
     *
     * @generated from protobuf field: string PeerAddr = 11 [json_name = "PeerAddr"];
     */
    peerAddr: string;
    /**
     * ProxyIDs is a list of proxy IDs this server is expected to be connected to.
     *
     * @generated from protobuf field: repeated string ProxyIDs = 12 [json_name = "ProxyIDs"];
     */
    proxyIDs: string[];
    /**
     * PublicAddrs is a list of public addresses where this server can be reached.
     *
     * @generated from protobuf field: repeated string public_addrs = 13;
     */
    publicAddrs: string[];
    /**
     * CloudMetadata contains info about the cloud instance the server is running
     * on, if any.
     *
     * @generated from protobuf field: types.CloudMetadata CloudMetadata = 14 [json_name = "CloudMetadata"];
     */
    cloudMetadata?: CloudMetadata;
    /**
     * GitHub contains info about GitHub proxies where each server represents a
     * GitHub organization.
     *
     * @generated from protobuf field: types.GitHubServerMetadata git_hub = 15;
     */
    gitHub?: GitHubServerMetadata;
}
/**
 * AWSInfo contains attributes to match to an EC2 instance.
 *
 * @generated from protobuf message types.AWSInfo
 */
export interface AWSInfo {
    /**
     * AccountID is an AWS account ID.
     *
     * @generated from protobuf field: string AccountID = 1 [json_name = "AccountID"];
     */
    accountID: string;
    /**
     * InstanceID is an EC2 instance ID.
     *
     * @generated from protobuf field: string InstanceID = 2 [json_name = "InstanceID"];
     */
    instanceID: string;
    /**
     * Region is the AWS EC2 Instance Region.
     *
     * @generated from protobuf field: string Region = 3 [json_name = "Region"];
     */
    region: string;
    /**
     * VPCID is the AWS VPC ID where the Instance is running.
     *
     * @generated from protobuf field: string VPCID = 4 [json_name = "VPCID"];
     */
    vPCID: string;
    /**
     * Integration is the integration name that added this Node.
     * When connecting to it, it will use this integration to issue AWS API calls in order to set up the connection.
     * This includes sending an SSH Key and then opening a tunnel (EC2 Instance Connect Endpoint) so Teleport can connect to it.
     *
     * @generated from protobuf field: string Integration = 5 [json_name = "Integration"];
     */
    integration: string;
    /**
     * SubnetID is the Subnet ID in use by the instance.
     *
     * @generated from protobuf field: string SubnetID = 6 [json_name = "SubnetID"];
     */
    subnetID: string;
}
/**
 * CloudMetadata contains info about the cloud instance a server is running
 * on, if any.
 *
 * @generated from protobuf message types.CloudMetadata
 */
export interface CloudMetadata {
    /**
     * AWSInfo contains attributes to match to an EC2 instance.
     *
     * @generated from protobuf field: types.AWSInfo AWS = 1 [json_name = "AWS"];
     */
    aWS?: AWSInfo;
}
/**
 * GitHubServerMetadata contains info about GitHub proxies where each server
 * represents a GitHub organization.
 *
 * @generated from protobuf message types.GitHubServerMetadata
 */
export interface GitHubServerMetadata {
    /**
     * Organization specifies the name of the organization for the GitHub integration.
     *
     * @generated from protobuf field: string organization = 1;
     */
    organization: string;
    /**
     * Integration is the integration that is associated with this Server.
     *
     * @generated from protobuf field: string integration = 2;
     */
    integration: string;
}
/**
 * AppServerV3 represents a single proxied web app.
 *
 * @generated from protobuf message types.AppServerV3
 */
export interface AppServerV3 {
    /**
     * Kind is the app server resource kind. Always "app_server".
     *
     * @generated from protobuf field: string Kind = 1 [json_name = "Kind"];
     */
    kind: string;
    /**
     * SubKind is an optional resource subkind.
     *
     * @generated from protobuf field: string SubKind = 2 [json_name = "SubKind"];
     */
    subKind: string;
    /**
     * Version is the resource version.
     *
     * @generated from protobuf field: string Version = 3 [json_name = "Version"];
     */
    version: string;
    /**
     * Metadata is the app server metadata.
     *
     * @generated from protobuf field: types.Metadata Metadata = 4 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Spec is the app server spec.
     *
     * @generated from protobuf field: types.AppServerSpecV3 Spec = 5 [json_name = "Spec"];
     */
    spec?: AppServerSpecV3;
}
/**
 * AppServerSpecV3 is the app access server spec.
 *
 * @generated from protobuf message types.AppServerSpecV3
 */
export interface AppServerSpecV3 {
    /**
     * Version is the Teleport version that the server is running.
     *
     * @generated from protobuf field: string Version = 1 [json_name = "Version"];
     */
    version: string;
    /**
     * Hostname is the app server hostname.
     *
     * @generated from protobuf field: string Hostname = 2 [json_name = "Hostname"];
     */
    hostname: string;
    /**
     * HostID is the app server host uuid.
     *
     * @generated from protobuf field: string HostID = 3 [json_name = "HostID"];
     */
    hostID: string;
    /**
     * Rotation contains the app server CA rotation information.
     *
     * @generated from protobuf field: types.Rotation Rotation = 4 [json_name = "Rotation"];
     */
    rotation?: Rotation;
    /**
     * App is the app proxied by this app server.
     *
     * @generated from protobuf field: types.AppV3 App = 5 [json_name = "App"];
     */
    app?: AppV3;
    /**
     * ProxyIDs is a list of proxy IDs this server is expected to be connected to.
     *
     * @generated from protobuf field: repeated string ProxyIDs = 6 [json_name = "ProxyIDs"];
     */
    proxyIDs: string[];
}
/**
 * AppV3List represents a list of app resources.
 *
 * @generated from protobuf message types.AppV3List
 */
export interface AppV3List {
    /**
     * Apps is a list of app resources.
     *
     * @generated from protobuf field: repeated types.AppV3 Apps = 1 [json_name = "Apps"];
     */
    apps: AppV3[];
}
/**
 * AppV3 represents an app resource.
 *
 * @generated from protobuf message types.AppV3
 */
export interface AppV3 {
    /**
     * Kind is the app resource kind. Always "app".
     *
     * @generated from protobuf field: string Kind = 1 [json_name = "Kind"];
     */
    kind: string;
    /**
     * SubKind is an optional resource subkind.
     *
     * @generated from protobuf field: string SubKind = 2 [json_name = "SubKind"];
     */
    subKind: string;
    /**
     * Version is the resource version. It must be specified.
     * Supported values are:`v3`.
     *
     * @generated from protobuf field: string Version = 3 [json_name = "Version"];
     */
    version: string;
    /**
     * Metadata is the app resource metadata.
     *
     * @generated from protobuf field: types.Metadata Metadata = 4 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Spec is the app resource spec.
     *
     * @generated from protobuf field: types.AppSpecV3 Spec = 5 [json_name = "Spec"];
     */
    spec?: AppSpecV3;
}
/**
 * CORSPolicy defines the CORS policy for AppSpecV3
 *
 * @generated from protobuf message types.CORSPolicy
 */
export interface CORSPolicy {
    /**
     * allowed_origins specifies which origins are allowed to access the app.
     *
     * @generated from protobuf field: repeated string allowed_origins = 1;
     */
    allowedOrigins: string[];
    /**
     * allowed_methods specifies which methods are allowed when accessing the app.
     *
     * @generated from protobuf field: repeated string allowed_methods = 2;
     */
    allowedMethods: string[];
    /**
     * allowed_headers specifies which headers can be used when accessing the app.
     *
     * @generated from protobuf field: repeated string allowed_headers = 3;
     */
    allowedHeaders: string[];
    /**
     * allow_credentials indicates whether credentials are allowed.
     *
     * @generated from protobuf field: bool allow_credentials = 4;
     */
    allowCredentials: boolean;
    /**
     * max_age indicates how long (in seconds) the results of a preflight request can be cached.
     *
     * @generated from protobuf field: uint32 max_age = 5;
     */
    maxAge: number;
    /**
     * exposed_headers indicates which headers are made available to scripts via the browser.
     *
     * @generated from protobuf field: repeated string exposed_headers = 6;
     */
    exposedHeaders: string[];
}
/**
 * IdentityCenterPermissionSet defines a permission set that is available on an
 * IdentityCenter account app
 *
 * @generated from protobuf message types.IdentityCenterPermissionSet
 */
export interface IdentityCenterPermissionSet {
    /**
     * ARN is the fully-formed ARN of the Permission Set.
     *
     * @generated from protobuf field: string ARN = 1 [json_name = "ARN"];
     */
    aRN: string;
    /**
     * Name is the human-readable name of the Permission Set.
     *
     * @generated from protobuf field: string Name = 2 [json_name = "Name"];
     */
    name: string;
    /**
     * AssignmentID is the ID of the Teleport Account Assignment resource that
     * represents this permission being assigned on the enclosing Account.
     *
     * @generated from protobuf field: string AssignmentID = 3 [json_name = "AssignmentID"];
     */
    assignmentID: string;
}
/**
 * AppIdentityCenter encapsulates information about an AWS Identity Center
 * account application.
 *
 * @generated from protobuf message types.AppIdentityCenter
 */
export interface AppIdentityCenter {
    /**
     * Account ID is the AWS-assigned ID of the account
     *
     * @generated from protobuf field: string AccountID = 1 [json_name = "AccountID"];
     */
    accountID: string;
    /**
     * PermissionSets lists the available permission sets on the given account
     *
     * @generated from protobuf field: repeated types.IdentityCenterPermissionSet PermissionSets = 2 [json_name = "PermissionSets"];
     */
    permissionSets: IdentityCenterPermissionSet[];
}
/**
 * AppSpecV3 is the AppV3 resource spec.
 *
 * @generated from protobuf message types.AppSpecV3
 */
export interface AppSpecV3 {
    /**
     * URI is the web app endpoint.
     *
     * @generated from protobuf field: string URI = 1 [json_name = "URI"];
     */
    uRI: string;
    /**
     * PublicAddr is the public address the application is accessible at.
     *
     * @generated from protobuf field: string PublicAddr = 2 [json_name = "PublicAddr"];
     */
    publicAddr: string;
    /**
     * DynamicLabels are the app's command labels.
     *
     * @generated from protobuf field: map<string, types.CommandLabelV2> DynamicLabels = 3 [json_name = "DynamicLabels"];
     */
    dynamicLabels: {
        [key: string]: CommandLabelV2;
    };
    /**
     * InsecureSkipVerify disables app's TLS certificate verification.
     *
     * @generated from protobuf field: bool InsecureSkipVerify = 4 [json_name = "InsecureSkipVerify"];
     */
    insecureSkipVerify: boolean;
    /**
     * Rewrite is a list of rewriting rules to apply to requests and responses.
     *
     * @generated from protobuf field: types.Rewrite Rewrite = 5 [json_name = "Rewrite"];
     */
    rewrite?: Rewrite;
    /**
     * AWS contains additional options for AWS applications.
     *
     * @generated from protobuf field: types.AppAWS AWS = 6 [json_name = "AWS"];
     */
    aWS?: AppAWS;
    /**
     * Cloud identifies the cloud instance the app represents.
     *
     * @generated from protobuf field: string Cloud = 7 [json_name = "Cloud"];
     */
    cloud: string;
    /**
     * UserGroups are a list of user group IDs that this app is associated with.
     *
     * @generated from protobuf field: repeated string UserGroups = 8 [json_name = "UserGroups"];
     */
    userGroups: string[];
    /**
     * Integration is the integration name that must be used to access this Application.
     * Only applicable to AWS App Access.
     * If present, the Application must use the Integration's credentials instead of ambient credentials to access Cloud APIs.
     *
     * @generated from protobuf field: string Integration = 9 [json_name = "Integration"];
     */
    integration: string;
    /**
     * RequiredAppNames is a list of app names that are required for this app to function. Any app listed here will
     * be part of the authentication redirect flow and authenticate along side this app.
     *
     * @generated from protobuf field: repeated string RequiredAppNames = 10 [json_name = "RequiredAppNames"];
     */
    requiredAppNames: string[];
    /**
     * CORSPolicy defines the Cross-Origin Resource Sharing settings for the app.
     *
     * @generated from protobuf field: types.CORSPolicy CORS = 11 [json_name = "CORS"];
     */
    cORS?: CORSPolicy;
    /**
     * IdentityCenter encasulates AWS identity-center specific information. Only
     * valid for Identity Center account apps.
     *
     * @generated from protobuf field: types.AppIdentityCenter IdentityCenter = 12 [json_name = "IdentityCenter"];
     */
    identityCenter?: AppIdentityCenter;
    /**
     * TCPPorts is a list of ports and port ranges that an app agent can forward connections to.
     * Only applicable to TCP App Access.
     * If this field is not empty, URI is expected to contain no port number and start with the tcp
     * protocol.
     *
     * @generated from protobuf field: repeated types.PortRange TCPPorts = 13 [json_name = "TCPPorts"];
     */
    tCPPorts: PortRange[];
    /**
     * UseAnyProxyPublicAddr will rebuild this app's fqdn based on the proxy public addr that the
     * request originated from. This should be true if your proxy has multiple proxy public addrs and you
     * want the app to be accessible from any of them. If `public_addr` is explicitly set in the app spec,
     * setting this value to true will overwrite that public address in the web UI.
     *
     * @generated from protobuf field: bool UseAnyProxyPublicAddr = 14 [json_name = "UseAnyProxyPublicAddr"];
     */
    useAnyProxyPublicAddr: boolean;
}
/**
 * Rewrite is a list of rewriting rules to apply to requests and responses.
 *
 * @generated from protobuf message types.Rewrite
 */
export interface Rewrite {
    /**
     * Redirect defines a list of hosts which will be rewritten to the public
     * address of the application if they occur in the "Location" header.
     *
     * @generated from protobuf field: repeated string Redirect = 1 [json_name = "Redirect"];
     */
    redirect: string[];
    /**
     * Headers is a list of headers to inject when passing the request over
     * to the application.
     *
     * @generated from protobuf field: repeated types.Header Headers = 2 [json_name = "Headers"];
     */
    headers: Header[];
    /**
     * JWTClaims configures whether roles/traits are included in the JWT token.
     *
     * @generated from protobuf field: string JWTClaims = 3 [json_name = "JWTClaims"];
     */
    jWTClaims: string;
}
/**
 * Header represents a single http header passed over to the proxied application.
 *
 * @generated from protobuf message types.Header
 */
export interface Header {
    /**
     * Name is the http header name.
     *
     * @generated from protobuf field: string Name = 1 [json_name = "Name"];
     */
    name: string;
    /**
     * Value is the http header value.
     *
     * @generated from protobuf field: string Value = 2 [json_name = "Value"];
     */
    value: string;
}
/**
 * PortRange describes a port range for TCP apps. The range starts with Port and ends with EndPort.
 * PortRange can be used to describe a single port in which case the Port field is the port and the
 * EndPort field is 0.
 *
 * @generated from protobuf message types.PortRange
 */
export interface PortRange {
    /**
     * Port describes the start of the range. It must be between 1 and 65535.
     *
     * @generated from protobuf field: uint32 Port = 1 [json_name = "Port"];
     */
    port: number;
    /**
     * EndPort describes the end of the range, inclusive. If set, it must be between 2 and 65535 and
     * be greater than Port when describing a port range. When omitted or set to zero, it signifies
     * that the port range defines a single port.
     *
     * @generated from protobuf field: uint32 EndPort = 2 [json_name = "EndPort"];
     */
    endPort: number;
}
/**
 * CommandLabelV2 is a label that has a value as a result of the
 * output generated by running command, e.g. hostname
 *
 * @generated from protobuf message types.CommandLabelV2
 */
export interface CommandLabelV2 {
    /**
     * Period is a time between command runs
     *
     * @generated from protobuf field: int64 Period = 1 [json_name = "Period"];
     */
    period: bigint;
    /**
     * Command is a command to run
     *
     * @generated from protobuf field: repeated string Command = 2 [json_name = "Command"];
     */
    command: string[];
    /**
     * Result captures standard output
     *
     * @generated from protobuf field: string Result = 3 [json_name = "Result"];
     */
    result: string;
}
/**
 * AppAWS contains additional options for AWS applications.
 *
 * @generated from protobuf message types.AppAWS
 */
export interface AppAWS {
    /**
     * ExternalID is the AWS External ID used when assuming roles in this app.
     *
     * @generated from protobuf field: string ExternalID = 1 [json_name = "ExternalID"];
     */
    externalID: string;
    /**
     * RolesAnywhereProfile contains the IAM Roles Anywhere fields associated with this Application.
     * These fields are set when performing the synchronization of AWS IAM Roles Anywhere Profiles into Teleport Apps.
     *
     * @generated from protobuf field: types.AppAWSRolesAnywhereProfile RolesAnywhereProfile = 2 [json_name = "RolesAnywhereProfile"];
     */
    rolesAnywhereProfile?: AppAWSRolesAnywhereProfile;
}
/**
 * AppAWSRolesAnywhereProfile contains the fields that represent an AWS IAM Roles Anywhere Profile.
 *
 * @generated from protobuf message types.AppAWSRolesAnywhereProfile
 */
export interface AppAWSRolesAnywhereProfile {
    /**
     * ProfileARN is the AWS IAM Roles Anywhere Profile ARN that originated this Teleport App.
     *
     * @generated from protobuf field: string ProfileARN = 1 [json_name = "ProfileARN"];
     */
    profileARN: string;
    /**
     * Whether this Roles Anywhere Profile accepts a custom role session name.
     * When not supported, the AWS Session Name will be the X.509 certificate's serial number.
     * When supported, the AWS Session Name will be the identity's username.
     * This values comes from:
     * https://docs.aws.amazon.com/rolesanywhere/latest/APIReference/API_ProfileDetail.html / acceptRoleSessionName
     *
     * @generated from protobuf field: bool AcceptRoleSessionName = 2 [json_name = "AcceptRoleSessionName"];
     */
    acceptRoleSessionName: boolean;
}
/**
 * SSHKeyPair is an SSH CA key pair.
 *
 * @generated from protobuf message types.SSHKeyPair
 */
export interface SSHKeyPair {
    /**
     * PublicKey is the SSH public key.
     *
     * @generated from protobuf field: bytes PublicKey = 1 [json_name = "PublicKey"];
     */
    publicKey: Uint8Array;
    /**
     * PrivateKey is the SSH private key.
     *
     * @generated from protobuf field: bytes PrivateKey = 2 [json_name = "PrivateKey"];
     */
    privateKey: Uint8Array;
    /**
     * PrivateKeyType is the type of the PrivateKey.
     *
     * @generated from protobuf field: types.PrivateKeyType PrivateKeyType = 3 [json_name = "PrivateKeyType"];
     */
    privateKeyType: PrivateKeyType;
}
/**
 * TLSKeyPair is a TLS key pair
 *
 * @generated from protobuf message types.TLSKeyPair
 */
export interface TLSKeyPair {
    /**
     * Cert is a PEM encoded TLS cert
     *
     * @generated from protobuf field: bytes Cert = 1 [json_name = "Cert"];
     */
    cert: Uint8Array;
    /**
     * Key is a PEM encoded TLS key
     *
     * @generated from protobuf field: bytes Key = 2 [json_name = "Key"];
     */
    key: Uint8Array;
    /**
     * KeyType is the type of the Key.
     *
     * @generated from protobuf field: types.PrivateKeyType KeyType = 3 [json_name = "KeyType"];
     */
    keyType: PrivateKeyType;
}
/**
 * JWTKeyPair is a PEM encoded keypair used for signing JWT tokens.
 *
 * @generated from protobuf message types.JWTKeyPair
 */
export interface JWTKeyPair {
    /**
     * PublicKey is a PEM encoded public key.
     *
     * @generated from protobuf field: bytes PublicKey = 1 [json_name = "PublicKey"];
     */
    publicKey: Uint8Array;
    /**
     * PrivateKey is a PEM encoded private key.
     *
     * @generated from protobuf field: bytes PrivateKey = 2 [json_name = "PrivateKey"];
     */
    privateKey: Uint8Array;
    /**
     * PrivateKeyType is the type of the PrivateKey.
     *
     * @generated from protobuf field: types.PrivateKeyType PrivateKeyType = 3 [json_name = "PrivateKeyType"];
     */
    privateKeyType: PrivateKeyType;
}
/**
 * CertAuthorityV2 is version 2 resource spec for Cert Authority
 *
 * @generated from protobuf message types.CertAuthorityV2
 */
export interface CertAuthorityV2 {
    /**
     * Kind is a resource kind
     *
     * @generated from protobuf field: string Kind = 1 [json_name = "Kind"];
     */
    kind: string;
    /**
     * SubKind is an optional resource sub kind, used in some resources
     *
     * @generated from protobuf field: string SubKind = 2 [json_name = "SubKind"];
     */
    subKind: string;
    /**
     * Version is version
     *
     * @generated from protobuf field: string Version = 3 [json_name = "Version"];
     */
    version: string;
    /**
     * Metadata is connector metadata
     *
     * @generated from protobuf field: types.Metadata Metadata = 4 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Spec contains cert authority specification
     *
     * @generated from protobuf field: types.CertAuthoritySpecV2 Spec = 5 [json_name = "Spec"];
     */
    spec?: CertAuthoritySpecV2;
}
/**
 * CertAuthoritySpecV2 is a host or user certificate authority that
 * can check and if it has private key stored as well, sign it too
 *
 * @generated from protobuf message types.CertAuthoritySpecV2
 */
export interface CertAuthoritySpecV2 {
    /**
     * Type is either user or host certificate authority
     *
     * @generated from protobuf field: string Type = 1 [json_name = "Type"];
     */
    type: string;
    /**
     * ClusterName identifies the cluster name this authority serves.
     *
     * @generated from protobuf field: string ClusterName = 2 [json_name = "ClusterName"];
     */
    clusterName: string;
    /**
     * Roles is a list of roles assumed by users signed by this CA
     *
     * @generated from protobuf field: repeated string Roles = 5 [json_name = "Roles"];
     */
    roles: string[];
    /**
     * RoleMap specifies role mappings to remote roles
     *
     * @generated from protobuf field: repeated types.RoleMapping RoleMap = 6 [json_name = "RoleMap"];
     */
    roleMap: RoleMapping[];
    /**
     * Rotation is a status of the certificate authority rotation
     *
     * @generated from protobuf field: types.Rotation Rotation = 8 [json_name = "Rotation"];
     */
    rotation?: Rotation;
    /**
     * SigningAlg is unused.
     *
     * Deprecated: SigningAlg is unused.
     *
     * @deprecated
     * @generated from protobuf field: types.CertAuthoritySpecV2.SigningAlgType SigningAlg = 9 [deprecated = true, json_name = "SigningAlg"];
     */
    signingAlg: CertAuthoritySpecV2_SigningAlgType;
    /**
     * ActiveKeys are the CA key sets used to sign any new certificates.
     *
     * @generated from protobuf field: types.CAKeySet ActiveKeys = 11 [json_name = "ActiveKeys"];
     */
    activeKeys?: CAKeySet;
    /**
     * AdditionalTrustedKeys are additional CA key sets that can be used to
     * verify certificates. Certificates should be verified with
     * AdditionalTrustedKeys and ActiveKeys combined.
     *
     * @generated from protobuf field: types.CAKeySet AdditionalTrustedKeys = 12 [json_name = "AdditionalTrustedKeys"];
     */
    additionalTrustedKeys?: CAKeySet;
}
/**
 * SigningAlgType is unused.
 *
 * Deprecated: SigningAlgType is unused.
 *
 * @deprecated
 * @generated from protobuf enum types.CertAuthoritySpecV2.SigningAlgType
 */
export enum CertAuthoritySpecV2_SigningAlgType {
    /**
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: RSA_SHA1 = 1;
     */
    RSA_SHA1 = 1,
    /**
     * @generated from protobuf enum value: RSA_SHA2_256 = 2;
     */
    RSA_SHA2_256 = 2,
    /**
     * @generated from protobuf enum value: RSA_SHA2_512 = 3;
     */
    RSA_SHA2_512 = 3
}
/**
 * CAKeySet is the set of CA keys.
 *
 * @generated from protobuf message types.CAKeySet
 */
export interface CAKeySet {
    /**
     * SSH contains SSH CA key pairs.
     *
     * @generated from protobuf field: repeated types.SSHKeyPair SSH = 1 [json_name = "SSH"];
     */
    sSH: SSHKeyPair[];
    /**
     * TLS contains TLS CA key/cert pairs.
     *
     * @generated from protobuf field: repeated types.TLSKeyPair TLS = 2 [json_name = "TLS"];
     */
    tLS: TLSKeyPair[];
    /**
     * JWT contains JWT signing key pairs.
     *
     * @generated from protobuf field: repeated types.JWTKeyPair JWT = 3 [json_name = "JWT"];
     */
    jWT: JWTKeyPair[];
}
/**
 * RoleMapping provides mapping of remote roles to local roles
 * for trusted clusters
 *
 * @generated from protobuf message types.RoleMapping
 */
export interface RoleMapping {
    /**
     * Remote specifies remote role name to map from
     *
     * @generated from protobuf field: string Remote = 1 [json_name = "Remote"];
     */
    remote: string;
    /**
     * Local specifies local roles to map to
     *
     * @generated from protobuf field: repeated string Local = 2 [json_name = "Local"];
     */
    local: string[];
}
/**
 * ProvisionTokenV1 is a provisioning token V1
 *
 * @generated from protobuf message types.ProvisionTokenV1
 */
export interface ProvisionTokenV1 {
    /**
     * Roles is a list of roles associated with the token,
     * that will be converted to metadata in the SSH and X509
     * certificates issued to the user of the token
     *
     * @generated from protobuf field: repeated string Roles = 1 [json_name = "Roles"];
     */
    roles: string[];
    /**
     * Expires is a global expiry time header can be set on any resource in the
     * system.
     *
     * @generated from protobuf field: google.protobuf.Timestamp Expires = 2 [json_name = "Expires"];
     */
    expires?: Timestamp;
    /**
     * Token is a token name
     *
     * @generated from protobuf field: string Token = 3 [json_name = "Token"];
     */
    token: string;
}
/**
 * ProvisionTokenV2 specifies provisioning token
 *
 * @generated from protobuf message types.ProvisionTokenV2
 */
export interface ProvisionTokenV2 {
    /**
     * Kind is a resource kind
     *
     * @generated from protobuf field: string Kind = 1 [json_name = "Kind"];
     */
    kind: string;
    /**
     * SubKind is an optional resource sub kind, used in some resources
     *
     * @generated from protobuf field: string SubKind = 2 [json_name = "SubKind"];
     */
    subKind: string;
    /**
     * Version is the resource version. It must be specified.
     * Supported values are:`v2`.
     *
     * @generated from protobuf field: string Version = 3 [json_name = "Version"];
     */
    version: string;
    /**
     * Metadata is resource metadata
     *
     * @generated from protobuf field: types.Metadata Metadata = 4 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Spec is a provisioning token V2 spec
     *
     * @generated from protobuf field: types.ProvisionTokenSpecV2 Spec = 5 [json_name = "Spec"];
     */
    spec?: ProvisionTokenSpecV2;
    /**
     * Status is extended status information, depending on token type. It is not
     * user writable.
     *
     * @generated from protobuf field: types.ProvisionTokenStatusV2 Status = 6 [json_name = "Status"];
     */
    status?: ProvisionTokenStatusV2;
}
/**
 * ProvisionTokenV2List is a list of provisioning tokens.
 *
 * @generated from protobuf message types.ProvisionTokenV2List
 */
export interface ProvisionTokenV2List {
    /**
     * ProvisionTokens is a list of provisioning tokens.
     *
     * @generated from protobuf field: repeated types.ProvisionTokenV2 ProvisionTokens = 1 [json_name = "ProvisionTokens"];
     */
    provisionTokens: ProvisionTokenV2[];
}
/**
 * TokenRule is a rule that a joining node must match in order to use the
 * associated token.
 *
 * @generated from protobuf message types.TokenRule
 */
export interface TokenRule {
    /**
     * AWSAccount is the AWS account ID.
     *
     * @generated from protobuf field: string AWSAccount = 1 [json_name = "AWSAccount"];
     */
    aWSAccount: string;
    /**
     * AWSRegions is used for the EC2 join method and is a list of AWS regions a
     * node is allowed to join from.
     *
     * @generated from protobuf field: repeated string AWSRegions = 2 [json_name = "AWSRegions"];
     */
    aWSRegions: string[];
    /**
     * AWSRole is used for the EC2 join method and is the ARN of the AWS
     * role that the Auth Service will assume in order to call the ec2 API.
     *
     * @generated from protobuf field: string AWSRole = 3 [json_name = "AWSRole"];
     */
    aWSRole: string;
    /**
     * AWSARN is used for the IAM join method, the AWS identity of joining nodes
     * must match this ARN. Supports wildcards "*" and "?".
     *
     * @generated from protobuf field: string AWSARN = 4 [json_name = "AWSARN"];
     */
    aWSARN: string;
}
/**
 * ProvisionTokenSpecV2 is a specification for V2 token
 *
 * @generated from protobuf message types.ProvisionTokenSpecV2
 */
export interface ProvisionTokenSpecV2 {
    /**
     * Roles is a list of roles associated with the token,
     * that will be converted to metadata in the SSH and X509
     * certificates issued to the user of the token
     *
     * @generated from protobuf field: repeated string Roles = 1 [json_name = "Roles"];
     */
    roles: string[];
    /**
     * Allow is a list of TokenRules, nodes using this token must match one
     * allow rule to use this token.
     *
     * @generated from protobuf field: repeated types.TokenRule Allow = 2 [json_name = "Allow"];
     */
    allow: TokenRule[];
    /**
     * AWSIIDTTL is the TTL to use for AWS EC2 Instance Identity Documents used
     * to join the cluster with this token.
     *
     * @generated from protobuf field: int64 AWSIIDTTL = 3 [json_name = "AWSIIDTTL"];
     */
    aWSIIDTTL: bigint;
    /**
     * JoinMethod is the joining method required in order to use this token.
     * Supported joining methods include: azure, circleci, ec2, gcp, github, gitlab, iam, kubernetes, spacelift, token, tpm
     *
     * @generated from protobuf field: string JoinMethod = 4 [json_name = "JoinMethod"];
     */
    joinMethod: string;
    /**
     * BotName is the name of the bot this token grants access to, if any
     *
     * @generated from protobuf field: string BotName = 5 [json_name = "BotName"];
     */
    botName: string;
    /**
     * SuggestedLabels is a set of labels that resources should set when using this token to enroll
     * themselves in the cluster.
     * Currently, only node-join scripts create a configuration according to the suggestion.
     *
     * @generated from protobuf field: wrappers.LabelValues SuggestedLabels = 6 [json_name = "SuggestedLabels"];
     */
    suggestedLabels?: LabelValues;
    /**
     * GitHub allows the configuration of options specific to the "github" join method.
     *
     * @generated from protobuf field: types.ProvisionTokenSpecV2GitHub GitHub = 7 [json_name = "GitHub"];
     */
    gitHub?: ProvisionTokenSpecV2GitHub;
    /**
     * CircleCI allows the configuration of options specific to the "circleci" join method.
     *
     * @generated from protobuf field: types.ProvisionTokenSpecV2CircleCI CircleCI = 8 [json_name = "CircleCI"];
     */
    circleCI?: ProvisionTokenSpecV2CircleCI;
    /**
     * SuggestedAgentMatcherLabels is a set of labels to be used by agents to match on resources.
     * When an agent uses this token, the agent should monitor resources that match those labels.
     * For databases, this means adding the labels to `db_service.resources.labels`.
     * Currently, only node-join scripts create a configuration according to the suggestion.
     *
     * @generated from protobuf field: wrappers.LabelValues SuggestedAgentMatcherLabels = 9 [json_name = "SuggestedAgentMatcherLabels"];
     */
    suggestedAgentMatcherLabels?: LabelValues;
    /**
     * Kubernetes allows the configuration of options specific to the "kubernetes" join method.
     *
     * @generated from protobuf field: types.ProvisionTokenSpecV2Kubernetes Kubernetes = 10 [json_name = "Kubernetes"];
     */
    kubernetes?: ProvisionTokenSpecV2Kubernetes;
    /**
     * Azure allows the configuration of options specific to the "azure" join method.
     *
     * @generated from protobuf field: types.ProvisionTokenSpecV2Azure Azure = 11 [json_name = "Azure"];
     */
    azure?: ProvisionTokenSpecV2Azure;
    /**
     * GitLab allows the configuration of options specific to the "gitlab" join method.
     *
     * @generated from protobuf field: types.ProvisionTokenSpecV2GitLab GitLab = 12 [json_name = "GitLab"];
     */
    gitLab?: ProvisionTokenSpecV2GitLab;
    /**
     * GCP allows the configuration of options specific to the "gcp" join method.
     *
     * @generated from protobuf field: types.ProvisionTokenSpecV2GCP GCP = 13 [json_name = "GCP"];
     */
    gCP?: ProvisionTokenSpecV2GCP;
    /**
     * Spacelift allows the configuration of options specific to the "spacelift" join method.
     *
     * @generated from protobuf field: types.ProvisionTokenSpecV2Spacelift Spacelift = 14 [json_name = "Spacelift"];
     */
    spacelift?: ProvisionTokenSpecV2Spacelift;
    /**
     * TPM allows the configuration of options specific to the "tpm" join method.
     *
     * @generated from protobuf field: types.ProvisionTokenSpecV2TPM TPM = 15 [json_name = "TPM"];
     */
    tPM?: ProvisionTokenSpecV2TPM;
    /**
     * TerraformCloud allows the configuration of options specific to the "terraform_cloud" join method.
     *
     * @generated from protobuf field: types.ProvisionTokenSpecV2TerraformCloud TerraformCloud = 16 [json_name = "TerraformCloud"];
     */
    terraformCloud?: ProvisionTokenSpecV2TerraformCloud;
    /**
     * Bitbucket allows the configuration of options specific to the "bitbucket" join method.
     *
     * @generated from protobuf field: types.ProvisionTokenSpecV2Bitbucket Bitbucket = 17 [json_name = "Bitbucket"];
     */
    bitbucket?: ProvisionTokenSpecV2Bitbucket;
    /**
     * Oracle allows the configuration of options specific to the "oracle" join method.
     *
     * @generated from protobuf field: types.ProvisionTokenSpecV2Oracle Oracle = 18 [json_name = "Oracle"];
     */
    oracle?: ProvisionTokenSpecV2Oracle;
    /**
     * BoundKeypair allows the configuration of options specific to the "bound_keypair" join method.
     *
     * @generated from protobuf field: types.ProvisionTokenSpecV2BoundKeypair BoundKeypair = 19 [json_name = "BoundKeypair"];
     */
    boundKeypair?: ProvisionTokenSpecV2BoundKeypair;
    /**
     * AzureDevops allows the configuration of options specific to the "azure_devops" join method.
     *
     * @generated from protobuf field: types.ProvisionTokenSpecV2AzureDevops AzureDevops = 20 [json_name = "AzureDevops"];
     */
    azureDevops?: ProvisionTokenSpecV2AzureDevops;
}
/**
 * ProvisionTokenSpecV2AzureDevops contains the Azure Devops-specific
 * configuration.
 *
 * @generated from protobuf message types.ProvisionTokenSpecV2AzureDevops
 */
export interface ProvisionTokenSpecV2AzureDevops {
    /**
     * Allow is a list of TokenRules, nodes using this token must match one
     * allow rule to use this token. At least one allow rule must be specified.
     *
     * @generated from protobuf field: repeated types.ProvisionTokenSpecV2AzureDevops.Rule Allow = 1 [json_name = "Allow"];
     */
    allow: ProvisionTokenSpecV2AzureDevops_Rule[];
    /**
     * OrganizationID specifies the UUID of the Azure DevOps organization that
     * this join token will grant access to. This is used to identify the correct
     * issuer verification of the ID token.
     * This is a required field.
     *
     * @generated from protobuf field: string OrganizationID = 2 [json_name = "OrganizationID"];
     */
    organizationID: string;
}
/**
 * @generated from protobuf message types.ProvisionTokenSpecV2AzureDevops.Rule
 */
export interface ProvisionTokenSpecV2AzureDevops_Rule {
    /**
     * Sub also known as Subject is a string that roughly uniquely identifies
     * the workload. Example:
     * `p://my-organization/my-project/my-pipeline`
     * Mapped from the `sub` claim.
     *
     * @generated from protobuf field: string Sub = 1 [json_name = "Sub"];
     */
    sub: string;
    /**
     * The name of the AZDO project. Example:
     * `my-project`.
     * Mapped out of the `sub` claim.
     *
     * @generated from protobuf field: string ProjectName = 2 [json_name = "ProjectName"];
     */
    projectName: string;
    /**
     * The name of the AZDO pipeline. Example:
     * `my-pipeline`.
     * Mapped out of the `sub` claim.
     *
     * @generated from protobuf field: string PipelineName = 3 [json_name = "PipelineName"];
     */
    pipelineName: string;
    /**
     * The ID of the AZDO pipeline. Example:
     * `271ef6f7-0000-0000-0000-4b54d9129990`
     * Mapped from the `prj_id` claim.
     *
     * @generated from protobuf field: string ProjectID = 4 [json_name = "ProjectID"];
     */
    projectID: string;
    /**
     * The ID of the AZDO pipeline definition. Example:
     * `1`
     * Mapped from the `def_id` claim.
     *
     * @generated from protobuf field: string DefinitionID = 5 [json_name = "DefinitionID"];
     */
    definitionID: string;
    /**
     * The URI of the repository the pipeline is using. Example:
     * `https://github.com/gravitational/teleport.git`.
     * Mapped from the `rpo_uri` claim.
     *
     * @generated from protobuf field: string RepositoryURI = 6 [json_name = "RepositoryURI"];
     */
    repositoryURI: string;
    /**
     * The individual commit of the repository the pipeline is using. Example:
     * `e6b9eb29a288b27a3a82cc19c48b9d94b80aff36`.
     * Mapped from the `rpo_ver` claim.
     *
     * @generated from protobuf field: string RepositoryVersion = 7 [json_name = "RepositoryVersion"];
     */
    repositoryVersion: string;
    /**
     * The reference of the repository the pipeline is using. Example:
     * `refs/heads/main`.
     * Mapped from the `rpo_ref` claim.
     *
     * @generated from protobuf field: string RepositoryRef = 8 [json_name = "RepositoryRef"];
     */
    repositoryRef: string;
}
/**
 * ProvisionTokenSpecV2TPM contains the TPM-specific part of the
 * ProvisionTokenSpecV2
 *
 * @generated from protobuf message types.ProvisionTokenSpecV2TPM
 */
export interface ProvisionTokenSpecV2TPM {
    /**
     * Allow is a list of Rules, the presented delegated identity must match one
     * allow rule to permit joining.
     *
     * @generated from protobuf field: repeated types.ProvisionTokenSpecV2TPM.Rule Allow = 1 [json_name = "Allow"];
     */
    allow: ProvisionTokenSpecV2TPM_Rule[];
    /**
     * EKCertAllowedCAs is a list of CA certificates that will be used to validate
     * TPM EKCerts.
     * When specified, joining TPMs must present an EKCert signed by one of the
     * specified CAs. TPMs that do not present an EKCert will be not permitted to
     * join.
     * When unspecified, TPMs will be allowed to join with either an EKCert or an
     * EKPubHash.
     *
     * @generated from protobuf field: repeated string EKCertAllowedCAs = 2 [json_name = "EKCertAllowedCAs"];
     */
    eKCertAllowedCAs: string[];
}
/**
 * @generated from protobuf message types.ProvisionTokenSpecV2TPM.Rule
 */
export interface ProvisionTokenSpecV2TPM_Rule {
    /**
     * Description is a human-readable description of the rule. It has no
     * bearing on whether or not a TPM is allowed to join, but can be used
     * to associate a rule with a specific host (e.g the asset tag of the server
     * in which the TPM resides).
     * Example: "build-server-100"
     *
     * @generated from protobuf field: string Description = 1 [json_name = "Description"];
     */
    description: string;
    /**
     * EKPublicHash is the SHA256 hash of the EKPub marshaled in PKIX format
     * and encoded in hexadecimal. This value will also be checked when a TPM
     * has submitted an EKCert, and the public key in the EKCert will be used
     * for this check.
     * Example: d4b45864d9d6fabfc568d74f26c35ababde2105337d7af9a6605e1c56c891aa6
     *
     * @generated from protobuf field: string EKPublicHash = 4 [json_name = "EKPublicHash"];
     */
    eKPublicHash: string;
    /**
     * EKCertificateSerial is the serial number of the EKCert in hexadecimal
     * with colon separated nibbles. This value will not be checked when a TPM
     * does not have an EKCert configured.
     * Example: 73:df:dc:bd:af:ef:8a:d8:15:2e:96:71:7a:3e:7f:a4
     *
     * @generated from protobuf field: string EKCertificateSerial = 5 [json_name = "EKCertificateSerial"];
     */
    eKCertificateSerial: string;
}
/**
 * ProvisionTokenSpecV2Github contains the GitHub-specific part of the
 * ProvisionTokenSpecV2
 *
 * @generated from protobuf message types.ProvisionTokenSpecV2GitHub
 */
export interface ProvisionTokenSpecV2GitHub {
    /**
     * Allow is a list of TokenRules, nodes using this token must match one
     * allow rule to use this token.
     *
     * @generated from protobuf field: repeated types.ProvisionTokenSpecV2GitHub.Rule Allow = 1 [json_name = "Allow"];
     */
    allow: ProvisionTokenSpecV2GitHub_Rule[];
    /**
     * EnterpriseServerHost allows joining from runners associated with a
     * GitHub Enterprise Server instance. When unconfigured, tokens will be
     * validated against github.com, but when configured to the host of a GHES
     * instance, then the tokens will be validated against host.
     *
     * This value should be the hostname of the GHES instance, and should not
     * include the scheme or a path. The instance must be accessible over HTTPS
     * at this hostname and the certificate must be trusted by the Auth Service.
     *
     * @generated from protobuf field: string EnterpriseServerHost = 2 [json_name = "EnterpriseServerHost"];
     */
    enterpriseServerHost: string;
    /**
     * EnterpriseSlug allows the slug of a GitHub Enterprise organisation to be
     * included in the expected issuer of the OIDC tokens. This is for
     * compatibility with the `include_enterprise_slug` option in GHE.
     *
     * This field should be set to the slug of your enterprise if this is enabled. If
     * this is not enabled, then this field must be left empty. This field cannot
     * be specified if `enterprise_server_host` is specified.
     *
     * See https://docs.github.com/en/enterprise-cloud@latest/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect#customizing-the-issuer-value-for-an-enterprise
     * for more information about customized issuer values.
     *
     * @generated from protobuf field: string EnterpriseSlug = 3 [json_name = "EnterpriseSlug"];
     */
    enterpriseSlug: string;
    /**
     * StaticJWKS disables fetching of the GHES signing keys via the JWKS/OIDC
     * endpoints, and allows them to be directly specified. This allows joining
     * from GitHub Actions in GHES instances that are not reachable by the
     * Teleport Auth Service.
     *
     * @generated from protobuf field: string StaticJWKS = 4 [json_name = "StaticJWKS"];
     */
    staticJWKS: string;
}
/**
 * Rule includes fields mapped from `lib/githubactions.IDToken`
 * Not all fields should be included, only ones that we expect to be useful
 * when trying to create rules around which workflows should be allowed to
 * authenticate against a cluster.
 *
 * @generated from protobuf message types.ProvisionTokenSpecV2GitHub.Rule
 */
export interface ProvisionTokenSpecV2GitHub_Rule {
    /**
     * Sub also known as Subject is a string that roughly uniquely identifies
     * the workload. The format of this varies depending on the type of
     * github action run.
     *
     * @generated from protobuf field: string Sub = 1 [json_name = "Sub"];
     */
    sub: string;
    /**
     * The repository from where the workflow is running.
     * This includes the name of the owner e.g `gravitational/teleport`
     *
     * @generated from protobuf field: string Repository = 2 [json_name = "Repository"];
     */
    repository: string;
    /**
     * The name of the organization in which the repository is stored.
     *
     * @generated from protobuf field: string RepositoryOwner = 3 [json_name = "RepositoryOwner"];
     */
    repositoryOwner: string;
    /**
     * The name of the workflow.
     *
     * @generated from protobuf field: string Workflow = 4 [json_name = "Workflow"];
     */
    workflow: string;
    /**
     * The name of the environment used by the job.
     *
     * @generated from protobuf field: string Environment = 5 [json_name = "Environment"];
     */
    environment: string;
    /**
     * The personal account that initiated the workflow run.
     *
     * @generated from protobuf field: string Actor = 6 [json_name = "Actor"];
     */
    actor: string;
    /**
     * The git ref that triggered the workflow run.
     *
     * @generated from protobuf field: string Ref = 7 [json_name = "Ref"];
     */
    ref: string;
    /**
     * The type of ref, for example: "branch".
     *
     * @generated from protobuf field: string RefType = 8 [json_name = "RefType"];
     */
    refType: string;
}
/**
 * ProvisionTokenSpecV2GitLab contains the GitLab-specific part of the
 * ProvisionTokenSpecV2
 *
 * @generated from protobuf message types.ProvisionTokenSpecV2GitLab
 */
export interface ProvisionTokenSpecV2GitLab {
    /**
     * Allow is a list of TokenRules, nodes using this token must match one
     * allow rule to use this token.
     *
     * @generated from protobuf field: repeated types.ProvisionTokenSpecV2GitLab.Rule Allow = 1 [json_name = "Allow"];
     */
    allow: ProvisionTokenSpecV2GitLab_Rule[];
    /**
     * Domain is the domain of your GitLab instance. This will default to
     * `gitlab.com` - but can be set to the domain of your self-hosted GitLab
     * e.g `gitlab.example.com`.
     *
     * @generated from protobuf field: string Domain = 2 [json_name = "Domain"];
     */
    domain: string;
    /**
     * StaticJWKS disables fetching of the GitLab signing keys via the JWKS/OIDC
     * endpoints, and allows them to be directly specified. This allows joining
     * from GitLab CI instances that are not reachable by the Teleport Auth
     * Service.
     *
     * @generated from protobuf field: string StaticJWKS = 3 [json_name = "StaticJWKS"];
     */
    staticJWKS: string;
}
/**
 * @generated from protobuf message types.ProvisionTokenSpecV2GitLab.Rule
 */
export interface ProvisionTokenSpecV2GitLab_Rule {
    /**
     * Sub roughly uniquely identifies the workload. Example:
     * `project_path:mygroup/my-project:ref_type:branch:ref:main`
     * project_path:GROUP/PROJECT:ref_type:TYPE:ref:BRANCH_NAME
     *
     * This field supports "glob-style" matching:
     * - Use '*' to match zero or more characters.
     * - Use '?' to match any single character.
     *
     * @generated from protobuf field: string Sub = 1 [json_name = "Sub"];
     */
    sub: string;
    /**
     * Ref allows access to be limited to jobs triggered by a specific git ref.
     * Ensure this is used in combination with ref_type.
     *
     * This field supports "glob-style" matching:
     * - Use '*' to match zero or more characters.
     * - Use '?' to match any single character.
     *
     * @generated from protobuf field: string Ref = 2 [json_name = "Ref"];
     */
    ref: string;
    /**
     * RefType allows access to be limited to jobs triggered by a specific git
     * ref type. Example:
     * `branch` or `tag`
     *
     * @generated from protobuf field: string RefType = 3 [json_name = "RefType"];
     */
    refType: string;
    /**
     * NamespacePath is used to limit access to jobs in a group or user's
     * projects.
     * Example:
     * `mygroup`
     *
     * This field supports "glob-style" matching:
     * - Use '*' to match zero or more characters.
     * - Use '?' to match any single character.
     *
     * @generated from protobuf field: string NamespacePath = 4 [json_name = "NamespacePath"];
     */
    namespacePath: string;
    /**
     * ProjectPath is used to limit access to jobs belonging to an individual
     * project. Example:
     * `mygroup/myproject`
     *
     * This field supports "glob-style" matching:
     * - Use '*' to match zero or more characters.
     * - Use '?' to match any single character.
     *
     * @generated from protobuf field: string ProjectPath = 5 [json_name = "ProjectPath"];
     */
    projectPath: string;
    /**
     * PipelineSource limits access by the job pipeline source type.
     * https://docs.gitlab.com/ee/ci/jobs/job_control.html#common-if-clauses-for-rules
     * Example: `web`
     *
     * @generated from protobuf field: string PipelineSource = 6 [json_name = "PipelineSource"];
     */
    pipelineSource: string;
    /**
     * Environment limits access by the environment the job deploys to
     * (if one is associated)
     *
     * @generated from protobuf field: string Environment = 7 [json_name = "Environment"];
     */
    environment: string;
    /**
     * UserLogin is the username of the user executing the job
     *
     * @generated from protobuf field: string UserLogin = 8 [json_name = "UserLogin"];
     */
    userLogin: string;
    /**
     * UserID is the ID of the user executing the job
     *
     * @generated from protobuf field: string UserID = 9 [json_name = "UserID"];
     */
    userID: string;
    /**
     * UserEmail is the email of the user executing the job
     *
     * @generated from protobuf field: string UserEmail = 10 [json_name = "UserEmail"];
     */
    userEmail: string;
    /**
     * RefProtected is true if the Git ref is protected, false otherwise.
     *
     * @generated from protobuf field: types.BoolValue RefProtected = 11 [json_name = "RefProtected"];
     */
    refProtected?: BoolValue;
    /**
     * EnvironmentProtected is true if the Git ref is protected, false otherwise.
     *
     * @generated from protobuf field: types.BoolValue EnvironmentProtected = 12 [json_name = "EnvironmentProtected"];
     */
    environmentProtected?: BoolValue;
    /**
     * CIConfigSHA is the git commit SHA for the ci_config_ref_uri.
     *
     * @generated from protobuf field: string CIConfigSHA = 13 [json_name = "CIConfigSHA"];
     */
    cIConfigSHA: string;
    /**
     * CIConfigRefURI is the ref path to the top-level pipeline definition, for example,
     * gitlab.example.com/my-group/my-project//.gitlab-ci.yml@refs/heads/main.
     *
     * @generated from protobuf field: string CIConfigRefURI = 14 [json_name = "CIConfigRefURI"];
     */
    cIConfigRefURI: string;
    /**
     * DeploymentTier is the deployment tier of the environment the job specifies
     *
     * @generated from protobuf field: string DeploymentTier = 15 [json_name = "DeploymentTier"];
     */
    deploymentTier: string;
    /**
     * ProjectVisibility is the visibility of the project where the pipeline is running.
     * Can be internal, private, or public.
     *
     * @generated from protobuf field: string ProjectVisibility = 16 [json_name = "ProjectVisibility"];
     */
    projectVisibility: string;
}
/**
 * ProvisionTokenSpecV2CircleCI contains the CircleCI-specific part of the
 * ProvisionTokenSpecV2
 *
 * @generated from protobuf message types.ProvisionTokenSpecV2CircleCI
 */
export interface ProvisionTokenSpecV2CircleCI {
    /**
     * Allow is a list of TokenRules, nodes using this token must match one
     * allow rule to use this token.
     *
     * @generated from protobuf field: repeated types.ProvisionTokenSpecV2CircleCI.Rule Allow = 1 [json_name = "Allow"];
     */
    allow: ProvisionTokenSpecV2CircleCI_Rule[];
    /**
     * @generated from protobuf field: string OrganizationID = 2 [json_name = "OrganizationID"];
     */
    organizationID: string;
}
/**
 * @generated from protobuf message types.ProvisionTokenSpecV2CircleCI.Rule
 */
export interface ProvisionTokenSpecV2CircleCI_Rule {
    /**
     * @generated from protobuf field: string ProjectID = 1 [json_name = "ProjectID"];
     */
    projectID: string;
    /**
     * @generated from protobuf field: string ContextID = 2 [json_name = "ContextID"];
     */
    contextID: string;
}
/**
 * ProvisionTokenSpecV2Spacelift contains the Spacelift-specific part of the
 * ProvisionTokenSpecV2
 *
 * @generated from protobuf message types.ProvisionTokenSpecV2Spacelift
 */
export interface ProvisionTokenSpecV2Spacelift {
    /**
     * Allow is a list of Rules, nodes using this token must match one
     * allow rule to use this token.
     *
     * @generated from protobuf field: repeated types.ProvisionTokenSpecV2Spacelift.Rule Allow = 1 [json_name = "Allow"];
     */
    allow: ProvisionTokenSpecV2Spacelift_Rule[];
    /**
     * Hostname is the hostname of the Spacelift tenant that tokens
     * will originate from. E.g `example.app.spacelift.io`
     *
     * @generated from protobuf field: string Hostname = 2 [json_name = "Hostname"];
     */
    hostname: string;
}
/**
 * @generated from protobuf message types.ProvisionTokenSpecV2Spacelift.Rule
 */
export interface ProvisionTokenSpecV2Spacelift_Rule {
    /**
     * SpaceID is the ID of the space in which the run that owns the token was
     * executed.
     *
     * @generated from protobuf field: string SpaceID = 1 [json_name = "SpaceID"];
     */
    spaceID: string;
    /**
     * CallerID is the ID of the caller, ie. the stack or module that generated
     * the run.
     *
     * @generated from protobuf field: string CallerID = 2 [json_name = "CallerID"];
     */
    callerID: string;
    /**
     * CallerType is the type of the caller, ie. the entity that owns the run -
     * either `stack` or `module`.
     *
     * @generated from protobuf field: string CallerType = 3 [json_name = "CallerType"];
     */
    callerType: string;
    /**
     * Scope is the scope of the token - either `read` or `write`.
     * See https://docs.spacelift.io/integrations/cloud-providers/oidc/#about-scopes
     *
     * @generated from protobuf field: string Scope = 4 [json_name = "Scope"];
     */
    scope: string;
}
/**
 * ProvisionTokenSpecV2Kubernetes contains the Kubernetes-specific part of the
 * ProvisionTokenSpecV2
 *
 * @generated from protobuf message types.ProvisionTokenSpecV2Kubernetes
 */
export interface ProvisionTokenSpecV2Kubernetes {
    /**
     * Allow is a list of Rules, nodes using this token must match one
     * allow rule to use this token.
     *
     * @generated from protobuf field: repeated types.ProvisionTokenSpecV2Kubernetes.Rule Allow = 1 [json_name = "Allow"];
     */
    allow: ProvisionTokenSpecV2Kubernetes_Rule[];
    /**
     * Type controls which behavior should be used for validating the Kubernetes
     * Service Account token. Support values:
     * - `in_cluster`
     * - `static_jwks`
     * If unset, this defaults to `in_cluster`.
     *
     * @generated from protobuf field: string Type = 2 [json_name = "Type"];
     */
    type: string;
    /**
     * StaticJWKS is the configuration specific to the `static_jwks` type.
     *
     * @generated from protobuf field: types.ProvisionTokenSpecV2Kubernetes.StaticJWKSConfig StaticJWKS = 3 [json_name = "StaticJWKS"];
     */
    staticJWKS?: ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig;
}
/**
 * @generated from protobuf message types.ProvisionTokenSpecV2Kubernetes.StaticJWKSConfig
 */
export interface ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig {
    /**
     * JWKS should be the JSON Web Key Set formatted public keys of that the
     * Kubernetes Cluster uses to sign service account tokens.
     * This can be fetched from /openid/v1/jwks on the Kubernetes API Server.
     *
     * @generated from protobuf field: string JWKS = 1 [json_name = "JWKS"];
     */
    jWKS: string;
}
/**
 * Rule is a set of properties the Kubernetes-issued token might have to be
 * allowed to use this ProvisionToken
 *
 * @generated from protobuf message types.ProvisionTokenSpecV2Kubernetes.Rule
 */
export interface ProvisionTokenSpecV2Kubernetes_Rule {
    /**
     * ServiceAccount is the namespaced name of the Kubernetes service account.
     * Its format is "namespace:service-account".
     *
     * @generated from protobuf field: string ServiceAccount = 1 [json_name = "ServiceAccount"];
     */
    serviceAccount: string;
}
/**
 * ProvisionTokenSpecV2Azure contains the Azure-specific part of the
 * ProvisionTokenSpecV2.
 *
 * @generated from protobuf message types.ProvisionTokenSpecV2Azure
 */
export interface ProvisionTokenSpecV2Azure {
    /**
     * Allow is a list of Rules, nodes using this token must match one
     * allow rule to use this token.
     *
     * @generated from protobuf field: repeated types.ProvisionTokenSpecV2Azure.Rule Allow = 1 [json_name = "Allow"];
     */
    allow: ProvisionTokenSpecV2Azure_Rule[];
}
/**
 * Rule is a set of properties the Azure-issued token might have to be
 * allowed to use this ProvisionToken.
 *
 * @generated from protobuf message types.ProvisionTokenSpecV2Azure.Rule
 */
export interface ProvisionTokenSpecV2Azure_Rule {
    /**
     * Subscription is the Azure subscription.
     *
     * @generated from protobuf field: string Subscription = 1 [json_name = "Subscription"];
     */
    subscription: string;
    /**
     * ResourceGroups is a list of Azure resource groups the node is allowed
     * to join from.
     *
     * @generated from protobuf field: repeated string ResourceGroups = 2 [json_name = "ResourceGroups"];
     */
    resourceGroups: string[];
}
/**
 * ProvisionTokenSpecV2GCP contains the GCP-specific part of the
 * ProvisionTokenSpecV2.
 *
 * @generated from protobuf message types.ProvisionTokenSpecV2GCP
 */
export interface ProvisionTokenSpecV2GCP {
    /**
     * Allow is a list of Rules, nodes using this token must match one
     * allow rule to use this token.
     *
     * @generated from protobuf field: repeated types.ProvisionTokenSpecV2GCP.Rule Allow = 1 [json_name = "Allow"];
     */
    allow: ProvisionTokenSpecV2GCP_Rule[];
}
/**
 * Rule is a set of properties the GCP-ussued token might have to be allowed
 * to use this ProvisionToken.
 *
 * @generated from protobuf message types.ProvisionTokenSpecV2GCP.Rule
 */
export interface ProvisionTokenSpecV2GCP_Rule {
    /**
     * ProjectIDs is a list of project IDs (e.g. `<example-id-123456>`).
     *
     * @generated from protobuf field: repeated string ProjectIDs = 1 [json_name = "ProjectIDs"];
     */
    projectIDs: string[];
    /**
     * Locations is a list of regions (e.g. "us-west1") and/or zones (e.g.
     * "us-west1-b").
     *
     * @generated from protobuf field: repeated string Locations = 2 [json_name = "Locations"];
     */
    locations: string[];
    /**
     * ServiceAccounts is a list of service account emails (e.g.
     * `<project-number>-compute@developer.gserviceaccount.com`).
     *
     * @generated from protobuf field: repeated string ServiceAccounts = 3 [json_name = "ServiceAccounts"];
     */
    serviceAccounts: string[];
}
/**
 * ProvisionTokenSpecV2Terraform contains Terraform-specific parts of the
 * ProvisionTokenSpecV2.
 *
 * @generated from protobuf message types.ProvisionTokenSpecV2TerraformCloud
 */
export interface ProvisionTokenSpecV2TerraformCloud {
    /**
     * Allow is a list of Rules, nodes using this token must match one
     * allow rule to use this token.
     *
     * @generated from protobuf field: repeated types.ProvisionTokenSpecV2TerraformCloud.Rule Allow = 1 [json_name = "Allow"];
     */
    allow: ProvisionTokenSpecV2TerraformCloud_Rule[];
    /**
     * Audience is the JWT audience as configured in the
     * TFC_WORKLOAD_IDENTITY_AUDIENCE(_$TAG) variable in Terraform Cloud. If
     * unset, defaults to the Teleport cluster name.
     * For example, if `TFC_WORKLOAD_IDENTITY_AUDIENCE_TELEPORT=foo` is set in
     * Terraform Cloud, this value should be `foo`. If the variable is set to
     * match the cluster name, it does not need to be set here.
     *
     * @generated from protobuf field: string Audience = 2 [json_name = "Audience"];
     */
    audience: string;
    /**
     * Hostname is the hostname of the Terraform Enterprise instance expected to
     * issue JWTs allowed by this token. This may be unset for regular Terraform
     * Cloud use, in which case it will be assumed to be `app.terraform.io`.
     * Otherwise, it must both match the `iss` (issuer) field included in JWTs,
     * and provide standard JWKS endpoints.
     *
     * @generated from protobuf field: string Hostname = 3 [json_name = "Hostname"];
     */
    hostname: string;
}
/**
 * Rule is a set of properties the Terraform-issued token might have to be
 * allowed to use this ProvisionToken.
 *
 * @generated from protobuf message types.ProvisionTokenSpecV2TerraformCloud.Rule
 */
export interface ProvisionTokenSpecV2TerraformCloud_Rule {
    /**
     * OrganizationID is the ID of the HCP Terraform organization. At least
     * one organization value is required, either ID or name.
     *
     * @generated from protobuf field: string OrganizationID = 1 [json_name = "OrganizationID"];
     */
    organizationID: string;
    /**
     * OrganizationName is the human-readable name of the HCP Terraform
     * organization. At least one organization value is required, either ID or
     * name.
     *
     * @generated from protobuf field: string OrganizationName = 2 [json_name = "OrganizationName"];
     */
    organizationName: string;
    /**
     * ProjectID is the ID of the HCP Terraform project. At least one project or
     * workspace value is required, either ID or name.
     *
     * @generated from protobuf field: string ProjectID = 3 [json_name = "ProjectID"];
     */
    projectID: string;
    /**
     * ProjectName is the human-readable name for the HCP Terraform project. At
     * least one project or workspace value is required, either ID or name.
     *
     * @generated from protobuf field: string ProjectName = 4 [json_name = "ProjectName"];
     */
    projectName: string;
    /**
     * WorkspaceID is the ID of the HCP Terraform workspace. At least one
     * project or workspace value is required, either ID or name.
     *
     * @generated from protobuf field: string WorkspaceID = 5 [json_name = "WorkspaceID"];
     */
    workspaceID: string;
    /**
     * WorkspaceName is the human-readable name of the HCP Terraform workspace.
     * At least one project or workspace value is required, either ID or name.
     *
     * @generated from protobuf field: string WorkspaceName = 6 [json_name = "WorkspaceName"];
     */
    workspaceName: string;
    /**
     * RunPhase is the phase of the run the token was issued for, e.g. `plan` or
     * `apply`
     *
     * @generated from protobuf field: string RunPhase = 7 [json_name = "RunPhase"];
     */
    runPhase: string;
}
/**
 * @generated from protobuf message types.ProvisionTokenSpecV2Bitbucket
 */
export interface ProvisionTokenSpecV2Bitbucket {
    /**
     * Allow is a list of Rules, nodes using this token must match one
     * allow rule to use this token.
     *
     * @generated from protobuf field: repeated types.ProvisionTokenSpecV2Bitbucket.Rule Allow = 1 [json_name = "Allow"];
     */
    allow: ProvisionTokenSpecV2Bitbucket_Rule[];
    /**
     * Audience is a Bitbucket-specified audience value for this token. It is
     * unique to each Bitbucket repository, and must be set to the value as
     * written in the Pipelines -> OpenID Connect section of the repository
     * settings.
     *
     * @generated from protobuf field: string Audience = 2 [json_name = "Audience"];
     */
    audience: string;
    /**
     * IdentityProviderURL is a Bitbucket-specified issuer URL for incoming OIDC
     * tokens. It is unique to each Bitbucket repository, and must be set to the
     * value as written in the Pipelines -> OpenID Connect section of the
     * repository settings.
     *
     * @generated from protobuf field: string IdentityProviderURL = 3 [json_name = "IdentityProviderURL"];
     */
    identityProviderURL: string;
}
/**
 * Rule is a set of properties the Bitbucket-issued token might have to be
 * allowed to use this ProvisionToken.
 *
 * @generated from protobuf message types.ProvisionTokenSpecV2Bitbucket.Rule
 */
export interface ProvisionTokenSpecV2Bitbucket_Rule {
    /**
     * WorkspaceUUID is the UUID of the workspace for which this token was
     * issued. Bitbucket UUIDs must begin and end with braces, e.g. `{...}`.
     * This value may be found in the Pipelines -> OpenID Connect section of the
     * repository settings.
     *
     * @generated from protobuf field: string WorkspaceUUID = 1 [json_name = "WorkspaceUUID"];
     */
    workspaceUUID: string;
    /**
     * RepositoryUUID is the UUID of the repository for which this token was
     * issued. Bitbucket UUIDs must begin and end with braces, e.g. `{...}`.
     * This value may be found in the Pipelines -> OpenID Connect section of the
     * repository settings.
     *
     * @generated from protobuf field: string RepositoryUUID = 2 [json_name = "RepositoryUUID"];
     */
    repositoryUUID: string;
    /**
     * DeploymentEnvironmentUUID is the UUID of the deployment environment
     * targeted by this pipelines run, if any. These values may be found in the
     * "Pipelines -> OpenID Connect -> Deployment environments" section of the
     * repository settings.
     *
     * @generated from protobuf field: string DeploymentEnvironmentUUID = 3 [json_name = "DeploymentEnvironmentUUID"];
     */
    deploymentEnvironmentUUID: string;
    /**
     * BranchName is the name of the branch on which this pipeline executed.
     *
     * @generated from protobuf field: string BranchName = 4 [json_name = "BranchName"];
     */
    branchName: string;
}
/**
 * ProvisionTokenSpecV2Oracle contains Oracle-specific parts of the
 * ProvisionTokenSpecV2.
 *
 * @generated from protobuf message types.ProvisionTokenSpecV2Oracle
 */
export interface ProvisionTokenSpecV2Oracle {
    /**
     * Allow is a list of Rules, nodes using this token must match one
     * allow rule to use this token.
     *
     * @generated from protobuf field: repeated types.ProvisionTokenSpecV2Oracle.Rule Allow = 1 [json_name = "Allow"];
     */
    allow: ProvisionTokenSpecV2Oracle_Rule[];
}
/**
 * Rule is a set of properties the Oracle instance might have to be allowed
 * to use this ProvisionToken.
 *
 * @generated from protobuf message types.ProvisionTokenSpecV2Oracle.Rule
 */
export interface ProvisionTokenSpecV2Oracle_Rule {
    /**
     * Tenancy is the OCID of the instance's tenancy. Required.
     *
     * @generated from protobuf field: string Tenancy = 1 [json_name = "Tenancy"];
     */
    tenancy: string;
    /**
     * ParentCompartments is a list of the OCIDs of compartments an instance is
     * allowed to join from. Only direct parents are allowed, i.e. no nested
     * compartments. If empty, any compartment is allowed.
     *
     * @generated from protobuf field: repeated string ParentCompartments = 2 [json_name = "ParentCompartments"];
     */
    parentCompartments: string[];
    /**
     * Regions is a list of regions an instance is allowed to join from. Both
     * full region names ("us-phoenix-1") and abbreviations ("phx") are allowed.
     * If empty, any region is allowed.
     *
     * @generated from protobuf field: repeated string Regions = 3 [json_name = "Regions"];
     */
    regions: string[];
}
/**
 * ProvisionTokenSpecV2BoundKeypair contains configuration for bound_keypair
 * type join tokens.
 *
 * @generated from protobuf message types.ProvisionTokenSpecV2BoundKeypair
 */
export interface ProvisionTokenSpecV2BoundKeypair {
    /**
     * Onboarding contains parameters related to initial onboarding and keypair
     * registration.
     *
     * @generated from protobuf field: types.ProvisionTokenSpecV2BoundKeypair.OnboardingSpec Onboarding = 1 [json_name = "Onboarding"];
     */
    onboarding?: ProvisionTokenSpecV2BoundKeypair_OnboardingSpec;
    /**
     * Recovery contains parameters related to recovery after identity expiration.
     *
     * @generated from protobuf field: types.ProvisionTokenSpecV2BoundKeypair.RecoverySpec Recovery = 2 [json_name = "Recovery"];
     */
    recovery?: ProvisionTokenSpecV2BoundKeypair_RecoverySpec;
    /**
     * RotateAfter is an optional timestamp that forces clients to perform a
     * keypair rotation on the next join or recovery attempt after the given date.
     * If `LastRotatedAt` is unset or before this timestamp, a rotation will be
     * requested. It is recommended to set this value to the current timestamp if
     * a rotation should be triggered on the next join attempt.
     *
     * @generated from protobuf field: google.protobuf.Timestamp RotateAfter = 3 [json_name = "RotateAfter"];
     */
    rotateAfter?: Timestamp;
}
/**
 * OnboardingSpec contains parameters for initial joining and keypair
 * registration.
 *
 * @generated from protobuf message types.ProvisionTokenSpecV2BoundKeypair.OnboardingSpec
 */
export interface ProvisionTokenSpecV2BoundKeypair_OnboardingSpec {
    /**
     * InitialPublicKey is used to preregister a public key generated by
     * `tbot keypair create`. When set, no initial join secret is generated or
     * made available for use, and clients must have the associated private key
     * available to join. If set, `initial_join_secret` and
     * `must_register_before` are ignored. This value is written in SSH
     * authorized_keys format.
     *
     * @generated from protobuf field: string InitialPublicKey = 1 [json_name = "InitialPublicKey"];
     */
    initialPublicKey: string;
    /**
     * RegistrationSecret is a secret joining clients may use to register their
     * public key on first join, which may be used instead of preregistering a
     * public key with `initial_public_key`. If `initial_public_key` is set,
     * this value is ignored. Otherwise, if set, this value will be used to
     * populate `.status.bound_keypair.intitial_join_secret`. If unset and no
     * `initial_public_key` is provided, a random secure value will be generated
     * server-side to populate the status field.
     *
     * @generated from protobuf field: string RegistrationSecret = 2 [json_name = "RegistrationSecret"];
     */
    registrationSecret: string;
    /**
     * MustRegisterBefore is an optional time before which registeration via
     * initial join secret must be performed. Attempts to register using an
     * initial join secret after this timestamp will not be allowed. This may be
     * modified after creation if necessary to allow the initial registration to
     * take place. This value is ignored if `initial_public_key` is set.
     *
     * @generated from protobuf field: google.protobuf.Timestamp MustRegisterBefore = 3 [json_name = "MustRegisterBefore"];
     */
    mustRegisterBefore?: Timestamp;
}
/**
 * RecoverySpec contains parameters for recovery after identity expiration.
 *
 * @generated from protobuf message types.ProvisionTokenSpecV2BoundKeypair.RecoverySpec
 */
export interface ProvisionTokenSpecV2BoundKeypair_RecoverySpec {
    /**
     * Limit is the maximum number of allowed recovery attempts. This value may
     * be raised or lowered after creation to allow additional recovery attempts
     * should the initial limit be exhausted. If `mode` is set to `standard`,
     * recovery attempts will only be allowed if
     * `.status.bound_keypair.recovery_count` is less than this limit. This
     * limit is not enforced if `mode` is set to `relaxed` or `insecure`. This
     * value must be at least 1 to allow for the initial join during onboarding,
     * which counts as a recovery.
     *
     * @generated from protobuf field: uint32 Limit = 1 [json_name = "Limit"];
     */
    limit: number;
    /**
     * Mode sets the recovery rule enforcement mode. It may be one of these
     * values:
     * - standard (or unset): all configured rules enforced. The recovery limit
     *   and client join state are required and verified. This is the most
     *   secure recovery mode.
     * - relaxed: recovery limit is not enforced, but client join state is still
     *   required. This effectively allows unlimited recovery attempts, but
     *   client join state still helps mitigate stolen credentials.
     * - insecure: neither the recovery limit nor client join state are
     *   enforced. This allows any client with the private key to join freely.
     *   This is less secure, but can be useful in certain situations, like in
     *   otherwise unsupported CI/CD providers. This mode should be used with
     *   care, and RBAC rules should be configured to heavily restrict which
     *   resources this identity can access.
     *
     * @generated from protobuf field: string Mode = 2 [json_name = "Mode"];
     */
    mode: string;
}
/**
 * ProvisionTokenStatusV2 contains status information about a particular
 * ProvisionTokenV2. These fields should not be modified by end users.
 *
 * @generated from protobuf message types.ProvisionTokenStatusV2
 */
export interface ProvisionTokenStatusV2 {
    /**
     * BoundKeypair contains status information related to bound_keypair type
     * tokens.
     *
     * @generated from protobuf field: types.ProvisionTokenStatusV2BoundKeypair BoundKeypair = 1 [json_name = "BoundKeypair"];
     */
    boundKeypair?: ProvisionTokenStatusV2BoundKeypair;
}
/**
 * ProvisionTokenStatusV2BoundKeypair contains status information specific to
 * bound_keypair type tokens.
 *
 * @generated from protobuf message types.ProvisionTokenStatusV2BoundKeypair
 */
export interface ProvisionTokenStatusV2BoundKeypair {
    /**
     * RegistrationSecret contains a secret value that may be used for public key
     * registration during the initial join process if no public key is
     * preregistered. If `.spec.bound_keypair.onboarding.initial_public_key`
     * is set, †his field will remain empty. Otherwise, if
     * `.spec.bound_keypair.onboarding.registration_secret` is set, that value
     * will be copied here. If that field is unset, a value will be randomly
     * generated.
     *
     * @generated from protobuf field: string RegistrationSecret = 1 [json_name = "RegistrationSecret"];
     */
    registrationSecret: string;
    /**
     * BoundPublicKey contains the currently bound public key. If
     * `.spec.bound_keypair.onboarding.initial_public_key` is set, that value will
     * be copied here on creation, otherwise it will be populated as part of
     * public key registration process. This value will be updated over time if
     * keypair rotation takes place, and will always reflect the currently trusted
     * public key. This value is written in SSH authorized_keys format.
     *
     * @generated from protobuf field: string BoundPublicKey = 2 [json_name = "BoundPublicKey"];
     */
    boundPublicKey: string;
    /**
     * BoundBotInstanceID is the ID of the currently associated bot instance. A
     * new bot instance is issued on each join; the new bot instance will
     * have a `previous_bot_instance` set to this value, if any.
     *
     * @generated from protobuf field: string BoundBotInstanceID = 3 [json_name = "BoundBotInstanceID"];
     */
    boundBotInstanceID: string;
    /**
     * RecoveryCount is a count of the total number of recoveries performed using
     * this token. It is incremented for every successful join or rejoin. Recovery
     * is only allowed if this value is less than
     * `.spec.bound_keypair.recovery.limit`, or if the recovery mode is `relaxed`
     * or `insecure`.
     *
     * @generated from protobuf field: uint32 RecoveryCount = 4 [json_name = "RecoveryCount"];
     */
    recoveryCount: number;
    /**
     * LastRecoveredAt contains a timestamp of the last successful recovery
     * attempt. Note that normal renewals do not count as a recovery attempt,
     * however onboarding does,  either with a preregistered key or registration
     * secret. This corresponds with the last time `bound_bot_instance_id` was
     * updated.
     *
     * @generated from protobuf field: google.protobuf.Timestamp LastRecoveredAt = 5 [json_name = "LastRecoveredAt"];
     */
    lastRecoveredAt?: Timestamp;
    /**
     * LastRotatedAt contains a timestamp of the last time the keypair was
     * rotated, if any. This is not set at initial join.
     *
     * @generated from protobuf field: google.protobuf.Timestamp LastRotatedAt = 6 [json_name = "LastRotatedAt"];
     */
    lastRotatedAt?: Timestamp;
}
/**
 * StaticTokensV2 implements the StaticTokens interface.
 *
 * @generated from protobuf message types.StaticTokensV2
 */
export interface StaticTokensV2 {
    /**
     * Kind is a resource kind
     *
     * @generated from protobuf field: string Kind = 1 [json_name = "Kind"];
     */
    kind: string;
    /**
     * SubKind is an optional resource sub kind, used in some csd presources
     *
     * @generated from protobuf field: string SubKind = 2 [json_name = "SubKind"];
     */
    subKind: string;
    /**
     * Version is version
     *
     * @generated from protobuf field: string Version = 3 [json_name = "Version"];
     */
    version: string;
    /**
     * Metadata is resource metadata
     *
     * @generated from protobuf field: types.Metadata Metadata = 4 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Spec is a provisioning token V2 spec
     *
     * @generated from protobuf field: types.StaticTokensSpecV2 Spec = 5 [json_name = "Spec"];
     */
    spec?: StaticTokensSpecV2;
}
/**
 * StaticTokensSpecV2 is the actual data we care about for StaticTokensSpecV2.
 *
 * @generated from protobuf message types.StaticTokensSpecV2
 */
export interface StaticTokensSpecV2 {
    /**
     * StaticTokens is a list of tokens that can be used to add nodes to the
     * cluster.
     *
     * @generated from protobuf field: repeated types.ProvisionTokenV1 StaticTokens = 1 [json_name = "StaticTokens"];
     */
    staticTokens: ProvisionTokenV1[];
}
/**
 * ClusterNameV2 implements the ClusterName interface.
 *
 * @generated from protobuf message types.ClusterNameV2
 */
export interface ClusterNameV2 {
    /**
     * Kind is a resource kind
     *
     * @generated from protobuf field: string Kind = 1 [json_name = "Kind"];
     */
    kind: string;
    /**
     * SubKind is an optional resource sub kind, used in some resources
     *
     * @generated from protobuf field: string SubKind = 2 [json_name = "SubKind"];
     */
    subKind: string;
    /**
     * Version is version
     *
     * @generated from protobuf field: string Version = 3 [json_name = "Version"];
     */
    version: string;
    /**
     * Metadata is resource metadata
     *
     * @generated from protobuf field: types.Metadata Metadata = 4 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Spec is a cluster name V2 spec
     *
     * @generated from protobuf field: types.ClusterNameSpecV2 Spec = 5 [json_name = "Spec"];
     */
    spec?: ClusterNameSpecV2;
}
/**
 * ClusterNameSpecV2 is the actual data we care about for ClusterName.
 *
 * @generated from protobuf message types.ClusterNameSpecV2
 */
export interface ClusterNameSpecV2 {
    /**
     * ClusterName is the name of the cluster. Changing this value once the
     * cluster is setup can and will cause catastrophic problems.
     *
     * @generated from protobuf field: string ClusterName = 1 [json_name = "ClusterName"];
     */
    clusterName: string;
    /**
     * ClusterID is the unique cluster ID that is set once during the first
     * Auth Service startup.
     *
     * @generated from protobuf field: string ClusterID = 2 [json_name = "ClusterID"];
     */
    clusterID: string;
}
/**
 * ClusterAuditConfigV2 represents audit log settings in the cluster.
 *
 * @generated from protobuf message types.ClusterAuditConfigV2
 */
export interface ClusterAuditConfigV2 {
    /**
     * Kind is a resource kind
     *
     * @generated from protobuf field: string Kind = 1 [json_name = "Kind"];
     */
    kind: string;
    /**
     * SubKind is an optional resource sub kind, used in some resources
     *
     * @generated from protobuf field: string SubKind = 2 [json_name = "SubKind"];
     */
    subKind: string;
    /**
     * Version is a resource version
     *
     * @generated from protobuf field: string Version = 3 [json_name = "Version"];
     */
    version: string;
    /**
     * Metadata is resource metadata
     *
     * @generated from protobuf field: types.Metadata Metadata = 4 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Spec is a ClusterAuditConfig specification
     *
     * @generated from protobuf field: types.ClusterAuditConfigSpecV2 Spec = 5 [json_name = "Spec"];
     */
    spec?: ClusterAuditConfigSpecV2;
}
/**
 * ClusterAuditConfigSpecV2 is the actual data we care about
 * for ClusterAuditConfig.
 *
 * @generated from protobuf message types.ClusterAuditConfigSpecV2
 */
export interface ClusterAuditConfigSpecV2 {
    /**
     * Type is audit backend type
     *
     * @generated from protobuf field: string Type = 1 [json_name = "Type"];
     */
    type: string;
    /**
     * Region is a region setting for audit sessions used by cloud providers
     *
     * @generated from protobuf field: string Region = 2 [json_name = "Region"];
     */
    region: string;
    /**
     * AuditSessionsURI is a parameter where to upload sessions
     *
     * @generated from protobuf field: string AuditSessionsURI = 3 [json_name = "AuditSessionsURI"];
     */
    auditSessionsURI: string;
    /**
     * AuditEventsURI is a parameter with all supported outputs
     * for audit events
     *
     * @generated from protobuf field: wrappers.StringValues AuditEventsURI = 4 [json_name = "AuditEventsURI"];
     */
    auditEventsURI?: StringValues;
    /**
     * EnableContinuousBackups is used to enable (or disable) PITR (Point-In-Time Recovery).
     *
     * @generated from protobuf field: bool EnableContinuousBackups = 6 [json_name = "EnableContinuousBackups"];
     */
    enableContinuousBackups: boolean;
    /**
     * EnableAutoScaling is used to enable (or disable) auto scaling policy.
     *
     * @generated from protobuf field: bool EnableAutoScaling = 7 [json_name = "EnableAutoScaling"];
     */
    enableAutoScaling: boolean;
    /**
     * ReadMaxCapacity is the maximum provisioned read capacity.
     *
     * @generated from protobuf field: int64 ReadMaxCapacity = 8 [json_name = "ReadMaxCapacity"];
     */
    readMaxCapacity: bigint;
    /**
     * ReadMinCapacity is the minimum provisioned read capacity.
     *
     * @generated from protobuf field: int64 ReadMinCapacity = 9 [json_name = "ReadMinCapacity"];
     */
    readMinCapacity: bigint;
    /**
     * ReadTargetValue is the ratio of consumed read to provisioned capacity.
     *
     * @generated from protobuf field: double ReadTargetValue = 10 [json_name = "ReadTargetValue"];
     */
    readTargetValue: number;
    /**
     * WriteMaxCapacity is the maximum provisioned write capacity.
     *
     * @generated from protobuf field: int64 WriteMaxCapacity = 11 [json_name = "WriteMaxCapacity"];
     */
    writeMaxCapacity: bigint;
    /**
     * WriteMinCapacity is the minimum provisioned write capacity.
     *
     * @generated from protobuf field: int64 WriteMinCapacity = 12 [json_name = "WriteMinCapacity"];
     */
    writeMinCapacity: bigint;
    /**
     * WriteTargetValue is the ratio of consumed write to provisioned capacity.
     *
     * @generated from protobuf field: double WriteTargetValue = 13 [json_name = "WriteTargetValue"];
     */
    writeTargetValue: number;
    /**
     * RetentionPeriod is the retention period for audit events.
     *
     * @generated from protobuf field: int64 RetentionPeriod = 14 [json_name = "RetentionPeriod"];
     */
    retentionPeriod: bigint;
    /**
     * UseFIPSEndpoint configures AWS endpoints to use FIPS.
     *
     * @generated from protobuf field: types.ClusterAuditConfigSpecV2.FIPSEndpointState UseFIPSEndpoint = 15 [json_name = "UseFIPSEndpoint"];
     */
    useFIPSEndpoint: ClusterAuditConfigSpecV2_FIPSEndpointState;
}
/**
 * FIPSEndpointState represents an AWS FIPS endpoint state.
 *
 * @generated from protobuf enum types.ClusterAuditConfigSpecV2.FIPSEndpointState
 */
export enum ClusterAuditConfigSpecV2_FIPSEndpointState {
    /**
     * FIPS_UNSET allows setting FIPS state for AWS S3/Dynamo using configuration files or
     * environment variables
     *
     * @generated from protobuf enum value: FIPS_UNSET = 0;
     */
    FIPS_UNSET = 0,
    /**
     * FIPS_ENABLED explicitly enables FIPS support for AWS S3/Dynamo
     *
     * @generated from protobuf enum value: FIPS_ENABLED = 1;
     */
    FIPS_ENABLED = 1,
    /**
     * FIPS_DISABLED explicitly disables FIPS support for AWS S3/Dynamo
     *
     * @generated from protobuf enum value: FIPS_DISABLED = 2;
     */
    FIPS_DISABLED = 2
}
/**
 * ClusterNetworkingConfigV2 contains cluster-wide networking configuration.
 *
 * @generated from protobuf message types.ClusterNetworkingConfigV2
 */
export interface ClusterNetworkingConfigV2 {
    /**
     * Kind is a resource kind
     *
     * @generated from protobuf field: string Kind = 1 [json_name = "Kind"];
     */
    kind: string;
    /**
     * SubKind is an optional resource sub kind, used in some resources
     *
     * @generated from protobuf field: string SubKind = 2 [json_name = "SubKind"];
     */
    subKind: string;
    /**
     * Version is the resource version. It must be specified.
     * Supported values are:`v2`.
     *
     * @generated from protobuf field: string Version = 3 [json_name = "Version"];
     */
    version: string;
    /**
     * Metadata is resource metadata
     *
     * @generated from protobuf field: types.Metadata Metadata = 4 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Spec is a ClusterNetworkingConfig specification
     *
     * @generated from protobuf field: types.ClusterNetworkingConfigSpecV2 Spec = 5 [json_name = "Spec"];
     */
    spec?: ClusterNetworkingConfigSpecV2;
}
/**
 * ClusterNetworkingConfigSpecV2 is the actual data we care about
 * for ClusterNetworkingConfig.
 *
 * @generated from protobuf message types.ClusterNetworkingConfigSpecV2
 */
export interface ClusterNetworkingConfigSpecV2 {
    /**
     * ClientIdleTimeout sets global cluster default setting for client idle
     * timeouts.
     *
     * @generated from protobuf field: int64 ClientIdleTimeout = 1 [json_name = "ClientIdleTimeout"];
     */
    clientIdleTimeout: bigint;
    /**
     * KeepAliveInterval is the interval at which the server sends keep-alive messages
     * to the client.
     *
     * @generated from protobuf field: int64 KeepAliveInterval = 2 [json_name = "KeepAliveInterval"];
     */
    keepAliveInterval: bigint;
    /**
     * KeepAliveCountMax is the number of keep-alive messages that can be
     * missed before the server disconnects the connection to the client.
     *
     * @generated from protobuf field: int64 KeepAliveCountMax = 3 [json_name = "KeepAliveCountMax"];
     */
    keepAliveCountMax: bigint;
    /**
     * SessionControlTimeout is the session control lease expiry and defines
     * the upper limit of how long a node may be out of contact with the auth
     * server before it begins terminating controlled sessions.
     *
     * @generated from protobuf field: int64 SessionControlTimeout = 4 [json_name = "SessionControlTimeout"];
     */
    sessionControlTimeout: bigint;
    /**
     * ClientIdleTimeoutMessage is the message sent to the user when a connection times out.
     *
     * @generated from protobuf field: string ClientIdleTimeoutMessage = 5 [json_name = "ClientIdleTimeoutMessage"];
     */
    clientIdleTimeoutMessage: string;
    /**
     * WebIdleTimeout sets global cluster default setting for the web UI idle
     * timeouts.
     *
     * @generated from protobuf field: int64 WebIdleTimeout = 6 [json_name = "WebIdleTimeout"];
     */
    webIdleTimeout: bigint;
    /**
     * ProxyListenerMode is proxy listener mode used by Teleport Proxies.
     * 0 is "separate"; 1 is "multiplex".
     *
     * @generated from protobuf field: types.ProxyListenerMode ProxyListenerMode = 7 [json_name = "ProxyListenerMode"];
     */
    proxyListenerMode: ProxyListenerMode;
    /**
     * RoutingStrategy determines the strategy used to route to nodes.
     * 0 is "unambiguous_match"; 1 is "most_recent".
     *
     * @generated from protobuf field: types.RoutingStrategy RoutingStrategy = 8 [json_name = "RoutingStrategy"];
     */
    routingStrategy: RoutingStrategy;
    /**
     * TunnelStrategyV1 determines the tunnel strategy used in the cluster.
     *
     * @generated from protobuf field: types.TunnelStrategyV1 TunnelStrategy = 9 [json_name = "TunnelStrategy"];
     */
    tunnelStrategy?: TunnelStrategyV1;
    /**
     * ProxyPingInterval defines in which interval the TLS routing ping message
     * should be sent. This is applicable only when using ping-wrapped
     * connections, regular TLS routing connections are not affected.
     *
     * @generated from protobuf field: int64 ProxyPingInterval = 10 [json_name = "ProxyPingInterval"];
     */
    proxyPingInterval: bigint;
    /**
     * AssistCommandExecutionWorkers determines the number of workers that will
     * execute arbitrary Assist commands on servers in parallel
     *
     * @generated from protobuf field: int32 AssistCommandExecutionWorkers = 11 [json_name = "AssistCommandExecutionWorkers"];
     */
    assistCommandExecutionWorkers: number;
    /**
     * CaseInsensitiveRouting causes proxies to use case-insensitive hostname matching.
     *
     * @generated from protobuf field: bool CaseInsensitiveRouting = 12 [json_name = "CaseInsensitiveRouting"];
     */
    caseInsensitiveRouting: boolean;
    /**
     * SSHDialTimeout is a custom dial timeout used when establishing
     * SSH connections. If not set, the default timeout of 30s will be used.
     *
     * @generated from protobuf field: int64 SSHDialTimeout = 13 [json_name = "SSHDialTimeout"];
     */
    sSHDialTimeout: bigint;
}
/**
 * TunnelStrategyV1 defines possible tunnel strategy types.
 *
 * @generated from protobuf message types.TunnelStrategyV1
 */
export interface TunnelStrategyV1 {
    /**
     * @generated from protobuf oneof: Strategy
     */
    strategy: {
        oneofKind: "agentMesh";
        /**
         * @generated from protobuf field: types.AgentMeshTunnelStrategy AgentMesh = 1 [json_name = "AgentMesh"];
         */
        agentMesh: AgentMeshTunnelStrategy;
    } | {
        oneofKind: "proxyPeering";
        /**
         * @generated from protobuf field: types.ProxyPeeringTunnelStrategy ProxyPeering = 2 [json_name = "ProxyPeering"];
         */
        proxyPeering: ProxyPeeringTunnelStrategy;
    } | {
        oneofKind: undefined;
    };
}
/**
 * AgentMeshTunnelStrategy requires reverse tunnels to dial every proxy.
 *
 * @generated from protobuf message types.AgentMeshTunnelStrategy
 */
export interface AgentMeshTunnelStrategy {
}
/**
 * ProxyPeeringTunnelStrategy requires reverse tunnels to dial a fixed number of proxies.
 *
 * @generated from protobuf message types.ProxyPeeringTunnelStrategy
 */
export interface ProxyPeeringTunnelStrategy {
    /**
     * @generated from protobuf field: int64 AgentConnectionCount = 1 [json_name = "AgentConnectionCount"];
     */
    agentConnectionCount: bigint;
}
/**
 * SessionRecordingConfigV2 contains session recording configuration.
 *
 * @generated from protobuf message types.SessionRecordingConfigV2
 */
export interface SessionRecordingConfigV2 {
    /**
     * Kind is a resource kind
     *
     * @generated from protobuf field: string Kind = 1 [json_name = "Kind"];
     */
    kind: string;
    /**
     * SubKind is an optional resource sub kind, used in some resources
     *
     * @generated from protobuf field: string SubKind = 2 [json_name = "SubKind"];
     */
    subKind: string;
    /**
     * Version is the resource version. It must be specified.
     * Supported values are:`v2`.
     *
     * @generated from protobuf field: string Version = 3 [json_name = "Version"];
     */
    version: string;
    /**
     * Metadata is resource metadata
     *
     * @generated from protobuf field: types.Metadata Metadata = 4 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Spec is a SessionRecordingConfig specification
     *
     * @generated from protobuf field: types.SessionRecordingConfigSpecV2 Spec = 5 [json_name = "Spec"];
     */
    spec?: SessionRecordingConfigSpecV2;
}
/**
 * SessionRecordingConfigSpecV2 is the actual data we care about
 * for SessionRecordingConfig.
 *
 * @generated from protobuf message types.SessionRecordingConfigSpecV2
 */
export interface SessionRecordingConfigSpecV2 {
    /**
     * Mode controls where (or if) the session is recorded.
     *
     * @generated from protobuf field: string Mode = 1 [json_name = "Mode"];
     */
    mode: string;
    /**
     * ProxyChecksHostKeys is used to control if the proxy will check host keys
     * when in recording mode.
     *
     * @generated from protobuf field: types.BoolValue ProxyChecksHostKeys = 2 [json_name = "ProxyChecksHostKeys"];
     */
    proxyChecksHostKeys?: BoolValue;
}
/**
 * AuthPreferenceV2 implements the AuthPreference interface.
 *
 * @generated from protobuf message types.AuthPreferenceV2
 */
export interface AuthPreferenceV2 {
    /**
     * Kind is a resource kind
     *
     * @generated from protobuf field: string Kind = 1 [json_name = "Kind"];
     */
    kind: string;
    /**
     * SubKind is an optional resource sub kind, used in some resources
     *
     * @generated from protobuf field: string SubKind = 2 [json_name = "SubKind"];
     */
    subKind: string;
    /**
     * Version is the resource version. It must be specified.
     * Supported values are: `v2`.
     *
     * @generated from protobuf field: string Version = 3 [json_name = "Version"];
     */
    version: string;
    /**
     * Metadata is resource metadata
     *
     * @generated from protobuf field: types.Metadata Metadata = 4 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Spec is an AuthPreference specification
     *
     * @generated from protobuf field: types.AuthPreferenceSpecV2 Spec = 5 [json_name = "Spec"];
     */
    spec?: AuthPreferenceSpecV2;
}
/**
 * AuthPreferenceSpecV2 is the actual data we care about for AuthPreference.
 *
 * @generated from protobuf message types.AuthPreferenceSpecV2
 */
export interface AuthPreferenceSpecV2 {
    /**
     * Type is the type of authentication.
     *
     * @generated from protobuf field: string Type = 1 [json_name = "Type"];
     */
    type: string;
    /**
     * SecondFactor is the type of mult-factor.
     * Deprecated: Prefer using SecondFactors instead.
     *
     * @deprecated
     * @generated from protobuf field: string SecondFactor = 2 [deprecated = true, json_name = "SecondFactor"];
     */
    secondFactor: string;
    /**
     * ConnectorName is the name of the OIDC or SAML connector. If this value is
     * not set the first connector in the backend will be used.
     *
     * @generated from protobuf field: string ConnectorName = 3 [json_name = "ConnectorName"];
     */
    connectorName: string;
    /**
     * U2F are the settings for the U2F device.
     *
     * @generated from protobuf field: types.U2F U2F = 4 [json_name = "U2F"];
     */
    u2F?: U2F;
    /**
     * DisconnectExpiredCert provides disconnect expired certificate setting -
     * if true, connections with expired client certificates will get disconnected
     *
     * @generated from protobuf field: types.BoolValue DisconnectExpiredCert = 6 [json_name = "DisconnectExpiredCert"];
     */
    disconnectExpiredCert?: BoolValue;
    /**
     * AllowLocalAuth is true if local authentication is enabled.
     *
     * @generated from protobuf field: types.BoolValue AllowLocalAuth = 7 [json_name = "AllowLocalAuth"];
     */
    allowLocalAuth?: BoolValue;
    /**
     * @generated from protobuf field: string MessageOfTheDay = 8 [json_name = "MessageOfTheDay"];
     */
    messageOfTheDay: string;
    /**
     * LockingMode is the cluster-wide locking mode default.
     *
     * @generated from protobuf field: string LockingMode = 9 [json_name = "LockingMode"];
     */
    lockingMode: string;
    /**
     * Webauthn are the settings for server-side Web Authentication support.
     *
     * @generated from protobuf field: types.Webauthn Webauthn = 10 [json_name = "Webauthn"];
     */
    webauthn?: Webauthn;
    /**
     * AllowPasswordless enables/disables passwordless support.
     * Passwordless requires Webauthn to work.
     * Defaults to true if the Webauthn is configured, defaults to false
     * otherwise.
     *
     * @generated from protobuf field: types.BoolValue AllowPasswordless = 11 [json_name = "AllowPasswordless"];
     */
    allowPasswordless?: BoolValue;
    /**
     * RequireMFAType is the type of MFA requirement enforced for this cluster.
     * 0 is "OFF", 1 is "SESSION", 2 is "SESSION_AND_HARDWARE_KEY", 3 is "HARDWARE_KEY_TOUCH",
     * 4 is "HARDWARE_KEY_PIN", 5 is "HARDWARE_KEY_TOUCH_AND_PIN".
     *
     * @generated from protobuf field: types.RequireMFAType RequireMFAType = 12 [json_name = "RequireMFAType"];
     */
    requireMFAType: RequireMFAType;
    /**
     * DeviceTrust holds settings related to trusted device verification.
     * Requires Teleport Enterprise.
     *
     * @generated from protobuf field: types.DeviceTrust DeviceTrust = 13 [json_name = "DeviceTrust"];
     */
    deviceTrust?: DeviceTrust;
    /**
     * IDP is a set of options related to accessing IdPs within Teleport.
     * Requires Teleport Enterprise.
     *
     * @generated from protobuf field: types.IdPOptions IDP = 14 [json_name = "IDP"];
     */
    iDP?: IdPOptions;
    /**
     * AllowHeadless enables/disables headless support.
     * Headless authentication requires Webauthn to work.
     * Defaults to true if the Webauthn is configured, defaults to false
     * otherwise.
     *
     * @generated from protobuf field: types.BoolValue AllowHeadless = 15 [json_name = "AllowHeadless"];
     */
    allowHeadless?: BoolValue;
    /**
     * DefaultSessionTTL is the TTL to use for user certs when
     * an explicit TTL is not requested.
     *
     * @generated from protobuf field: int64 DefaultSessionTTL = 16 [json_name = "DefaultSessionTTL"];
     */
    defaultSessionTTL: bigint;
    /**
     * Okta is a set of options related to the Okta service in Teleport.
     * Requires Teleport Enterprise.
     *
     * @generated from protobuf field: types.OktaOptions Okta = 17 [json_name = "Okta"];
     */
    okta?: OktaOptions;
    /**
     * HardwareKey are the settings for hardware key support.
     *
     * @generated from protobuf field: types.HardwareKey HardwareKey = 19 [json_name = "HardwareKey"];
     */
    hardwareKey?: HardwareKey;
    /**
     * SignatureAlgorithmSuite is the configured signature algorithm suite for the cluster.
     * If unspecified, the current default value is "legacy".
     * 1 is "legacy", 2 is "balanced-v1", 3 is "fips-v1", 4 is "hsm-v1".
     *
     * @generated from protobuf field: types.SignatureAlgorithmSuite signature_algorithm_suite = 20;
     */
    signatureAlgorithmSuite: SignatureAlgorithmSuite;
    /**
     * SecondFactors is a list of supported multi-factor types.
     * 1 is "otp", 2 is "webauthn", 3 is "sso",
     * If unspecified, the current default value is [1], or ["otp"].
     *
     * @generated from protobuf field: repeated types.SecondFactorType SecondFactors = 21 [json_name = "SecondFactors"];
     */
    secondFactors: SecondFactorType[];
    /**
     * StableUnixUserConfig contains the cluster-wide configuration for stable
     * UNIX users.
     *
     * @generated from protobuf field: types.StableUNIXUserConfig stable_unix_user_config = 22;
     */
    stableUnixUserConfig?: StableUNIXUserConfig;
}
/**
 * StableUNIXUserConfig contains the cluster-wide configuration for stable UNIX
 * users.
 *
 * @generated from protobuf message types.StableUNIXUserConfig
 */
export interface StableUNIXUserConfig {
    /**
     * Enabled signifies that (UNIX) Teleport SSH hosts should obtain a UID from
     * the control plane if they're about to provision a host user with no other
     * configured UID.
     *
     * @generated from protobuf field: bool enabled = 1;
     */
    enabled: boolean;
    /**
     * FirstUid is the start of the range of UIDs for autoprovisioned host users.
     * The range is inclusive on both ends, so the specified UID can be assigned.
     *
     * @generated from protobuf field: int32 first_uid = 2;
     */
    firstUid: number;
    /**
     * LastUid is the end of the range of UIDs for autoprovisioned host users. The
     * range is inclusive on both ends, so the specified UID can be assigned.
     *
     * @generated from protobuf field: int32 last_uid = 3;
     */
    lastUid: number;
}
/**
 * U2F defines settings for U2F device.
 * Deprecated: U2F is transparently converted to WebAuthn by Teleport. Prefer
 * using WebAuthn instead.
 *
 * @generated from protobuf message types.U2F
 */
export interface U2F {
    /**
     * AppID returns the application ID for universal mult-factor.
     *
     * @generated from protobuf field: string AppID = 1 [json_name = "AppID"];
     */
    appID: string;
    /**
     * Facets returns the facets for universal mult-factor.
     * Deprecated: Kept for backwards compatibility reasons, but Facets have no
     * effect since Teleport v10, when Webauthn replaced the U2F implementation.
     *
     * @generated from protobuf field: repeated string Facets = 2 [json_name = "Facets"];
     */
    facets: string[];
    /**
     * DeviceAttestationCAs contains the trusted attestation CAs for U2F
     * devices.
     *
     * @generated from protobuf field: repeated string DeviceAttestationCAs = 3 [json_name = "DeviceAttestationCAs"];
     */
    deviceAttestationCAs: string[];
}
/**
 * Webauthn defines user-visible settings for server-side Web Authentication
 * support.
 *
 * @generated from protobuf message types.Webauthn
 */
export interface Webauthn {
    /**
     * RPID is the ID of the Relying Party.
     * It should be set to the domain name of the Teleport installation.
     *
     * IMPORTANT: RPID must never change in the lifetime of the cluster, because
     * it's recorded in the registration data on the WebAuthn device. If the
     * RPID changes, all existing WebAuthn key registrations will become invalid
     * and all users who use WebAuthn as the multi-factor will need to
     * re-register.
     *
     * @generated from protobuf field: string RPID = 1 [json_name = "RPID"];
     */
    rPID: string;
    /**
     * Allow list of device attestation CAs in PEM format.
     * If present, only devices whose attestation certificates match the
     * certificates specified here may be registered (existing registrations are
     * unchanged).
     * If supplied in conjunction with AttestationDeniedCAs, then both
     * conditions need to be true for registration to be allowed (the device
     * MUST match an allowed CA and MUST NOT match a denied CA).
     * By default all devices are allowed.
     *
     * @generated from protobuf field: repeated string AttestationAllowedCAs = 2 [json_name = "AttestationAllowedCAs"];
     */
    attestationAllowedCAs: string[];
    /**
     * Deny list of device attestation CAs in PEM format.
     * If present, only devices whose attestation certificates don't match the
     * certificates specified here may be registered (existing registrations are
     * unchanged).
     * If supplied in conjunction with AttestationAllowedCAs, then both
     * conditions need to be true for registration to be allowed (the device
     * MUST match an allowed CA and MUST NOT match a denied CA).
     * By default no devices are denied.
     *
     * @generated from protobuf field: repeated string AttestationDeniedCAs = 3 [json_name = "AttestationDeniedCAs"];
     */
    attestationDeniedCAs: string[];
}
/**
 * DeviceTrust holds settings related to trusted device verification.
 * Requires Teleport Enterprise.
 *
 * @generated from protobuf message types.DeviceTrust
 */
export interface DeviceTrust {
    /**
     * Mode of verification for trusted devices.
     *
     * The following modes are supported:
     *
     * - "off": disables both device authentication and authorization.
     * - "optional": allows both device authentication and authorization, but
     *   doesn't enforce the presence of device extensions for sensitive
     *   endpoints.
     * - "required": enforces the presence of device extensions for sensitive
     *   endpoints.
     *
     * Mode is always "off" for OSS.
     * Defaults to "optional" for Enterprise.
     *
     * @generated from protobuf field: string Mode = 1 [json_name = "Mode"];
     */
    mode: string;
    /**
     * Enable device auto-enroll.
     * Auto-enroll lets any user issue a device enrollment token for a known
     * device that is not already enrolled.
     * `tsh` takes advantage of auto-enroll to automatically enroll devices on
     * user login, when appropriate.
     * The effective cluster Mode still applies: AutoEnroll=true is meaningless if
     * Mode="off".
     *
     * @generated from protobuf field: bool AutoEnroll = 2 [json_name = "AutoEnroll"];
     */
    autoEnroll: boolean;
    /**
     * Allow list of EKCert CAs in PEM format.
     * If present, only TPM devices that present an EKCert that is signed by a
     * CA specified here may be enrolled (existing enrollments are
     * unchanged).
     *
     * If not present, then the CA of TPM EKCerts will not be checked during
     * enrollment, this allows any device to enroll.
     *
     * @generated from protobuf field: repeated string EKCertAllowedCAs = 3 [json_name = "EKCertAllowedCAs"];
     */
    eKCertAllowedCAs: string[];
}
/**
 * HardwareKey holds settings related to hardware key support.
 * Requires Teleport Enterprise.
 *
 * @generated from protobuf message types.HardwareKey
 */
export interface HardwareKey {
    /**
     * PIVSlot is a PIV slot that Teleport clients should use instead of the
     * default based on private key policy. For example, "9a" or "9e".
     *
     * @generated from protobuf field: string PIVSlot = 1 [json_name = "PIVSlot"];
     */
    pIVSlot: string;
    /**
     * SerialNumberValidation holds settings for hardware key serial number validation.
     * By default, serial number validation is disabled.
     *
     * @generated from protobuf field: types.HardwareKeySerialNumberValidation SerialNumberValidation = 2 [json_name = "SerialNumberValidation"];
     */
    serialNumberValidation?: HardwareKeySerialNumberValidation;
    /**
     * PinCacheTTL is the amount of time in nanoseconds that Teleport clients
     * will cache the user's PIV PIN when hardware key PIN policy is enabled.
     *
     * @generated from protobuf field: int64 PinCacheTTL = 3 [json_name = "PinCacheTTL"];
     */
    pinCacheTTL: bigint;
}
/**
 * @generated from protobuf message types.HardwareKeySerialNumberValidation
 */
export interface HardwareKeySerialNumberValidation {
    /**
     * Enabled indicates whether hardware key serial number validation is enabled.
     *
     * @generated from protobuf field: bool Enabled = 1 [json_name = "Enabled"];
     */
    enabled: boolean;
    /**
     * SerialNumberTraitName is an optional custom user trait name for hardware key
     * serial numbers to replace the default: "hardware_key_serial_numbers".
     *
     * Note: Values for this user trait should be a comma-separated list of serial numbers,
     * or a list of comm-separated lists. e.g ["123", "345,678"]
     *
     * @generated from protobuf field: string SerialNumberTraitName = 2 [json_name = "SerialNumberTraitName"];
     */
    serialNumberTraitName: string;
}
/**
 * Namespace represents namespace resource specification
 *
 * @generated from protobuf message types.Namespace
 */
export interface Namespace {
    /**
     * Kind is a resource kind
     *
     * @generated from protobuf field: string Kind = 1 [json_name = "Kind"];
     */
    kind: string;
    /**
     * SubKind is an optional resource sub kind, used in some resources
     *
     * @generated from protobuf field: string SubKind = 2 [json_name = "SubKind"];
     */
    subKind: string;
    /**
     * Version is version
     *
     * @generated from protobuf field: string Version = 3 [json_name = "Version"];
     */
    version: string;
    /**
     * Metadata is resource metadata
     *
     * @generated from protobuf field: types.Metadata Metadata = 4 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Spec is a namespace spec
     *
     * @generated from protobuf field: types.NamespaceSpec Spec = 5 [json_name = "Spec"];
     */
    spec?: NamespaceSpec;
}
/**
 * NamespaceSpec is a namespace specification
 *
 * @generated from protobuf message types.NamespaceSpec
 */
export interface NamespaceSpec {
}
/**
 * @generated from protobuf message types.UserTokenV3
 */
export interface UserTokenV3 {
    /**
     * Kind is a resource kind
     *
     * @generated from protobuf field: string Kind = 1 [json_name = "Kind"];
     */
    kind: string;
    /**
     * SubKind is a resource sub kind, used to define the type of user token.
     *
     * @generated from protobuf field: string SubKind = 2 [json_name = "SubKind"];
     */
    subKind: string;
    /**
     * Version is version
     *
     * @generated from protobuf field: string Version = 3 [json_name = "Version"];
     */
    version: string;
    /**
     * Metadata is resource metadata
     *
     * @generated from protobuf field: types.Metadata Metadata = 4 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Spec is an resource specification
     *
     * @generated from protobuf field: types.UserTokenSpecV3 Spec = 5 [json_name = "Spec"];
     */
    spec?: UserTokenSpecV3;
}
/**
 * @generated from protobuf message types.UserTokenSpecV3
 */
export interface UserTokenSpecV3 {
    /**
     * User is user name associated with this token
     *
     * @generated from protobuf field: string User = 1 [json_name = "User"];
     */
    user: string;
    /**
     * URL is this token URL
     *
     * @generated from protobuf field: string URL = 2 [json_name = "URL"];
     */
    uRL: string;
    /**
     * Usage is an optional field that provides more information about how this token will be used.
     *
     * @generated from protobuf field: types.UserTokenUsage Usage = 3 [json_name = "Usage"];
     */
    usage: UserTokenUsage;
    /**
     * Created holds information about when the token was created
     *
     * @generated from protobuf field: google.protobuf.Timestamp Created = 4 [json_name = "Created"];
     */
    created?: Timestamp;
}
/**
 * @generated from protobuf message types.UserTokenSecretsV3
 */
export interface UserTokenSecretsV3 {
    /**
     * Kind is a resource kind
     *
     * @generated from protobuf field: string Kind = 1 [json_name = "Kind"];
     */
    kind: string;
    /**
     * SubKind is an optional resource sub kind, used in some resources
     *
     * @generated from protobuf field: string SubKind = 2 [json_name = "SubKind"];
     */
    subKind: string;
    /**
     * Version is version
     *
     * @generated from protobuf field: string Version = 3 [json_name = "Version"];
     */
    version: string;
    /**
     * Metadata is resource metadata
     *
     * @generated from protobuf field: types.Metadata Metadata = 4 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Spec is an resource specification
     *
     * @generated from protobuf field: types.UserTokenSecretsSpecV3 Spec = 5 [json_name = "Spec"];
     */
    spec?: UserTokenSecretsSpecV3;
}
/**
 * @generated from protobuf message types.UserTokenSecretsSpecV3
 */
export interface UserTokenSecretsSpecV3 {
    /**
     * OTPKey is is a secret value of one time password secret generator
     *
     * @generated from protobuf field: string OTPKey = 1 [json_name = "OTPKey"];
     */
    oTPKey: string;
    /**
     * OTPKey is is a secret value of one time password secret generator
     *
     * @generated from protobuf field: string QRCode = 2 [json_name = "QRCode"];
     */
    qRCode: string;
    /**
     * Created holds information about when the token was created
     *
     * @generated from protobuf field: google.protobuf.Timestamp Created = 3 [json_name = "Created"];
     */
    created?: Timestamp;
}
/**
 * AccessRequest represents an Access Request resource specification
 *
 * @generated from protobuf message types.AccessRequestV3
 */
export interface AccessRequestV3 {
    /**
     * Kind is a resource kind
     *
     * @generated from protobuf field: string Kind = 1 [json_name = "Kind"];
     */
    kind: string;
    /**
     * SubKind is an optional resource sub kind, used in some resources
     *
     * @generated from protobuf field: string SubKind = 2 [json_name = "SubKind"];
     */
    subKind: string;
    /**
     * Version is version
     *
     * @generated from protobuf field: string Version = 3 [json_name = "Version"];
     */
    version: string;
    /**
     * Metadata is AccessRequest metadata
     *
     * @generated from protobuf field: types.Metadata Metadata = 4 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Spec is an AccessRequest specification
     *
     * @generated from protobuf field: types.AccessRequestSpecV3 Spec = 5 [json_name = "Spec"];
     */
    spec?: AccessRequestSpecV3;
}
/**
 * AccessReviewThreshold describes a filter used to match access reviews,
 * as well as approval/denial counts which trigger state-transitions.  This type
 * can be used to describe policies such as "can be approved by 2 admins"
 * or "can be denied by any non-contractor".
 *
 * @generated from protobuf message types.AccessReviewThreshold
 */
export interface AccessReviewThreshold {
    /**
     * Name is the optional human-readable name of the threshold.
     *
     * @generated from protobuf field: string Name = 1 [json_name = "Name"];
     */
    name: string;
    /**
     * Filter is an optional predicate used to determine which reviews
     * count toward this threshold.
     *
     * @generated from protobuf field: string Filter = 2 [json_name = "Filter"];
     */
    filter: string;
    /**
     * Approve is the number of matching approvals needed for state-transition.
     *
     * @generated from protobuf field: uint32 Approve = 3 [json_name = "Approve"];
     */
    approve: number;
    /**
     * Deny is the number of denials needed for state-transition.
     *
     * @generated from protobuf field: uint32 Deny = 4 [json_name = "Deny"];
     */
    deny: number;
}
/**
 * PromotedAccessList is a minimal access list representation used for
 * promoting Access Requests to access lists.
 *
 * @generated from protobuf message types.PromotedAccessList
 */
export interface PromotedAccessList {
    /**
     * Name is the name of the access list.
     *
     * @generated from protobuf field: string Name = 1 [json_name = "Name"];
     */
    name: string;
    /**
     * Title is the title of the access list.
     *
     * @generated from protobuf field: string Title = 2 [json_name = "Title"];
     */
    title: string;
}
/**
 * AccessReview is a review to be applied to an Access Request.
 *
 * @generated from protobuf message types.AccessReview
 */
export interface AccessReview {
    /**
     * Author is the teleport username of the review author.
     *
     * @generated from protobuf field: string Author = 1 [json_name = "Author"];
     */
    author: string;
    /**
     * Roles is a list used for role-subselection (not yet fully supported).
     *
     * @generated from protobuf field: repeated string Roles = 2 [json_name = "Roles"];
     */
    roles: string[];
    /**
     * ProposedState is the proposed state (must be APPROVED or DENIED).
     *
     * @generated from protobuf field: types.RequestState ProposedState = 3 [json_name = "ProposedState"];
     */
    proposedState: RequestState;
    /**
     * Reason is an optional human-readable reason for why the above state
     * is being proposed.
     *
     * @generated from protobuf field: string Reason = 4 [json_name = "Reason"];
     */
    reason: string;
    /**
     * Created is the time at which the review was created.
     *
     * @generated from protobuf field: google.protobuf.Timestamp Created = 5 [json_name = "Created"];
     */
    created?: Timestamp;
    /**
     * Annotations is the proposed value of the request's resolve_annotations field.
     *
     * @generated from protobuf field: wrappers.LabelValues Annotations = 6 [json_name = "Annotations"];
     */
    annotations?: LabelValues;
    /**
     * ThresholdIndexes stores the indexes of thresholds which this review matches
     * (internal use only).
     *
     * @generated from protobuf field: repeated uint32 ThresholdIndexes = 7 [json_name = "ThresholdIndexes"];
     */
    thresholdIndexes: number[];
    /**
     * AccessList is the access list that this request was promoted to.
     * This field is only populated when the request is in the PROMOTED state.
     *
     * @generated from protobuf field: types.PromotedAccessList accessList = 9;
     */
    accessList?: PromotedAccessList;
    /**
     * AssumeStartTime is the time the requested roles can be assumed.
     *
     * @generated from protobuf field: google.protobuf.Timestamp AssumeStartTime = 10 [json_name = "AssumeStartTime"];
     */
    assumeStartTime?: Timestamp;
}
/**
 * AccessReviewSubmission encodes the necessary parameters for submitting
 * a new access review.
 *
 * @generated from protobuf message types.AccessReviewSubmission
 */
export interface AccessReviewSubmission {
    /**
     * RequestID is the unique ID of the request to be reviewed.
     *
     * @generated from protobuf field: string RequestID = 1 [json_name = "RequestID"];
     */
    requestID: string;
    /**
     * Review is the review to be applied.
     *
     * @generated from protobuf field: types.AccessReview Review = 2 [json_name = "Review"];
     */
    review?: AccessReview;
}
/**
 * ThresholdIndexSet encodes a list of threshold indexes. One of the listed thresholds
 * must pass for the set to be considered to have passed (i.e. this is an `or` operator).
 *
 * @generated from protobuf message types.ThresholdIndexSet
 */
export interface ThresholdIndexSet {
    /**
     * Indexes are the indexes of thresholds which relate to the role.
     *
     * @generated from protobuf field: repeated uint32 Indexes = 1 [json_name = "Indexes"];
     */
    indexes: number[];
}
/**
 * ThresholdIndexSets is a list of threshold index sets.  Each of the individual
 * sets must pass (i.e. this is an `and` operator).
 *
 * @generated from protobuf message types.ThresholdIndexSets
 */
export interface ThresholdIndexSets {
    /**
     * Sets are the sets that make up this group.
     *
     * @generated from protobuf field: repeated types.ThresholdIndexSet Sets = 1 [json_name = "Sets"];
     */
    sets: ThresholdIndexSet[];
}
/**
 * AccessRequestSpec is the specification for AccessRequest
 *
 * @generated from protobuf message types.AccessRequestSpecV3
 */
export interface AccessRequestSpecV3 {
    /**
     * User is the name of the user to whom the roles will be applied.
     *
     * @generated from protobuf field: string User = 1 [json_name = "User"];
     */
    user: string;
    /**
     * Roles is the name of the roles being requested.
     *
     * @generated from protobuf field: repeated string Roles = 2 [json_name = "Roles"];
     */
    roles: string[];
    /**
     * State is the current state of this Access Request.
     *
     * @generated from protobuf field: types.RequestState State = 3 [json_name = "State"];
     */
    state: RequestState;
    /**
     * Created encodes the time at which the request was registered with the auth
     * server.
     *
     * @generated from protobuf field: google.protobuf.Timestamp Created = 4 [json_name = "Created"];
     */
    created?: Timestamp;
    /**
     * Expires constrains the maximum lifetime of any login session for which this
     * request is active.
     *
     * @generated from protobuf field: google.protobuf.Timestamp Expires = 5 [json_name = "Expires"];
     */
    expires?: Timestamp;
    /**
     * RequestReason is an optional message explaining the reason for the request.
     *
     * @generated from protobuf field: string RequestReason = 6 [json_name = "RequestReason"];
     */
    requestReason: string;
    /**
     * ResolveReason is an optional message explaining the reason for the resolution
     * of the request (approval, denial, etc...).
     *
     * @generated from protobuf field: string ResolveReason = 7 [json_name = "ResolveReason"];
     */
    resolveReason: string;
    /**
     * ResolveAnnotations is a set of arbitrary values received from plugins or other
     * resolving parties during approval/denial.  Importantly, these annotations are
     * included in the access_request.update event, allowing plugins to propagate
     * arbitrary structured data to the audit log.
     *
     * @generated from protobuf field: wrappers.LabelValues ResolveAnnotations = 8 [json_name = "ResolveAnnotations"];
     */
    resolveAnnotations?: LabelValues;
    /**
     * SystemAnnotations is a set of programmatically generated annotations attached
     * to pending Access Requests by teleport.  These annotations are generated by
     * applying variable interpolation to the RoleConditions.Request.Annotations block
     * of a user's role(s).  These annotations serve as a mechanism for administrators
     * to pass extra information to plugins when they process pending Access Requests.
     *
     * @generated from protobuf field: wrappers.LabelValues SystemAnnotations = 9 [json_name = "SystemAnnotations"];
     */
    systemAnnotations?: LabelValues;
    /**
     * Thresholds is a list of review thresholds relevant to this request.  Order must be
     * preserved, as thresholds are referenced by index (internal use only).
     *
     * @generated from protobuf field: repeated types.AccessReviewThreshold Thresholds = 10 [json_name = "Thresholds"];
     */
    thresholds: AccessReviewThreshold[];
    /**
     * RoleThresholdMapping encodes the relationship between the requested roles and
     * the review threshold requirements for the given role (internal use only).
     * By storing a representation of which thresholds must pass for each requested role, we
     * both eliminate the need to cache the requestor's roles directly, and allow future
     * versions of teleport to become smarter about calculating more granular requirements
     * in a backwards-compatible manner (i.e. calculation can become smarter in minor releases).
     * Storing this relationship on the request is necessary in order to avoid unexpected or
     * inconsistent behavior due to review submission timing.
     *
     * @generated from protobuf field: map<string, types.ThresholdIndexSets> RoleThresholdMapping = 11 [json_name = "RoleThresholdMapping"];
     */
    roleThresholdMapping: {
        [key: string]: ThresholdIndexSets;
    };
    /**
     * Reviews is a list of reviews applied to this request (internal use only).
     *
     * @generated from protobuf field: repeated types.AccessReview Reviews = 12 [json_name = "Reviews"];
     */
    reviews: AccessReview[];
    /**
     * SuggestedReviewers is a list of reviewer suggestions.  These can be teleport usernames, but
     * that is not a requirement.
     *
     * @generated from protobuf field: repeated string SuggestedReviewers = 13 [json_name = "SuggestedReviewers"];
     */
    suggestedReviewers: string[];
    /**
     * RequestedResourceIDs is a set of resources to which access is being requested.
     *
     * @generated from protobuf field: repeated types.ResourceID RequestedResourceIDs = 14 [json_name = "RequestedResourceIDs"];
     */
    requestedResourceIDs: ResourceID[];
    /**
     * LoginHint is used as a hint for search-based Access Requests to select
     * roles based on the login the user is attempting.
     *
     * @generated from protobuf field: string LoginHint = 15 [json_name = "LoginHint"];
     */
    loginHint: string;
    /**
     * DryRun indicates that the request should not actually be created, the
     * Auth Service should only validate the Access Request.
     *
     * @generated from protobuf field: bool DryRun = 16 [json_name = "DryRun"];
     */
    dryRun: boolean;
    /**
     * MaxDuration indicates how long the access should be granted for.
     *
     * @generated from protobuf field: google.protobuf.Timestamp MaxDuration = 17 [json_name = "MaxDuration"];
     */
    maxDuration?: Timestamp;
    /**
     * SessionTLL indicated how long a certificate for a session should be valid for.
     *
     * @generated from protobuf field: google.protobuf.Timestamp SessionTTL = 18 [json_name = "SessionTTL"];
     */
    sessionTTL?: Timestamp;
    /**
     * PromotedAccessListTitle is the title of the access list that this request
     * was promoted to. Used by WebUI to display the title of the access list.
     * This field is only populated when the request is in the PROMOTED state.
     *
     * @generated from protobuf field: types.PromotedAccessList accessList = 20;
     */
    accessList?: PromotedAccessList;
    /**
     * AssumeStartTime is the time the requested roles can be assumed.
     *
     * @generated from protobuf field: google.protobuf.Timestamp AssumeStartTime = 21 [json_name = "AssumeStartTime"];
     */
    assumeStartTime?: Timestamp;
    /**
     * ResourceExpiry is the time at which the access request resource will expire.
     *
     * @generated from protobuf field: google.protobuf.Timestamp ResourceExpiry = 22 [json_name = "ResourceExpiry"];
     */
    resourceExpiry?: Timestamp;
}
/**
 * AccessRequestFilter encodes filter params for Access Requests.
 *
 * @generated from protobuf message types.AccessRequestFilter
 */
export interface AccessRequestFilter {
    /**
     * ID specifies a request ID if set.
     *
     * @generated from protobuf field: string ID = 1 [json_name = "ID"];
     */
    iD: string;
    /**
     * User specifies a username if set.
     *
     * @generated from protobuf field: string User = 2 [json_name = "User"];
     */
    user: string;
    /**
     * RequestState filters for requests in a specific state.
     *
     * @generated from protobuf field: types.RequestState State = 3 [json_name = "State"];
     */
    state: RequestState;
    /**
     * SearchKeywords is a list of search keywords to match against resource field values.
     * The matcher goes through select field values from a resource
     * and tries to match against the list of search values, ignoring case and order.
     * Returns true if all search vals were matched (or if nil search vals).
     * Returns false if no or partial match (or nil field values).
     *
     * @generated from protobuf field: repeated string SearchKeywords = 4 [json_name = "SearchKeywords"];
     */
    searchKeywords: string[];
    /**
     * Scope is an aditional filter to view requests based on needs review, reviewed, my requests
     *
     * @generated from protobuf field: types.AccessRequestScope Scope = 5 [json_name = "Scope"];
     */
    scope: AccessRequestScope;
    /**
     * Requester is the requester of the api call. This is set by the Auth Service
     * Use User for the requester of the request.
     *
     * @generated from protobuf field: string Requester = 6 [json_name = "Requester"];
     */
    requester: string;
}
/**
 * AccessCapabilities is a summary of capabilities that a user
 * is granted via their dynamic access privileges which may not be
 * calculable by directly examining the user's own static roles.
 *
 * @generated from protobuf message types.AccessCapabilities
 */
export interface AccessCapabilities {
    /**
     * RequestableRoles is a list of existent roles which the user is allowed to request.
     *
     * @generated from protobuf field: repeated string RequestableRoles = 1 [json_name = "RequestableRoles"];
     */
    requestableRoles: string[];
    /**
     * SuggestedReviewers is a list of all reviewers which are suggested by the user's roles.
     *
     * @generated from protobuf field: repeated string SuggestedReviewers = 2 [json_name = "SuggestedReviewers"];
     */
    suggestedReviewers: string[];
    /**
     * ApplicableRolesForResources is a list of the roles applicable for access to a given set of resources.
     *
     * @generated from protobuf field: repeated string ApplicableRolesForResources = 3 [json_name = "ApplicableRolesForResources"];
     */
    applicableRolesForResources: string[];
    /**
     * RequestPrompt is an optional message which tells users what they aught to request.
     *
     * @generated from protobuf field: string RequestPrompt = 4 [json_name = "RequestPrompt"];
     */
    requestPrompt: string;
    /**
     * RequireReason indicates whether the request strategy is one that requires
     * users to always supply reasons with their requests.
     *
     * @generated from protobuf field: bool RequireReason = 5 [json_name = "RequireReason"];
     */
    requireReason: boolean;
    /**
     * AutoRequest indicates whether the request strategy indicates that a
     * request should be automatically generated on login.
     *
     * @generated from protobuf field: bool AutoRequest = 6 [json_name = "AutoRequest"];
     */
    autoRequest: boolean;
}
/**
 * AccessCapabilitiesRequest encodes parameters for the GetAccessCapabilities method.
 *
 * @generated from protobuf message types.AccessCapabilitiesRequest
 */
export interface AccessCapabilitiesRequest {
    /**
     * User is the name of the user whose capabilities we are interested in (defaults to
     * the caller's own username).
     *
     * @generated from protobuf field: string User = 1 [json_name = "User"];
     */
    user: string;
    /**
     * RequestableRoles is a flag indicating that we would like to view the list of roles
     * that the user is able to request.
     *
     * @generated from protobuf field: bool RequestableRoles = 2 [json_name = "RequestableRoles"];
     */
    requestableRoles: boolean;
    /**
     * SuggestedReviewers is a flag indicating that we would like to view the list of all
     * reviewers which are suggested by the user's roles.
     *
     * @generated from protobuf field: bool SuggestedReviewers = 3 [json_name = "SuggestedReviewers"];
     */
    suggestedReviewers: boolean;
    /**
     * ResourceIDs is the list of the ResourceIDs of the resources we would like to view
     * the necessary roles for.
     *
     * @generated from protobuf field: repeated types.ResourceID ResourceIDs = 4 [json_name = "ResourceIDs"];
     */
    resourceIDs: ResourceID[];
    /**
     * Login is the host login the user is requesting access for.
     *
     * @generated from protobuf field: string Login = 5 [json_name = "Login"];
     */
    login: string;
    /**
     * FilterRequestableRolesByResource is a flag indicating that the returned
     * list of roles that the user can request should be filtered to only include
     * roles that allow access to the provided ResourceIDs.
     *
     * @generated from protobuf field: bool FilterRequestableRolesByResource = 6 [json_name = "FilterRequestableRolesByResource"];
     */
    filterRequestableRolesByResource: boolean;
}
/**
 * RequestKubernetesResource is the Kubernetes resource identifier used
 * in access request settings.
 * Modeled after existing message KubernetesResource.
 *
 * @generated from protobuf message types.RequestKubernetesResource
 */
export interface RequestKubernetesResource {
    /**
     * kind specifies the Kubernetes Resource type.
     *
     * @generated from protobuf field: string kind = 1;
     */
    kind: string;
}
/**
 * ResourceID is a unique identifier for a teleport resource.
 * Must be kept in sync with teleport.decision.v1alpha1.ResourceId.
 *
 * @generated from protobuf message types.ResourceID
 */
export interface ResourceID {
    /**
     * ClusterName is the name of the cluster the resource is in.
     *
     * @generated from protobuf field: string ClusterName = 1 [json_name = "ClusterName"];
     */
    clusterName: string;
    /**
     * Kind is the resource kind.
     *
     * @generated from protobuf field: string Kind = 2 [json_name = "Kind"];
     */
    kind: string;
    /**
     * Name is the name of the specific resource.
     *
     * @generated from protobuf field: string Name = 3 [json_name = "Name"];
     */
    name: string;
    /**
     * SubResourceName is the resource belonging to resource identified by "Name"
     * that the user is allowed to access to.
     * When granting access to a subresource, access to other resources is limited.
     * Currently it just supports resources of Kind=pod and the format is the following
     * "<kube_namespace>/<kube_pod>".
     *
     * @generated from protobuf field: string SubResourceName = 4 [json_name = "SubResourceName"];
     */
    subResourceName: string;
}
/**
 * PluginData stores a collection of values associated with a specific resource.
 *
 * @generated from protobuf message types.PluginDataV3
 */
export interface PluginDataV3 {
    /**
     * Kind is a resource kind
     *
     * @generated from protobuf field: string Kind = 1 [json_name = "Kind"];
     */
    kind: string;
    /**
     * SubKind is an optional resource sub kind, used in some resources
     *
     * @generated from protobuf field: string SubKind = 2 [json_name = "SubKind"];
     */
    subKind: string;
    /**
     * Version is version
     *
     * @generated from protobuf field: string Version = 3 [json_name = "Version"];
     */
    version: string;
    /**
     * Metadata is PluginData metadata
     *
     * @generated from protobuf field: types.Metadata Metadata = 4 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Spec is a PluginData specification
     *
     * @generated from protobuf field: types.PluginDataSpecV3 Spec = 5 [json_name = "Spec"];
     */
    spec?: PluginDataSpecV3;
}
/**
 * PluginDataEntry wraps a mapping of arbitrary string values used by
 * plugins to store per-resource information.
 *
 * @generated from protobuf message types.PluginDataEntry
 */
export interface PluginDataEntry {
    /**
     * Data is a mapping of arbitrary string values.
     *
     * @generated from protobuf field: map<string, string> Data = 1 [json_name = "Data"];
     */
    data: {
        [key: string]: string;
    };
}
/**
 * PluginData stores a collection of values associated with a specific resource.
 *
 * @generated from protobuf message types.PluginDataSpecV3
 */
export interface PluginDataSpecV3 {
    /**
     * Entries is a collection of PluginData values organized by plugin name.
     *
     * @generated from protobuf field: map<string, types.PluginDataEntry> Entries = 1 [json_name = "Entries"];
     */
    entries: {
        [key: string]: PluginDataEntry;
    };
}
// NOTE: PluginDataFilter and PluginDataUpdateParams currently only target AccessRequest resources
// since those are the only resources currently managed via plugin.  Support for additional resource
// kinds may be added in a backwards-compatible manner by adding a `Kind` field which defaults
// to `access_request` if unspecified.

/**
 * PluginDataFilter encodes filter params for plugin data.
 *
 * @generated from protobuf message types.PluginDataFilter
 */
export interface PluginDataFilter {
    /**
     * Kind is the kind of resource that the target plugin data
     * is associated with.
     *
     * @generated from protobuf field: string Kind = 1 [json_name = "Kind"];
     */
    kind: string;
    /**
     * Resource matches a specific resource name if set.
     *
     * @generated from protobuf field: string Resource = 2 [json_name = "Resource"];
     */
    resource: string;
    /**
     * Plugin matches a specific plugin name if set.
     *
     * @generated from protobuf field: string Plugin = 3 [json_name = "Plugin"];
     */
    plugin: string;
}
/**
 * PluginDataUpdateParams encodes parameters for updating a PluginData field.
 *
 * @generated from protobuf message types.PluginDataUpdateParams
 */
export interface PluginDataUpdateParams {
    /**
     * Kind is the kind of resource that the target plugin data
     * is associated with.
     *
     * @generated from protobuf field: string Kind = 1 [json_name = "Kind"];
     */
    kind: string;
    /**
     * Resource indicates the name of the target resource.
     *
     * @generated from protobuf field: string Resource = 2 [json_name = "Resource"];
     */
    resource: string;
    /**
     * Plugin is the name of the plugin that owns the data.
     *
     * @generated from protobuf field: string Plugin = 3 [json_name = "Plugin"];
     */
    plugin: string;
    /**
     * Set indicates the fields which should be set by this operation.
     *
     * @generated from protobuf field: map<string, string> Set = 4 [json_name = "Set"];
     */
    set: {
        [key: string]: string;
    };
    /**
     * Expect optionally indicates the expected state of fields prior to this update.
     *
     * @generated from protobuf field: map<string, string> Expect = 5 [json_name = "Expect"];
     */
    expect: {
        [key: string]: string;
    };
}
/**
 * RoleFilter matches role resources.
 *
 * @generated from protobuf message types.RoleFilter
 */
export interface RoleFilter {
    /**
     * SearchKeywords is a list of search keywords to match against resource field values.
     *
     * @generated from protobuf field: repeated string SearchKeywords = 1 [json_name = "SearchKeywords"];
     */
    searchKeywords: string[];
    /**
     * SkipSystemRoles filters out teleport system roles from the results.
     *
     * @generated from protobuf field: bool SkipSystemRoles = 2 [json_name = "SkipSystemRoles"];
     */
    skipSystemRoles: boolean;
}
/**
 * RoleV6 represents role resource specification
 *
 * @generated from protobuf message types.RoleV6
 */
export interface RoleV6 {
    /**
     * Kind is a resource kind
     *
     * @generated from protobuf field: string Kind = 1 [json_name = "Kind"];
     */
    kind: string;
    /**
     * SubKind is an optional resource sub kind, used in some resources
     *
     * @generated from protobuf field: string SubKind = 2 [json_name = "SubKind"];
     */
    subKind: string;
    /**
     * Version is the resource version. It must be specified.
     * Supported values are: `v3`, `v4`, `v5`, `v6`, `v7`.
     *
     * @generated from protobuf field: string Version = 3 [json_name = "Version"];
     */
    version: string;
    /**
     * Metadata is resource metadata
     *
     * @generated from protobuf field: types.Metadata Metadata = 4 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Spec is a role specification
     *
     * @generated from protobuf field: types.RoleSpecV6 Spec = 5 [json_name = "Spec"];
     */
    spec?: RoleSpecV6;
}
/**
 * RoleSpecV6 is role specification for RoleV6.
 *
 * @generated from protobuf message types.RoleSpecV6
 */
export interface RoleSpecV6 {
    /**
     * Options is for OpenSSH options like agent forwarding.
     *
     * @generated from protobuf field: types.RoleOptions Options = 1 [json_name = "Options"];
     */
    options?: RoleOptions;
    /**
     * Allow is the set of conditions evaluated to grant access.
     *
     * @generated from protobuf field: types.RoleConditions Allow = 2 [json_name = "Allow"];
     */
    allow?: RoleConditions;
    /**
     * Deny is the set of conditions evaluated to deny access. Deny takes priority
     * over allow.
     *
     * @generated from protobuf field: types.RoleConditions Deny = 3 [json_name = "Deny"];
     */
    deny?: RoleConditions;
}
/**
 * SSHLocalPortForwarding configures access controls for local SSH port forwarding.
 *
 * @generated from protobuf message types.SSHLocalPortForwarding
 */
export interface SSHLocalPortForwarding {
    /**
     * @generated from protobuf field: types.BoolValue Enabled = 1 [json_name = "Enabled"];
     */
    enabled?: BoolValue;
}
/**
 * SSHRemotePortForwarding configures access controls for remote SSH port forwarding.
 *
 * @generated from protobuf message types.SSHRemotePortForwarding
 */
export interface SSHRemotePortForwarding {
    /**
     * @generated from protobuf field: types.BoolValue Enabled = 1 [json_name = "Enabled"];
     */
    enabled?: BoolValue;
}
/**
 * SSHPortForwarding configures what types of SSH port forwarding are allowed by a role.
 *
 * @generated from protobuf message types.SSHPortForwarding
 */
export interface SSHPortForwarding {
    /**
     * Allow local port forwarding.
     *
     * @generated from protobuf field: types.SSHLocalPortForwarding Local = 1 [json_name = "Local"];
     */
    local?: SSHLocalPortForwarding;
    /**
     * Allow remote port forwarding.
     *
     * @generated from protobuf field: types.SSHRemotePortForwarding Remote = 2 [json_name = "Remote"];
     */
    remote?: SSHRemotePortForwarding;
}
/**
 * RoleOptions is a set of role options
 *
 * @generated from protobuf message types.RoleOptions
 */
export interface RoleOptions {
    /**
     * ForwardAgent is SSH agent forwarding.
     *
     * @generated from protobuf field: bool ForwardAgent = 1 [json_name = "ForwardAgent"];
     */
    forwardAgent: boolean;
    /**
     * MaxSessionTTL defines how long a SSH session can last for.
     *
     * @generated from protobuf field: int64 MaxSessionTTL = 2 [json_name = "MaxSessionTTL"];
     */
    maxSessionTTL: bigint;
    /**
     * Deprecated: Use SSHPortForwarding instead
     *
     * @deprecated
     * @generated from protobuf field: types.BoolValue PortForwarding = 3 [deprecated = true, json_name = "PortForwarding"];
     */
    portForwarding?: BoolValue;
    /**
     * CertificateFormat defines the format of the user certificate to allow
     * compatibility with older versions of OpenSSH.
     *
     * @generated from protobuf field: string CertificateFormat = 4 [json_name = "CertificateFormat"];
     */
    certificateFormat: string;
    /**
     * ClientIdleTimeout sets disconnect clients on idle timeout behavior,
     * if set to 0 means do not disconnect, otherwise is set to the idle
     * duration.
     *
     * @generated from protobuf field: int64 ClientIdleTimeout = 5 [json_name = "ClientIdleTimeout"];
     */
    clientIdleTimeout: bigint;
    /**
     * DisconnectExpiredCert sets disconnect clients on expired certificates.
     *
     * @generated from protobuf field: bool DisconnectExpiredCert = 6 [json_name = "DisconnectExpiredCert"];
     */
    disconnectExpiredCert: boolean;
    /**
     * BPF defines what events to record for the BPF-based session recorder.
     *
     * @generated from protobuf field: repeated string BPF = 7 [json_name = "BPF"];
     */
    bPF: string[];
    /**
     * PermitX11Forwarding authorizes use of X11 forwarding.
     *
     * @generated from protobuf field: bool PermitX11Forwarding = 8 [json_name = "PermitX11Forwarding"];
     */
    permitX11Forwarding: boolean;
    /**
     * MaxConnections defines the maximum number of
     * concurrent connections a user may hold.
     *
     * @generated from protobuf field: int64 MaxConnections = 9 [json_name = "MaxConnections"];
     */
    maxConnections: bigint;
    /**
     * MaxSessions defines the maximum number of
     * concurrent sessions per connection.
     *
     * @generated from protobuf field: int64 MaxSessions = 10 [json_name = "MaxSessions"];
     */
    maxSessions: bigint;
    /**
     * RequestAccess defines the request strategy (optional|reason|always)
     * where optional is the default.
     *
     * @generated from protobuf field: string RequestAccess = 11 [json_name = "RequestAccess"];
     */
    requestAccess: string;
    /**
     * RequestPrompt is an optional message which tells users what they aught to request.
     *
     * @generated from protobuf field: string RequestPrompt = 12 [json_name = "RequestPrompt"];
     */
    requestPrompt: string;
    /**
     * Lock specifies the locking mode (strict|best_effort) to be applied with
     * the role.
     *
     * @generated from protobuf field: string Lock = 14 [json_name = "Lock"];
     */
    lock: string;
    /**
     * RecordDesktopSession indicates whether desktop access sessions should be recorded.
     * It defaults to true unless explicitly set to false.
     *
     * @generated from protobuf field: types.RecordSession RecordSession = 15 [json_name = "RecordSession"];
     */
    recordSession?: RecordSession;
    /**
     * DesktopClipboard indicates whether clipboard sharing is allowed between the user's
     * workstation and the remote desktop. It defaults to true unless explicitly set to
     * false.
     *
     * @generated from protobuf field: types.BoolValue DesktopClipboard = 16 [json_name = "DesktopClipboard"];
     */
    desktopClipboard?: BoolValue;
    /**
     * CertExtensions specifies the key/values
     *
     * @generated from protobuf field: repeated types.CertExtension CertExtensions = 17 [json_name = "CertExtensions"];
     */
    certExtensions: CertExtension[];
    /**
     * MaxKubernetesConnections defines the maximum number of concurrent
     * Kubernetes sessions a user may hold.
     *
     * @generated from protobuf field: int64 MaxKubernetesConnections = 18 [json_name = "MaxKubernetesConnections"];
     */
    maxKubernetesConnections: bigint;
    /**
     * DesktopDirectorySharing indicates whether directory sharing is allowed between the user's
     * workstation and the remote desktop. It defaults to false unless explicitly set to
     * true.
     *
     * @generated from protobuf field: types.BoolValue DesktopDirectorySharing = 19 [json_name = "DesktopDirectorySharing"];
     */
    desktopDirectorySharing?: BoolValue;
    /**
     * Deprecated: use CreateHostUserMode instead.
     *
     * @generated from protobuf field: types.BoolValue CreateHostUser = 20 [json_name = "CreateHostUser"];
     */
    createHostUser?: BoolValue;
    /**
     * PinSourceIP forces the same client IP for certificate generation and usage
     *
     * @generated from protobuf field: bool PinSourceIP = 21 [json_name = "PinSourceIP"];
     */
    pinSourceIP: boolean;
    /**
     * SSHFileCopy indicates whether remote file operations via SCP or SFTP are allowed
     * over an SSH session. It defaults to true unless explicitly set to false.
     *
     * @generated from protobuf field: types.BoolValue SSHFileCopy = 22 [json_name = "SSHFileCopy"];
     */
    sSHFileCopy?: BoolValue;
    /**
     * RequireMFAType is the type of MFA requirement enforced for this user.
     * 0 is "OFF", 1 is "SESSION", 2 is "SESSION_AND_HARDWARE_KEY", 3 is "HARDWARE_KEY_TOUCH",
     * 4 is "HARDWARE_KEY_PIN", 5 is "HARDWARE_KEY_TOUCH_AND_PIN".
     *
     * @generated from protobuf field: types.RequireMFAType RequireMFAType = 23 [json_name = "RequireMFAType"];
     */
    requireMFAType: RequireMFAType;
    /**
     * DeviceTrustMode is the device authorization mode used for the resources
     * associated with the role.
     * See DeviceTrust.Mode.
     *
     * @generated from protobuf field: string DeviceTrustMode = 24 [json_name = "DeviceTrustMode"];
     */
    deviceTrustMode: string;
    /**
     * IDP is a set of options related to accessing IdPs within Teleport.
     * Requires Teleport Enterprise.
     *
     * @generated from protobuf field: types.IdPOptions IDP = 25 [json_name = "IDP"];
     */
    iDP?: IdPOptions;
    /**
     * CreateDesktopUser allows users to be automatically created on a Windows desktop
     *
     * @generated from protobuf field: types.BoolValue CreateDesktopUser = 26 [json_name = "CreateDesktopUser"];
     */
    createDesktopUser?: BoolValue;
    /**
     * CreateDatabaseUser enabled automatic database user creation.
     *
     * @generated from protobuf field: types.BoolValue CreateDatabaseUser = 27 [json_name = "CreateDatabaseUser"];
     */
    createDatabaseUser?: BoolValue;
    /**
     * CreateHostUserMode allows users to be automatically created on a
     * host when not set to off.
     * 0 is "unspecified"; 1 is "off"; 2 is "drop" (removed for v15 and above),
     * 3 is "keep"; 4 is "insecure-drop".
     *
     * @generated from protobuf field: types.CreateHostUserMode CreateHostUserMode = 28 [json_name = "CreateHostUserMode"];
     */
    createHostUserMode: CreateHostUserMode;
    /**
     * CreateDatabaseUserMode allows users to be automatically created on a
     * database when not set to off.
     * 0 is "unspecified", 1 is "off", 2 is "keep", 3 is "best_effort_drop".
     *
     * @generated from protobuf field: types.CreateDatabaseUserMode CreateDatabaseUserMode = 29 [json_name = "CreateDatabaseUserMode"];
     */
    createDatabaseUserMode: CreateDatabaseUserMode;
    /**
     * MFAVerificationInterval optionally defines the maximum duration that can elapse
     * between successive MFA verifications. This variable is used to ensure
     * that users are periodically prompted to verify their identity, enhancing
     * security by preventing prolonged sessions without re-authentication when using
     * tsh proxy * derivatives.
     * It's only effective if the session requires MFA.
     * If not set, defaults to `max_session_ttl`.
     *
     * @generated from protobuf field: google.protobuf.Duration MFAVerificationInterval = 30 [json_name = "MFAVerificationInterval"];
     */
    mFAVerificationInterval?: Duration;
    /**
     * CreateHostUserDefaultShell is used to configure the default shell for newly provisioned host users.
     *
     * @generated from protobuf field: string CreateHostUserDefaultShell = 31 [json_name = "CreateHostUserDefaultShell"];
     */
    createHostUserDefaultShell: string;
    /**
     * SSHPortForwarding configures what types of SSH port forwarding are allowed by a role.
     *
     * @generated from protobuf field: types.SSHPortForwarding SSHPortForwarding = 32 [json_name = "SSHPortForwarding"];
     */
    sSHPortForwarding?: SSHPortForwarding;
}
/**
 * @generated from protobuf message types.RecordSession
 */
export interface RecordSession {
    /**
     * Desktop indicates whether desktop sessions should be recorded.
     * It defaults to true unless explicitly set to false.
     *
     * @generated from protobuf field: types.BoolValue Desktop = 1 [json_name = "Desktop"];
     */
    desktop?: BoolValue;
    /**
     * Default indicates the default value for the services.
     *
     * @generated from protobuf field: string Default = 2 [json_name = "Default"];
     */
    default: string;
    /**
     * SSH indicates the session mode used on SSH sessions.
     *
     * @generated from protobuf field: string SSH = 3 [json_name = "SSH"];
     */
    sSH: string;
}
/**
 * CertExtension represents a key/value for a certificate extension
 *
 * @generated from protobuf message types.CertExtension
 */
export interface CertExtension {
    /**
     * Type represents the certificate type being extended, only ssh
     * is supported at this time.
     * 0 is "ssh".
     *
     * @generated from protobuf field: types.CertExtensionType Type = 1 [json_name = "Type"];
     */
    type: CertExtensionType;
    /**
     * Mode is the type of extension to be used -- currently
     * critical-option is not supported.
     * 0 is "extension".
     *
     * @generated from protobuf field: types.CertExtensionMode Mode = 2 [json_name = "Mode"];
     */
    mode: CertExtensionMode;
    /**
     * Name specifies the key to be used in the cert extension.
     *
     * @generated from protobuf field: string Name = 3 [json_name = "Name"];
     */
    name: string;
    /**
     * Value specifies the value to be used in the cert extension.
     *
     * @generated from protobuf field: string Value = 4 [json_name = "Value"];
     */
    value: string;
}
/**
 * RoleConditions is a set of conditions that must all match to be allowed or
 * denied access.
 *
 * @generated from protobuf message types.RoleConditions
 */
export interface RoleConditions {
    /**
     * Logins is a list of *nix system logins.
     *
     * @generated from protobuf field: repeated string Logins = 1 [json_name = "Logins"];
     */
    logins: string[];
    /**
     * Namespaces is a list of namespaces (used to partition a cluster). The
     * field should be called "namespaces" when it returns in Teleport 2.4.
     *
     * @generated from protobuf field: repeated string Namespaces = 2 [json_name = "Namespaces"];
     */
    namespaces: string[];
    /**
     * NodeLabels is a map of node labels (used to dynamically grant access to
     * nodes).
     *
     * @generated from protobuf field: wrappers.LabelValues NodeLabels = 3 [json_name = "NodeLabels"];
     */
    nodeLabels?: LabelValues;
    /**
     * Rules is a list of rules and their access levels. Rules are a high level
     * construct used for access control.
     *
     * @generated from protobuf field: repeated types.Rule Rules = 4 [json_name = "Rules"];
     */
    rules: Rule[];
    /**
     * KubeGroups is a list of kubernetes groups
     *
     * @generated from protobuf field: repeated string KubeGroups = 5 [json_name = "KubeGroups"];
     */
    kubeGroups: string[];
    /**
     * @generated from protobuf field: types.AccessRequestConditions Request = 6 [json_name = "Request"];
     */
    request?: AccessRequestConditions;
    /**
     * KubeUsers is an optional kubernetes users to impersonate
     *
     * @generated from protobuf field: repeated string KubeUsers = 7 [json_name = "KubeUsers"];
     */
    kubeUsers: string[];
    /**
     * AppLabels is a map of labels used as part of the RBAC system.
     *
     * @generated from protobuf field: wrappers.LabelValues AppLabels = 8 [json_name = "AppLabels"];
     */
    appLabels?: LabelValues;
    /**
     * ClusterLabels is a map of node labels (used to dynamically grant access to
     * clusters).
     *
     * @generated from protobuf field: wrappers.LabelValues ClusterLabels = 9 [json_name = "ClusterLabels"];
     */
    clusterLabels?: LabelValues;
    /**
     * KubernetesLabels is a map of kubernetes cluster labels used for RBAC.
     *
     * @generated from protobuf field: wrappers.LabelValues KubernetesLabels = 10 [json_name = "KubernetesLabels"];
     */
    kubernetesLabels?: LabelValues;
    /**
     * DatabaseLabels are used in RBAC system to allow/deny access to databases.
     *
     * @generated from protobuf field: wrappers.LabelValues DatabaseLabels = 11 [json_name = "DatabaseLabels"];
     */
    databaseLabels?: LabelValues;
    /**
     * DatabaseNames is a list of database names this role is allowed to connect to.
     *
     * @generated from protobuf field: repeated string DatabaseNames = 12 [json_name = "DatabaseNames"];
     */
    databaseNames: string[];
    /**
     * DatabaseUsers is a list of databases users this role is allowed to connect as.
     *
     * @generated from protobuf field: repeated string DatabaseUsers = 13 [json_name = "DatabaseUsers"];
     */
    databaseUsers: string[];
    /**
     * Impersonate specifies what users and roles this role is allowed to impersonate
     * by issuing certificates or other possible means.
     *
     * @generated from protobuf field: types.ImpersonateConditions Impersonate = 14 [json_name = "Impersonate"];
     */
    impersonate?: ImpersonateConditions;
    /**
     * ReviewRequests defines conditions for submitting access reviews.
     *
     * @generated from protobuf field: types.AccessReviewConditions ReviewRequests = 15 [json_name = "ReviewRequests"];
     */
    reviewRequests?: AccessReviewConditions;
    /**
     * AWSRoleARNs is a list of AWS role ARNs this role is allowed to assume.
     *
     * @generated from protobuf field: repeated string AWSRoleARNs = 16 [json_name = "AWSRoleARNs"];
     */
    aWSRoleARNs: string[];
    /**
     * WindowsDesktopLogins is a list of desktop login names allowed/denied for Windows desktops.
     *
     * @generated from protobuf field: repeated string WindowsDesktopLogins = 17 [json_name = "WindowsDesktopLogins"];
     */
    windowsDesktopLogins: string[];
    /**
     * WindowsDesktopLabels are used in the RBAC system to allow/deny access to Windows desktops.
     *
     * @generated from protobuf field: wrappers.LabelValues WindowsDesktopLabels = 18 [json_name = "WindowsDesktopLabels"];
     */
    windowsDesktopLabels?: LabelValues;
    /**
     * RequireSessionJoin specifies policies for required users to start a session.
     *
     * @generated from protobuf field: repeated types.SessionRequirePolicy RequireSessionJoin = 19 [json_name = "RequireSessionJoin"];
     */
    requireSessionJoin: SessionRequirePolicy[];
    /**
     * JoinSessions specifies policies to allow users to join other sessions.
     *
     * @generated from protobuf field: repeated types.SessionJoinPolicy JoinSessions = 20 [json_name = "JoinSessions"];
     */
    joinSessions: SessionJoinPolicy[];
    /**
     * HostGroups is a list of groups for created users to be added to
     *
     * @generated from protobuf field: repeated string HostGroups = 21 [json_name = "HostGroups"];
     */
    hostGroups: string[];
    /**
     * HostSudoers is a list of entries to include in a users sudoer file
     *
     * @generated from protobuf field: repeated string HostSudoers = 22 [json_name = "HostSudoers"];
     */
    hostSudoers: string[];
    /**
     * AzureIdentities is a list of Azure identities this role is allowed to assume.
     *
     * @generated from protobuf field: repeated string AzureIdentities = 23 [json_name = "AzureIdentities"];
     */
    azureIdentities: string[];
    /**
     * KubernetesResources is the Kubernetes Resources this Role grants access to.
     *
     * @generated from protobuf field: repeated types.KubernetesResource KubernetesResources = 24 [json_name = "KubernetesResources"];
     */
    kubernetesResources: KubernetesResource[];
    /**
     * GCPServiceAccounts is a list of GCP service accounts this role is allowed to assume.
     *
     * @generated from protobuf field: repeated string GCPServiceAccounts = 25 [json_name = "GCPServiceAccounts"];
     */
    gCPServiceAccounts: string[];
    /**
     * DatabaseServiceLabels are used in RBAC system to allow/deny access to Database Services.
     *
     * @generated from protobuf field: wrappers.LabelValues DatabaseServiceLabels = 26 [json_name = "DatabaseServiceLabels"];
     */
    databaseServiceLabels?: LabelValues;
    /**
     * GroupLabels is a map of labels used as part of the RBAC system.
     *
     * @generated from protobuf field: wrappers.LabelValues GroupLabels = 27 [json_name = "GroupLabels"];
     */
    groupLabels?: LabelValues;
    /**
     * DesktopGroups is a list of groups for created desktop users to be added to
     *
     * @generated from protobuf field: repeated string DesktopGroups = 28 [json_name = "DesktopGroups"];
     */
    desktopGroups: string[];
    /**
     * DatabaseRoles is a list of databases roles for automatic user creation.
     *
     * @generated from protobuf field: repeated string DatabaseRoles = 29 [json_name = "DatabaseRoles"];
     */
    databaseRoles: string[];
    /**
     * NodeLabelsExpression is a predicate expression used to allow/deny access to
     * SSH nodes.
     *
     * @generated from protobuf field: string NodeLabelsExpression = 30 [json_name = "NodeLabelsExpression"];
     */
    nodeLabelsExpression: string;
    /**
     * AppLabelsExpression is a predicate expression used to allow/deny access to
     * Apps.
     *
     * @generated from protobuf field: string AppLabelsExpression = 31 [json_name = "AppLabelsExpression"];
     */
    appLabelsExpression: string;
    /**
     * ClusterLabelsExpression is a predicate expression used to allow/deny access
     * to remote Teleport clusters.
     *
     * @generated from protobuf field: string ClusterLabelsExpression = 32 [json_name = "ClusterLabelsExpression"];
     */
    clusterLabelsExpression: string;
    /**
     * KubernetesLabelsExpression is a predicate expression used to allow/deny
     * access to kubernetes clusters.
     *
     * @generated from protobuf field: string KubernetesLabelsExpression = 33 [json_name = "KubernetesLabelsExpression"];
     */
    kubernetesLabelsExpression: string;
    /**
     * DatabaseLabelsExpression is a predicate expression used to allow/deny
     * access to Databases.
     *
     * @generated from protobuf field: string DatabaseLabelsExpression = 34 [json_name = "DatabaseLabelsExpression"];
     */
    databaseLabelsExpression: string;
    /**
     * DatabaseServiceLabelsExpression is a predicate expression used to
     * allow/deny access to Database Services.
     *
     * @generated from protobuf field: string DatabaseServiceLabelsExpression = 35 [json_name = "DatabaseServiceLabelsExpression"];
     */
    databaseServiceLabelsExpression: string;
    /**
     * WindowsDesktopLabelsExpression is a predicate expression used to allow/deny
     * access to Windows desktops.
     *
     * @generated from protobuf field: string WindowsDesktopLabelsExpression = 36 [json_name = "WindowsDesktopLabelsExpression"];
     */
    windowsDesktopLabelsExpression: string;
    /**
     * GroupLabelsExpression is a predicate expression used to allow/deny
     * access to user groups.
     *
     * @generated from protobuf field: string GroupLabelsExpression = 37 [json_name = "GroupLabelsExpression"];
     */
    groupLabelsExpression: string;
    /**
     * DatabasePermissions specifies a set of permissions that will be granted
     * to the database user when using automatic database user provisioning.
     *
     * @generated from protobuf field: repeated types.DatabasePermission DatabasePermissions = 38 [json_name = "DatabasePermissions"];
     */
    databasePermissions: DatabasePermission[];
    /**
     * SPIFFE is used to allow or deny access to a role holder to generating a
     * SPIFFE SVID.
     *
     * @generated from protobuf field: repeated types.SPIFFERoleCondition SPIFFE = 39 [json_name = "SPIFFE"];
     */
    sPIFFE: SPIFFERoleCondition[];
    /**
     * AccountAssignments holds the list of account assignments affected by this
     * condition.
     *
     * @generated from protobuf field: repeated types.IdentityCenterAccountAssignment AccountAssignments = 42 [json_name = "AccountAssignments"];
     */
    accountAssignments: IdentityCenterAccountAssignment[];
    /**
     * GitHubPermissions defines GitHub integration related permissions.
     *
     * @generated from protobuf field: repeated types.GitHubPermission git_hub_permissions = 43;
     */
    gitHubPermissions: GitHubPermission[];
    /**
     * WorkloadIdentityLabels controls whether or not specific WorkloadIdentity
     * resources can be invoked. Further authorization controls exist on the
     * WorkloadIdentity resource itself.
     *
     * @generated from protobuf field: wrappers.LabelValues WorkloadIdentityLabels = 44 [json_name = "WorkloadIdentityLabels"];
     */
    workloadIdentityLabels?: LabelValues;
    /**
     * WorkloadIdentityLabelsExpression is a predicate expression used to
     * allow/deny access to issuing a WorkloadIdentity.
     *
     * @generated from protobuf field: string WorkloadIdentityLabelsExpression = 45 [json_name = "WorkloadIdentityLabelsExpression"];
     */
    workloadIdentityLabelsExpression: string;
}
/**
 * IdentityCenterAccountAssignment captures an AWS Identity Center account
 * assignment (acccount + permission set) pair.
 *
 * @generated from protobuf message types.IdentityCenterAccountAssignment
 */
export interface IdentityCenterAccountAssignment {
    /**
     * @generated from protobuf field: string PermissionSet = 1 [json_name = "PermissionSet"];
     */
    permissionSet: string;
    /**
     * @generated from protobuf field: string Account = 2 [json_name = "Account"];
     */
    account: string;
}
/**
 * GitHubPermission defines GitHub integration related permissions.
 *
 * @generated from protobuf message types.GitHubPermission
 */
export interface GitHubPermission {
    /**
     * @generated from protobuf field: repeated string organizations = 1;
     */
    organizations: string[];
}
/**
 * SPIFFERoleCondition sets out which SPIFFE identities this role is allowed or
 * denied to generate. The Path matcher is required, and is evaluated first. If,
 * the Path does not match then the other matcher fields are not evaluated.
 *
 * @generated from protobuf message types.SPIFFERoleCondition
 */
export interface SPIFFERoleCondition {
    /**
     * Path specifies a matcher for the SPIFFE ID path. It should not include the
     * trust domain and should start with a leading slash.
     *
     * The matcher by default allows '*' to be used to indicate zero or more of
     * any character. Prepend '^' and append '$' to instead switch to matching
     * using the Go regex syntax.
     *
     * Example:
     * - /svc/foo/*\/bar would match /svc/foo/baz/bar
     * - ^\/svc\/foo\/.*\/bar$ would match /svc/foo/baz/bar
     *
     * @generated from protobuf field: string Path = 1 [json_name = "Path"];
     */
    path: string;
    /**
     * DNSSANs specifies matchers for the SPIFFE ID DNS SANs.
     *
     * Each requested DNS SAN is compared against all matchers configured and if
     * any match, the condition is considered to be met.
     *
     * The matcher by default allows '*' to be used to indicate zero or more of
     * any character. Prepend '^' and append '$' to instead switch to matching
     * using the Go regex syntax.
     *
     * Example: *.example.com would match foo.example.com
     *
     * @generated from protobuf field: repeated string DNSSANs = 2 [json_name = "DNSSANs"];
     */
    dNSSANs: string[];
    /**
     * IPSANs specifies matchers for the SPIFFE ID IP SANs.
     *
     * Each requested IP SAN is compared against all matchers configured and if
     * any match, the condition is considered to be met.
     *
     * The matchers should be specified using CIDR notation, it supports IPv4 and
     * IPv6.
     *
     * Examples:
     * - 10.0.0.0/24 would match 10.0.0.0 to 10.255.255.255
     * - 10.0.0.42/32 would match only 10.0.0.42
     *
     * @generated from protobuf field: repeated string IPSANs = 3 [json_name = "IPSANs"];
     */
    iPSANs: string[];
}
/**
 * DatabasePermission specifies the database object permission for the user.
 *
 * @generated from protobuf message types.DatabasePermission
 */
export interface DatabasePermission {
    /**
     * Permission is the list of string representations of the permission to be given, e.g. SELECT, INSERT, UPDATE, ...
     *
     * @generated from protobuf field: repeated string Permissions = 1 [json_name = "Permissions"];
     */
    permissions: string[];
    /**
     * Match is a list of object labels that must be matched for the permission to be granted.
     *
     * @generated from protobuf field: wrappers.LabelValues Match = 2 [json_name = "Match"];
     */
    match?: LabelValues;
}
/**
 * KubernetesResource is the Kubernetes resource identifier.
 *
 * @generated from protobuf message types.KubernetesResource
 */
export interface KubernetesResource {
    /**
     * Kind specifies the Kubernetes Resource type.
     *
     * @generated from protobuf field: string Kind = 1 [json_name = "Kind"];
     */
    kind: string;
    /**
     * Namespace is the resource namespace.
     * It supports wildcards.
     *
     * @generated from protobuf field: string Namespace = 2 [json_name = "Namespace"];
     */
    namespace: string;
    /**
     * Name is the resource name.
     * It supports wildcards.
     *
     * @generated from protobuf field: string Name = 3 [json_name = "Name"];
     */
    name: string;
    /**
     * Verbs are the allowed Kubernetes verbs for the following resource.
     *
     * @generated from protobuf field: repeated string Verbs = 4 [json_name = "Verbs"];
     */
    verbs: string[];
    /**
     * APIGroup specifies the Kubernetes API group of the Kubernetes resource.
     * It supports wildcards.
     *
     * @generated from protobuf field: string APIGroup = 5 [json_name = "APIGroup"];
     */
    aPIGroup: string;
}
/**
 * SessionRequirePolicy a requirement policy that needs to be fulfilled to grant access.
 *
 * @generated from protobuf message types.SessionRequirePolicy
 */
export interface SessionRequirePolicy {
    /**
     * Name is the name of the policy.
     *
     * @generated from protobuf field: string Name = 1 [json_name = "Name"];
     */
    name: string;
    /**
     * Filter is a predicate that determines what users count towards this policy.
     *
     * @generated from protobuf field: string Filter = 2 [json_name = "Filter"];
     */
    filter: string;
    /**
     * Kinds are the session kinds this policy applies to.
     *
     * @generated from protobuf field: repeated string Kinds = 3 [json_name = "Kinds"];
     */
    kinds: string[];
    /**
     * Count is the amount of people that need to be matched for this policy to be fulfilled.
     *
     * @generated from protobuf field: int32 Count = 4 [json_name = "Count"];
     */
    count: number;
    /**
     * Modes is the list of modes that may be used to fulfill this policy.
     *
     * @generated from protobuf field: repeated string Modes = 5 [json_name = "Modes"];
     */
    modes: string[];
    /**
     * OnLeave is the behaviour that's used when the policy is no longer fulfilled
     * for a live session.
     *
     * @generated from protobuf field: string OnLeave = 6 [json_name = "OnLeave"];
     */
    onLeave: string;
}
/**
 * SessionJoinPolicy defines a policy that allows a user to join sessions.
 *
 * @generated from protobuf message types.SessionJoinPolicy
 */
export interface SessionJoinPolicy {
    /**
     * Name is the name of the policy.
     *
     * @generated from protobuf field: string Name = 1 [json_name = "Name"];
     */
    name: string;
    /**
     * Roles is a list of roles that you can join the session of.
     *
     * @generated from protobuf field: repeated string Roles = 2 [json_name = "Roles"];
     */
    roles: string[];
    /**
     * Kinds are the session kinds this policy applies to.
     *
     * @generated from protobuf field: repeated string Kinds = 3 [json_name = "Kinds"];
     */
    kinds: string[];
    /**
     * Modes is a list of permitted participant modes for this policy.
     *
     * @generated from protobuf field: repeated string Modes = 4 [json_name = "Modes"];
     */
    modes: string[];
}
/**
 * AccessRequestConditions is a matcher for allow/deny restrictions on
 * access-requests.
 * Please remember to update IsEmpty when updating this message.
 *
 * @generated from protobuf message types.AccessRequestConditions
 */
export interface AccessRequestConditions {
    /**
     * Roles is the name of roles which will match the request rule.
     *
     * @generated from protobuf field: repeated string Roles = 1 [json_name = "Roles"];
     */
    roles: string[];
    /**
     * ClaimsToRoles specifies a mapping from claims (traits) to teleport roles.
     *
     * @generated from protobuf field: repeated types.ClaimMapping ClaimsToRoles = 2 [json_name = "ClaimsToRoles"];
     */
    claimsToRoles: ClaimMapping[];
    /**
     * Annotations is a collection of annotations to be programmatically
     * appended to pending Access Requests at the time of their creation.
     * These annotations serve as a mechanism to propagate extra information
     * to plugins.  Since these annotations support variable interpolation
     * syntax, they also offer a mechanism for forwarding claims from an
     * external identity provider, to a plugin via `{{external.trait_name}}`
     * style substitutions.
     *
     * @generated from protobuf field: wrappers.LabelValues Annotations = 3 [json_name = "Annotations"];
     */
    annotations?: LabelValues;
    /**
     * Thresholds is a list of thresholds, one of which must be met in order for reviews
     * to trigger a state-transition.  If no thresholds are provided, a default threshold
     * of 1 for approval and denial is used.
     *
     * @generated from protobuf field: repeated types.AccessReviewThreshold Thresholds = 4 [json_name = "Thresholds"];
     */
    thresholds: AccessReviewThreshold[];
    /**
     * SuggestedReviewers is a list of reviewer suggestions.  These can be teleport usernames, but
     * that is not a requirement.
     *
     * @generated from protobuf field: repeated string SuggestedReviewers = 5 [json_name = "SuggestedReviewers"];
     */
    suggestedReviewers: string[];
    /**
     * SearchAsRoles is a list of extra roles which should apply to a user while
     * they are searching for resources as part of a Resource Access Request, and
     * defines the underlying roles which will be requested as part of any
     * Resource Access Request.
     *
     * @generated from protobuf field: repeated string SearchAsRoles = 6 [json_name = "SearchAsRoles"];
     */
    searchAsRoles: string[];
    /**
     * MaxDuration is the amount of time the access will be granted for.
     * If this is zero, the default duration is used.
     *
     * @generated from protobuf field: int64 MaxDuration = 7 [json_name = "MaxDuration"];
     */
    maxDuration: bigint;
    /**
     * kubernetes_resources can optionally enforce a requester to request only certain kinds of kube resources.
     * Eg: Users can make request to either a resource kind "kube_cluster" or any of its
     * subresources like "namespaces". This field can be defined such that it prevents a user
     * from requesting "kube_cluster" and enforce requesting any of its subresources.
     *
     * @generated from protobuf field: repeated types.RequestKubernetesResource kubernetes_resources = 8;
     */
    kubernetesResources: RequestKubernetesResource[];
    /**
     * Reason defines settings for the reason for the access provided by the user.
     *
     * @generated from protobuf field: types.AccessRequestConditionsReason Reason = 9 [json_name = "Reason"];
     */
    reason?: AccessRequestConditionsReason;
}
/**
 * AccessRequestConditionsReason defines settings for the reason for the access provided by the
 * user.
 *
 * @generated from protobuf message types.AccessRequestConditionsReason
 */
export interface AccessRequestConditionsReason {
    /**
     * Mode can be either "required" or "optional". Empty string is treated as "optional". If a role
     * has the request reason mode set to "required", then reason is required for all Access Requests
     * requesting roles or resources allowed by this role. It applies only to users who have this
     * role assigned.
     *
     * @generated from protobuf field: string Mode = 1 [json_name = "Mode"];
     */
    mode: string;
}
/**
 * AccessReviewConditions is a matcher for allow/deny restrictions on
 * access reviews.
 * Please remember to update IsEmpty when updating this message.
 *
 * @generated from protobuf message types.AccessReviewConditions
 */
export interface AccessReviewConditions {
    /**
     * Roles is the name of roles which may be reviewed.
     *
     * @generated from protobuf field: repeated string Roles = 1 [json_name = "Roles"];
     */
    roles: string[];
    /**
     * ClaimsToRoles specifies a mapping from claims (traits) to teleport roles.
     *
     * @generated from protobuf field: repeated types.ClaimMapping ClaimsToRoles = 2 [json_name = "ClaimsToRoles"];
     */
    claimsToRoles: ClaimMapping[];
    /**
     * Where is an optional predicate which further limits which requests are
     * reviewable.
     *
     * @generated from protobuf field: string Where = 3 [json_name = "Where"];
     */
    where: string;
    /**
     * PreviewAsRoles is a list of extra roles which should apply to a reviewer
     * while they are viewing a Resource Access Request for the purposes of
     * viewing details such as the hostname and labels of requested resources.
     *
     * @generated from protobuf field: repeated string PreviewAsRoles = 4 [json_name = "PreviewAsRoles"];
     */
    previewAsRoles: string[];
}
/**
 * AccessRequestAllowedPromotion describes an allowed promotion to an Access List.
 *
 * @generated from protobuf message types.AccessRequestAllowedPromotion
 */
export interface AccessRequestAllowedPromotion {
    /**
     * associated access list
     *
     * @generated from protobuf field: string accessListName = 1;
     */
    accessListName: string;
}
/**
 * AccessRequestAllowedPromotions describes an valid promotion from an access request
 * to an access list.
 *
 * @generated from protobuf message types.AccessRequestAllowedPromotions
 */
export interface AccessRequestAllowedPromotions {
    /**
     * suggestions is a list of allowed access lists promotions.
     *
     * @generated from protobuf field: repeated types.AccessRequestAllowedPromotion promotions = 1;
     */
    promotions: AccessRequestAllowedPromotion[];
}
/**
 * ClaimMapping maps a claim to teleport roles.
 *
 * @generated from protobuf message types.ClaimMapping
 */
export interface ClaimMapping {
    /**
     * Claim is a claim name.
     *
     * @generated from protobuf field: string Claim = 1 [json_name = "Claim"];
     */
    claim: string;
    /**
     * Value is a claim value to match.
     *
     * @generated from protobuf field: string Value = 2 [json_name = "Value"];
     */
    value: string;
    /**
     * Roles is a list of static teleport roles to match.
     *
     * @generated from protobuf field: repeated string Roles = 3 [json_name = "Roles"];
     */
    roles: string[];
}
/**
 * TraitMapping maps a trait to teleport roles.
 *
 * @generated from protobuf message types.TraitMapping
 */
export interface TraitMapping {
    /**
     * Trait is a trait name.
     *
     * @generated from protobuf field: string Trait = 1 [json_name = "Trait"];
     */
    trait: string;
    /**
     * Value is a trait value to match.
     *
     * @generated from protobuf field: string Value = 2 [json_name = "Value"];
     */
    value: string;
    /**
     * Roles is a list of static teleport roles to match.
     *
     * @generated from protobuf field: repeated string Roles = 3 [json_name = "Roles"];
     */
    roles: string[];
}
/**
 * Rule represents allow or deny rule that is executed to check
 * if user or service have access to resource
 *
 * @generated from protobuf message types.Rule
 */
export interface Rule {
    /**
     * Resources is a list of resources
     *
     * @generated from protobuf field: repeated string Resources = 1 [json_name = "Resources"];
     */
    resources: string[];
    /**
     * Verbs is a list of verbs
     *
     * @generated from protobuf field: repeated string Verbs = 2 [json_name = "Verbs"];
     */
    verbs: string[];
    /**
     * Where specifies optional advanced matcher
     *
     * @generated from protobuf field: string Where = 3 [json_name = "Where"];
     */
    where: string;
    /**
     * Actions specifies optional actions taken when this rule matches
     *
     * @generated from protobuf field: repeated string Actions = 4 [json_name = "Actions"];
     */
    actions: string[];
}
/**
 * ImpersonateConditions specifies whether users are allowed
 * to issue certificates for other users or groups.
 *
 * @generated from protobuf message types.ImpersonateConditions
 */
export interface ImpersonateConditions {
    /**
     * Users is a list of resources this role is allowed to impersonate,
     * could be an empty list or a Wildcard pattern
     *
     * @generated from protobuf field: repeated string Users = 1 [json_name = "Users"];
     */
    users: string[];
    /**
     * Roles is a list of resources this role is allowed to impersonate
     *
     * @generated from protobuf field: repeated string Roles = 2 [json_name = "Roles"];
     */
    roles: string[];
    /**
     * Where specifies optional advanced matcher
     *
     * @generated from protobuf field: string Where = 3 [json_name = "Where"];
     */
    where: string;
}
/**
 * BoolValue is a wrapper around bool, used in cases
 * whenever bool value can have different default value when missing
 *
 * @generated from protobuf message types.BoolValue
 */
export interface BoolValue {
    /**
     * @generated from protobuf field: bool Value = 1 [json_name = "Value"];
     */
    value: boolean;
}
/**
 * UserFilter matches user resources.
 *
 * @generated from protobuf message types.UserFilter
 */
export interface UserFilter {
    /**
     * SearchKeywords is a list of search keywords to match against resource field values.
     *
     * @generated from protobuf field: repeated string SearchKeywords = 1 [json_name = "SearchKeywords"];
     */
    searchKeywords: string[];
}
/**
 * UserV2 is version 2 resource spec of the user
 *
 * @generated from protobuf message types.UserV2
 */
export interface UserV2 {
    /**
     * Kind is a resource kind
     *
     * @generated from protobuf field: string Kind = 1 [json_name = "Kind"];
     */
    kind: string;
    /**
     * SubKind is an optional resource sub kind, used in some resources
     *
     * @generated from protobuf field: string SubKind = 2 [json_name = "SubKind"];
     */
    subKind: string;
    /**
     * Version is the resource version. It must be specified.
     * Supported values are: `v2`.
     *
     * @generated from protobuf field: string Version = 3 [json_name = "Version"];
     */
    version: string;
    /**
     * Metadata is resource metadata
     *
     * @generated from protobuf field: types.Metadata Metadata = 4 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Spec is a user specification
     *
     * @generated from protobuf field: types.UserSpecV2 Spec = 5 [json_name = "Spec"];
     */
    spec?: UserSpecV2;
    /**
     * @generated from protobuf field: types.UserStatusV2 Status = 6 [json_name = "Status"];
     */
    status?: UserStatusV2;
}
/**
 * UserStatusV2 is a dynamic state of UserV2.
 *
 * @generated from protobuf message types.UserStatusV2
 */
export interface UserStatusV2 {
    /**
     * password_state reflects what the system knows about the user's password.
     * Note that this is a "best effort" property, in that it can be UNSPECIFIED
     * for users who were created before this property was introduced and didn't
     * perform any password-related activity since then. See RFD 0159 for
     * details. Do NOT use this value for authentication purposes!
     *
     * @generated from protobuf field: types.PasswordState password_state = 1;
     */
    passwordState: PasswordState;
    /**
     * mfa_weakest_device reflects what the system knows about the user's weakest MFA device.
     * Note that this is a "best effort" property, in that it can be UNSPECIFIED.
     *
     * @generated from protobuf field: types.MFADeviceKind mfa_weakest_device = 2;
     */
    mfaWeakestDevice: MFADeviceKind;
}
/**
 * UserSpecV2 is a specification for V2 user
 *
 * @generated from protobuf message types.UserSpecV2
 */
export interface UserSpecV2 {
    /**
     * OIDCIdentities lists associated OpenID Connect identities
     * that let user log in using externally verified identity
     *
     * @generated from protobuf field: repeated types.ExternalIdentity OIDCIdentities = 1 [json_name = "OIDCIdentities"];
     */
    oIDCIdentities: ExternalIdentity[];
    /**
     * SAMLIdentities lists associated SAML identities
     * that let user log in using externally verified identity
     *
     * @generated from protobuf field: repeated types.ExternalIdentity SAMLIdentities = 2 [json_name = "SAMLIdentities"];
     */
    sAMLIdentities: ExternalIdentity[];
    /**
     * GithubIdentities list associated Github OAuth2 identities
     * that let user log in using externally verified identity
     *
     * @generated from protobuf field: repeated types.ExternalIdentity GithubIdentities = 3 [json_name = "GithubIdentities"];
     */
    githubIdentities: ExternalIdentity[];
    /**
     * Roles is a list of roles assigned to user
     *
     * @generated from protobuf field: repeated string Roles = 4 [json_name = "Roles"];
     */
    roles: string[];
    /**
     * Traits are key/value pairs received from an identity provider (through
     * OIDC claims or SAML assertions) or from a system administrator for local
     * accounts. Traits are used to populate role variables.
     *
     * @generated from protobuf field: wrappers.LabelValues Traits = 5 [json_name = "Traits"];
     */
    traits?: LabelValues;
    /**
     * Status is a login status of the user
     *
     * @generated from protobuf field: types.LoginStatus Status = 6 [json_name = "Status"];
     */
    status?: LoginStatus;
    /**
     * Expires if set sets TTL on the user
     *
     * @generated from protobuf field: google.protobuf.Timestamp Expires = 7 [json_name = "Expires"];
     */
    expires?: Timestamp;
    /**
     * CreatedBy holds information about agent or person created this user
     *
     * @generated from protobuf field: types.CreatedBy CreatedBy = 8 [json_name = "CreatedBy"];
     */
    createdBy?: CreatedBy;
    /**
     * LocalAuth holds sensitive data necessary for performing local
     * authentication
     *
     * @generated from protobuf field: types.LocalAuthSecrets LocalAuth = 9 [json_name = "LocalAuth"];
     */
    localAuth?: LocalAuthSecrets;
    /**
     * TrustedDeviceIDs contains the IDs of trusted devices enrolled by the user.
     *
     * Note that SSO users are transient and thus may contain an empty
     * TrustedDeviceIDs field, even though the user->device association exists
     * under the Device Trust subsystem. Do not rely on this field to determine
     * device associations or ownership, it exists for legacy/informative purposes
     * only.
     *
     * Managed by the Device Trust subsystem, avoid manual edits.
     *
     * @generated from protobuf field: repeated string TrustedDeviceIDs = 10 [json_name = "TrustedDeviceIDs"];
     */
    trustedDeviceIDs: string[];
}
/**
 * ExternalIdentity is OpenID Connect/SAML or Github identity that is linked
 * to particular user and connector and lets user to log in using external
 * credentials, e.g. google
 *
 * @generated from protobuf message types.ExternalIdentity
 */
export interface ExternalIdentity {
    /**
     * ConnectorID is id of registered OIDC connector, e.g. 'google-example.com'
     *
     * @generated from protobuf field: string ConnectorID = 1 [json_name = "ConnectorID"];
     */
    connectorID: string;
    /**
     * Username is username supplied by external identity provider
     *
     * @generated from protobuf field: string Username = 2 [json_name = "Username"];
     */
    username: string;
    /**
     * SAMLSingleLogoutURL is the SAML Single log-out URL to initiate SAML SLO (single log-out), if applicable.
     *
     * @generated from protobuf field: string SAMLSingleLogoutURL = 3 [json_name = "SAMLSingleLogoutURL"];
     */
    sAMLSingleLogoutURL: string;
    /**
     * UserID is the ID of the identity. Some connectors like GitHub have an
     * unique ID apart from the username.
     *
     * @generated from protobuf field: string UserID = 4 [json_name = "UserID"];
     */
    userID: string;
}
/**
 * LoginStatus is a login status of the user
 *
 * @generated from protobuf message types.LoginStatus
 */
export interface LoginStatus {
    /**
     * IsLocked tells us if user is locked
     *
     * @generated from protobuf field: bool IsLocked = 1 [json_name = "IsLocked"];
     */
    isLocked: boolean;
    /**
     * LockedMessage contains the message in case if user is locked
     *
     * @generated from protobuf field: string LockedMessage = 2 [json_name = "LockedMessage"];
     */
    lockedMessage: string;
    /**
     * LockedTime contains time when user was locked
     *
     * @generated from protobuf field: google.protobuf.Timestamp LockedTime = 3 [json_name = "LockedTime"];
     */
    lockedTime?: Timestamp;
    /**
     * LockExpires contains time when this lock will expire
     *
     * @generated from protobuf field: google.protobuf.Timestamp LockExpires = 4 [json_name = "LockExpires"];
     */
    lockExpires?: Timestamp;
}
/**
 * CreatedBy holds information about the person or agent who created the user
 *
 * @generated from protobuf message types.CreatedBy
 */
export interface CreatedBy {
    /**
     * Identity if present means that user was automatically created by identity
     *
     * @generated from protobuf field: types.ConnectorRef Connector = 1 [json_name = "Connector"];
     */
    connector?: ConnectorRef;
    /**
     * Time specifies when user was created
     *
     * @generated from protobuf field: google.protobuf.Timestamp Time = 2 [json_name = "Time"];
     */
    time?: Timestamp;
    /**
     * User holds information about user
     *
     * @generated from protobuf field: types.UserRef User = 3 [json_name = "User"];
     */
    user?: UserRef;
}
/**
 * LocalAuthSecrets holds sensitive data used to authenticate a local user.
 *
 * @generated from protobuf message types.LocalAuthSecrets
 */
export interface LocalAuthSecrets {
    /**
     * PasswordHash encodes a combined salt & hash for password verification.
     *
     * @generated from protobuf field: bytes PasswordHash = 1 [json_name = "PasswordHash"];
     */
    passwordHash: Uint8Array;
    /**
     * Deprecated 2nd factor fields, use MFA below instead.
     *
     * @generated from protobuf field: string TOTPKey = 2 [json_name = "TOTPKey"];
     */
    tOTPKey: string;
    /**
     * @generated from protobuf field: repeated types.MFADevice MFA = 5 [json_name = "MFA"];
     */
    mFA: MFADevice[];
    /**
     * Webauthn holds settings necessary for webauthn local auth.
     * May be null for legacy users or users that haven't yet used webauthn as
     * their multi-factor.
     *
     * @generated from protobuf field: types.WebauthnLocalAuth Webauthn = 6 [json_name = "Webauthn"];
     */
    webauthn?: WebauthnLocalAuth;
}
/**
 * MFADevice is a multi-factor authentication device, such as a security key or
 * an OTP app.
 *
 * @generated from protobuf message types.MFADevice
 */
export interface MFADevice {
    /**
     * Boilerplate for implementing the Resource interface.
     *
     * @generated from protobuf field: string kind = 1;
     */
    kind: string;
    /**
     * @generated from protobuf field: string sub_kind = 2;
     */
    subKind: string;
    /**
     * @generated from protobuf field: string version = 3;
     */
    version: string;
    /**
     * @generated from protobuf field: types.Metadata metadata = 4;
     */
    metadata?: Metadata;
    /**
     * ID is a UUID of this device.
     *
     * @generated from protobuf field: string id = 5;
     */
    id: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp added_at = 6;
     */
    addedAt?: Timestamp;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp last_used = 7;
     */
    lastUsed?: Timestamp;
    /**
     * @generated from protobuf oneof: device
     */
    device: {
        oneofKind: "totp";
        /**
         * @generated from protobuf field: types.TOTPDevice totp = 8;
         */
        totp: TOTPDevice;
    } | {
        oneofKind: "u2F";
        /**
         * @generated from protobuf field: types.U2FDevice u2f = 9 [json_name = "u2f"];
         */
        u2F: U2FDevice;
    } | {
        oneofKind: "webauthn";
        /**
         * @generated from protobuf field: types.WebauthnDevice webauthn = 10;
         */
        webauthn: WebauthnDevice;
    } | {
        oneofKind: "sso";
        /**
         * @generated from protobuf field: types.SSOMFADevice sso = 11;
         */
        sso: SSOMFADevice;
    } | {
        oneofKind: undefined;
    };
}
/**
 * TOTPDevice holds the TOTP-specific fields of MFADevice.
 *
 * @generated from protobuf message types.TOTPDevice
 */
export interface TOTPDevice {
    /**
     * @generated from protobuf field: string key = 1;
     */
    key: string;
}
/**
 * U2FDevice holds the U2F-specific fields of MFADevice.
 *
 * @generated from protobuf message types.U2FDevice
 */
export interface U2FDevice {
    /**
     * KeyHandle uniquely identifies a key on a device
     *
     * @generated from protobuf field: bytes key_handle = 1;
     */
    keyHandle: Uint8Array;
    /**
     * PubKey is an DER encoded ecdsa public key
     *
     * @generated from protobuf field: bytes pub_key = 2;
     */
    pubKey: Uint8Array;
    /**
     * Counter is the latest seen value of the U2F usage counter.
     *
     * @generated from protobuf field: uint32 counter = 3;
     */
    counter: number;
}
/**
 * WebauthnDevice holds Webauthn-specific fields of MFADevice.
 *
 * @generated from protobuf message types.WebauthnDevice
 */
export interface WebauthnDevice {
    /**
     * Credential ID for the authenticator.
     *
     * @generated from protobuf field: bytes credential_id = 1;
     */
    credentialId: Uint8Array;
    /**
     * Public key encoded in CBOR format.
     * Webauthn support various key algorithms; CBOR encoding is used to reflect
     * those choices.
     * See https://w3c.github.io/webauthn/#sctn-alg-identifier for a starter
     * reference.
     *
     * @generated from protobuf field: bytes public_key_cbor = 2;
     */
    publicKeyCbor: Uint8Array;
    /**
     * Attestation format used by the authenticator, if any.
     *
     * @generated from protobuf field: string attestation_type = 3;
     */
    attestationType: string;
    /**
     * AAGUID is the globally unique identifier of the authenticator model.
     * Zeroed for U2F devices.
     *
     * @generated from protobuf field: bytes aaguid = 4;
     */
    aaguid: Uint8Array;
    /**
     * Signature counter for login operations.
     * Actual counter values received from the authenticator are expected to be
     * higher than the previously-stored value.
     *
     * @generated from protobuf field: uint32 signature_counter = 5;
     */
    signatureCounter: number;
    /**
     * Raw attestation object, as returned by the authentication during
     * registration.
     * Absent for legacy entries (Teleport 8.x).
     *
     * @generated from protobuf field: bytes attestation_object = 6;
     */
    attestationObject: Uint8Array;
    /**
     * True if a resident key was requested during registration.
     * Marks passwordless-capable devices.
     * (Note that resident_key=true represents the server-side / Relying Party
     * view of the registration process; the authenticator alone can determine
     * if a key is truly resident.)
     *
     * @generated from protobuf field: bool resident_key = 7;
     */
    residentKey: boolean;
    /**
     * Relying Party ID used by the credential.
     * Recorded on registration for new credentials, or on first successful
     * authentication for "old" credentials (created before the field existed).
     * Ideally, this is always the same as the configured RPID.
     * If an RPID change does happen, this helps Teleport detect it and react
     * accordingly.
     *
     * @generated from protobuf field: string credential_rp_id = 8;
     */
    credentialRpId: string;
    /**
     * Authenticator Backup Eligibility (BE) bit, recorded during registration or
     * backfill (for older authenticators).
     * https://w3c.github.io/webauthn/#authdata-flags-be
     *
     * @generated from protobuf field: google.protobuf.BoolValue credential_backup_eligible = 9;
     */
    credentialBackupEligible?: BoolValue$;
    /**
     * Authenticator Backup State (BS) bit, recorded during registration or
     * backfill (for older authenticators).
     * https://w3c.github.io/webauthn/#authdata-flags-bs
     *
     * @generated from protobuf field: google.protobuf.BoolValue credential_backed_up = 10;
     */
    credentialBackedUp?: BoolValue$;
}
/**
 * SSOMFADevice contains details of an SSO MFA method.
 *
 * @generated from protobuf message types.SSOMFADevice
 */
export interface SSOMFADevice {
    /**
     * connector_id is the ID of the SSO connector.
     *
     * @generated from protobuf field: string connector_id = 1;
     */
    connectorId: string;
    /**
     * connector_type is the type of the SSO connector.
     *
     * @generated from protobuf field: string connector_type = 2;
     */
    connectorType: string;
    /**
     * display_name is the display name of the SSO connector
     *
     * @generated from protobuf field: string display_name = 3;
     */
    displayName: string;
}
/**
 * WebauthnLocalAuth holds settings necessary for local webauthn use.
 *
 * @generated from protobuf message types.WebauthnLocalAuth
 */
export interface WebauthnLocalAuth {
    /**
     * UserID is the random user handle generated for the user.
     * See https://www.w3.org/TR/webauthn-2/#sctn-user-handle-privacy.
     *
     * @generated from protobuf field: bytes UserID = 1 [json_name = "UserID"];
     */
    userID: Uint8Array;
}
/**
 * ConnectorRef holds information about OIDC connector
 *
 * @generated from protobuf message types.ConnectorRef
 */
export interface ConnectorRef {
    /**
     * Type is connector type
     *
     * @generated from protobuf field: string Type = 1 [json_name = "Type"];
     */
    type: string;
    /**
     * ID is connector ID
     *
     * @generated from protobuf field: string ID = 2 [json_name = "ID"];
     */
    iD: string;
    /**
     * Identity is external identity of the user
     *
     * @generated from protobuf field: string Identity = 3 [json_name = "Identity"];
     */
    identity: string;
}
/**
 * UserRef holds references to user
 *
 * @generated from protobuf message types.UserRef
 */
export interface UserRef {
    /**
     * Name is name of the user
     *
     * @generated from protobuf field: string Name = 1 [json_name = "Name"];
     */
    name: string;
}
/**
 * ReverseTunnelV2 is version 2 of the resource spec of the reverse tunnel
 *
 * @generated from protobuf message types.ReverseTunnelV2
 */
export interface ReverseTunnelV2 {
    /**
     * Kind is a resource kind
     *
     * @generated from protobuf field: string Kind = 1 [json_name = "Kind"];
     */
    kind: string;
    /**
     * SubKind is an optional resource sub kind, used in some resources
     *
     * @generated from protobuf field: string SubKind = 2 [json_name = "SubKind"];
     */
    subKind: string;
    /**
     * Version is version
     *
     * @generated from protobuf field: string Version = 3 [json_name = "Version"];
     */
    version: string;
    /**
     * Metadata is a resource metadata
     *
     * @generated from protobuf field: types.Metadata Metadata = 4 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Spec is a reverse tunnel specification
     *
     * @generated from protobuf field: types.ReverseTunnelSpecV2 Spec = 5 [json_name = "Spec"];
     */
    spec?: ReverseTunnelSpecV2;
}
/**
 * ReverseTunnelSpecV2 is a specification for V2 reverse tunnel
 *
 * @generated from protobuf message types.ReverseTunnelSpecV2
 */
export interface ReverseTunnelSpecV2 {
    /**
     * ClusterName is a domain name of remote cluster we are connecting to
     *
     * @generated from protobuf field: string ClusterName = 1 [json_name = "ClusterName"];
     */
    clusterName: string;
    /**
     * DialAddrs is a list of remote address to establish a connection to
     * it's always SSH over TCP
     *
     * @generated from protobuf field: repeated string DialAddrs = 2 [json_name = "DialAddrs"];
     */
    dialAddrs: string[];
    /**
     * Type is the type of reverse tunnel, either proxy or node.
     *
     * @generated from protobuf field: string Type = 3 [json_name = "Type"];
     */
    type: string;
}
/**
 * TunnelConnectionV2 is version 2 of the resource spec of the tunnel connection
 *
 * @generated from protobuf message types.TunnelConnectionV2
 */
export interface TunnelConnectionV2 {
    /**
     * Kind is a resource kind
     *
     * @generated from protobuf field: string Kind = 1 [json_name = "Kind"];
     */
    kind: string;
    /**
     * SubKind is an optional resource sub kind, used in some resources
     *
     * @generated from protobuf field: string SubKind = 2 [json_name = "SubKind"];
     */
    subKind: string;
    /**
     * Version is version
     *
     * @generated from protobuf field: string Version = 3 [json_name = "Version"];
     */
    version: string;
    /**
     * Metadata is a resource metadata
     *
     * @generated from protobuf field: types.Metadata Metadata = 4 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Spec is a tunnel specification
     *
     * @generated from protobuf field: types.TunnelConnectionSpecV2 Spec = 5 [json_name = "Spec"];
     */
    spec?: TunnelConnectionSpecV2;
}
/**
 * TunnelConnectionSpecV2 is a specification for V2 tunnel connection
 *
 * @generated from protobuf message types.TunnelConnectionSpecV2
 */
export interface TunnelConnectionSpecV2 {
    /**
     * ClusterName is a name of the cluster
     *
     * @generated from protobuf field: string ClusterName = 1 [json_name = "ClusterName"];
     */
    clusterName: string;
    /**
     * ProxyName is the name of the proxy server
     *
     * @generated from protobuf field: string ProxyName = 2 [json_name = "ProxyName"];
     */
    proxyName: string;
    /**
     * LastHeartbeat is a time of the last heartbeat
     *
     * @generated from protobuf field: google.protobuf.Timestamp LastHeartbeat = 3 [json_name = "LastHeartbeat"];
     */
    lastHeartbeat?: Timestamp;
    /**
     * Type is the type of reverse tunnel, either proxy or node.
     *
     * @generated from protobuf field: string Type = 4 [json_name = "Type"];
     */
    type: string;
}
/**
 * SemaphoreFilter encodes semaphore filtering params.
 * A semaphore filter matches a semaphore if all nonzero fields
 * match the corresponding semaphore fields (e.g. a filter which
 * specifies only `kind=foo` would match all semaphores of
 * kind `foo`).
 *
 * @generated from protobuf message types.SemaphoreFilter
 */
export interface SemaphoreFilter {
    /**
     * SemaphoreKind is the kind of the semaphore.
     *
     * @generated from protobuf field: string SemaphoreKind = 1 [json_name = "SemaphoreKind"];
     */
    semaphoreKind: string;
    /**
     * SemaphoreName is the name of the semaphore.
     *
     * @generated from protobuf field: string SemaphoreName = 2 [json_name = "SemaphoreName"];
     */
    semaphoreName: string;
}
/**
 * AcquireSemaphoreRequest holds semaphore lease acquisition parameters.
 *
 * @generated from protobuf message types.AcquireSemaphoreRequest
 */
export interface AcquireSemaphoreRequest {
    /**
     * SemaphoreKind is the kind of the semaphore.
     *
     * @generated from protobuf field: string SemaphoreKind = 1 [json_name = "SemaphoreKind"];
     */
    semaphoreKind: string;
    /**
     * SemaphoreName is the name of the semaphore.
     *
     * @generated from protobuf field: string SemaphoreName = 2 [json_name = "SemaphoreName"];
     */
    semaphoreName: string;
    /**
     * MaxLeases is the maximum number of concurrent leases.  If acquisition
     * would cause more than MaxLeases to exist, acquisition must fail.
     *
     * @generated from protobuf field: int64 MaxLeases = 3 [json_name = "MaxLeases"];
     */
    maxLeases: bigint;
    /**
     * Expires is the time at which this lease expires.
     *
     * @generated from protobuf field: google.protobuf.Timestamp Expires = 4 [json_name = "Expires"];
     */
    expires?: Timestamp;
    /**
     * Holder identifies the entity holding the lease.
     *
     * @generated from protobuf field: string Holder = 5 [json_name = "Holder"];
     */
    holder: string;
}
/**
 * SemaphoreLease represents lease acquired for semaphore
 *
 * @generated from protobuf message types.SemaphoreLease
 */
export interface SemaphoreLease {
    /**
     * SemaphoreKind is the kind of the semaphore.
     *
     * @generated from protobuf field: string SemaphoreKind = 1 [json_name = "SemaphoreKind"];
     */
    semaphoreKind: string;
    /**
     * SemaphoreName is the name of the semaphore.
     *
     * @generated from protobuf field: string SemaphoreName = 2 [json_name = "SemaphoreName"];
     */
    semaphoreName: string;
    /**
     * LeaseID uniquely identifies this lease.
     *
     * @generated from protobuf field: string LeaseID = 3 [json_name = "LeaseID"];
     */
    leaseID: string;
    /**
     * Expires is the time at which this lease expires.
     *
     * @generated from protobuf field: google.protobuf.Timestamp Expires = 5 [json_name = "Expires"];
     */
    expires?: Timestamp;
}
/**
 * SemaphoreLeaseRef identifies an existent lease.
 *
 * @generated from protobuf message types.SemaphoreLeaseRef
 */
export interface SemaphoreLeaseRef {
    /**
     * LeaseID is the unique ID of the lease.
     *
     * @generated from protobuf field: string LeaseID = 1 [json_name = "LeaseID"];
     */
    leaseID: string;
    /**
     * Expires is the time at which the lease expires.
     *
     * @generated from protobuf field: google.protobuf.Timestamp Expires = 2 [json_name = "Expires"];
     */
    expires?: Timestamp;
    /**
     * Holder identifies the lease holder.
     *
     * @generated from protobuf field: string Holder = 3 [json_name = "Holder"];
     */
    holder: string;
}
/**
 * SemaphoreV3 implements Semaphore interface
 *
 * @generated from protobuf message types.SemaphoreV3
 */
export interface SemaphoreV3 {
    /**
     * Kind is a resource kind
     *
     * @generated from protobuf field: string Kind = 1 [json_name = "Kind"];
     */
    kind: string;
    /**
     * SubKind is an optional resource sub kind, used in some resources
     *
     * @generated from protobuf field: string SubKind = 2 [json_name = "SubKind"];
     */
    subKind: string;
    /**
     * Version is version
     *
     * @generated from protobuf field: string Version = 3 [json_name = "Version"];
     */
    version: string;
    /**
     * Metadata is Semaphore metadata
     *
     * @generated from protobuf field: types.Metadata Metadata = 4 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Spec is a lease V3 spec
     *
     * @generated from protobuf field: types.SemaphoreSpecV3 Spec = 5 [json_name = "Spec"];
     */
    spec?: SemaphoreSpecV3;
}
/**
 * SemaphoreSpecV3 contains the data about lease
 *
 * @generated from protobuf message types.SemaphoreSpecV3
 */
export interface SemaphoreSpecV3 {
    /**
     * Leases is a list of all currently acquired leases.
     *
     * @generated from protobuf field: repeated types.SemaphoreLeaseRef Leases = 1 [json_name = "Leases"];
     */
    leases: SemaphoreLeaseRef[];
}
/**
 * WebSessionV2 represents an application or UI web session.
 *
 * @generated from protobuf message types.WebSessionV2
 */
export interface WebSessionV2 {
    /**
     * Kind is a resource kind.
     *
     * @generated from protobuf field: string Kind = 1 [json_name = "Kind"];
     */
    kind: string;
    /**
     * SubKind is an optional resource sub kind, used in some resources.
     *
     * @generated from protobuf field: string SubKind = 2 [json_name = "SubKind"];
     */
    subKind: string;
    /**
     * Version is version.
     *
     * @generated from protobuf field: string Version = 3 [json_name = "Version"];
     */
    version: string;
    /**
     * Metadata is a resource metadata.
     *
     * @generated from protobuf field: types.Metadata Metadata = 4 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Spec is a tunnel specification.
     *
     * @generated from protobuf field: types.WebSessionSpecV2 Spec = 5 [json_name = "Spec"];
     */
    spec?: WebSessionSpecV2;
}
/**
 * WebSessionSpecV2 is a specification for web session.
 *
 * @generated from protobuf message types.WebSessionSpecV2
 */
export interface WebSessionSpecV2 {
    /**
     * User is the identity of the user to which the web session belongs.
     *
     * @generated from protobuf field: string User = 1 [json_name = "User"];
     */
    user: string;
    /**
     * Pub is the SSH certificate for the user, marshaled in the authorized key
     * format.
     *
     * @generated from protobuf field: bytes Pub = 2 [json_name = "Pub"];
     */
    pub: Uint8Array;
    /**
     * Priv is the SSH private key for the user, in PEM-encoded PKCS#1 or PKCS#8
     * format. If TLSPriv is unset, this is also the TLS private key.
     *
     * @generated from protobuf field: bytes Priv = 3 [json_name = "Priv"];
     */
    priv: Uint8Array;
    /**
     * TLSCert is the X.509 certificate for the user (PEM-encoded).
     *
     * @generated from protobuf field: bytes TLSCert = 4 [json_name = "TLSCert"];
     */
    tLSCert: Uint8Array;
    /**
     * BearerToken is a token that is paired with the session cookie for
     * authentication. It is periodically rotated so a stolen cookie itself
     * is not enough to steal a session. In addition it is used for CSRF
     * mitigation.
     *
     * @generated from protobuf field: string BearerToken = 5 [json_name = "BearerToken"];
     */
    bearerToken: string;
    /**
     * BearerTokenExpires is the absolute time when the token expires.
     *
     * @generated from protobuf field: google.protobuf.Timestamp BearerTokenExpires = 6 [json_name = "BearerTokenExpires"];
     */
    bearerTokenExpires?: Timestamp;
    /**
     * Expires is the absolute time when the session expires.
     *
     * @generated from protobuf field: google.protobuf.Timestamp Expires = 7 [json_name = "Expires"];
     */
    expires?: Timestamp;
    /**
     * LoginTime is the time this user recently logged in.
     *
     * @generated from protobuf field: google.protobuf.Timestamp LoginTime = 8 [json_name = "LoginTime"];
     */
    loginTime?: Timestamp;
    /**
     * IdleTimeout is the max time a user can be inactive in a session.
     *
     * @generated from protobuf field: int64 IdleTimeout = 9 [json_name = "IdleTimeout"];
     */
    idleTimeout: bigint;
    /**
     * ConsumedAccessRequestID is the ID of the access request from which additional roles to assume
     * were obtained.
     *
     * @generated from protobuf field: string ConsumedAccessRequestID = 10 [json_name = "ConsumedAccessRequestID"];
     */
    consumedAccessRequestID: string;
    /**
     * SAMLSession is data associated with a SAML IdP session.
     *
     * @generated from protobuf field: types.SAMLSessionData SAMLSession = 11 [json_name = "SAMLSession"];
     */
    sAMLSession?: SAMLSessionData;
    /**
     * Device trust web authentication token.
     * May be exchanged for a single on-behalf-of device authentication attempt
     * (typically performed by Connect).
     * Only present if on-behalf-of device authentication is possible.
     *
     * @generated from protobuf field: types.DeviceWebToken DeviceWebToken = 12 [json_name = "DeviceWebToken"];
     */
    deviceWebToken?: DeviceWebToken;
    /**
     * HasDeviceExtensions is true if the session's TLS and SSH certificates are
     * augmented with device extensions.
     *
     * @generated from protobuf field: bool HasDeviceExtensions = 13 [json_name = "HasDeviceExtensions"];
     */
    hasDeviceExtensions: boolean;
    /**
     * TrustedDeviceRequirement indicates whether access may be hindered by the
     * lack of a trusted device.
     *
     * If during login a device is required and DeviceWebToken is nil, then it's
     * likely the user needs to enroll their device to avoid impacting access.
     *
     * @generated from protobuf field: types.TrustedDeviceRequirement TrustedDeviceRequirement = 14 [json_name = "TrustedDeviceRequirement"];
     */
    trustedDeviceRequirement: TrustedDeviceRequirement;
    /**
     * TLSPriv is the TLS private key for the user, in PEM-encoded PKCS#1 or PKCS#8
     * format. If unset, then Priv is used as both the SSH and TLS private key.
     *
     * @generated from protobuf field: bytes TLSPriv = 15 [json_name = "TLSPriv"];
     */
    tLSPriv: Uint8Array;
}
/**
 * Web-focused view of teleport.devicetrust.v1.DeviceWebToken.
 *
 * @generated from protobuf message types.DeviceWebToken
 */
export interface DeviceWebToken {
    /**
     * Opaque token identifier.
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * Opaque device web token, in plaintext, encoded in base64.RawURLEncoding
     * (so it is inherently safe for URl use).
     *
     * @generated from protobuf field: string token = 2;
     */
    token: string;
}
/**
 * WebSessionFilter encodes cache watch parameters for filtering web sessions.
 *
 * @generated from protobuf message types.WebSessionFilter
 */
export interface WebSessionFilter {
    /**
     * User is the username to filter web sessions for.
     *
     * @generated from protobuf field: string User = 1 [json_name = "User"];
     */
    user: string;
}
/**
 * SAMLSessionData contains data for a SAML session.
 * Based on crewjam/saml's session object: https://github.com/crewjam/saml/blob/main/identity_provider.go
 *
 * @generated from protobuf message types.SAMLSessionData
 */
export interface SAMLSessionData {
    /**
     * ID is the identifier for the SAML session.
     *
     * @generated from protobuf field: string ID = 1 [json_name = "ID"];
     */
    iD: string;
    /**
     * CreateTime is the time that the session was created.
     *
     * @generated from protobuf field: google.protobuf.Timestamp CreateTime = 2 [json_name = "CreateTime"];
     */
    createTime?: Timestamp;
    /**
     * ExpireTime is the time that the session will expire.
     *
     * @generated from protobuf field: google.protobuf.Timestamp ExpireTime = 3 [json_name = "ExpireTime"];
     */
    expireTime?: Timestamp;
    /**
     * Index is the session index that allows the IdP to uniquely identify a session.
     *
     * @generated from protobuf field: string Index = 4 [json_name = "Index"];
     */
    index: string;
    /**
     * NameID an identifier for the session.
     *
     * @generated from protobuf field: string NameID = 5 [json_name = "NameID"];
     */
    nameID: string;
    /**
     * NameIDFormat is the format of the Name ID.
     *
     * @generated from protobuf field: string NameIDFormat = 6 [json_name = "NameIDFormat"];
     */
    nameIDFormat: string;
    /**
     * SubjectID is the identifier for the subject of the session.
     *
     * @generated from protobuf field: string SubjectID = 7 [json_name = "SubjectID"];
     */
    subjectID: string;
    /**
     * Groups is a list of groups that the user has access to.
     *
     * @generated from protobuf field: repeated string Groups = 8 [json_name = "Groups"];
     */
    groups: string[];
    /**
     * UserName is the user's name.
     *
     * @generated from protobuf field: string UserName = 9 [json_name = "UserName"];
     */
    userName: string;
    /**
     * UserEmail is the user's e-mail.
     *
     * @generated from protobuf field: string UserEmail = 10 [json_name = "UserEmail"];
     */
    userEmail: string;
    /**
     * UserCommonName is the user's common name.
     *
     * @generated from protobuf field: string UserCommonName = 11 [json_name = "UserCommonName"];
     */
    userCommonName: string;
    /**
     * UserSurname is the user's surname.
     *
     * @generated from protobuf field: string UserSurname = 12 [json_name = "UserSurname"];
     */
    userSurname: string;
    /**
     * UserGivenName is the user's given name.
     *
     * @generated from protobuf field: string UserGivenName = 13 [json_name = "UserGivenName"];
     */
    userGivenName: string;
    /**
     * UserScopedAffiliation is the user's scoped affiliation.
     *
     * @generated from protobuf field: string UserScopedAffiliation = 14 [json_name = "UserScopedAffiliation"];
     */
    userScopedAffiliation: string;
    /**
     * CustomAttributes are any custom attributes associated with the request.
     *
     * @generated from protobuf field: repeated types.SAMLAttribute CustomAttributes = 15 [json_name = "CustomAttributes"];
     */
    customAttributes: SAMLAttribute[];
}
/**
 * SAMLAttribute contains an attribute name and associated values.
 * Defined in http://docs.oasis-open.org/security/saml/v2.0/saml-core-2.0-os.pdf.
 *
 * @generated from protobuf message types.SAMLAttribute
 */
export interface SAMLAttribute {
    /**
     * FriendlyName is a user readable name for the attribute.
     *
     * @generated from protobuf field: string FriendlyName = 1 [json_name = "FriendlyName"];
     */
    friendlyName: string;
    /**
     * Name is a full name for the attribute, typically an OID value.
     *
     * @generated from protobuf field: string Name = 2 [json_name = "Name"];
     */
    name: string;
    /**
     * NameFormat is the format of the name.
     *
     * @generated from protobuf field: string NameFormat = 3 [json_name = "NameFormat"];
     */
    nameFormat: string;
    /**
     * Values is a list of attribute values.
     *
     * @generated from protobuf field: repeated types.SAMLAttributeValue Values = 4 [json_name = "Values"];
     */
    values: SAMLAttributeValue[];
}
/**
 * SAMLAttributeValues contains a type, value, and an associated name ID block.
 * Defined in http://docs.oasis-open.org/security/saml/v2.0/saml-core-2.0-os.pdf.
 *
 * @generated from protobuf message types.SAMLAttributeValue
 */
export interface SAMLAttributeValue {
    /**
     * Type is the type of value this attribute represents.
     *
     * @generated from protobuf field: string Type = 1 [json_name = "Type"];
     */
    type: string;
    /**
     * Value is the value of the attribute.
     *
     * @generated from protobuf field: string Value = 2 [json_name = "Value"];
     */
    value: string;
    /**
     * NameID is a more restrictive identifier for the attribute value.
     *
     * @generated from protobuf field: types.SAMLNameID NameID = 3 [json_name = "NameID"];
     */
    nameID?: SAMLNameID;
}
/**
 * SAMLNameID is a more restrictive identifier for an object in SAML.
 * Defined in http://docs.oasis-open.org/security/saml/v2.0/saml-core-2.0-os.pdf.
 *
 * @generated from protobuf message types.SAMLNameID
 */
export interface SAMLNameID {
    /**
     * NameQualifier is the domain that qualifies the identifier.
     *
     * @generated from protobuf field: string NameQualifier = 1 [json_name = "NameQualifier"];
     */
    nameQualifier: string;
    /**
     * SPNameQualifier qualifies the identifier with the name of the service provider.
     *
     * @generated from protobuf field: string SPNameQualifier = 2 [json_name = "SPNameQualifier"];
     */
    sPNameQualifier: string;
    /**
     * Format is the format of the identifier.
     *
     * @generated from protobuf field: string Format = 3 [json_name = "Format"];
     */
    format: string;
    /**
     * SPProvidedID is an identifier established by the service provider.
     *
     * @generated from protobuf field: string SPProvidedID = 4 [json_name = "SPProvidedID"];
     */
    sPProvidedID: string;
    /**
     * Value is the value of the name ID.
     *
     * @generated from protobuf field: string Value = 5 [json_name = "Value"];
     */
    value: string;
}
/**
 * RemoteClusterV3 represents remote cluster resource specification
 *
 * @generated from protobuf message types.RemoteClusterV3
 */
export interface RemoteClusterV3 {
    /**
     * Kind is a resource kind
     *
     * @generated from protobuf field: string Kind = 1 [json_name = "Kind"];
     */
    kind: string;
    /**
     * SubKind is an optional resource sub kind, used in some resources
     *
     * @generated from protobuf field: string SubKind = 2 [json_name = "SubKind"];
     */
    subKind: string;
    /**
     * Version is resource API version
     *
     * @generated from protobuf field: string Version = 3 [json_name = "Version"];
     */
    version: string;
    /**
     * Metadata is resource metadata
     *
     * @generated from protobuf field: types.Metadata Metadata = 4 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Status is a remote cluster status
     *
     * @generated from protobuf field: types.RemoteClusterStatusV3 Status = 5 [json_name = "Status"];
     */
    status?: RemoteClusterStatusV3;
}
/**
 * RemoteClusterStatusV3 represents status of the remote cluster
 *
 * @generated from protobuf message types.RemoteClusterStatusV3
 */
export interface RemoteClusterStatusV3 {
    /**
     * Connection represents connection status, online or offline
     *
     * @generated from protobuf field: string Connection = 1 [json_name = "Connection"];
     */
    connection: string;
    /**
     * LastHeartbeat records last heartbeat of the cluster
     *
     * @generated from protobuf field: google.protobuf.Timestamp LastHeartbeat = 2 [json_name = "LastHeartbeat"];
     */
    lastHeartbeat?: Timestamp;
}
/**
 * KubernetesCluster is a named kubernetes API endpoint handled by a Server.
 *
 * TODO: deprecate and convert all usage to KubernetesClusterV3
 *
 * @generated from protobuf message types.KubernetesCluster
 */
export interface KubernetesCluster {
    /**
     * Name is the name of this kubernetes cluster.
     *
     * @generated from protobuf field: string Name = 1 [json_name = "Name"];
     */
    name: string;
    /**
     * StaticLabels is map of static labels associated with this cluster.
     * Used for RBAC.
     *
     * @generated from protobuf field: map<string, string> StaticLabels = 2 [json_name = "StaticLabels"];
     */
    staticLabels: {
        [key: string]: string;
    };
    /**
     * DynamicLabels is map of dynamic labels associated with this cluster.
     * Used for RBAC.
     *
     * @generated from protobuf field: map<string, types.CommandLabelV2> DynamicLabels = 3 [json_name = "DynamicLabels"];
     */
    dynamicLabels: {
        [key: string]: CommandLabelV2;
    };
}
/**
 * KubernetesClusterV3 represents a named kubernetes API endpoint.
 *
 * @generated from protobuf message types.KubernetesClusterV3
 */
export interface KubernetesClusterV3 {
    /**
     * Kind is the cluster resource kind.
     *
     * @generated from protobuf field: string Kind = 1 [json_name = "Kind"];
     */
    kind: string;
    /**
     * SubKind is an optional resource subkind.
     *
     * @generated from protobuf field: string SubKind = 2 [json_name = "SubKind"];
     */
    subKind: string;
    /**
     * Version is the resource version.
     *
     * @generated from protobuf field: string Version = 3 [json_name = "Version"];
     */
    version: string;
    /**
     * Metadata is the resource metadata.
     *
     * @generated from protobuf field: types.Metadata Metadata = 4 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Spec is the resource spec.
     *
     * @generated from protobuf field: types.KubernetesClusterSpecV3 Spec = 5 [json_name = "Spec"];
     */
    spec?: KubernetesClusterSpecV3;
}
/**
 * KubernetesClusterSpecV3 is a specification for a Kubernetes cluster.
 *
 * @generated from protobuf message types.KubernetesClusterSpecV3
 */
export interface KubernetesClusterSpecV3 {
    /**
     * DynamicLabels are the cluster's dynamic labels.
     *
     * @generated from protobuf field: map<string, types.CommandLabelV2> DynamicLabels = 1 [json_name = "DynamicLabels"];
     */
    dynamicLabels: {
        [key: string]: CommandLabelV2;
    };
    /**
     * Kubeconfig is the kubeconfig file payload that grants access to the cluster.
     * If multiple contexts are specified, the first will be selected.
     *
     * @generated from protobuf field: bytes Kubeconfig = 2 [json_name = "Kubeconfig"];
     */
    kubeconfig: Uint8Array;
    /**
     * Azure holds the required Azure information for Teleport to access the cluster.
     *
     * @generated from protobuf field: types.KubeAzure Azure = 3 [json_name = "Azure"];
     */
    azure?: KubeAzure;
    /**
     * AWS holds the required AWS information for Teleport to access the cluster.
     *
     * @generated from protobuf field: types.KubeAWS AWS = 4 [json_name = "AWS"];
     */
    aWS?: KubeAWS;
    /**
     * GCP holds the required GCP information for Teleport to access the cluster.
     *
     * @generated from protobuf field: types.KubeGCP GCP = 5 [json_name = "GCP"];
     */
    gCP?: KubeGCP;
}
/**
 * KubeAzure contains the Azure information about the cluster.
 *
 * @generated from protobuf message types.KubeAzure
 */
export interface KubeAzure {
    /**
     * ResourceName is the AKS cluster name.
     *
     * @generated from protobuf field: string ResourceName = 1 [json_name = "ResourceName"];
     */
    resourceName: string;
    /**
     * ResourceGroup is the Azure resource group name.
     *
     * @generated from protobuf field: string ResourceGroup = 2 [json_name = "ResourceGroup"];
     */
    resourceGroup: string;
    /**
     * TenantID is the AKS cluster Tenant ID.
     *
     * @generated from protobuf field: string TenantID = 3 [json_name = "TenantID"];
     */
    tenantID: string;
    /**
     * SubscriptionID is the AKS cluster SubscriptionID.
     *
     * @generated from protobuf field: string SubscriptionID = 4 [json_name = "SubscriptionID"];
     */
    subscriptionID: string;
}
/**
 * KubeAWS contains the AWS information about the cluster.
 *
 * @generated from protobuf message types.KubeAWS
 */
export interface KubeAWS {
    /**
     * Region is a AWS cloud region.
     *
     * @generated from protobuf field: string Region = 1 [json_name = "Region"];
     */
    region: string;
    /**
     * AccountID is a AWS Account ID.
     *
     * @generated from protobuf field: string AccountID = 2 [json_name = "AccountID"];
     */
    accountID: string;
    /**
     * Name is a AWS EKS cluster name.
     *
     * @generated from protobuf field: string Name = 3 [json_name = "Name"];
     */
    name: string;
}
/**
 * KubeGCP contains the GCP information about the cluster.
 *
 * @generated from protobuf message types.KubeGCP
 */
export interface KubeGCP {
    /**
     * Location is a GKE cluster location.
     *
     * @generated from protobuf field: string Location = 1 [json_name = "Location"];
     */
    location: string;
    /**
     * ProjectID is the GKE Project ID.
     *
     * @generated from protobuf field: string ProjectID = 2 [json_name = "ProjectID"];
     */
    projectID: string;
    /**
     * Name is a GCP GKE cluster name.
     *
     * @generated from protobuf field: string Name = 3 [json_name = "Name"];
     */
    name: string;
}
/**
 * KubernetesClusterV3List represents a list of kubernetes clusters.
 *
 * @generated from protobuf message types.KubernetesClusterV3List
 */
export interface KubernetesClusterV3List {
    /**
     * KubernetesClusters is a list of kubernetes clusters resources.
     *
     * @generated from protobuf field: repeated types.KubernetesClusterV3 KubernetesClusters = 1 [json_name = "KubernetesClusters"];
     */
    kubernetesClusters: KubernetesClusterV3[];
}
/**
 * KubernetesServerV3 represents a Kubernetes server.
 *
 * @generated from protobuf message types.KubernetesServerV3
 */
export interface KubernetesServerV3 {
    /**
     * Kind is the Kubernetes server resource kind. Always "kube_server".
     *
     * @generated from protobuf field: string Kind = 1 [json_name = "Kind"];
     */
    kind: string;
    /**
     * SubKind is an optional resource subkind.
     *
     * @generated from protobuf field: string SubKind = 2 [json_name = "SubKind"];
     */
    subKind: string;
    /**
     * Version is the resource version.
     *
     * @generated from protobuf field: string Version = 3 [json_name = "Version"];
     */
    version: string;
    /**
     * Metadata is the Kubernetes server metadata.
     *
     * @generated from protobuf field: types.Metadata Metadata = 4 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Spec is the Kubernetes server spec.
     *
     * @generated from protobuf field: types.KubernetesServerSpecV3 Spec = 5 [json_name = "Spec"];
     */
    spec?: KubernetesServerSpecV3;
}
/**
 * KubernetesServerSpecV3 is the Kubernetes server spec.
 *
 * @generated from protobuf message types.KubernetesServerSpecV3
 */
export interface KubernetesServerSpecV3 {
    /**
     * Version is the Teleport version that the server is running.
     *
     * @generated from protobuf field: string Version = 1 [json_name = "Version"];
     */
    version: string;
    /**
     * Hostname is the Kubernetes server hostname.
     *
     * @generated from protobuf field: string Hostname = 2 [json_name = "Hostname"];
     */
    hostname: string;
    /**
     * HostID is the Kubernetes server host uuid.
     *
     * @generated from protobuf field: string HostID = 3 [json_name = "HostID"];
     */
    hostID: string;
    /**
     * Rotation contains the Kubernetes server CA rotation information.
     *
     * @generated from protobuf field: types.Rotation Rotation = 4 [json_name = "Rotation"];
     */
    rotation?: Rotation;
    /**
     * Cluster is a Kubernetes Cluster proxied by this Kubernetes server.
     *
     * @generated from protobuf field: types.KubernetesClusterV3 Cluster = 5 [json_name = "Cluster"];
     */
    cluster?: KubernetesClusterV3;
    /**
     * ProxyIDs is a list of proxy IDs this server is expected to be connected to.
     *
     * @generated from protobuf field: repeated string ProxyIDs = 6 [json_name = "ProxyIDs"];
     */
    proxyIDs: string[];
}
/**
 * WebTokenV3 describes a web token. Web tokens are used as a transport to relay bearer tokens
 * to the client.
 * Initially bound to a web session, these have been factored out into a separate resource to
 * enable separate lifecycle management.
 *
 * @generated from protobuf message types.WebTokenV3
 */
export interface WebTokenV3 {
    /**
     * Kind is a resource kind
     *
     * @generated from protobuf field: string Kind = 1 [json_name = "Kind"];
     */
    kind: string;
    /**
     * SubKind is an optional resource sub kind
     *
     * @generated from protobuf field: string SubKind = 2 [json_name = "SubKind"];
     */
    subKind: string;
    /**
     * Version is the resource version
     *
     * @generated from protobuf field: string Version = 3 [json_name = "Version"];
     */
    version: string;
    /**
     * Metadata is resource metadata
     *
     * @generated from protobuf field: types.Metadata Metadata = 4 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Spec defines the web token
     *
     * @generated from protobuf field: types.WebTokenSpecV3 Spec = 5 [json_name = "Spec"];
     */
    spec?: WebTokenSpecV3;
}
/**
 * WebTokenSpecV3 is a unique time-limited token bound to a user's web session
 *
 * @generated from protobuf message types.WebTokenSpecV3
 */
export interface WebTokenSpecV3 {
    /**
     * User specifies the user the token is bound to.
     *
     * @generated from protobuf field: string User = 1 [json_name = "User"];
     */
    user: string;
    /**
     * Token specifies the token's value.
     *
     * @generated from protobuf field: string Token = 2 [json_name = "Token"];
     */
    token: string;
}
/**
 * GetWebSessionRequest describes a request to query a web session
 *
 * @generated from protobuf message types.GetWebSessionRequest
 */
export interface GetWebSessionRequest {
    /**
     * User specifies the user the web session is for.
     *
     * @generated from protobuf field: string User = 1 [json_name = "User"];
     */
    user: string;
    /**
     * SessionID specifies the web session ID.
     *
     * @generated from protobuf field: string SessionID = 2 [json_name = "SessionID"];
     */
    sessionID: string;
}
/**
 * DeleteWebSessionRequest describes a request to delete a web session
 *
 * @generated from protobuf message types.DeleteWebSessionRequest
 */
export interface DeleteWebSessionRequest {
    /**
     * User specifies the user the session is bound to
     *
     * @generated from protobuf field: string User = 1 [json_name = "User"];
     */
    user: string;
    /**
     * SessionID specifies the web session ID to delete.
     *
     * @generated from protobuf field: string SessionID = 2 [json_name = "SessionID"];
     */
    sessionID: string;
}
/**
 * GetWebTokenRequest describes a request to query a web token
 *
 * @generated from protobuf message types.GetWebTokenRequest
 */
export interface GetWebTokenRequest {
    /**
     * User specifies the user the token is for.
     *
     * @generated from protobuf field: string User = 1 [json_name = "User"];
     */
    user: string;
    /**
     * Token specifies the token to get.
     *
     * @generated from protobuf field: string Token = 2 [json_name = "Token"];
     */
    token: string;
}
/**
 * DeleteWebTokenRequest describes a request to delete a web token
 *
 * @generated from protobuf message types.DeleteWebTokenRequest
 */
export interface DeleteWebTokenRequest {
    /**
     * User specifies the user the token is for.
     *
     * @generated from protobuf field: string User = 1 [json_name = "User"];
     */
    user: string;
    /**
     * Token specifies the token to delete.
     *
     * @generated from protobuf field: string Token = 2 [json_name = "Token"];
     */
    token: string;
}
/**
 * ResourceRequest is a request relating to a named resource.
 *
 * @generated from protobuf message types.ResourceRequest
 */
export interface ResourceRequest {
    /**
     * Name is the name of the resource.
     *
     * @generated from protobuf field: string Name = 1 [json_name = "Name"];
     */
    name: string;
}
/**
 * ResourceWithSecretsRequest is a request relating to a named resource with secrets.
 *
 * @generated from protobuf message types.ResourceWithSecretsRequest
 */
export interface ResourceWithSecretsRequest {
    /**
     * Name is the name of the resource.
     *
     * @generated from protobuf field: string Name = 1 [json_name = "Name"];
     */
    name: string;
    /**
     * WithSecrets specifies whether to load associated secrets.
     *
     * @generated from protobuf field: bool WithSecrets = 2 [json_name = "WithSecrets"];
     */
    withSecrets: boolean;
    /**
     * SAMLValidationNoFollowURLs specifies whether to skip following URLs when
     * validating SAML connector resources.
     * ResourceWithSecretsRequest is not a great place for this field but it's
     * necessary for backward compatibility.
     *
     * @generated from protobuf field: bool SAMLValidationNoFollowURLs = 3 [json_name = "SAMLValidationNoFollowURLs"];
     */
    sAMLValidationNoFollowURLs: boolean;
}
/**
 * ResourcesWithSecretsRequest is a request relating to resources with secrets.
 *
 * @generated from protobuf message types.ResourcesWithSecretsRequest
 */
export interface ResourcesWithSecretsRequest {
    /**
     * WithSecrets specifies whether to load associated secrets.
     *
     * @generated from protobuf field: bool WithSecrets = 1 [json_name = "WithSecrets"];
     */
    withSecrets: boolean;
    /**
     * SAMLValidationNoFollowURLs specifies whether to skip following URLs when
     * validating SAML connector resources.
     * ResourceWithSecretsRequest is not a great place for this field but it's
     * necessary for backward compatibility.
     *
     * @generated from protobuf field: bool SAMLValidationNoFollowURLs = 2 [json_name = "SAMLValidationNoFollowURLs"];
     */
    sAMLValidationNoFollowURLs: boolean;
}
/**
 * ResourcesInNamespaceRequest is a request relating to a named resource in the given namespace.
 *
 * @generated from protobuf message types.ResourceInNamespaceRequest
 */
export interface ResourceInNamespaceRequest {
    /**
     * Name is the name of the resource.
     *
     * @generated from protobuf field: string Name = 1 [json_name = "Name"];
     */
    name: string;
    /**
     * Namespace is the namespace of resources.
     *
     * @generated from protobuf field: string Namespace = 2 [json_name = "Namespace"];
     */
    namespace: string;
}
/**
 * ResourcesInNamespaceRequest is a request relating to resources in the given namespace.
 *
 * @generated from protobuf message types.ResourcesInNamespaceRequest
 */
export interface ResourcesInNamespaceRequest {
    /**
     * Namespace is the namespace of resources.
     *
     * @generated from protobuf field: string Namespace = 1 [json_name = "Namespace"];
     */
    namespace: string;
}
/**
 * OIDCConnectorV3 represents an OIDC connector.
 *
 * @generated from protobuf message types.OIDCConnectorV3
 */
export interface OIDCConnectorV3 {
    /**
     * Kind is a resource kind.
     *
     * @generated from protobuf field: string Kind = 1 [json_name = "Kind"];
     */
    kind: string;
    /**
     * SubKind is an optional resource sub kind, used in some resources.
     *
     * @generated from protobuf field: string SubKind = 2 [json_name = "SubKind"];
     */
    subKind: string;
    /**
     * Version is the resource version. It must be specified.
     * Supported values are: `v3`.
     *
     * @generated from protobuf field: string Version = 3 [json_name = "Version"];
     */
    version: string;
    /**
     * Metadata holds resource metadata.
     *
     * @generated from protobuf field: types.Metadata Metadata = 4 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Spec is an OIDC connector specification.
     *
     * @generated from protobuf field: types.OIDCConnectorSpecV3 Spec = 5 [json_name = "Spec"];
     */
    spec?: OIDCConnectorSpecV3;
}
/**
 * OIDCConnectorV3List is a list of OIDC connectors.
 *
 * @generated from protobuf message types.OIDCConnectorV3List
 */
export interface OIDCConnectorV3List {
    /**
     * OIDCConnectors is a list of OIDC connectors.
     *
     * @generated from protobuf field: repeated types.OIDCConnectorV3 OIDCConnectors = 1 [json_name = "OIDCConnectors"];
     */
    oIDCConnectors: OIDCConnectorV3[];
}
/**
 * OIDCConnectorSpecV3 is an OIDC connector specification.
 *
 * It specifies configuration for Open ID Connect compatible external
 * identity provider: https://openid.net/specs/openid-connect-core-1_0.html
 *
 * @generated from protobuf message types.OIDCConnectorSpecV3
 */
export interface OIDCConnectorSpecV3 {
    /**
     * IssuerURL is the endpoint of the provider, e.g. https://accounts.google.com.
     *
     * @generated from protobuf field: string IssuerURL = 1 [json_name = "IssuerURL"];
     */
    issuerURL: string;
    /**
     * ClientID is the id of the authentication client (Teleport Auth Service).
     *
     * @generated from protobuf field: string ClientID = 2 [json_name = "ClientID"];
     */
    clientID: string;
    /**
     * ClientSecret is used to authenticate the client.
     *
     * @generated from protobuf field: string ClientSecret = 3 [json_name = "ClientSecret"];
     */
    clientSecret: string;
    /**
     * ACR is an Authentication Context Class Reference value. The meaning of the ACR
     * value is context-specific and varies for identity providers.
     *
     * @generated from protobuf field: string ACR = 5 [json_name = "ACR"];
     */
    aCR: string;
    /**
     * Provider is the external identity provider.
     *
     * @generated from protobuf field: string Provider = 6 [json_name = "Provider"];
     */
    provider: string;
    /**
     * Display is the friendly name for this provider.
     *
     * @generated from protobuf field: string Display = 7 [json_name = "Display"];
     */
    display: string;
    /**
     * Scope specifies additional scopes set by provider.
     *
     * @generated from protobuf field: repeated string Scope = 8 [json_name = "Scope"];
     */
    scope: string[];
    /**
     * Prompt is an optional OIDC prompt. An empty string omits prompt.
     * If not specified, it defaults to select_account for backwards compatibility.
     *
     * @generated from protobuf field: string Prompt = 9 [json_name = "Prompt"];
     */
    prompt: string;
    /**
     * ClaimsToRoles specifies a dynamic mapping from claims to roles.
     *
     * @generated from protobuf field: repeated types.ClaimMapping ClaimsToRoles = 10 [json_name = "ClaimsToRoles"];
     */
    claimsToRoles: ClaimMapping[];
    /**
     * GoogleServiceAccountURI is a path to a google service account uri.
     *
     * @generated from protobuf field: string GoogleServiceAccountURI = 11 [json_name = "GoogleServiceAccountURI"];
     */
    googleServiceAccountURI: string;
    /**
     * GoogleServiceAccount is a string containing google service account credentials.
     *
     * @generated from protobuf field: string GoogleServiceAccount = 12 [json_name = "GoogleServiceAccount"];
     */
    googleServiceAccount: string;
    /**
     * GoogleAdminEmail is the email of a google admin to impersonate.
     *
     * @generated from protobuf field: string GoogleAdminEmail = 13 [json_name = "GoogleAdminEmail"];
     */
    googleAdminEmail: string;
    /**
     * RedirectURLs is a list of callback URLs which the identity provider can use
     * to redirect the client back to the Teleport Proxy to complete authentication.
     * This list should match the URLs on the provider's side. The URL used for a
     * given auth request will be chosen to match the requesting Proxy's public
     * address. If there is no match, the first url in the list will be used.
     *
     * @generated from protobuf field: wrappers.StringValues RedirectURLs = 14 [json_name = "RedirectURLs"];
     */
    redirectURLs?: StringValues;
    /**
     * AllowUnverifiedEmail tells the connector to accept OIDC users with unverified emails.
     *
     * @generated from protobuf field: bool AllowUnverifiedEmail = 15 [json_name = "AllowUnverifiedEmail"];
     */
    allowUnverifiedEmail: boolean;
    /**
     * UsernameClaim specifies the name of the claim from the OIDC connector to be used as the user's username.
     *
     * @generated from protobuf field: string UsernameClaim = 16 [json_name = "UsernameClaim"];
     */
    usernameClaim: string;
    /**
     * MaxAge is the amount of time that user logins are
     * valid for. If a user logs in, but then does not login again
     * within this time period, they will be forced to re-authenticate.
     *
     * @generated from protobuf field: types.MaxAge MaxAge = 17 [json_name = "MaxAge"];
     */
    maxAge?: MaxAge;
    /**
     * ClientRedirectSettings defines which client redirect URLs are allowed for
     * non-browser SSO logins other than the standard localhost ones.
     *
     * @generated from protobuf field: types.SSOClientRedirectSettings ClientRedirectSettings = 18 [json_name = "ClientRedirectSettings"];
     */
    clientRedirectSettings?: SSOClientRedirectSettings;
    /**
     * MFASettings contains settings to enable SSO MFA checks through this auth connector.
     *
     * @generated from protobuf field: types.OIDCConnectorMFASettings MFASettings = 19 [json_name = "MFASettings"];
     */
    mFASettings?: OIDCConnectorMFASettings;
    /**
     * PKCEMode represents the configuration state for PKCE (Proof Key for Code Exchange). It can be "enabled" or "disabled"
     *
     * @generated from protobuf field: string PKCEMode = 20 [json_name = "PKCEMode"];
     */
    pKCEMode: string;
}
/**
 * MaxAge allows the max_age parameter to be nullable to preserve backwards
 * compatibility. The duration is stored as nanoseconds.
 *
 * @generated from protobuf message types.MaxAge
 */
export interface MaxAge {
    /**
     * @generated from protobuf field: int64 Value = 1 [json_name = "Value"];
     */
    value: bigint;
}
/**
 * SSOClientRedirectSettings contains settings to define which additional client
 * redirect URLs should be allowed for non-browser SSO logins.
 *
 * @generated from protobuf message types.SSOClientRedirectSettings
 */
export interface SSOClientRedirectSettings {
    /**
     * a list of hostnames allowed for https client redirect URLs
     *
     * @generated from protobuf field: repeated string allowed_https_hostnames = 1;
     */
    allowedHttpsHostnames: string[];
    /**
     * a list of CIDRs allowed for HTTP or HTTPS client redirect URLs
     *
     * @generated from protobuf field: repeated string insecure_allowed_cidr_ranges = 2;
     */
    insecureAllowedCidrRanges: string[];
}
/**
 * OIDCConnectorMFASettings contains OIDC MFA settings.
 *
 * @generated from protobuf message types.OIDCConnectorMFASettings
 */
export interface OIDCConnectorMFASettings {
    /**
     * Enabled specified whether this OIDC connector supports MFA checks. Defaults to false.
     *
     * @generated from protobuf field: bool enabled = 1;
     */
    enabled: boolean;
    /**
     * ClientID is the OIDC OAuth app client ID.
     *
     * @generated from protobuf field: string client_id = 2;
     */
    clientId: string;
    /**
     * ClientSecret is the OIDC OAuth app client secret.
     *
     * @generated from protobuf field: string client_secret = 3;
     */
    clientSecret: string;
    /**
     * AcrValues are Authentication Context Class Reference values. The meaning of the ACR
     * value is context-specific and varies for identity providers. Some identity providers
     * support MFA specific contexts, such Okta with its "phr" (phishing-resistant) ACR.
     *
     * @generated from protobuf field: string acr_values = 4;
     */
    acrValues: string;
    /**
     * Prompt is an optional OIDC prompt. An empty string omits prompt.
     * If not specified, it defaults to select_account for backwards compatibility.
     *
     * @generated from protobuf field: string prompt = 5;
     */
    prompt: string;
    /**
     * MaxAge is the amount of time in nanoseconds that an IdP session is valid for. Defaults to
     * 0 to always force re-authentication for MFA checks. This should only be set to a non-zero
     * value if the IdP is setup to perform MFA checks on top of active user sessions.
     *
     * @generated from protobuf field: int64 max_age = 6;
     */
    maxAge: bigint;
}
/**
 * OIDCAuthRequest is a request to authenticate with OIDC
 * provider, the state about request is managed by Auth Service
 *
 * @generated from protobuf message types.OIDCAuthRequest
 */
export interface OIDCAuthRequest {
    /**
     * ConnectorID is ID of OIDC connector this request uses
     *
     * @generated from protobuf field: string ConnectorID = 1 [json_name = "ConnectorID"];
     */
    connectorID: string;
    /**
     * Type is opaque string that helps callbacks identify the request type
     *
     * @generated from protobuf field: string Type = 2 [json_name = "Type"];
     */
    type: string;
    /**
     * CheckUser tells validator if it should expect and check user
     *
     * @generated from protobuf field: bool CheckUser = 3 [json_name = "CheckUser"];
     */
    checkUser: boolean;
    /**
     * StateToken is generated by service and is used to validate
     * request coming from
     *
     * @generated from protobuf field: string StateToken = 4 [json_name = "StateToken"];
     */
    stateToken: string;
    /**
     * CSRFToken is associated with user web session token
     *
     * @generated from protobuf field: string CSRFToken = 5 [json_name = "CSRFToken"];
     */
    cSRFToken: string;
    /**
     * RedirectURL will be used to route the user back to a
     * Teleport Proxy after the oidc login attempt in the browser.
     *
     * @generated from protobuf field: string RedirectURL = 6 [json_name = "RedirectURL"];
     */
    redirectURL: string;
    /**
     * PublicKey is an optional public key, users want these keys to be signed by
     * the Auth Service's user CA in case of successful auth.
     *
     * Deprecated: prefer SshPublicKey and/or TlsPublicKey.
     *
     * @deprecated
     * @generated from protobuf field: bytes PublicKey = 7 [deprecated = true, json_name = "PublicKey"];
     */
    publicKey: Uint8Array;
    /**
     * CertTTL is the TTL of the certificate user wants to get
     *
     * @generated from protobuf field: int64 CertTTL = 8 [json_name = "CertTTL"];
     */
    certTTL: bigint;
    /**
     * CreateWebSession indicates if user wants to generate a web
     * session after successful authentication
     *
     * @generated from protobuf field: bool CreateWebSession = 9 [json_name = "CreateWebSession"];
     */
    createWebSession: boolean;
    /**
     * ClientRedirectURL is a URL client wants to be redirected
     * after successful authentication
     *
     * @generated from protobuf field: string ClientRedirectURL = 10 [json_name = "ClientRedirectURL"];
     */
    clientRedirectURL: string;
    /**
     * Compatibility specifies OpenSSH compatibility flags.
     *
     * @generated from protobuf field: string Compatibility = 11 [json_name = "Compatibility"];
     */
    compatibility: string;
    /**
     * RouteToCluster is the name of Teleport cluster to issue credentials for.
     *
     * @generated from protobuf field: string RouteToCluster = 12 [json_name = "RouteToCluster"];
     */
    routeToCluster: string;
    /**
     * KubernetesCluster is the name of Kubernetes cluster to issue credentials for.
     *
     * @generated from protobuf field: string KubernetesCluster = 13 [json_name = "KubernetesCluster"];
     */
    kubernetesCluster: string;
    /**
     * SSOTestFlow indicates if the request is part of the test flow.
     *
     * @generated from protobuf field: bool SSOTestFlow = 14 [json_name = "SSOTestFlow"];
     */
    sSOTestFlow: boolean;
    /**
     * ConnectorSpec is embedded connector spec for use in test flow.
     *
     * @generated from protobuf field: types.OIDCConnectorSpecV3 ConnectorSpec = 15 [json_name = "ConnectorSpec"];
     */
    connectorSpec?: OIDCConnectorSpecV3;
    /**
     * ProxyAddress is an optional address which can be used to
     * find a redirect url from the OIDC connector which matches
     * the address. If there is no match, the default redirect
     * url will be used.
     *
     * @generated from protobuf field: string ProxyAddress = 16 [json_name = "ProxyAddress"];
     */
    proxyAddress: string;
    /**
     * attestation_statement is an attestation statement for the given public key.
     *
     * Deprecated: prefer SshAttestationStatement and/or TlsAttestationStatement.
     *
     * @deprecated
     * @generated from protobuf field: teleport.attestation.v1.AttestationStatement attestation_statement = 17 [deprecated = true];
     */
    attestationStatement?: AttestationStatement;
    /**
     * ClientLoginIP specifies IP address of the client for login, it will be written to the user's certificates.
     *
     * @generated from protobuf field: string ClientLoginIP = 18 [json_name = "ClientLoginIP"];
     */
    clientLoginIP: string;
    /**
     * ClientUserAgent is the user agent of the Web browser, used for issuing a
     * DeviceWebToken.
     *
     * @generated from protobuf field: string ClientUserAgent = 19 [json_name = "ClientUserAgent"];
     */
    clientUserAgent: string;
    /**
     * SshPublicKey is an optional public key to use as the subject of an issued
     * SSH cert in case of successful auth.
     *
     * @generated from protobuf field: bytes ssh_public_key = 20;
     */
    sshPublicKey: Uint8Array;
    /**
     * TlsPublicKey is an optional public key to use as the subject of an issued
     * TLS cert in case of successful auth.
     *
     * @generated from protobuf field: bytes tls_public_key = 21;
     */
    tlsPublicKey: Uint8Array;
    /**
     * SshAttestationStatement is an attestation statement for the given SSH public key.
     *
     * @generated from protobuf field: teleport.attestation.v1.AttestationStatement ssh_attestation_statement = 22;
     */
    sshAttestationStatement?: AttestationStatement;
    /**
     * TlsAttestationStatement is an attestation statement for the given TLS public key.
     *
     * @generated from protobuf field: teleport.attestation.v1.AttestationStatement tls_attestation_statement = 23;
     */
    tlsAttestationStatement?: AttestationStatement;
    /**
     * pkce_verifier is used to verified a generated code challenge.
     *
     * @generated from protobuf field: string pkce_verifier = 24;
     */
    pkceVerifier: string;
}
/**
 * SAMLConnectorV2 represents a SAML connector.
 *
 * @generated from protobuf message types.SAMLConnectorV2
 */
export interface SAMLConnectorV2 {
    /**
     * Kind is a resource kind.
     *
     * @generated from protobuf field: string Kind = 1 [json_name = "Kind"];
     */
    kind: string;
    /**
     * SubKind is an optional resource sub kind, used in some resources.
     *
     * @generated from protobuf field: string SubKind = 2 [json_name = "SubKind"];
     */
    subKind: string;
    /**
     * Version is the resource version. It must be specified.
     * Supported values are: `v2`.
     *
     * @generated from protobuf field: string Version = 3 [json_name = "Version"];
     */
    version: string;
    /**
     * Metadata holds resource metadata.
     *
     * @generated from protobuf field: types.Metadata Metadata = 4 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Spec is an SAML connector specification.
     *
     * @generated from protobuf field: types.SAMLConnectorSpecV2 Spec = 5 [json_name = "Spec"];
     */
    spec?: SAMLConnectorSpecV2;
}
/**
 * SAMLConnectorV2List is a list of SAML connectors.
 *
 * @generated from protobuf message types.SAMLConnectorV2List
 */
export interface SAMLConnectorV2List {
    /**
     * SAMLConnectors is a list of SAML connectors.
     *
     * @generated from protobuf field: repeated types.SAMLConnectorV2 SAMLConnectors = 1 [json_name = "SAMLConnectors"];
     */
    sAMLConnectors: SAMLConnectorV2[];
}
/**
 * SAMLConnectorSpecV2 is a SAML connector specification.
 *
 * @generated from protobuf message types.SAMLConnectorSpecV2
 */
export interface SAMLConnectorSpecV2 {
    /**
     * Issuer is the identity provider issuer.
     *
     * @generated from protobuf field: string Issuer = 1 [json_name = "Issuer"];
     */
    issuer: string;
    /**
     * SSO is the URL of the identity provider's SSO service.
     *
     * @generated from protobuf field: string SSO = 2 [json_name = "SSO"];
     */
    sSO: string;
    /**
     * Cert is the identity provider certificate PEM.
     * IDP signs `<Response>` responses using this certificate.
     *
     * @generated from protobuf field: string Cert = 3 [json_name = "Cert"];
     */
    cert: string;
    /**
     * Display controls how this connector is displayed.
     *
     * @generated from protobuf field: string Display = 4 [json_name = "Display"];
     */
    display: string;
    /**
     * AssertionConsumerService is a URL for assertion consumer service
     * on the service provider (Teleport's side).
     *
     * @generated from protobuf field: string AssertionConsumerService = 5 [json_name = "AssertionConsumerService"];
     */
    assertionConsumerService: string;
    /**
     * Audience uniquely identifies our service provider.
     *
     * @generated from protobuf field: string Audience = 6 [json_name = "Audience"];
     */
    audience: string;
    /**
     * ServiceProviderIssuer is the issuer of the service provider (Teleport).
     *
     * @generated from protobuf field: string ServiceProviderIssuer = 7 [json_name = "ServiceProviderIssuer"];
     */
    serviceProviderIssuer: string;
    /**
     * EntityDescriptor is XML with descriptor. It can be used to supply configuration
     * parameters in one XML file rather than supplying them in the individual elements.
     *
     * @generated from protobuf field: string EntityDescriptor = 8 [json_name = "EntityDescriptor"];
     */
    entityDescriptor: string;
    /**
     * EntityDescriptorURL is a URL that supplies a configuration XML.
     *
     * @generated from protobuf field: string EntityDescriptorURL = 9 [json_name = "EntityDescriptorURL"];
     */
    entityDescriptorURL: string;
    /**
     * AttributesToRoles is a list of mappings of attribute statements to roles.
     *
     * @generated from protobuf field: repeated types.AttributeMapping AttributesToRoles = 10 [json_name = "AttributesToRoles"];
     */
    attributesToRoles: AttributeMapping[];
    /**
     * SigningKeyPair is an x509 key pair used to sign AuthnRequest.
     *
     * @generated from protobuf field: types.AsymmetricKeyPair SigningKeyPair = 11 [json_name = "SigningKeyPair"];
     */
    signingKeyPair?: AsymmetricKeyPair;
    /**
     * Provider is the external identity provider.
     *
     * @generated from protobuf field: string Provider = 12 [json_name = "Provider"];
     */
    provider: string;
    /**
     * EncryptionKeyPair is a key pair used for decrypting SAML assertions.
     *
     * @generated from protobuf field: types.AsymmetricKeyPair EncryptionKeyPair = 13 [json_name = "EncryptionKeyPair"];
     */
    encryptionKeyPair?: AsymmetricKeyPair;
    /**
     * AllowIDPInitiated is a flag that indicates if the connector can be used for IdP-initiated
     * logins.
     *
     * @generated from protobuf field: bool AllowIDPInitiated = 14 [json_name = "AllowIDPInitiated"];
     */
    allowIDPInitiated: boolean;
    /**
     * ClientRedirectSettings defines which client redirect URLs are allowed for
     * non-browser SSO logins other than the standard localhost ones.
     *
     * @generated from protobuf field: types.SSOClientRedirectSettings ClientRedirectSettings = 15 [json_name = "ClientRedirectSettings"];
     */
    clientRedirectSettings?: SSOClientRedirectSettings;
    /**
     * SingleLogoutURL is the SAML Single log-out URL to initiate SAML SLO (single log-out). If this is not provided, SLO is disabled.
     *
     * @generated from protobuf field: string SingleLogoutURL = 16 [json_name = "SingleLogoutURL"];
     */
    singleLogoutURL: string;
    /**
     * MFASettings contains settings to enable SSO MFA checks through this auth connector.
     *
     * @generated from protobuf field: types.SAMLConnectorMFASettings MFASettings = 17 [json_name = "MFASettings"];
     */
    mFASettings?: SAMLConnectorMFASettings;
    /**
     * ForceAuthn specified whether re-authentication should be forced on login. UNSPECIFIED
     * is treated as NO.
     *
     * @generated from protobuf field: types.SAMLForceAuthn ForceAuthn = 18 [json_name = "ForceAuthn"];
     */
    forceAuthn: SAMLForceAuthn;
}
/**
 * SAMLConnectorMFASettings contains SAML MFA settings.
 *
 * @generated from protobuf message types.SAMLConnectorMFASettings
 */
export interface SAMLConnectorMFASettings {
    /**
     * Enabled specified whether this SAML connector supports MFA checks. Defaults to false.
     *
     * @generated from protobuf field: bool enabled = 1;
     */
    enabled: boolean;
    /**
     * EntityDescriptor is XML with descriptor. It can be used to supply configuration
     * parameters in one XML file rather than supplying them in the individual elements.
     * Usually set from EntityDescriptorUrl.
     *
     * @generated from protobuf field: string entity_descriptor = 2;
     */
    entityDescriptor: string;
    /**
     * EntityDescriptorUrl is a URL that supplies a configuration XML.
     *
     * @generated from protobuf field: string entity_descriptor_url = 3;
     */
    entityDescriptorUrl: string;
    /**
     * ForceAuthn specified whether re-authentication should be forced for MFA checks. UNSPECIFIED is
     * treated as YES to always re-authentication for MFA checks. This should only be set to NO if the
     * IdP is setup to perform MFA checks on top of active user sessions.
     *
     * @generated from protobuf field: types.SAMLForceAuthn force_authn = 4;
     */
    forceAuthn: SAMLForceAuthn;
    /**
     * Issuer is the identity provider issuer. Usually set from EntityDescriptor.
     *
     * @generated from protobuf field: string issuer = 5;
     */
    issuer: string;
    /**
     * SSO is the URL of the identity provider's SSO service. Usually set from EntityDescriptor.
     *
     * @generated from protobuf field: string sso = 6;
     */
    sso: string;
    /**
     * Cert is the identity provider certificate PEM.
     * IDP signs `<Response>` responses using this certificate.
     *
     * @generated from protobuf field: string cert = 7;
     */
    cert: string;
}
/**
 * SAMLAuthRequest is a request to authenticate with SAML
 * provider, the state about request is managed by the Auth Service
 *
 * @generated from protobuf message types.SAMLAuthRequest
 */
export interface SAMLAuthRequest {
    /**
     * ID is a unique request ID.
     *
     * @generated from protobuf field: string ID = 1 [json_name = "ID"];
     */
    iD: string;
    /**
     * ConnectorID is ID of OIDC connector this request uses.
     *
     * @generated from protobuf field: string ConnectorID = 2 [json_name = "ConnectorID"];
     */
    connectorID: string;
    /**
     * Type is opaque string that helps callbacks identify the request type.
     *
     * @generated from protobuf field: string Type = 3 [json_name = "Type"];
     */
    type: string;
    /**
     * CheckUser tells validator if it should expect and check user.
     *
     * @generated from protobuf field: bool CheckUser = 4 [json_name = "CheckUser"];
     */
    checkUser: boolean;
    /**
     * RedirectURL will be used by browser.
     *
     * @generated from protobuf field: string RedirectURL = 5 [json_name = "RedirectURL"];
     */
    redirectURL: string;
    /**
     * PublicKey is an optional public key, users want these
     * keys to be signed by Auth Service's user CA in case
     * of successful auth.
     *
     * Deprecated: prefer SshPublicKey and/or TlsPublicKey.
     *
     * @deprecated
     * @generated from protobuf field: bytes PublicKey = 6 [deprecated = true, json_name = "PublicKey"];
     */
    publicKey: Uint8Array;
    /**
     * CertTTL is the TTL of the certificate user wants to get.
     *
     * @generated from protobuf field: int64 CertTTL = 7 [json_name = "CertTTL"];
     */
    certTTL: bigint;
    /**
     * CSRFToken is associated with user web session token.
     *
     * @generated from protobuf field: string CSRFToken = 8 [json_name = "CSRFToken"];
     */
    cSRFToken: string;
    /**
     * CreateWebSession indicates if user wants to generate a web
     * session after successful authentication.
     *
     * @generated from protobuf field: bool CreateWebSession = 9 [json_name = "CreateWebSession"];
     */
    createWebSession: boolean;
    /**
     * ClientRedirectURL is a URL client wants to be redirected
     * after successful authentication.
     *
     * @generated from protobuf field: string ClientRedirectURL = 10 [json_name = "ClientRedirectURL"];
     */
    clientRedirectURL: string;
    /**
     * Compatibility specifies OpenSSH compatibility flags.
     *
     * @generated from protobuf field: string Compatibility = 11 [json_name = "Compatibility"];
     */
    compatibility: string;
    /**
     * RouteToCluster is the name of Teleport cluster to issue credentials for.
     *
     * @generated from protobuf field: string RouteToCluster = 12 [json_name = "RouteToCluster"];
     */
    routeToCluster: string;
    /**
     * KubernetesCluster is the name of Kubernetes cluster to issue credentials for.
     *
     * @generated from protobuf field: string KubernetesCluster = 13 [json_name = "KubernetesCluster"];
     */
    kubernetesCluster: string;
    /**
     * SSOTestFlow indicates if the request is part of the test flow.
     *
     * @generated from protobuf field: bool SSOTestFlow = 14 [json_name = "SSOTestFlow"];
     */
    sSOTestFlow: boolean;
    /**
     * ConnectorSpec is embedded connector spec for use in test flow.
     *
     * @generated from protobuf field: types.SAMLConnectorSpecV2 ConnectorSpec = 15 [json_name = "ConnectorSpec"];
     */
    connectorSpec?: SAMLConnectorSpecV2;
    /**
     * attestation_statement is an attestation statement for the given public key.
     *
     * Deprecated: prefer SshAttestationStatement and/or TlsAttestationStatement.
     *
     * @generated from protobuf field: teleport.attestation.v1.AttestationStatement attestation_statement = 16;
     */
    attestationStatement?: AttestationStatement;
    /**
     * ClientLoginIP specifies IP address of the client for login, it will be written to the user's certificates.
     *
     * @generated from protobuf field: string ClientLoginIP = 17 [json_name = "ClientLoginIP"];
     */
    clientLoginIP: string;
    /**
     * ClientUserAgent is the user agent of the Web browser, used for issuing a
     * DeviceWebToken.
     *
     * @generated from protobuf field: string ClientUserAgent = 18 [json_name = "ClientUserAgent"];
     */
    clientUserAgent: string;
    /**
     * SshPublicKey is an optional public key to use as the subject of an issued
     * SSH cert in case of successful auth.
     *
     * @generated from protobuf field: bytes ssh_public_key = 19;
     */
    sshPublicKey: Uint8Array;
    /**
     * TlsPublicKey is an optional public key to use as the subject of an issued
     * TLS cert in case of successful auth.
     *
     * @generated from protobuf field: bytes tls_public_key = 20;
     */
    tlsPublicKey: Uint8Array;
    /**
     * SshAttestationStatement is an attestation statement for the given SSH public key.
     *
     * @generated from protobuf field: teleport.attestation.v1.AttestationStatement ssh_attestation_statement = 21;
     */
    sshAttestationStatement?: AttestationStatement;
    /**
     * TlsAttestationStatement is an attestation statement for the given TLS public key.
     *
     * @generated from protobuf field: teleport.attestation.v1.AttestationStatement tls_attestation_statement = 22;
     */
    tlsAttestationStatement?: AttestationStatement;
}
/**
 * AttributeMapping maps a SAML attribute statement to teleport roles.
 *
 * @generated from protobuf message types.AttributeMapping
 */
export interface AttributeMapping {
    /**
     * Name is an attribute statement name.
     *
     * @generated from protobuf field: string Name = 1 [json_name = "Name"];
     */
    name: string;
    /**
     * Value is an attribute statement value to match.
     *
     * @generated from protobuf field: string Value = 2 [json_name = "Value"];
     */
    value: string;
    /**
     * Roles is a list of static teleport roles to map to.
     *
     * @generated from protobuf field: repeated string Roles = 3 [json_name = "Roles"];
     */
    roles: string[];
}
/**
 * AsymmetricKeyPair is a combination of a public certificate and
 * private key that can be used for encryption and signing.
 *
 * @generated from protobuf message types.AsymmetricKeyPair
 */
export interface AsymmetricKeyPair {
    /**
     * PrivateKey is a PEM encoded x509 private key.
     *
     * @generated from protobuf field: string PrivateKey = 1 [json_name = "PrivateKey"];
     */
    privateKey: string;
    /**
     * Cert is a PEM-encoded x509 certificate.
     *
     * @generated from protobuf field: string Cert = 2 [json_name = "Cert"];
     */
    cert: string;
}
/**
 * GithubConnectorV3 represents a Github connector.
 *
 * @generated from protobuf message types.GithubConnectorV3
 */
export interface GithubConnectorV3 {
    /**
     * Kind is a resource kind.
     *
     * @generated from protobuf field: string Kind = 1 [json_name = "Kind"];
     */
    kind: string;
    /**
     * SubKind is an optional resource sub kind, used in some resources.
     *
     * @generated from protobuf field: string SubKind = 2 [json_name = "SubKind"];
     */
    subKind: string;
    /**
     * Version is the resource version. It must be specified.
     * Supported values are: `v3`.
     *
     * @generated from protobuf field: string Version = 3 [json_name = "Version"];
     */
    version: string;
    /**
     * Metadata holds resource metadata.
     *
     * @generated from protobuf field: types.Metadata Metadata = 4 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Spec is an Github connector specification.
     *
     * @generated from protobuf field: types.GithubConnectorSpecV3 Spec = 5 [json_name = "Spec"];
     */
    spec?: GithubConnectorSpecV3;
}
/**
 * GithubConnectorV3List is a list of Github connectors.
 *
 * @generated from protobuf message types.GithubConnectorV3List
 */
export interface GithubConnectorV3List {
    /**
     * GithubConnectors is a list of Github connectors.
     *
     * @generated from protobuf field: repeated types.GithubConnectorV3 GithubConnectors = 1 [json_name = "GithubConnectors"];
     */
    githubConnectors: GithubConnectorV3[];
}
/**
 * GithubConnectorSpecV3 is a Github connector specification.
 *
 * @generated from protobuf message types.GithubConnectorSpecV3
 */
export interface GithubConnectorSpecV3 {
    /**
     * ClientID is the Github OAuth app client ID.
     *
     * @generated from protobuf field: string ClientID = 1 [json_name = "ClientID"];
     */
    clientID: string;
    /**
     * ClientSecret is the Github OAuth app client secret.
     *
     * @generated from protobuf field: string ClientSecret = 2 [json_name = "ClientSecret"];
     */
    clientSecret: string;
    /**
     * RedirectURL is the authorization callback URL.
     *
     * @generated from protobuf field: string RedirectURL = 3 [json_name = "RedirectURL"];
     */
    redirectURL: string;
    /**
     * TeamsToLogins maps Github team memberships onto allowed logins/roles.
     *
     * DELETE IN 11.0.0
     * Deprecated: use GithubTeamsToRoles instead.
     *
     * @generated from protobuf field: repeated types.TeamMapping TeamsToLogins = 4 [json_name = "TeamsToLogins"];
     */
    teamsToLogins: TeamMapping[];
    /**
     * Display is the connector display name.
     *
     * @generated from protobuf field: string Display = 5 [json_name = "Display"];
     */
    display: string;
    /**
     * TeamsToRoles maps Github team memberships onto allowed roles.
     *
     * @generated from protobuf field: repeated types.TeamRolesMapping TeamsToRoles = 6 [json_name = "TeamsToRoles"];
     */
    teamsToRoles: TeamRolesMapping[];
    /**
     * EndpointURL is the URL of the GitHub instance this connector is for.
     *
     * @generated from protobuf field: string EndpointURL = 7 [json_name = "EndpointURL"];
     */
    endpointURL: string;
    /**
     * APIEndpointURL is the URL of the API endpoint of the Github instance
     * this connector is for.
     *
     * @generated from protobuf field: string APIEndpointURL = 8 [json_name = "APIEndpointURL"];
     */
    aPIEndpointURL: string;
    /**
     * ClientRedirectSettings defines which client redirect URLs are allowed for
     * non-browser SSO logins other than the standard localhost ones.
     *
     * @generated from protobuf field: types.SSOClientRedirectSettings ClientRedirectSettings = 9 [json_name = "ClientRedirectSettings"];
     */
    clientRedirectSettings?: SSOClientRedirectSettings;
}
/**
 * GithubAuthRequest is the request to start Github OAuth2 flow.
 *
 * @generated from protobuf message types.GithubAuthRequest
 */
export interface GithubAuthRequest {
    /**
     * ConnectorID is the name of the connector to use.
     *
     * @generated from protobuf field: string ConnectorID = 1 [json_name = "ConnectorID"];
     */
    connectorID: string;
    /**
     * Type is opaque string that helps callbacks identify the request type.
     *
     * @generated from protobuf field: string Type = 2 [json_name = "Type"];
     */
    type: string;
    /**
     * StateToken is used to validate the request.
     *
     * @generated from protobuf field: string StateToken = 3 [json_name = "StateToken"];
     */
    stateToken: string;
    /**
     * CSRFToken is used to protect against CSRF attacks.
     *
     * @generated from protobuf field: string CSRFToken = 4 [json_name = "CSRFToken"];
     */
    cSRFToken: string;
    /**
     * PublicKey is an optional public key to sign in case of successful auth.
     *
     * Deprecated: prefer SshPublicKey and/or TlsPublicKey.
     *
     * @deprecated
     * @generated from protobuf field: bytes PublicKey = 5 [deprecated = true, json_name = "PublicKey"];
     */
    publicKey: Uint8Array;
    /**
     * CertTTL is TTL of the cert that's generated in case of successful auth.
     *
     * @generated from protobuf field: int64 CertTTL = 6 [json_name = "CertTTL"];
     */
    certTTL: bigint;
    /**
     * CreateWebSession indicates that a user wants to generate a web session
     * after successful authentication.
     *
     * @generated from protobuf field: bool CreateWebSession = 7 [json_name = "CreateWebSession"];
     */
    createWebSession: boolean;
    /**
     * RedirectURL will be used by browser.
     *
     * @generated from protobuf field: string RedirectURL = 8 [json_name = "RedirectURL"];
     */
    redirectURL: string;
    /**
     * ClientRedirectURL is the URL where client will be redirected after
     * successful auth.
     *
     * @generated from protobuf field: string ClientRedirectURL = 9 [json_name = "ClientRedirectURL"];
     */
    clientRedirectURL: string;
    /**
     * Compatibility specifies OpenSSH compatibility flags.
     *
     * @generated from protobuf field: string Compatibility = 10 [json_name = "Compatibility"];
     */
    compatibility: string;
    /**
     * Expires is a global expiry time header can be set on any resource in the system.
     *
     * @generated from protobuf field: google.protobuf.Timestamp Expires = 11 [json_name = "Expires"];
     */
    expires?: Timestamp;
    /**
     * RouteToCluster is the name of Teleport cluster to issue credentials for.
     *
     * @generated from protobuf field: string RouteToCluster = 12 [json_name = "RouteToCluster"];
     */
    routeToCluster: string;
    /**
     * KubernetesCluster is the name of Kubernetes cluster to issue credentials for.
     *
     * @generated from protobuf field: string KubernetesCluster = 13 [json_name = "KubernetesCluster"];
     */
    kubernetesCluster: string;
    /**
     * SSOTestFlow indicates if the request is part of the test flow.
     *
     * @generated from protobuf field: bool SSOTestFlow = 14 [json_name = "SSOTestFlow"];
     */
    sSOTestFlow: boolean;
    /**
     * ConnectorSpec is embedded connector spec for use in test flow or authenticated user flow.
     *
     * @generated from protobuf field: types.GithubConnectorSpecV3 ConnectorSpec = 15 [json_name = "ConnectorSpec"];
     */
    connectorSpec?: GithubConnectorSpecV3;
    /**
     * AttestationStatement is an attestation statement for the given public key.
     *
     * Deprecated: prefer SshAttestationStatement and/or TlsAttestationStatement.
     *
     * @deprecated
     * @generated from protobuf field: teleport.attestation.v1.AttestationStatement attestation_statement = 16 [deprecated = true];
     */
    attestationStatement?: AttestationStatement;
    /**
     * ClientLoginIP specifies IP address of the client for login, it will be written to the user's certificates.
     *
     * @generated from protobuf field: string ClientLoginIP = 17 [json_name = "ClientLoginIP"];
     */
    clientLoginIP: string;
    /**
     * ClientUserAgent is the user agent of the Web browser, used for issuing
     * a DeviceWebToken.
     *
     * @generated from protobuf field: string ClientUserAgent = 18 [json_name = "ClientUserAgent"];
     */
    clientUserAgent: string;
    /**
     * SshPublicKey is an optional public key to use as the subject of an issued
     * SSH cert in case of successful auth.
     *
     * @generated from protobuf field: bytes ssh_public_key = 19;
     */
    sshPublicKey: Uint8Array;
    /**
     * TlsPublicKey is an optional public key to use as the subject of an issued
     * TLS cert in case of successful auth.
     *
     * @generated from protobuf field: bytes tls_public_key = 20;
     */
    tlsPublicKey: Uint8Array;
    /**
     * SshAttestationStatement is an attestation statement for the given SSH public key.
     *
     * @generated from protobuf field: teleport.attestation.v1.AttestationStatement ssh_attestation_statement = 21;
     */
    sshAttestationStatement?: AttestationStatement;
    /**
     * TlsAttestationStatement is an attestation statement for the given TLS public key.
     *
     * @generated from protobuf field: teleport.attestation.v1.AttestationStatement tls_attestation_statement = 22;
     */
    tlsAttestationStatement?: AttestationStatement;
    /**
     * AuthenticatedUser is the username of an authenticated Teleport user. This
     * OAuth flow is used to retrieve GitHub identity info which will be added to
     * the existing user.
     *
     * @generated from protobuf field: string authenticated_user = 23;
     */
    authenticatedUser: string;
}
/**
 * SSOWarnings conveys a user-facing main message along with auxiliary warnings.
 *
 * @generated from protobuf message types.SSOWarnings
 */
export interface SSOWarnings {
    /**
     * Message is main user-facing message to be shown.
     *
     * @generated from protobuf field: string Message = 1 [json_name = "Message"];
     */
    message: string;
    /**
     * Warnings is a set of distinct warnings to be reported.
     *
     * @generated from protobuf field: repeated string Warnings = 2 [json_name = "Warnings"];
     */
    warnings: string[];
}
/**
 * CreateUserParams represents the user creation parameters as called during SSO login flow.
 *
 * @generated from protobuf message types.CreateUserParams
 */
export interface CreateUserParams {
    /**
     * ConnectorName is the name of the connector used for SSO login flow.
     *
     * @generated from protobuf field: string ConnectorName = 1 [json_name = "ConnectorName"];
     */
    connectorName: string;
    /**
     * Username is the name of the user to be created.
     *
     * @generated from protobuf field: string Username = 2 [json_name = "Username"];
     */
    username: string;
    /**
     * Logins is a list of available unix logins.
     *
     * @generated from protobuf field: repeated string Logins = 3 [json_name = "Logins"];
     */
    logins: string[];
    /**
     * KubeGroups is a list of assigned kube groups.
     *
     * @generated from protobuf field: repeated string KubeGroups = 4 [json_name = "KubeGroups"];
     */
    kubeGroups: string[];
    /**
     * KubeUsers is a list of available kube users.
     *
     * @generated from protobuf field: repeated string KubeUsers = 5 [json_name = "KubeUsers"];
     */
    kubeUsers: string[];
    /**
     * Roles is a list of assigned roles.
     *
     * @generated from protobuf field: repeated string Roles = 6 [json_name = "Roles"];
     */
    roles: string[];
    /**
     * Traits is the set of traits the user is assigned.
     *
     * @generated from protobuf field: wrappers.LabelValues Traits = 7 [json_name = "Traits"];
     */
    traits?: LabelValues;
    /**
     * SessionTTL determines the TTL.
     *
     * @generated from protobuf field: int64 SessionTTL = 8 [json_name = "SessionTTL"];
     */
    sessionTTL: bigint;
}
/**
 * SSODiagnosticInfo is a single SSO diagnostic info entry.
 *
 * @generated from protobuf message types.SSODiagnosticInfo
 */
export interface SSODiagnosticInfo {
    /**
     * TestFlow indicates the SSO flow was a test one.
     *
     * @generated from protobuf field: bool TestFlow = 1 [json_name = "TestFlow"];
     */
    testFlow: boolean;
    /**
     * Error stores user-friendly error message.
     *
     * @generated from protobuf field: string Error = 2 [json_name = "Error"];
     */
    error: string;
    /**
     * Success if present, marks the flow as finished with success.
     *
     * @generated from protobuf field: bool Success = 3 [json_name = "Success"];
     */
    success: boolean;
    /**
     * CreateUserParams represents the user creation parameters as called during SSO login flow.
     *
     * @generated from protobuf field: types.CreateUserParams CreateUserParams = 4 [json_name = "CreateUserParams"];
     */
    createUserParams?: CreateUserParams;
    /**
     * SAMLAttributesToRoles represents mapping from attributes to roles, as used during SAML SSO
     * login flow.
     *
     * @generated from protobuf field: repeated types.AttributeMapping SAMLAttributesToRoles = 10 [json_name = "SAMLAttributesToRoles"];
     */
    sAMLAttributesToRoles: AttributeMapping[];
    /**
     * SAMLAttributesToRolesWarnings contains warnings produced during the process of mapping the
     * SAML attributes to roles.
     *
     * @generated from protobuf field: types.SSOWarnings SAMLAttributesToRolesWarnings = 11 [json_name = "SAMLAttributesToRolesWarnings"];
     */
    sAMLAttributesToRolesWarnings?: SSOWarnings;
    /**
     * SAMLAttributeStatements represents SAML attribute statements.
     *
     * @generated from protobuf field: wrappers.LabelValues SAMLAttributeStatements = 12 [json_name = "SAMLAttributeStatements"];
     */
    sAMLAttributeStatements?: LabelValues;
    /**
     * SAMLAssertionInfo represents raw SAML assertion info as returned by IdP during SAML flow.
     *
     * @generated from protobuf field: wrappers.CustomType SAMLAssertionInfo = 13 [json_name = "SAMLAssertionInfo"];
     */
    sAMLAssertionInfo?: CustomType;
    /**
     * SAMLTraitsFromAssertions represents traits translated from SAML assertions.
     *
     * @generated from protobuf field: wrappers.LabelValues SAMLTraitsFromAssertions = 14 [json_name = "SAMLTraitsFromAssertions"];
     */
    sAMLTraitsFromAssertions?: LabelValues;
    /**
     * SAMLConnectorTraitMapping represents connector-specific trait mapping.
     *
     * @generated from protobuf field: repeated types.TraitMapping SAMLConnectorTraitMapping = 15 [json_name = "SAMLConnectorTraitMapping"];
     */
    sAMLConnectorTraitMapping: TraitMapping[];
    /**
     * OIDCClaimsToRoles specifies a mapping from claims (traits) to teleport roles.
     *
     * @generated from protobuf field: repeated types.ClaimMapping OIDCClaimsToRoles = 20 [json_name = "OIDCClaimsToRoles"];
     */
    oIDCClaimsToRoles: ClaimMapping[];
    /**
     * OIDCClaimsToRolesWarnings contains warnings produced during the process of mapping the
     * OIDC claims to roles.
     *
     * @generated from protobuf field: types.SSOWarnings OIDCClaimsToRolesWarnings = 21 [json_name = "OIDCClaimsToRolesWarnings"];
     */
    oIDCClaimsToRolesWarnings?: SSOWarnings;
    /**
     * OIDCClaims represents OIDC claims.
     *
     * @generated from protobuf field: wrappers.CustomType OIDCClaims = 22 [json_name = "OIDCClaims"];
     */
    oIDCClaims?: CustomType;
    /**
     * OIDCIdentity represents mapped OIDC Identity.
     *
     * @generated from protobuf field: wrappers.CustomType OIDCIdentity = 23 [json_name = "OIDCIdentity"];
     */
    oIDCIdentity?: CustomType;
    /**
     * OIDCTraitsFromClaims represents traits translated from OIDC claims.
     *
     * @generated from protobuf field: wrappers.LabelValues OIDCTraitsFromClaims = 24 [json_name = "OIDCTraitsFromClaims"];
     */
    oIDCTraitsFromClaims?: LabelValues;
    /**
     * OIDCConnectorTraitMapping represents connector-specific trait mapping.
     *
     * @generated from protobuf field: repeated types.TraitMapping OIDCConnectorTraitMapping = 25 [json_name = "OIDCConnectorTraitMapping"];
     */
    oIDCConnectorTraitMapping: TraitMapping[];
    /**
     * GithubClaims represents Github user information obtained during OAuth2 flow.
     *
     * @generated from protobuf field: types.GithubClaims GithubClaims = 30 [json_name = "GithubClaims"];
     */
    githubClaims?: GithubClaims;
    /**
     * GithubTeamsToLogins is TeamsToLogins mapping from Github connector used in the SSO flow.
     *
     * @generated from protobuf field: repeated types.TeamMapping GithubTeamsToLogins = 31 [json_name = "GithubTeamsToLogins"];
     */
    githubTeamsToLogins: TeamMapping[];
    /**
     * GithubTeamsToRoles is TeamRolesMapping mapping from Github connector used in the SSO flow.
     *
     * @generated from protobuf field: repeated types.TeamRolesMapping GithubTeamsToRoles = 32 [json_name = "GithubTeamsToRoles"];
     */
    githubTeamsToRoles: TeamRolesMapping[];
    /**
     * GithubTokenInfo stores diagnostic info about Github OAuth2 token obtained during SSO flow.
     *
     * @generated from protobuf field: types.GithubTokenInfo GithubTokenInfo = 33 [json_name = "GithubTokenInfo"];
     */
    githubTokenInfo?: GithubTokenInfo;
    /**
     * AppliedLoginRules stores the name of each login rule that was applied.
     *
     * @generated from protobuf field: repeated string AppliedLoginRules = 34 [json_name = "AppliedLoginRules"];
     */
    appliedLoginRules: string[];
}
/**
 * GithubTokenInfo stores diagnostic info about Github OAuth2 token obtained during SSO flow.
 * The token itself is secret and therefore not included.
 *
 * @generated from protobuf message types.GithubTokenInfo
 */
export interface GithubTokenInfo {
    /**
     * @generated from protobuf field: string TokenType = 1 [json_name = "TokenType"];
     */
    tokenType: string;
    /**
     * @generated from protobuf field: int64 Expires = 2 [json_name = "Expires"];
     */
    expires: bigint;
    /**
     * @generated from protobuf field: string Scope = 3 [json_name = "Scope"];
     */
    scope: string;
}
/**
 * GithubClaims represents Github user information obtained during OAuth2 flow
 *
 * @generated from protobuf message types.GithubClaims
 */
export interface GithubClaims {
    /**
     * Username is the user's username
     *
     * @generated from protobuf field: string Username = 1 [json_name = "Username"];
     */
    username: string;
    /**
     * OrganizationToTeams is the user's organization and team membership
     *
     * @generated from protobuf field: wrappers.LabelValues OrganizationToTeams = 2 [json_name = "OrganizationToTeams"];
     */
    organizationToTeams?: LabelValues;
    /**
     * Teams is the users team membership
     *
     * @generated from protobuf field: repeated string Teams = 3 [json_name = "Teams"];
     */
    teams: string[];
    /**
     * UserID is a global unique integer that is assigned to each GitHub user. The
     * user ID is immutable (unlike the GitHub username) and can be found in APIs
     * like get user.
     * https://docs.github.com/en/rest/users/users
     *
     * @generated from protobuf field: string UserID = 4 [json_name = "UserID"];
     */
    userID: string;
}
/**
 * TeamMapping represents a single team membership mapping.
 *
 * DELETE IN 11.0.0
 *
 * @generated from protobuf message types.TeamMapping
 */
export interface TeamMapping {
    /**
     * Organization is a Github organization a user belongs to.
     *
     * @generated from protobuf field: string Organization = 1 [json_name = "Organization"];
     */
    organization: string;
    /**
     * Team is a team within the organization a user belongs to.
     *
     * @generated from protobuf field: string Team = 2 [json_name = "Team"];
     */
    team: string;
    /**
     * Logins is a list of allowed logins for this org/team.
     *
     * @generated from protobuf field: repeated string Logins = 3 [json_name = "Logins"];
     */
    logins: string[];
    /**
     * KubeGroups is a list of allowed kubernetes groups for this org/team.
     *
     * @generated from protobuf field: repeated string KubeGroups = 4 [json_name = "KubeGroups"];
     */
    kubeGroups: string[];
    /**
     * KubeUsers is a list of allowed kubernetes users to impersonate for this org/team.
     *
     * @generated from protobuf field: repeated string KubeUsers = 5 [json_name = "KubeUsers"];
     */
    kubeUsers: string[];
}
/**
 * TeamRolesMapping represents a single team membership mapping.
 *
 * @generated from protobuf message types.TeamRolesMapping
 */
export interface TeamRolesMapping {
    /**
     * Organization is a Github organization a user belongs to.
     *
     * @generated from protobuf field: string Organization = 1 [json_name = "Organization"];
     */
    organization: string;
    /**
     * Team is a team within the organization a user belongs to.
     *
     * @generated from protobuf field: string Team = 2 [json_name = "Team"];
     */
    team: string;
    /**
     * Roles is a list of allowed logins for this org/team.
     *
     * @generated from protobuf field: repeated string Roles = 3 [json_name = "Roles"];
     */
    roles: string[];
}
/**
 * TrustedClusterV2 represents a Trusted Cluster.
 *
 * @generated from protobuf message types.TrustedClusterV2
 */
export interface TrustedClusterV2 {
    /**
     * Kind is a resource kind.
     *
     * @generated from protobuf field: string Kind = 1 [json_name = "Kind"];
     */
    kind: string;
    /**
     * SubKind is an optional resource sub kind, used in some resources.
     *
     * @generated from protobuf field: string SubKind = 2 [json_name = "SubKind"];
     */
    subKind: string;
    /**
     * Version is the resource version. It must be specified.
     * Supported values are: `v2`.
     *
     * @generated from protobuf field: string Version = 3 [json_name = "Version"];
     */
    version: string;
    /**
     * Metadata holds resource metadata.
     *
     * @generated from protobuf field: types.Metadata Metadata = 4 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Spec is a Trusted Cluster specification.
     *
     * @generated from protobuf field: types.TrustedClusterSpecV2 Spec = 5 [json_name = "Spec"];
     */
    spec?: TrustedClusterSpecV2;
}
/**
 * TrustedClusterV2List is a list of trusted cluster.
 *
 * @generated from protobuf message types.TrustedClusterV2List
 */
export interface TrustedClusterV2List {
    /**
     * TrustedClusters is a list of trusted cluster.
     *
     * @generated from protobuf field: repeated types.TrustedClusterV2 TrustedClusters = 1 [json_name = "TrustedClusters"];
     */
    trustedClusters: TrustedClusterV2[];
}
/**
 * TrustedClusterSpecV2 is a Trusted Cluster specification.
 *
 * @generated from protobuf message types.TrustedClusterSpecV2
 */
export interface TrustedClusterSpecV2 {
    /**
     * Enabled is a bool that indicates if the TrustedCluster is enabled or disabled.
     * Setting Enabled to false has a side effect of deleting the user and host certificate
     * authority (CA).
     *
     * @generated from protobuf field: bool Enabled = 1 [json_name = "Enabled"];
     */
    enabled: boolean;
    /**
     * Roles is a list of roles that users will be assuming when connecting to this cluster.
     *
     * @generated from protobuf field: repeated string Roles = 2 [json_name = "Roles"];
     */
    roles: string[];
    /**
     * Token is the authorization token provided by another cluster needed by this cluster to join.
     *
     * @generated from protobuf field: string Token = 3 [json_name = "Token"];
     */
    token: string;
    /**
     * ProxyAddress is the address of the web proxy server of the cluster to join. If not set,
     * it is derived from `<metadata.name>:<default web proxy server port>`.
     *
     * @generated from protobuf field: string ProxyAddress = 4 [json_name = "ProxyAddress"];
     */
    proxyAddress: string;
    /**
     * ReverseTunnelAddress is the address of the SSH proxy server of the cluster to join. If
     * not set, it is derived from `<metadata.name>:<default reverse tunnel port>`.
     *
     * @generated from protobuf field: string ReverseTunnelAddress = 5 [json_name = "ReverseTunnelAddress"];
     */
    reverseTunnelAddress: string;
    /**
     * RoleMap specifies role mappings to remote roles.
     *
     * @generated from protobuf field: repeated types.RoleMapping RoleMap = 6 [json_name = "RoleMap"];
     */
    roleMap: RoleMapping[];
}
/**
 * LockV2 represents a lock.
 * Locks are used to restrict access to a Teleport environment by disabling
 * interactions involving a user, an RBAC role, a node, etc.
 * See rfd/0009-locking.md for more details.
 *
 * @generated from protobuf message types.LockV2
 */
export interface LockV2 {
    /**
     * Kind is a resource kind.
     *
     * @generated from protobuf field: string Kind = 1 [json_name = "Kind"];
     */
    kind: string;
    /**
     * SubKind is an optional resource sub kind, used in some resources.
     *
     * @generated from protobuf field: string SubKind = 2 [json_name = "SubKind"];
     */
    subKind: string;
    /**
     * Version is the resource version. It must be specified.
     * Supported values are: `v2`.
     *
     * @generated from protobuf field: string Version = 3 [json_name = "Version"];
     */
    version: string;
    /**
     * Metadata holds resource metadata.
     *
     * @generated from protobuf field: types.Metadata Metadata = 4 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Spec is a Lock specification.
     *
     * @generated from protobuf field: types.LockSpecV2 Spec = 5 [json_name = "Spec"];
     */
    spec?: LockSpecV2;
}
/**
 * LockSpecV2 is a Lock specification.
 *
 * @generated from protobuf message types.LockSpecV2
 */
export interface LockSpecV2 {
    /**
     * Target describes the set of interactions that the lock applies to.
     *
     * @generated from protobuf field: types.LockTarget Target = 1 [json_name = "Target"];
     */
    target?: LockTarget;
    /**
     * Message is the message displayed to locked-out users.
     *
     * @generated from protobuf field: string Message = 2 [json_name = "Message"];
     */
    message: string;
    /**
     * Expires if set specifies when the lock ceases to be in force.
     *
     * @generated from protobuf field: google.protobuf.Timestamp Expires = 3 [json_name = "Expires"];
     */
    expires?: Timestamp;
    /**
     * CreatedAt is the date time that the lock was created.
     *
     * @generated from protobuf field: google.protobuf.Timestamp CreatedAt = 4 [json_name = "CreatedAt"];
     */
    createdAt?: Timestamp;
    /**
     * CreatedBy is the username of the author of the lock.
     *
     * @generated from protobuf field: string CreatedBy = 5 [json_name = "CreatedBy"];
     */
    createdBy: string;
}
/**
 * LockTarget lists the attributes of interactions to be disabled.
 *
 * @generated from protobuf message types.LockTarget
 */
export interface LockTarget {
    /**
     * User specifies the name of a Teleport user.
     *
     * @generated from protobuf field: string User = 1 [json_name = "User"];
     */
    user: string;
    /**
     * Role specifies the name of an RBAC role known to the root cluster.
     * In remote clusters, this constraint is evaluated before translating to local roles.
     *
     * @generated from protobuf field: string Role = 2 [json_name = "Role"];
     */
    role: string;
    /**
     * Login specifies the name of a local UNIX user.
     *
     * @generated from protobuf field: string Login = 3 [json_name = "Login"];
     */
    login: string;
    /**
     * MFADevice specifies the UUID of a user MFA device.
     *
     * @generated from protobuf field: string MFADevice = 5 [json_name = "MFADevice"];
     */
    mFADevice: string;
    /**
     * WindowsDesktop specifies the name of a Windows desktop.
     *
     * @generated from protobuf field: string WindowsDesktop = 6 [json_name = "WindowsDesktop"];
     */
    windowsDesktop: string;
    /**
     * AccessRequest specifies the UUID of an access request.
     *
     * @generated from protobuf field: string AccessRequest = 7 [json_name = "AccessRequest"];
     */
    accessRequest: string;
    /**
     * Device is the device ID of a trusted device.
     * Requires Teleport Enterprise.
     *
     * @generated from protobuf field: string Device = 8 [json_name = "Device"];
     */
    device: string;
    /**
     * ServerID is the host id of the Teleport instance.
     *
     * @generated from protobuf field: string ServerID = 9 [json_name = "ServerID"];
     */
    serverID: string;
}
/**
 * AddressCondition represents a set of addresses. Presently the addresses are specified
 * exclusively in terms of IPv4/IPv6 ranges.
 *
 * @generated from protobuf message types.AddressCondition
 */
export interface AddressCondition {
    /**
     * CIDR is IPv4 or IPv6 address. Valid value are either CIDR ranges (e.g. "10.0.1.0/24",
     * "fe::/8") or a single IP address (e.g "10.1.2.3")
     *
     * @generated from protobuf field: string CIDR = 1 [json_name = "CIDR"];
     */
    cIDR: string;
}
/**
 * @generated from protobuf message types.NetworkRestrictionsSpecV4
 */
export interface NetworkRestrictionsSpecV4 {
    /**
     * Allow lists the addresses that should be allowed.
     *
     * @generated from protobuf field: repeated types.AddressCondition Allow = 1 [json_name = "Allow"];
     */
    allow: AddressCondition[];
    /**
     * Deny lists the addresses that should be denied even if they're allowed by Allow condition.
     *
     * @generated from protobuf field: repeated types.AddressCondition Deny = 2 [json_name = "Deny"];
     */
    deny: AddressCondition[];
}
/**
 * NetworkRestrictions specifies a list of addresses to restrict (block). The deny
 * list is checked first and the allow lists overrides it. Thus an empty allow
 * list does not mean that no addresses will be allowed, that will only be the
 * case if the deny list covers the whole address range.
 *
 * @generated from protobuf message types.NetworkRestrictionsV4
 */
export interface NetworkRestrictionsV4 {
    /**
     * Kind is the network restrictions resource kind.
     *
     * @generated from protobuf field: string Kind = 1 [json_name = "Kind"];
     */
    kind: string;
    /**
     * SubKind is an optional resource subkind.
     *
     * @generated from protobuf field: string SubKind = 2 [json_name = "SubKind"];
     */
    subKind: string;
    /**
     * Version is the resource version.
     *
     * @generated from protobuf field: string Version = 3 [json_name = "Version"];
     */
    version: string;
    /**
     * Metadata is the network restrictions metadata.
     *
     * @generated from protobuf field: types.Metadata Metadata = 4 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Spec contains the network restrictions data
     *
     * @generated from protobuf field: types.NetworkRestrictionsSpecV4 Spec = 5 [json_name = "Spec"];
     */
    spec?: NetworkRestrictionsSpecV4;
}
/**
 * WindowsDesktopServiceV3 represents a windows desktop access service.
 *
 * @generated from protobuf message types.WindowsDesktopServiceV3
 */
export interface WindowsDesktopServiceV3 {
    /**
     * Header is the common resource header.
     *
     * @generated from protobuf field: types.ResourceHeader Header = 1 [json_name = "Header"];
     */
    header?: ResourceHeader;
    /**
     * Spec is the windows desktop service spec.
     *
     * @generated from protobuf field: types.WindowsDesktopServiceSpecV3 Spec = 2 [json_name = "Spec"];
     */
    spec?: WindowsDesktopServiceSpecV3;
}
/**
 * WindowsDesktopServiceSpecV3 is the windows desktop service spec.
 *
 * @generated from protobuf message types.WindowsDesktopServiceSpecV3
 */
export interface WindowsDesktopServiceSpecV3 {
    /**
     * Addr is the address that this service can be reached at.
     *
     * @generated from protobuf field: string Addr = 1 [json_name = "Addr"];
     */
    addr: string;
    /**
     * TeleportVersion is teleport binary version running this service.
     *
     * @generated from protobuf field: string TeleportVersion = 2 [json_name = "TeleportVersion"];
     */
    teleportVersion: string;
    /**
     * Hostname is the desktop service hostname.
     *
     * @generated from protobuf field: string Hostname = 3 [json_name = "Hostname"];
     */
    hostname: string;
    /**
     * ProxyIDs is a list of proxy IDs this server is expected to be connected to.
     *
     * @generated from protobuf field: repeated string ProxyIDs = 4 [json_name = "ProxyIDs"];
     */
    proxyIDs: string[];
}
/**
 * WindowsDesktopFilter are filters to apply when searching for windows desktops.
 *
 * @generated from protobuf message types.WindowsDesktopFilter
 */
export interface WindowsDesktopFilter {
    /**
     * HostID is the ID of the host the Windows Desktop Service proxying the desktop.
     *
     * @generated from protobuf field: string HostID = 1 [json_name = "HostID"];
     */
    hostID: string;
    /**
     * Name is the name of the desktop.
     *
     * @generated from protobuf field: string Name = 2 [json_name = "Name"];
     */
    name: string;
}
/**
 * WindowsDesktopV3 represents a Windows host for desktop access.
 *
 * @generated from protobuf message types.WindowsDesktopV3
 */
export interface WindowsDesktopV3 {
    /**
     * Header is the common resource header.
     *
     * @generated from protobuf field: types.ResourceHeader Header = 1 [json_name = "Header"];
     */
    header?: ResourceHeader;
    /**
     * Spec is the Windows host spec.
     *
     * @generated from protobuf field: types.WindowsDesktopSpecV3 Spec = 2 [json_name = "Spec"];
     */
    spec?: WindowsDesktopSpecV3;
}
/**
 * WindowsDesktopSpecV3 is the Windows host spec.
 *
 * @generated from protobuf message types.WindowsDesktopSpecV3
 */
export interface WindowsDesktopSpecV3 {
    /**
     * Addr is the address that this host can be reached at.
     *
     * @generated from protobuf field: string Addr = 1 [json_name = "Addr"];
     */
    addr: string;
    /**
     * Domain is the ActiveDirectory domain that this host belongs to.
     *
     * @generated from protobuf field: string Domain = 2 [json_name = "Domain"];
     */
    domain: string;
    /**
     * HostID is the ID of the host the Windows Desktop Service proxying the desktop.
     *
     * @generated from protobuf field: string HostID = 3 [json_name = "HostID"];
     */
    hostID: string;
    /**
     * NonAD marks this desktop as a standalone host that is
     * not joined to an Active Directory domain.
     *
     * @generated from protobuf field: bool NonAD = 4 [json_name = "NonAD"];
     */
    nonAD: boolean;
    /**
     * ScreenSize specifies the size of the screen to use for sessions
     * on this host. In most cases this should be unspecified, in which
     * case Teleport will fill the browser window.
     *
     * @generated from protobuf field: types.Resolution ScreenSize = 5 [json_name = "ScreenSize"];
     */
    screenSize?: Resolution;
}
/**
 * DynamicWindowsDesktopV1 represents a dynamic windows host for desktop access.
 *
 * @generated from protobuf message types.DynamicWindowsDesktopV1
 */
export interface DynamicWindowsDesktopV1 {
    /**
     * Header is the common resource header.
     *
     * @generated from protobuf field: types.ResourceHeader Header = 1 [json_name = "Header"];
     */
    header?: ResourceHeader;
    /**
     * Spec is the DynamicWindows host spec.
     *
     * @generated from protobuf field: types.DynamicWindowsDesktopSpecV1 Spec = 2 [json_name = "Spec"];
     */
    spec?: DynamicWindowsDesktopSpecV1;
}
/**
 * DynamicWindowsDesktopSpecV1 is the dynamic windows host spec.
 *
 * @generated from protobuf message types.DynamicWindowsDesktopSpecV1
 */
export interface DynamicWindowsDesktopSpecV1 {
    /**
     * Addr is the address that this host can be reached at.
     *
     * @generated from protobuf field: string Addr = 1 [json_name = "Addr"];
     */
    addr: string;
    /**
     * Domain is the ActiveDirectory domain that this host belongs to.
     *
     * @generated from protobuf field: string Domain = 2 [json_name = "Domain"];
     */
    domain: string;
    /**
     * NonAD marks this desktop as a standalone host that is
     * not joined to an Active Directory domain.
     *
     * @generated from protobuf field: bool NonAD = 4 [json_name = "NonAD"];
     */
    nonAD: boolean;
    /**
     * ScreenSize specifies the size of the screen to use for sessions
     * on this host. In most cases this should be unspecified, in which
     * case Teleport will fill the browser window.
     *
     * @generated from protobuf field: types.Resolution ScreenSize = 5 [json_name = "ScreenSize"];
     */
    screenSize?: Resolution;
}
/**
 * @generated from protobuf message types.Resolution
 */
export interface Resolution {
    /**
     * @generated from protobuf field: uint32 Width = 1 [json_name = "Width"];
     */
    width: number;
    /**
     * @generated from protobuf field: uint32 Height = 2 [json_name = "Height"];
     */
    height: number;
}
/**
 * RegisterUsingTokenRequest is a request to register with the Auth Service using
 * an authentication token
 *
 * @generated from protobuf message types.RegisterUsingTokenRequest
 */
export interface RegisterUsingTokenRequest {
    /**
     * HostID is a unique host ID, usually a UUID
     *
     * @generated from protobuf field: string HostID = 1 [json_name = "HostID"];
     */
    hostID: string;
    /**
     * NodeName is a node name
     *
     * @generated from protobuf field: string NodeName = 2 [json_name = "NodeName"];
     */
    nodeName: string;
    /**
     * Role is a system role, e.g. Proxy
     *
     * @generated from protobuf field: string Role = 3 [json_name = "Role"];
     */
    role: string;
    /**
     * Token is the name of an authentication token
     *
     * @generated from protobuf field: string Token = 4 [json_name = "Token"];
     */
    token: string;
    /**
     * AdditionalPrincipals is a list of additional principals
     *
     * @generated from protobuf field: repeated string AdditionalPrincipals = 5 [json_name = "AdditionalPrincipals"];
     */
    additionalPrincipals: string[];
    /**
     * DNSNames is a list of DNS names to include in the x509 client certificate
     *
     * @generated from protobuf field: repeated string DNSNames = 6 [json_name = "DNSNames"];
     */
    dNSNames: string[];
    /**
     * PublicTLSKey is a PEM encoded public key
     * used for TLS setup
     *
     * @generated from protobuf field: bytes PublicTLSKey = 7 [json_name = "PublicTLSKey"];
     */
    publicTLSKey: Uint8Array;
    /**
     * PublicSSHKey is a SSH encoded public key,
     * if present will be signed as a return value
     * otherwise, new public/private key pair will be generated
     *
     * @generated from protobuf field: bytes PublicSSHKey = 8 [json_name = "PublicSSHKey"];
     */
    publicSSHKey: Uint8Array;
    /**
     * RemoteAddr is the remote address of the host requesting a host certificate.
     * It is used to replace 0.0.0.0 in the list of additional principals.
     *
     * @generated from protobuf field: string RemoteAddr = 9 [json_name = "RemoteAddr"];
     */
    remoteAddr: string;
    /**
     * EC2IdentityDocument is used for the EC2 join method to prove the identity
     * of a joining EC2 instance.
     *
     * @generated from protobuf field: bytes EC2IdentityDocument = 10 [json_name = "EC2IdentityDocument"];
     */
    eC2IdentityDocument: Uint8Array;
    /**
     * IDToken is a token provided by a workload identity provider as part of
     * OIDC join types such as GitHub.
     *
     * @generated from protobuf field: string IDToken = 11 [json_name = "IDToken"];
     */
    iDToken: string;
    /**
     * Expires is a desired time of the expiry of user certificates returned by
     * registration. This only applies to bot joining, and will be ignored by
     * node joining.
     *
     * @generated from protobuf field: google.protobuf.Timestamp Expires = 12 [json_name = "Expires"];
     */
    expires?: Timestamp;
    /**
     * BotInstanceID is a trusted instance identifier for a Machine ID bot,
     * provided when rejoining. This parameters may only be provided by the join
     * service and is ignored otherwise; bots should otherwise rejoin with their
     * existing client certificate to prove their instance identity.
     *
     * @generated from protobuf field: string BotInstanceID = 13 [json_name = "BotInstanceID"];
     */
    botInstanceID: string;
    /**
     * BotGeneration is a trusted generation counter value for Machine ID bots,
     * provided to Auth by the Join Service when bots rejoin via a streamed/gRPC
     * join method. Rejoining bots supply this value via a client certificate
     * extension; it is ignored from other sources.
     *
     * @generated from protobuf field: int32 BotGeneration = 14 [json_name = "BotGeneration"];
     */
    botGeneration: number;
}
/**
 * RecoveryCodes holds a user's recovery code information. Recovery codes allows users to regain
 * access to their account by restoring their lost password or multi-factor. Once a recovery code
 * is successfully verified, the code is mark used (which invalidates it), and lets the user begin
 * the recovery flow. When a user successfully finishes the recovery flow, users will get a new set
 * of codes that will replace all the previous ones.
 *
 * @generated from protobuf message types.RecoveryCodesV1
 */
export interface RecoveryCodesV1 {
    /**
     * Kind is the resource kind.
     *
     * @generated from protobuf field: string Kind = 1 [json_name = "Kind"];
     */
    kind: string;
    /**
     * SubKind is an optional resource subkind. Currently unused for this resource.
     *
     * @generated from protobuf field: string SubKind = 2 [json_name = "SubKind"];
     */
    subKind: string;
    /**
     * Version is the resource version.
     *
     * @generated from protobuf field: string Version = 3 [json_name = "Version"];
     */
    version: string;
    /**
     * Metadata is the resource metadata.
     *
     * @generated from protobuf field: types.Metadata Metadata = 4 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Spec is the resource spec.
     *
     * @generated from protobuf field: types.RecoveryCodesSpecV1 Spec = 5 [json_name = "Spec"];
     */
    spec?: RecoveryCodesSpecV1;
}
/**
 * RecoveryCodesSpecV1 is the recovery codes spec.
 *
 * @generated from protobuf message types.RecoveryCodesSpecV1
 */
export interface RecoveryCodesSpecV1 {
    /**
     * Codes hold a list of numOfRecoveryCodes.
     *
     * @generated from protobuf field: repeated types.RecoveryCode Codes = 1 [json_name = "Codes"];
     */
    codes: RecoveryCode[];
    /**
     * Created is when the set of recovery codes were generated. Updated when a new set of recovery
     * codes are inserted.
     *
     * @generated from protobuf field: google.protobuf.Timestamp Created = 2 [json_name = "Created"];
     */
    created?: Timestamp;
}
/**
 * RecoveryCode describes a recovery code.
 *
 * @generated from protobuf message types.RecoveryCode
 */
export interface RecoveryCode {
    /**
     * HashedCode is a bcrypt hash of this recovery code.
     *
     * @generated from protobuf field: bytes HashedCode = 1 [json_name = "HashedCode"];
     */
    hashedCode: Uint8Array;
    /**
     * IsUsed determines if this recovery code was used.
     *
     * @generated from protobuf field: bool IsUsed = 2 [json_name = "IsUsed"];
     */
    isUsed: boolean;
}
/**
 * @generated from protobuf message types.NullableSessionState
 */
export interface NullableSessionState {
    /**
     * @generated from protobuf field: types.SessionState State = 1 [json_name = "State"];
     */
    state: SessionState;
}
/**
 * SessionTrackerFilter are filters to apply when searching for session trackers.
 *
 * @generated from protobuf message types.SessionTrackerFilter
 */
export interface SessionTrackerFilter {
    /**
     * Kind describes what kind of session this is.
     *
     * @generated from protobuf field: string Kind = 1 [json_name = "Kind"];
     */
    kind: string;
    /**
     * State is the current state of this session.
     *
     * @generated from protobuf field: types.NullableSessionState State = 2 [json_name = "State"];
     */
    state?: NullableSessionState;
    /**
     * DesktopName is the windows desktop server this session belongs to.
     *
     * @generated from protobuf field: string DesktopName = 3 [json_name = "DesktopName"];
     */
    desktopName: string;
}
/**
 * SessionTrackerV1 represents a live session resource.
 *
 * @generated from protobuf message types.SessionTrackerV1
 */
export interface SessionTrackerV1 {
    /**
     * Header is the common resource header.
     *
     * @generated from protobuf field: types.ResourceHeader Header = 1 [json_name = "Header"];
     */
    header?: ResourceHeader;
    /**
     * Spec is a session specification.
     *
     * @generated from protobuf field: types.SessionTrackerSpecV1 Spec = 2 [json_name = "Spec"];
     */
    spec?: SessionTrackerSpecV1;
}
/**
 * SessionTrackerSpecV1 is the specification for a live session.
 *
 * @generated from protobuf message types.SessionTrackerSpecV1
 */
export interface SessionTrackerSpecV1 {
    /**
     * SessionID is unique identifier of this session.
     *
     * @generated from protobuf field: string SessionID = 1 [json_name = "SessionID"];
     */
    sessionID: string;
    /**
     * Kind describes what kind of session this is.
     *
     * @generated from protobuf field: string Kind = 2 [json_name = "Kind"];
     */
    kind: string;
    /**
     * State is the current state of this session.
     *
     * @generated from protobuf field: types.SessionState State = 3 [json_name = "State"];
     */
    state: SessionState;
    /**
     * Created encodes the time at which the session was registered with the auth
     * server.
     *
     * This should match the timestamp in the corresponding `session.create` event.
     * It's thus up to the tracker creator to set the correct timestamp.
     *
     * @generated from protobuf field: google.protobuf.Timestamp Created = 4 [json_name = "Created"];
     */
    created?: Timestamp;
    /**
     * Expires encodes the time at which this session expires and becomes invalid.
     *
     * @generated from protobuf field: google.protobuf.Timestamp Expires = 5 [json_name = "Expires"];
     */
    expires?: Timestamp;
    /**
     * AttachedData is arbitrary attached JSON serialized metadata.
     *
     * @generated from protobuf field: string AttachedData = 6 [json_name = "AttachedData"];
     */
    attachedData: string;
    /**
     * Reason is an arbitrary string that may be used to describe the session and/or it's
     * purpose.
     *
     * @generated from protobuf field: string Reason = 7 [json_name = "Reason"];
     */
    reason: string;
    /**
     * Invited is a list of invited users, this field can be used by
     * clients to deliver notifications to invited users.
     *
     * @generated from protobuf field: repeated string Invited = 8 [json_name = "Invited"];
     */
    invited: string[];
    /**
     * Hostname identifies the target this session is connected to.
     *
     * @generated from protobuf field: string Hostname = 9 [json_name = "Hostname"];
     */
    hostname: string;
    /**
     * Address is the address of the target this session is connected to.
     *
     * @generated from protobuf field: string Address = 10 [json_name = "Address"];
     */
    address: string;
    /**
     * ClusterName is the name of the Teleport cluster that this session belongs to.
     *
     * @generated from protobuf field: string ClusterName = 11 [json_name = "ClusterName"];
     */
    clusterName: string;
    /**
     * Login is the local login/user on the target used by the session.
     *
     * @generated from protobuf field: string Login = 12 [json_name = "Login"];
     */
    login: string;
    /**
     * Participants is a list of session participants.
     *
     * @generated from protobuf field: repeated types.Participant Participants = 13 [json_name = "Participants"];
     */
    participants: Participant[];
    /**
     * The Kubernetes cluster this session belongs to.
     *
     * @generated from protobuf field: string KubernetesCluster = 14 [json_name = "KubernetesCluster"];
     */
    kubernetesCluster: string;
    /**
     * HostUser is the user regarded as the owner of this session, RBAC checks are performed
     * against the require policies of this user.
     *
     * This refers to the Teleport user but may not be the same as the sessions initiator.
     *
     * @generated from protobuf field: string HostUser = 15 [json_name = "HostUser"];
     */
    hostUser: string;
    /**
     * HostPolicies is a list of RBAC policy sets held by the host user at the time of session
     * creation.
     *
     * @generated from protobuf field: repeated types.SessionTrackerPolicySet HostPolicies = 16 [json_name = "HostPolicies"];
     */
    hostPolicies: SessionTrackerPolicySet[];
    /**
     * DatabaseName is the database server this session belongs to.
     *
     * @generated from protobuf field: string DatabaseName = 17 [json_name = "DatabaseName"];
     */
    databaseName: string;
    /**
     * AppName is the app server this session belongs to.
     *
     * @generated from protobuf field: string AppName = 18 [json_name = "AppName"];
     */
    appName: string;
    /**
     * AppSessionID is the unique ID of the app access certificate used to start this app session.
     *
     * @generated from protobuf field: string AppSessionID = 19 [json_name = "AppSessionID"];
     */
    appSessionID: string;
    /**
     * DesktopName is the windows desktop server this session belongs to.
     *
     * @generated from protobuf field: string DesktopName = 20 [json_name = "DesktopName"];
     */
    desktopName: string;
    /**
     * HostID is the target host id that created the session tracker.
     * It's useful for Kubernetes moderated sessions when running in high availabilty
     * otherwise kube proxy is not able to know which agent runs the session.
     *
     * @generated from protobuf field: string HostID = 21 [json_name = "HostID"];
     */
    hostID: string;
    /**
     * TargetSubKind is the sub kind of the target server.
     *
     * @generated from protobuf field: string TargetSubKind = 22 [json_name = "TargetSubKind"];
     */
    targetSubKind: string;
    /**
     * InitialCommand is the command that was executed to start this session.
     *
     * @generated from protobuf field: repeated string InitialCommand = 23 [json_name = "InitialCommand"];
     */
    initialCommand: string[];
}
/**
 * SessionTrackerPolicySet is a set of RBAC policies held by the session tracker
 * that contain additional metadata from the originating role.
 *
 * @generated from protobuf message types.SessionTrackerPolicySet
 */
export interface SessionTrackerPolicySet {
    /**
     * Name is name of the role this policy set originates from.
     *
     * @generated from protobuf field: string Name = 1 [json_name = "Name"];
     */
    name: string;
    /**
     * Version is version of the role this policy set originates from.
     *
     * @generated from protobuf field: string Version = 2 [json_name = "Version"];
     */
    version: string;
    /**
     * RequireSessionJoin specifies policies for required users to start a session.
     *
     * @generated from protobuf field: repeated types.SessionRequirePolicy RequireSessionJoin = 3 [json_name = "RequireSessionJoin"];
     */
    requireSessionJoin: SessionRequirePolicy[];
}
/**
 * Participant stores information about a participant in the session.
 *
 * @generated from protobuf message types.Participant
 */
export interface Participant {
    /**
     * ID is a unique UUID of this participant for a given session.
     *
     * @generated from protobuf field: string ID = 1 [json_name = "ID"];
     */
    iD: string;
    /**
     * User is the canonical name of the Teleport user controlling this participant.
     *
     * @generated from protobuf field: string User = 2 [json_name = "User"];
     */
    user: string;
    /**
     * Mode is the participant mode.
     *
     * @generated from protobuf field: string Mode = 3 [json_name = "Mode"];
     */
    mode: string;
    /**
     * LastActive is the last time this party was active in the session.
     *
     * @generated from protobuf field: google.protobuf.Timestamp LastActive = 4 [json_name = "LastActive"];
     */
    lastActive?: Timestamp;
}
/**
 * UIConfigV1 represents the configuration for the web UI served by the proxy service
 *
 * @generated from protobuf message types.UIConfigV1
 */
export interface UIConfigV1 {
    /**
     * Header is the resource header for the UI configuration.
     *
     * @generated from protobuf field: types.ResourceHeader Header = 1 [json_name = "Header"];
     */
    header?: ResourceHeader;
    /**
     * Spec is the resource spec.
     *
     * @generated from protobuf field: types.UIConfigSpecV1 Spec = 5 [json_name = "Spec"];
     */
    spec?: UIConfigSpecV1;
}
/**
 * UIConfigSpecV1 is the specification for a UIConfig
 *
 * @generated from protobuf message types.UIConfigSpecV1
 */
export interface UIConfigSpecV1 {
    /**
     * ScrollbackLines is the max number of lines the UI terminal can display in its history.
     *
     * @generated from protobuf field: int32 ScrollbackLines = 1 [json_name = "ScrollbackLines"];
     */
    scrollbackLines: number;
    /**
     * ShowResources determines which resources are shown in the web UI. Default if unset is "requestable"
     * which means resources the user has access to and resources they can request will be shown in the
     * resources UI. If set to `accessible_only`, only resources the user already has access to will be shown.
     *
     * @generated from protobuf field: string ShowResources = 2 [json_name = "ShowResources"];
     */
    showResources: string;
}
/**
 * InstallerV1 represents an installer script resource. Used to
 * provide a script to install teleport on discovered nodes.
 *
 * @generated from protobuf message types.InstallerV1
 */
export interface InstallerV1 {
    /**
     * Kind is the resource kind.
     *
     * @generated from protobuf field: string Kind = 1 [json_name = "Kind"];
     */
    kind: string;
    /**
     * SubKind is an optional resource subkind. Currently unused for this resource.
     *
     * @generated from protobuf field: string SubKind = 2 [json_name = "SubKind"];
     */
    subKind: string;
    /**
     * Version is the resource version.
     *
     * @generated from protobuf field: string Version = 3 [json_name = "Version"];
     */
    version: string;
    /**
     * Metadata is the resource metadata.
     *
     * @generated from protobuf field: types.Metadata Metadata = 4 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Spec is the resource spec.
     *
     * @generated from protobuf field: types.InstallerSpecV1 Spec = 5 [json_name = "Spec"];
     */
    spec?: InstallerSpecV1;
}
/**
 * InstallerSpecV1 is the specification for an Installer
 *
 * @generated from protobuf message types.InstallerSpecV1
 */
export interface InstallerSpecV1 {
    /**
     * Script represents the contents of a installer shell script
     *
     * @generated from protobuf field: string Script = 1 [json_name = "Script"];
     */
    script: string;
}
/**
 * InstallerV1List represents a list of installer resources.
 *
 * @generated from protobuf message types.InstallerV1List
 */
export interface InstallerV1List {
    /**
     * Installers is a list of installer resources.
     *
     * @generated from protobuf field: repeated types.InstallerV1 installers = 1;
     */
    installers: InstallerV1[];
}
/**
 * SortBy defines a sort criteria.
 *
 * @generated from protobuf message types.SortBy
 */
export interface SortBy {
    /**
     * IsDesc is a sort direction flag where if true the direction is descending, else ascending.
     *
     * @generated from protobuf field: bool IsDesc = 1 [json_name = "IsDesc"];
     */
    isDesc: boolean;
    /**
     * Field is the name of an objects field to sort by.
     *
     * @generated from protobuf field: string Field = 2 [json_name = "Field"];
     */
    field: string;
}
/**
 * ConnectionDiagnosticV1 is the result of testing a connection.
 * When setting up a new resource in Teleport, it's useful to know if we can connect to it.
 * This can be done using the test connection feature.
 * The user can then receive the result as feedback using the UI
 *
 * @generated from protobuf message types.ConnectionDiagnosticV1
 */
export interface ConnectionDiagnosticV1 {
    /**
     * @generated from protobuf field: types.ResourceHeader Header = 1 [json_name = "Header"];
     */
    header?: ResourceHeader;
    /**
     * Spec is the resource spec.
     *
     * @generated from protobuf field: types.ConnectionDiagnosticSpecV1 Spec = 5 [json_name = "Spec"];
     */
    spec?: ConnectionDiagnosticSpecV1;
}
/**
 * ConnectionDiagnosticSpecV1 is the ConnectionDiagnostic Spec.
 * It contains the result of testing a connection.
 * It has the overall result of the connection and then a list of traces.
 * Each trace contains checkpoints of the connection attempt and its result.
 *
 * @generated from protobuf message types.ConnectionDiagnosticSpecV1
 */
export interface ConnectionDiagnosticSpecV1 {
    /**
     * Success describes whether the connection was a success or a failure.
     *
     * @generated from protobuf field: bool Success = 1 [json_name = "Success"];
     */
    success: boolean;
    /**
     * Message may contain some user friendly message to let the user know whether it was
     * successful or a failure.
     *
     * @generated from protobuf field: string Message = 2 [json_name = "Message"];
     */
    message: string;
    /**
     * Traces contain a list of checkpoints defined by
     *
     * @generated from protobuf field: repeated types.ConnectionDiagnosticTrace Traces = 3 [json_name = "Traces"];
     */
    traces: ConnectionDiagnosticTrace[];
}
/**
 * ConnectionDiagnosticTrace describes a trace of a connection diagnostic
 *
 * @generated from protobuf message types.ConnectionDiagnosticTrace
 */
export interface ConnectionDiagnosticTrace {
    /**
     * @generated from protobuf field: types.ConnectionDiagnosticTrace.TraceType Type = 1 [json_name = "Type"];
     */
    type: ConnectionDiagnosticTrace_TraceType;
    /**
     * @generated from protobuf field: types.ConnectionDiagnosticTrace.StatusType Status = 2 [json_name = "Status"];
     */
    status: ConnectionDiagnosticTrace_StatusType;
    /**
     * Details contains a User friendly message of the check's result.
     *
     * @generated from protobuf field: string Details = 3 [json_name = "Details"];
     */
    details: string;
    /**
     * Error contains the low level error message in case of a failure.
     *
     * @generated from protobuf field: string Error = 4 [json_name = "Error"];
     */
    error: string;
}
/**
 * TraceType is an identification of the checkpoint.
 *
 * @generated from protobuf enum types.ConnectionDiagnosticTrace.TraceType
 */
export enum ConnectionDiagnosticTrace_TraceType {
    /**
     * @generated from protobuf enum value: TRACE_TYPE_UNSPECIFIED = 0;
     */
    TRACE_TYPE_UNSPECIFIED = 0,
    /**
     * UNKNOWN_ERROR is used when we don't know the error.
     * It's not always possible to offer guidance based on the received error.
     * This trace type should be used when the error is too generic given the context we
     * have.
     *
     * @generated from protobuf enum value: UNKNOWN_ERROR = 1;
     */
    UNKNOWN_ERROR = 1,
    /**
     * RBAC_NODE is for RBAC checks for the node.
     *
     * @generated from protobuf enum value: RBAC_NODE = 2;
     */
    RBAC_NODE = 2,
    /**
     * CONNECTIVITY is for network connectivity checks.
     *
     * @generated from protobuf enum value: CONNECTIVITY = 3;
     */
    CONNECTIVITY = 3,
    /**
     * RBAC_PRINCIPAL is used when checking if the principal is allowed per RBAC rules.
     *
     * @generated from protobuf enum value: RBAC_PRINCIPAL = 4;
     */
    RBAC_PRINCIPAL = 4,
    /**
     * NODE_PRINCIPAL is used when checking if the Node has the requested principal.
     *
     * @generated from protobuf enum value: NODE_PRINCIPAL = 5;
     */
    NODE_PRINCIPAL = 5,
    /**
     * RBAC_KUBE is for RBAC checks to kubernetes the cluster.
     *
     * @generated from protobuf enum value: RBAC_KUBE = 6;
     */
    RBAC_KUBE = 6,
    /**
     * KUBE_PRINCIPAL is used when checking if the Kube Cluster has at least one user principals.
     *
     * @generated from protobuf enum value: KUBE_PRINCIPAL = 7;
     */
    KUBE_PRINCIPAL = 7,
    /**
     * RBAC_DATABASE is for RBAC checks to database access (db_labels).
     *
     * @generated from protobuf enum value: RBAC_DATABASE = 8;
     */
    RBAC_DATABASE = 8,
    /**
     * RBAC_DATABASE_LOGIN is for RBAC checks to database login (db_name and db_user).
     *
     * @generated from protobuf enum value: RBAC_DATABASE_LOGIN = 9;
     */
    RBAC_DATABASE_LOGIN = 9,
    /**
     * DATABASE_DB_USER is used when checking whether the Database has the requested Database User.
     *
     * @generated from protobuf enum value: DATABASE_DB_USER = 10;
     */
    DATABASE_DB_USER = 10,
    /**
     * DATABASE_DB_NAME is used when checking whether the Database has the requested Database Name.
     *
     * @generated from protobuf enum value: DATABASE_DB_NAME = 11;
     */
    DATABASE_DB_NAME = 11
}
/**
 * StatusType describes whether this was a success or a failure.
 *
 * @generated from protobuf enum types.ConnectionDiagnosticTrace.StatusType
 */
export enum ConnectionDiagnosticTrace_StatusType {
    /**
     * @generated from protobuf enum value: STATUS_UNSPECIFIED = 0;
     */
    STATUS_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: SUCCESS = 1;
     */
    SUCCESS = 1,
    /**
     * @generated from protobuf enum value: FAILED = 2;
     */
    FAILED = 2
}
/**
 * DatabaseServiceV1 is the representation of a DatabaseService (agent) process.
 *
 * @generated from protobuf message types.DatabaseServiceV1
 */
export interface DatabaseServiceV1 {
    /**
     * @generated from protobuf field: types.ResourceHeader Header = 1 [json_name = "Header"];
     */
    header?: ResourceHeader;
    /**
     * Spec is the resource spec.
     *
     * @generated from protobuf field: types.DatabaseServiceSpecV1 Spec = 2 [json_name = "Spec"];
     */
    spec?: DatabaseServiceSpecV1;
}
/**
 * DatabaseServiceSpecV1 is the DatabaseService Spec.
 *
 * @generated from protobuf message types.DatabaseServiceSpecV1
 */
export interface DatabaseServiceSpecV1 {
    /**
     * ResourceMatchers is the configured match for Database resources.
     *
     * @generated from protobuf field: repeated types.DatabaseResourceMatcher ResourceMatchers = 1 [json_name = "ResourceMatchers"];
     */
    resourceMatchers: DatabaseResourceMatcher[];
    /**
     * Hostname is the hostname where this service is running.
     *
     * @generated from protobuf field: string Hostname = 2 [json_name = "Hostname"];
     */
    hostname: string;
}
/**
 * DatabaseResourceMatcher is a set of properties that is used to match on resources.
 *
 * @generated from protobuf message types.DatabaseResourceMatcher
 */
export interface DatabaseResourceMatcher {
    /**
     * @generated from protobuf field: wrappers.LabelValues Labels = 1 [json_name = "Labels"];
     */
    labels?: LabelValues;
    /**
     * @generated from protobuf field: types.ResourceMatcherAWS AWS = 2 [json_name = "AWS"];
     */
    aWS?: ResourceMatcherAWS;
}
/**
 * ResourceMatcherAWS contains AWS specific settings for resource matcher.
 *
 * @generated from protobuf message types.ResourceMatcherAWS
 */
export interface ResourceMatcherAWS {
    /**
     * AssumeRoleARN is an optional AWS role ARN to assume when accessing a database.
     *
     * @generated from protobuf field: string AssumeRoleARN = 1 [json_name = "AssumeRoleARN"];
     */
    assumeRoleARN: string;
    /**
     * ExternalID is an optional AWS external ID used to enable assuming an AWS role across accounts.
     *
     * @generated from protobuf field: string ExternalID = 2 [json_name = "ExternalID"];
     */
    externalID: string;
}
/**
 * ClusterAlert is a cluster-level alert message.
 *
 * @generated from protobuf message types.ClusterAlert
 */
export interface ClusterAlert {
    /**
     * @generated from protobuf field: types.ResourceHeader Header = 1 [json_name = "Header"];
     */
    header?: ResourceHeader;
    /**
     * @generated from protobuf field: types.ClusterAlertSpec Spec = 2 [json_name = "Spec"];
     */
    spec?: ClusterAlertSpec;
}
/**
 * ClusterAlertSpec is a cluster alert specification.
 *
 * @generated from protobuf message types.ClusterAlertSpec
 */
export interface ClusterAlertSpec {
    /**
     * Severity represents how problematic/urgent the alert is.
     *
     * @generated from protobuf field: types.AlertSeverity Severity = 1 [json_name = "Severity"];
     */
    severity: AlertSeverity;
    /**
     * Message is the user-facing message associated with the alert.
     *
     * @generated from protobuf field: string Message = 2 [json_name = "Message"];
     */
    message: string;
    /**
     * Created is the time at which the alert was generated.
     *
     * @generated from protobuf field: google.protobuf.Timestamp Created = 3 [json_name = "Created"];
     */
    created?: Timestamp;
}
/**
 * GetClusterAlertsRequest matches cluster alerts.
 *
 * @generated from protobuf message types.GetClusterAlertsRequest
 */
export interface GetClusterAlertsRequest {
    /**
     * Severity is an optional minimum severity.
     *
     * @generated from protobuf field: types.AlertSeverity Severity = 1 [json_name = "Severity"];
     */
    severity: AlertSeverity;
    /**
     * AlertID optionally specifies the ID of the alert being requested.
     *
     * @generated from protobuf field: string AlertID = 2 [json_name = "AlertID"];
     */
    alertID: string;
    /**
     * Labels is an optional label selector.
     *
     * @generated from protobuf field: map<string, string> Labels = 3 [json_name = "Labels"];
     */
    labels: {
        [key: string]: string;
    };
    /**
     * WithSuperseded includes superseded alerts in the output of the request.
     *
     * @generated from protobuf field: bool WithSuperseded = 4 [json_name = "WithSuperseded"];
     */
    withSuperseded: boolean;
    /**
     * WithAcknowledged includes acknowledged alerts in the output of the request.
     *
     * @generated from protobuf field: bool WithAcknowledged = 5 [json_name = "WithAcknowledged"];
     */
    withAcknowledged: boolean;
    /**
     * WithUntargeted requests that alerts be included even if they are not specifically
     * targeted toward the caller. This has no effect unless the caller has `cluster_alert:list`.
     *
     * @generated from protobuf field: bool WithUntargeted = 6 [json_name = "WithUntargeted"];
     */
    withUntargeted: boolean;
}
/**
 * AlertAcknowledgement marks a cluster alert as having been "acknowledged".
 * This causes the alert to no longer be displayed in 'tsh login', UI banners,
 * etc. Acknowledgements must have an expiry and a message describing why the
 * alert can be considered acknowledged.
 *
 * @generated from protobuf message types.AlertAcknowledgement
 */
export interface AlertAcknowledgement {
    /**
     * AlertID is the ID of the alert being acknowledged.
     *
     * @generated from protobuf field: string AlertID = 1 [json_name = "AlertID"];
     */
    alertID: string;
    /**
     * Reason describes the reason why the alert can be considered
     * acknowledged (e.g. 'alice will fix next week').
     *
     * @generated from protobuf field: string Reason = 2 [json_name = "Reason"];
     */
    reason: string;
    /**
     * Expires is the time after which the acknowledgement expires.
     *
     * @generated from protobuf field: google.protobuf.Timestamp Expires = 4 [json_name = "Expires"];
     */
    expires?: Timestamp;
}
/**
 * Release correspond to a Teleport Enterprise releases
 *
 * @generated from protobuf message types.Release
 */
export interface Release {
    /**
     * NotesMD is the notes of the release in markdown
     *
     * @generated from protobuf field: string NotesMD = 1 [json_name = "NotesMD"];
     */
    notesMD: string;
    /**
     * Product is the release product, teleport or teleport-ent
     *
     * @generated from protobuf field: string Product = 2 [json_name = "Product"];
     */
    product: string;
    /**
     * ReleaseID is the ID of the product
     *
     * @generated from protobuf field: string ReleaseID = 3 [json_name = "ReleaseID"];
     */
    releaseID: string;
    /**
     * Status is the status of the release
     *
     * @generated from protobuf field: string Status = 4 [json_name = "Status"];
     */
    status: string;
    /**
     * Version is the version of the release
     *
     * @generated from protobuf field: string Version = 5 [json_name = "Version"];
     */
    version: string;
    /**
     * Assets is a list of assets related to the release
     *
     * @generated from protobuf field: repeated types.Asset Assets = 6 [json_name = "Assets"];
     */
    assets: Asset[];
}
/**
 * Asset represents a release asset
 *
 * @generated from protobuf message types.Asset
 */
export interface Asset {
    /**
     * Arch is the architecture of the asset
     *
     * @generated from protobuf field: string Arch = 1 [json_name = "Arch"];
     */
    arch: string;
    /**
     * Description is the description of the asset
     *
     * @generated from protobuf field: string Description = 2 [json_name = "Description"];
     */
    description: string;
    /**
     * Name is the name of the asset
     *
     * @generated from protobuf field: string Name = 3 [json_name = "Name"];
     */
    name: string;
    /**
     * OS is which OS the asset is built for
     *
     * @generated from protobuf field: string OS = 4 [json_name = "OS"];
     */
    oS: string;
    /**
     * SHA256 is the sha256 of the asset
     *
     * @generated from protobuf field: string SHA256 = 5 [json_name = "SHA256"];
     */
    sHA256: string;
    /**
     * Size is the size of the release in bytes
     *
     * @generated from protobuf field: int64 AssetSize = 6 [json_name = "AssetSize"];
     */
    assetSize: bigint;
    /**
     * DisplaySize is the human-readable size of the asset
     *
     * @generated from protobuf field: string DisplaySize = 7 [json_name = "DisplaySize"];
     */
    displaySize: string;
    /**
     * ReleaseIDs is a list of releases that have the asset included
     *
     * @generated from protobuf field: repeated string ReleaseIDs = 8 [json_name = "ReleaseIDs"];
     */
    releaseIDs: string[];
    /**
     * PublicURL is the public URL used to download the asset
     *
     * @generated from protobuf field: string PublicURL = 9 [json_name = "PublicURL"];
     */
    publicURL: string;
}
/**
 * Plugin describes a single instance of a Teleport Plugin
 *
 * @generated from protobuf message types.PluginV1
 */
export interface PluginV1 {
    /**
     * kind is the plugin resource kind.
     *
     * @generated from protobuf field: string kind = 1;
     */
    kind: string;
    /**
     * sub_kind is an optional resource subkind.
     *
     * @generated from protobuf field: string sub_kind = 2;
     */
    subKind: string;
    /**
     * version is the resource version.
     *
     * @generated from protobuf field: string version = 3;
     */
    version: string;
    /**
     * metadata is the resource metadata.
     *
     * @generated from protobuf field: types.Metadata metadata = 4;
     */
    metadata?: Metadata;
    /**
     * @generated from protobuf field: types.PluginSpecV1 spec = 5;
     */
    spec?: PluginSpecV1;
    /**
     * @generated from protobuf field: types.PluginStatusV1 status = 6;
     */
    status?: PluginStatusV1;
    /**
     * credentials are "live" credentials to the 3rd party API.
     * These are considered secrets.
     *
     * @generated from protobuf field: types.PluginCredentialsV1 credentials = 7;
     */
    credentials?: PluginCredentialsV1;
}
/**
 * @generated from protobuf message types.PluginSpecV1
 */
export interface PluginSpecV1 {
    /**
     * @generated from protobuf oneof: settings
     */
    settings: {
        oneofKind: "slackAccessPlugin";
        /**
         * Settings for the Slack access plugin
         *
         * @generated from protobuf field: types.PluginSlackAccessSettings slack_access_plugin = 1;
         */
        slackAccessPlugin: PluginSlackAccessSettings;
    } | {
        oneofKind: "opsgenie";
        /**
         * Settings for the Opsgenie access plugin
         *
         * @generated from protobuf field: types.PluginOpsgenieAccessSettings opsgenie = 2;
         */
        opsgenie: PluginOpsgenieAccessSettings;
    } | {
        oneofKind: "openai";
        /**
         * Settings for OpenAI plugin
         *
         * @generated from protobuf field: types.PluginOpenAISettings openai = 3;
         */
        openai: PluginOpenAISettings;
    } | {
        oneofKind: "okta";
        /**
         * Settings for the Okta plugin
         *
         * @generated from protobuf field: types.PluginOktaSettings okta = 4;
         */
        okta: PluginOktaSettings;
    } | {
        oneofKind: "jamf";
        /**
         * Settings for device trust jamf plugin
         *
         * @generated from protobuf field: types.PluginJamfSettings jamf = 5;
         */
        jamf: PluginJamfSettings;
    } | {
        oneofKind: "pagerDuty";
        /**
         * Settings for the PagerDuty plugin
         *
         * @generated from protobuf field: types.PluginPagerDutySettings pager_duty = 6;
         */
        pagerDuty: PluginPagerDutySettings;
    } | {
        oneofKind: "mattermost";
        /**
         * Settings for the Mattermost plugin
         *
         * @generated from protobuf field: types.PluginMattermostSettings mattermost = 7;
         */
        mattermost: PluginMattermostSettings;
    } | {
        oneofKind: "jira";
        /**
         * Settings for the JIRA plugin
         *
         * @generated from protobuf field: types.PluginJiraSettings jira = 8;
         */
        jira: PluginJiraSettings;
    } | {
        oneofKind: "discord";
        /**
         * Settings for the Discord plugin
         *
         * @generated from protobuf field: types.PluginDiscordSettings discord = 9;
         */
        discord: PluginDiscordSettings;
    } | {
        oneofKind: "serviceNow";
        /**
         * Settings for the ServiceNow plugin
         *
         * @generated from protobuf field: types.PluginServiceNowSettings serviceNow = 10;
         */
        serviceNow: PluginServiceNowSettings;
    } | {
        oneofKind: "gitlab";
        /**
         * Settings for the Gitlab plugin.
         *
         * @generated from protobuf field: types.PluginGitlabSettings gitlab = 12;
         */
        gitlab: PluginGitlabSettings;
    } | {
        oneofKind: "entraId";
        /**
         * Settings for the Entra ID plugin
         *
         * @generated from protobuf field: types.PluginEntraIDSettings entra_id = 13;
         */
        entraId: PluginEntraIDSettings;
    } | {
        oneofKind: "scim";
        /**
         * Settings for the SCIM plugin
         *
         * @generated from protobuf field: types.PluginSCIMSettings scim = 14;
         */
        scim: PluginSCIMSettings;
    } | {
        oneofKind: "datadog";
        /**
         * Settings for the Datadog Incident Management plugin
         *
         * @generated from protobuf field: types.PluginDatadogAccessSettings datadog = 15;
         */
        datadog: PluginDatadogAccessSettings;
    } | {
        oneofKind: "awsIc";
        /**
         * PluginAWSICSettings holds settings for AWSICSettings
         *
         * @generated from protobuf field: types.PluginAWSICSettings aws_ic = 16;
         */
        awsIc: PluginAWSICSettings;
    } | {
        oneofKind: "email";
        /**
         * Settings for the Email Access Request plugin
         *
         * @generated from protobuf field: types.PluginEmailSettings email = 17;
         */
        email: PluginEmailSettings;
    } | {
        oneofKind: "msteams";
        /**
         * Settings for the Microsoft Teams plugin
         *
         * @generated from protobuf field: types.PluginMSTeamsSettings msteams = 18;
         */
        msteams: PluginMSTeamsSettings;
    } | {
        oneofKind: "netIq";
        /**
         * Settings for the OpenTex NetIQ plugin.
         *
         * @generated from protobuf field: types.PluginNetIQSettings net_iq = 19;
         */
        netIq: PluginNetIQSettings;
    } | {
        oneofKind: "github";
        /**
         * Settings for the GitHub plugin.
         *
         * @generated from protobuf field: types.PluginGithubSettings github = 20;
         */
        github: PluginGithubSettings;
    } | {
        oneofKind: undefined;
    };
    /**
     * generation contains a unique ID that should:
     * - Be created by the backend on plugin creation.
     * - Be updated by the backend if the plugin is updated in any way.
     *
     * For older plugins, it's possible for this to be empty.
     *
     * @generated from protobuf field: string generation = 11;
     */
    generation: string;
}
/**
 * PluginGithubSettings defines the configuration parameters required for a plugin
 * to connect to and interact with a specific GitHub organization's API.
 *
 * @generated from protobuf message types.PluginGithubSettings
 */
export interface PluginGithubSettings {
    /**
     * Base URL for the GitHub API endpoint.
     * For GitHub Enterprise, set to your instance URL (ex.: "https://github.mycompany.com/api/v3/").
     * If empty, defaults to the public GitHub API ("https://api.github.com/").
     *
     * @generated from protobuf field: string api_endpoint = 1;
     */
    apiEndpoint: string;
    /**
     * The Client ID of the OAuth application registered with GitHub, used for API authentication.
     * ex.: "Iv1.123abc456def7890".
     *
     * @generated from protobuf field: string client_id = 2;
     */
    clientId: string;
    /**
     * The name of the GitHub organization that this plugin configuration targets.
     * ex.: "octo-org".
     *
     * @generated from protobuf field: string organization_name = 3;
     */
    organizationName: string;
    /**
     * The date from which the plugin should start fetching data (ex.: audit logs, events)
     * from GitHub for the specified organization. This field is effectively required.
     *
     * @generated from protobuf field: google.protobuf.Timestamp start_date = 4;
     */
    startDate?: Timestamp;
}
/**
 * @generated from protobuf message types.PluginSlackAccessSettings
 */
export interface PluginSlackAccessSettings {
    /**
     * @generated from protobuf field: string fallback_channel = 1;
     */
    fallbackChannel: string;
}
/**
 * @generated from protobuf message types.PluginGitlabSettings
 */
export interface PluginGitlabSettings {
    /**
     * APIEndpoint is the address of Gitlab API.
     *
     * @generated from protobuf field: string api_endpoint = 1;
     */
    apiEndpoint: string;
}
/**
 * @generated from protobuf message types.PluginOpsgenieAccessSettings
 */
export interface PluginOpsgenieAccessSettings {
    /**
     * Priority to create Opsgenie alerts with
     *
     * @generated from protobuf field: string priority = 2;
     */
    priority: string;
    /**
     * List of tags to be added to alerts created in Opsgenie
     *
     * @generated from protobuf field: repeated string alert_tags = 3;
     */
    alertTags: string[];
    /**
     * Default on-call schedules to check if none are provided in the access request annotations
     *
     * @generated from protobuf field: repeated string default_schedules = 4;
     */
    defaultSchedules: string[];
    /**
     * APIEndpoint is the address of Opsgenie API.
     *
     * @generated from protobuf field: string api_endpoint = 5;
     */
    apiEndpoint: string;
}
/**
 * PluginServiceNowSettings are the settings for the serviceNow plugin
 *
 * @generated from protobuf message types.PluginServiceNowSettings
 */
export interface PluginServiceNowSettings {
    /**
     * ApiEndpoint is the ServiceNow API endpoint.
     *
     * @generated from protobuf field: string api_endpoint = 1;
     */
    apiEndpoint: string;
    /**
     * Username is the ServiceNow API username.
     *
     * @generated from protobuf field: string username = 2;
     */
    username: string;
    /**
     * Password is the ServiceNow API password.
     *
     * @generated from protobuf field: string password = 3;
     */
    password: string;
    /**
     * CloseCode is the close code that ServiceNow incidents will use.
     *
     * @generated from protobuf field: string close_code = 4;
     */
    closeCode: string;
}
/**
 * @generated from protobuf message types.PluginPagerDutySettings
 */
export interface PluginPagerDutySettings {
    /**
     * UserEmail is the email address of the PagerDuty user that will be
     * listed as the reporter source of incidents, comments, etc
     * within PagerDuty. Should usually be the same user the API key
     * represents.
     *
     * @generated from protobuf field: string user_email = 1;
     */
    userEmail: string;
    /**
     * APIEndpoint is the address of PagerDuty API.
     *
     * @generated from protobuf field: string api_endpoint = 2;
     */
    apiEndpoint: string;
}
/**
 * @generated from protobuf message types.PluginJiraSettings
 */
export interface PluginJiraSettings {
    /**
     * ServerURL is the address of the target JIRA Server instance.
     *
     * @generated from protobuf field: string server_url = 1;
     */
    serverUrl: string;
    /**
     * ProjectKey is the key of the Jira project that will receive
     * notifications and issues from the plugin.
     *
     * @generated from protobuf field: string project_key = 2;
     */
    projectKey: string;
    /**
     * IssueType is the type of Jira Issue that the plugin will create
     *
     * @generated from protobuf field: string issue_type = 3;
     */
    issueType: string;
}
/**
 * Defines settings for the OpenAI plugin. Currently there are no settings.
 *
 * @generated from protobuf message types.PluginOpenAISettings
 */
export interface PluginOpenAISettings {
}
/**
 * Defines settings for the Mattermost plugin.
 *
 * @generated from protobuf message types.PluginMattermostSettings
 */
export interface PluginMattermostSettings {
    /**
     * serverURL is the URL to access Mattermost.
     *
     * @generated from protobuf field: string server_url = 1;
     */
    serverUrl: string;
    /**
     * team is the Mattermost workspace.
     *
     * @generated from protobuf field: string team = 2;
     */
    team: string;
    /**
     * channel is the Mattermost channel in the workspace
     * (team) to send notifications to.
     *
     * @generated from protobuf field: string channel = 3;
     */
    channel: string;
    /**
     * report_to_email is an optional email address of a Mattermost user
     * to notify via a direct message when the plugin receives an
     * Access Request event.
     *
     * @generated from protobuf field: string report_to_email = 4;
     */
    reportToEmail: string;
}
/**
 * Defines settings for Jamf plugin.
 *
 * @generated from protobuf message types.PluginJamfSettings
 */
export interface PluginJamfSettings {
    /**
     * Jamf service spec
     *
     * @generated from protobuf field: types.JamfSpecV1 jamf_spec = 1;
     */
    jamfSpec?: JamfSpecV1;
}
/**
 * Defines settings for the Okta plugin.
 *
 * @generated from protobuf message types.PluginOktaSettings
 */
export interface PluginOktaSettings {
    /**
     * OrgUrl is the Okta organization URL to use for API communication.
     *
     * @generated from protobuf field: string org_url = 1;
     */
    orgUrl: string;
    /**
     * EnableUserSync controls the user sync in the Okta integration service. Deprecated.
     * TODO(mdwn): Remove once e changes have been made.
     *
     * @generated from protobuf field: bool enable_user_sync = 2;
     */
    enableUserSync: boolean;
    /**
     * SSOConnectorID (deprecated)
     * TODO(mdwn): Remove once e changes have been made.
     *
     * @generated from protobuf field: string sso_connector_id = 3;
     */
    ssoConnectorId: string;
    /**
     * Sync settings controls the user and access list sync settings for Okta.
     *
     * @generated from protobuf field: types.PluginOktaSyncSettings sync_settings = 4;
     */
    syncSettings?: PluginOktaSyncSettings;
    /**
     * CredentialsInfo contains information about the Okta credentials.
     *
     * @generated from protobuf field: types.PluginOktaCredentialsInfo credentials_info = 5;
     */
    credentialsInfo?: PluginOktaCredentialsInfo;
    /**
     * EnableSiemIntegration enables SIEM (Security Information and Event Management).
     *
     * @generated from protobuf field: bool enable_system_log_export = 6;
     */
    enableSystemLogExport: boolean;
}
/**
 * PluginOktaCredentialsInfo contains information about the Okta credentials.
 * This is used to determine if the plugin has configured the necessary credentials.
 *
 * @generated from protobuf message types.PluginOktaCredentialsInfo
 */
export interface PluginOktaCredentialsInfo {
    /**
     * HasSSMSToken is true if the plugin has configured SSMSToken.
     *
     * @generated from protobuf field: bool has_ssm_token = 1;
     */
    hasSsmToken: boolean;
    /**
     * HasOauthCredentials is true if the plugin has configured OauthCredentials.
     *
     * @generated from protobuf field: bool has_oauth_credentials = 2;
     */
    hasOauthCredentials: boolean;
    /**
     * HasSCIMToken is true if the plugin has configured SCIMToken.
     *
     * @generated from protobuf field: bool has_scim_token = 3;
     */
    hasScimToken: boolean;
}
/**
 * Defines settings for syncing users and access lists from Okta.
 *
 * @generated from protobuf message types.PluginOktaSyncSettings
 */
export interface PluginOktaSyncSettings {
    /**
     * SyncUsers controls the user sync in the Okta integration service. The source of truth for the
     * users is defined by UserSyncSource.
     *
     * @generated from protobuf field: bool sync_users = 1;
     */
    syncUsers: boolean;
    /**
     * SSOConnectorID is the name of the Teleport SSO connector created and used by the Okta plugin
     *
     * @generated from protobuf field: string sso_connector_id = 2;
     */
    ssoConnectorId: string;
    /**
     * SyncAccessLists controls the access list sync in the Okta integration service.
     *
     * @generated from protobuf field: bool sync_access_lists = 3;
     */
    syncAccessLists: boolean;
    /**
     * DefaultOwners are the default owners for all imported access lists.
     *
     * @generated from protobuf field: repeated string default_owners = 4;
     */
    defaultOwners: string[];
    /**
     * AppID is the Okta-assigned ID of the Okta App that Teleport uses as a
     * gateway to interact with Okta for SAML login, SCIM provisioning and user
     * sync. When set, user sync will pull users from the assignment list for this
     * app.
     *
     * @generated from protobuf field: string app_id = 5;
     */
    appId: string;
    /**
     * GroupFilters are filters for which Okta groups to synchronize as access lists.
     * Filters can be globs, for example:
     *   group*
     *   *service*
     * Or regexes if they're prefixed and suffixed with ^ and $, for example:
     *   ^group.*$
     *   ^.*service.*$
     *
     * @generated from protobuf field: repeated string group_filters = 6;
     */
    groupFilters: string[];
    /**
     * AppFilters are filters for which Okta applications to synchronize as access lists.
     * Filters can be globs, for example:
     *   app*
     *   *service*
     * Or regexes if they're prefixed and suffixed with ^ and $, for example:
     *   ^app.*$
     *   ^.*service.*$
     *
     * @generated from protobuf field: repeated string app_filters = 7;
     */
    appFilters: string[];
    /**
     * AppName is the Okta-assigned unique name of the Okta App that Teleport uses
     * as a gateway to interact with Okta for SAML login, SCIM provisioning and user
     * sync.
     *
     * @generated from protobuf field: string app_name = 8;
     */
    appName: string;
    /**
     * DisableSyncAppGroups disables syncing of app groups from Okta.
     * This is useful when the app groups are not needed in Teleport.
     * and integration with Okta is only used for user sync.
     *
     * @generated from protobuf field: bool disable_sync_app_groups = 9;
     */
    disableSyncAppGroups: boolean;
    /**
     * DisableBidirectionalSync prevents syncing anything from Teleport to Okta. I.e. prevents
     * creating Okta assignments.
     *
     * @generated from protobuf field: bool disable_bidirectional_sync = 10;
     */
    disableBidirectionalSync: boolean;
    /**
     * UserSyncSource defines the source of truth for Okta users. It can be one of "" (empty string),
     * "saml_app" or "org". "saml_app" is set for all newly created plugins and indicates that source
     * of truth for the sync are users assigned to the connector Okta SAML application. "org" is the
     * legacy setting indicating that the source of truth for users are all the users from the Okta
     * organization. If it's an empty string and UserSync is true, that means it's a legacy plugin
     * that has not been yet updated and during the next update the value will be set to "org" if
     * AppID is empty or "saml_app" if not.
     *
     * @generated from protobuf field: string user_sync_source = 11;
     */
    userSyncSource: string;
}
/**
 * Defines a set of discord channel IDs
 *
 * @generated from protobuf message types.DiscordChannels
 */
export interface DiscordChannels {
    /**
     * @generated from protobuf field: repeated string channel_ids = 1;
     */
    channelIds: string[];
}
/**
 * Defines settings for the discord plugin
 *
 * @generated from protobuf message types.PluginDiscordSettings
 */
export interface PluginDiscordSettings {
    /**
     * RoleToRecipients maps Teleport roles (by name) to the set of Discord
     * channel IDs that will receive notifications and requests regarding that
     * that Role.
     *
     * @generated from protobuf field: map<string, types.DiscordChannels> role_to_recipients = 1;
     */
    roleToRecipients: {
        [key: string]: DiscordChannels;
    };
}
/**
 * PluginEntraIDSettings defines settings for the Entra ID sync plugin
 *
 * @generated from protobuf message types.PluginEntraIDSettings
 */
export interface PluginEntraIDSettings {
    /**
     * SyncSettings controls the user and access list sync settings for EntraID.
     *
     * @generated from protobuf field: types.PluginEntraIDSyncSettings sync_settings = 1;
     */
    syncSettings?: PluginEntraIDSyncSettings;
    /**
     * AccessGraphSettings controls settings for syncing access graph specific data.
     * When this is null, Entra ID integration with Access Graph is disabled.
     *
     * @generated from protobuf field: types.PluginEntraIDAccessGraphSettings access_graph_settings = 2;
     */
    accessGraphSettings?: PluginEntraIDAccessGraphSettings;
}
/**
 * Defines settings for syncing users and access lists from Entra ID.
 *
 * @generated from protobuf message types.PluginEntraIDSyncSettings
 */
export interface PluginEntraIDSyncSettings {
    /**
     * DefaultOwners are the default owners for all imported access lists.
     *
     * @generated from protobuf field: repeated string default_owners = 1;
     */
    defaultOwners: string[];
    /**
     * SSOConnectorID is the name of the Teleport SSO connector created and used by the Entra ID plugin.
     *
     * @generated from protobuf field: string sso_connector_id = 2;
     */
    ssoConnectorId: string;
    /**
     * credentials_source specifies the source of the credentials used for authentication with Azure.
     *
     * @generated from protobuf field: types.EntraIDCredentialsSource credentials_source = 3;
     */
    credentialsSource: EntraIDCredentialsSource;
    /**
     * tenant_id refers to the Azure Directory that this plugin synchronizes with.
     * This field is populated on a best-effort basis for legacy plugins but mandatory for plugins created after its introduction.
     * For existing plugins, it is filled in using the Entra integration when utilized.
     *
     * @generated from protobuf field: string tenant_id = 4;
     */
    tenantId: string;
    /**
     * entra_app_id refers to the Entra Application ID that supports the SSO for "sso_connector_id".
     * This field is populated on a best-effort basis for legacy plugins but mandatory for plugins created after its introduction.
     * For existing plugins, it is filled in using the entity descriptor url when utilized.
     *
     * @generated from protobuf field: string entra_app_id = 5;
     */
    entraAppId: string;
}
/**
 * AccessGraphSettings controls settings for syncing access graph specific data.
 *
 * @generated from protobuf message types.PluginEntraIDAccessGraphSettings
 */
export interface PluginEntraIDAccessGraphSettings {
    /**
     * AppSsoSettingsCache is an array of single sign-on settings for Entra enterprise applications.
     *
     * This data is stored here because it is not available through traditional methods (MS Graph API).
     * Instead, it is fetched once during the plugin's set up using the user's credentials to connect to Azure's private API.
     *
     * @generated from protobuf field: repeated types.PluginEntraIDAppSSOSettings app_sso_settings_cache = 1;
     */
    appSsoSettingsCache: PluginEntraIDAppSSOSettings[];
}
/**
 * PluginEntraIDAppSSOSettings is a container for a single Entra ID enterprise application's
 * cached SSO settings.
 * As this data is only parsed by TAG, each value is stored as an opaque JSON blob.
 *
 * @generated from protobuf message types.PluginEntraIDAppSSOSettings
 */
export interface PluginEntraIDAppSSOSettings {
    /**
     * AppID is the `AppID` property of Entra application.
     *
     * @generated from protobuf field: string app_id = 1;
     */
    appId: string;
    /**
     * FederatedSSOV2 contains the cached, gzip-compressed payload from the /ApplicationSso/{servicePrincipalId}/FederatedSSOV2 endpoint.
     *
     * @generated from protobuf field: bytes federated_sso_v2 = 2;
     */
    federatedSsoV2: Uint8Array;
}
/**
 * PluginSCIMSettings defines the settings for a SCIM integration plugin
 *
 * @generated from protobuf message types.PluginSCIMSettings
 */
export interface PluginSCIMSettings {
    /**
     * SamlConnectorName is the name of the SAML Connector that users provisioned
     * by this SCIM plugin will use to log in to Teleport.
     *
     * @generated from protobuf field: string saml_connector_name = 1;
     */
    samlConnectorName: string;
    /**
     * DefaultRole is the default role assigned to users provisioned by this
     * plugin.
     *
     * @generated from protobuf field: string default_role = 2;
     */
    defaultRole: string;
}
/**
 * PluginDatadogAccessSettings defines the settings for a Datadog Incident Management plugin
 *
 * @generated from protobuf message types.PluginDatadogAccessSettings
 */
export interface PluginDatadogAccessSettings {
    /**
     * ApiEndpoint is the Datadog API endpoint.
     *
     * @generated from protobuf field: string api_endpoint = 1;
     */
    apiEndpoint: string;
    /**
     * FallbackRecipient specifies the default recipient.
     *
     * @generated from protobuf field: string fallback_recipient = 2;
     */
    fallbackRecipient: string;
}
/**
 * PluginAWSICSettings holds the settings for an AWS Identity Center integration.
 *
 * @generated from protobuf message types.PluginAWSICSettings
 */
export interface PluginAWSICSettings {
    /**
     * IntegrationName is the Teleport OIDC integration used to gain access to the
     * AWS account. May be empty if [CredentialsSource] is `SYSTEM`.
     * DEPRECATED: Use [Credentials] instead. DELETE in Teleport 19+
     *
     * @deprecated
     * @generated from protobuf field: string integration_name = 1 [deprecated = true];
     */
    integrationName: string;
    /**
     * Region is the AWS region the target Identity Center instance is configured in
     *
     * @generated from protobuf field: string region = 2;
     */
    region: string;
    /**
     * InstanceARN is the arn of the Identity Center instance to manage
     *
     * @generated from protobuf field: string arn = 3;
     */
    arn: string;
    /**
     * Provisioning holds settings for provisioning users and groups into AWS
     *
     * @generated from protobuf field: types.AWSICProvisioningSpec provisioning_spec = 4;
     */
    provisioningSpec?: AWSICProvisioningSpec;
    /**
     * AccessListDefaultOwners is a list of default owners for Access List created for
     * user groups imported from AWS Idenity Center.
     *
     * @generated from protobuf field: repeated string access_list_default_owners = 5;
     */
    accessListDefaultOwners: string[];
    /**
     * SAMLIdPServiceProviderName is the name of a SAML service provider created
     * for the Identity Center.
     *
     * @generated from protobuf field: string saml_idp_service_provider_name = 6;
     */
    samlIdpServiceProviderName: string;
    /**
     * CredentialsSource indicates how the Identity Center plugin should source
     * its AWS login credentials.
     * DEPRECATED: Use [Credentials] instead. DELETE in Teleport 19+
     *
     * @deprecated
     * @generated from protobuf field: types.AWSICCredentialsSource credentials_source = 7 [deprecated = true];
     */
    credentialsSource: AWSICCredentialsSource;
    /**
     * UserSyncLabelsFilter specifies a map of key-value pairs used to filter users
     * based on their metadata labels. These filtered users will be provisioned
     * from Teleport to AWS IC via SCIM provisioning.
     * If multiple user_sync_filters are provided the match is combined with OR operator.
     *
     * Example:
     * If Okta is used as the Identity Source and only users originating from Okta
     * should be synced, set the filter to:
     * [{
     *   "okta/org": "https://trial-123456.okta.com",
     *   "teleport.dev/origin": "okta"
     * }]
     *
     * If AWS IC uses Teleport as the Identity Provider, the filter should remain empty.
     *
     * NOTE: System users are always filtered out by default and will not be provisioned to AWS IC.
     *
     * @generated from protobuf field: repeated types.AWSICUserSyncFilter user_sync_filters = 8;
     */
    userSyncFilters: AWSICUserSyncFilter[];
    /**
     * AwsAccountFilters is an optional allow-list of AWS accounts to import and
     * manage. An empty list implies that all accounts managed by the Identity Center
     * instance will be imported and managed.
     *
     * @generated from protobuf field: repeated types.AWSICResourceFilter aws_accounts_filters = 9;
     */
    awsAccountsFilters: AWSICResourceFilter[];
    /**
     * GroupSyncLabelsFilter is used to specify filters that determine which AWS groups
     * should be included during synchronization.
     *
     * @generated from protobuf field: repeated types.AWSICResourceFilter group_sync_filters = 10;
     */
    groupSyncFilters: AWSICResourceFilter[];
    /**
     * Credentials represents the AWS credentials used by the Identity Center
     * integration
     *
     * @generated from protobuf field: types.AWSICCredentials credentials = 11;
     */
    credentials?: AWSICCredentials;
}
/**
 * AWSICCredentials holds the credentials for authenticating with AWS
 *
 * @generated from protobuf message types.AWSICCredentials
 */
export interface AWSICCredentials {
    /**
     * @generated from protobuf oneof: source
     */
    source: {
        oneofKind: "system";
        /**
         * @generated from protobuf field: types.AWSICCredentialSourceSystem system = 1;
         */
        system: AWSICCredentialSourceSystem;
    } | {
        oneofKind: "oidc";
        /**
         * @generated from protobuf field: types.AWSICCredentialSourceOIDC oidc = 2;
         */
        oidc: AWSICCredentialSourceOIDC;
    } | {
        oneofKind: undefined;
    };
}
/**
 * AWSICCredentialSourceSystem holds AWSIC credentials drawn from the ambient
 * system configuration
 *
 * @generated from protobuf message types.AWSICCredentialSourceSystem
 */
export interface AWSICCredentialSourceSystem {
    /**
     * AwsRoleArn is an optional AWS role for the IC client to assume, overriding
     * any roles
     *
     * @generated from protobuf field: string assume_role_arn = 1;
     */
    assumeRoleArn: string;
}
/**
 * AWSICCredentialSourceSystem holds AWSIC credentials drawn from a Teleport
 * OIDC integration
 *
 * @generated from protobuf message types.AWSICCredentialSourceOIDC
 */
export interface AWSICCredentialSourceOIDC {
    /**
     * IntegrationName is the name of the Teleport OIDC integration used by the
     * Identity Center integration to authenticate with AWS.
     *
     * @generated from protobuf field: string integration_name = 1;
     */
    integrationName: string;
}
/**
 * AWSICResourceFilter is an entry in the AWS IC plugin settings' allow-list of
 * resources to import. The filter can specify inclusion either by account ID or
 * regex on the resource name.
 *
 * @generated from protobuf message types.AWSICResourceFilter
 */
export interface AWSICResourceFilter {
    /**
     * @generated from protobuf oneof: include
     */
    include: {
        oneofKind: "id";
        /**
         * Id indicates that the resource should be filtered by ID
         *
         * @generated from protobuf field: string id = 1;
         */
        id: string;
    } | {
        oneofKind: "nameRegex";
        /**
         * NameRegex indicates that the resource should be included its name matches
         * the supplied regex.
         *
         * @generated from protobuf field: string name_regex = 2;
         */
        nameRegex: string;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf oneof: exclude
     */
    exclude: {
        oneofKind: "excludeId";
        /**
         * ExcludeId indicates that a resource should be excluded by exact ID.
         *
         * @generated from protobuf field: string exclude_id = 3;
         */
        excludeId: string;
    } | {
        oneofKind: "excludeNameRegex";
        /**
         * ExcludeNameRegex excludes resources whose name matches this regex.
         *
         * @generated from protobuf field: string exclude_name_regex = 4;
         */
        excludeNameRegex: string;
    } | {
        oneofKind: undefined;
    };
}
/**
 * UserSyncFilter is a map of key-value pairs used to filter users based on their metadata labels.
 *
 * @generated from protobuf message types.AWSICUserSyncFilter
 */
export interface AWSICUserSyncFilter {
    /**
     * @generated from protobuf field: map<string, string> labels = 8;
     */
    labels: {
        [key: string]: string;
    };
}
/**
 * AWSICProvisioningSpec holds provisioning-specific Identity Center settings
 *
 * @generated from protobuf message types.AWSICProvisioningSpec
 */
export interface AWSICProvisioningSpec {
    /**
     * BaseURL is the SCIM base URL
     *
     * @generated from protobuf field: string base_url = 1;
     */
    baseUrl: string;
    /**
     * BearerToken is used to authenticate with AWS when provisioning users and
     * groups via SCIM. This is expected to be empty in serialized records, as the
     * actual credential is stored separetely ain a PluginStaticCredentials
     * service, and populated at runtime as necessary.
     *
     * @generated from protobuf field: string bearer_token = 2;
     */
    bearerToken: string;
}
/**
 * PluginAWSICStatusV1 defines AWS Identity Center plugin sub-process status.
 *
 * @generated from protobuf message types.PluginAWSICStatusV1
 */
export interface PluginAWSICStatusV1 {
    /**
     * GroupImportStatus is a status of Identity Center group and group members import.
     *
     * @generated from protobuf field: types.AWSICGroupImportStatus group_import_status = 1;
     */
    groupImportStatus?: AWSICGroupImportStatus;
}
/**
 * AWSICGroupImportStatus defines Identity Center group and group members import status.
 *
 * @generated from protobuf message types.AWSICGroupImportStatus
 */
export interface AWSICGroupImportStatus {
    /**
     * StatusCode is a status code of group and group members import operation.
     *
     * @generated from protobuf field: types.AWSICGroupImportStatusCode status_code = 1;
     */
    statusCode: AWSICGroupImportStatusCode;
    /**
     * ErrorMessage contains error message for a group and group members import attempt
     * that met with an error.
     *
     * @generated from protobuf field: string error_message = 2;
     */
    errorMessage: string;
}
/**
 * PluginEmailSettings holds the settings for an Email Access Request plugin.
 *
 * @generated from protobuf message types.PluginEmailSettings
 */
export interface PluginEmailSettings {
    /**
     * Sender specifies the email sender.
     *
     * @generated from protobuf field: string sender = 1;
     */
    sender: string;
    /**
     * FallbackRecipient specifies the default recipient.
     *
     * @generated from protobuf field: string fallback_recipient = 2;
     */
    fallbackRecipient: string;
    /**
     * @generated from protobuf oneof: spec
     */
    spec: {
        oneofKind: "mailgunSpec";
        /**
         * MailgunSpec configures Mailgun service settings.
         *
         * @generated from protobuf field: types.MailgunSpec mailgun_spec = 3;
         */
        mailgunSpec: MailgunSpec;
    } | {
        oneofKind: "smtpSpec";
        /**
         * SmtpSpec configures generic SMTP service settings.
         *
         * @generated from protobuf field: types.SMTPSpec smtp_spec = 4;
         */
        smtpSpec: SMTPSpec;
    } | {
        oneofKind: undefined;
    };
}
/**
 * MailgunSpec holds Mailgun-specific settings.
 *
 * @generated from protobuf message types.MailgunSpec
 */
export interface MailgunSpec {
    /**
     * Domain specifies the Mailgun sending domain.
     *
     * @generated from protobuf field: string domain = 1;
     */
    domain: string;
}
/**
 * SMTPSpec holds a generic SMTP service specific settings.
 *
 * @generated from protobuf message types.SMTPSpec
 */
export interface SMTPSpec {
    /**
     * Host specifies the SMTP service host name.
     *
     * @generated from protobuf field: string host = 1;
     */
    host: string;
    /**
     * Port specifies the SMTP service port number.
     *
     * @generated from protobuf field: int32 port = 2;
     */
    port: number;
    /**
     * StartTLSPolicy specifies the SMTP start TLS policy used to send emails over
     * SMTP.
     *
     * @generated from protobuf field: string start_tls_policy = 3;
     */
    startTlsPolicy: string;
}
/**
 * PluginMSTeamsSettings defines the settings for a Microsoft Teams integration plugin
 *
 * @generated from protobuf message types.PluginMSTeamsSettings
 */
export interface PluginMSTeamsSettings {
    /**
     * AppId is the Microsoft application ID (uuid, for Azure bots must be underlying app id, not bot's id).
     *
     * @generated from protobuf field: string app_id = 1;
     */
    appId: string;
    /**
     * TenantId is the Microsoft tenant ID.
     *
     * @generated from protobuf field: string tenant_id = 2;
     */
    tenantId: string;
    /**
     * TeamsAppId is the Microsoft teams application ID.
     *
     * @generated from protobuf field: string teams_app_id = 3;
     */
    teamsAppId: string;
    /**
     * Region to be used by the Microsoft Graph API client.
     *
     * @generated from protobuf field: string region = 4;
     */
    region: string;
    /**
     * DefaultRecipient is the default recipient to use if no access monitoring rules are specified.
     *
     * @generated from protobuf field: string default_recipient = 5;
     */
    defaultRecipient: string;
}
/**
 * PluginNetIQSettings defines the settings for a NetIQ integration plugin
 *
 * @generated from protobuf message types.PluginNetIQSettings
 */
export interface PluginNetIQSettings {
    /**
     * oauth_issuer_endpoint is the NetIQ Oauth Issuer endpoint.
     * Usually, it's equal to https://osp.domain.ext/a/idm/auth/oauth2
     *
     * @generated from protobuf field: string oauth_issuer_endpoint = 1;
     */
    oauthIssuerEndpoint: string;
    /**
     * api_endpoint is the IDM PROV Rest API location.
     *
     * @generated from protobuf field: string api_endpoint = 2;
     */
    apiEndpoint: string;
    /**
     * insecure_skip_verify controls whether the NetIQ certificate validation should be skipped.
     *
     * @generated from protobuf field: bool insecure_skip_verify = 3;
     */
    insecureSkipVerify: boolean;
}
/**
 * @generated from protobuf message types.PluginBootstrapCredentialsV1
 */
export interface PluginBootstrapCredentialsV1 {
    /**
     * @generated from protobuf oneof: credentials
     */
    credentials: {
        oneofKind: "oauth2AuthorizationCode";
        /**
         * @generated from protobuf field: types.PluginOAuth2AuthorizationCodeCredentials oauth2_authorization_code = 1;
         */
        oauth2AuthorizationCode: PluginOAuth2AuthorizationCodeCredentials;
    } | {
        oneofKind: "bearerToken";
        /**
         * @generated from protobuf field: types.PluginBearerTokenCredentials bearer_token = 2;
         */
        bearerToken: PluginBearerTokenCredentials;
    } | {
        oneofKind: "idSecret";
        /**
         * @generated from protobuf field: types.PluginIdSecretCredential id_secret = 3;
         */
        idSecret: PluginIdSecretCredential;
    } | {
        oneofKind: undefined;
    };
}
/**
 * PluginIdSecretCredential can be OAuth2-like client_id and client_secret or username and password.
 *
 * @generated from protobuf message types.PluginIdSecretCredential
 */
export interface PluginIdSecretCredential {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: string secret = 2;
     */
    secret: string;
}
/**
 * @generated from protobuf message types.PluginOAuth2AuthorizationCodeCredentials
 */
export interface PluginOAuth2AuthorizationCodeCredentials {
    /**
     * @generated from protobuf field: string authorization_code = 1;
     */
    authorizationCode: string;
    /**
     * @generated from protobuf field: string redirect_uri = 2;
     */
    redirectUri: string;
}
/**
 * PluginStatus is the user-facing status for the plugin instance.
 *
 * @generated from protobuf message types.PluginStatusV1
 */
export interface PluginStatusV1 {
    /**
     * @generated from protobuf field: types.PluginStatusCode code = 1;
     */
    code: PluginStatusCode;
    /**
     * error_message is a human-readable error message that can be displayed to the user.
     *
     * @generated from protobuf field: string error_message = 2;
     */
    errorMessage: string;
    /**
     * last_sync_time is the last time the plugin was run.
     *
     * @generated from protobuf field: google.protobuf.Timestamp last_sync_time = 3;
     */
    lastSyncTime?: Timestamp;
    /**
     * @generated from protobuf oneof: details
     */
    details: {
        oneofKind: "gitlab";
        /**
         * gitlab is the status details for the Gitlab plugin.
         *
         * @generated from protobuf field: types.PluginGitlabStatusV1 gitlab = 4;
         */
        gitlab: PluginGitlabStatusV1;
    } | {
        oneofKind: "entraId";
        /**
         * @generated from protobuf field: types.PluginEntraIDStatusV1 entra_id = 5;
         */
        entraId: PluginEntraIDStatusV1;
    } | {
        oneofKind: "okta";
        /**
         * Okta holds status details for the Okta plugin
         *
         * @generated from protobuf field: types.PluginOktaStatusV1 okta = 7;
         */
        okta: PluginOktaStatusV1;
    } | {
        oneofKind: "awsIc";
        /**
         * AWSIC holds status details for the AWS Identity Center plugin.
         *
         * @generated from protobuf field: types.PluginAWSICStatusV1 aws_ic = 8;
         */
        awsIc: PluginAWSICStatusV1;
    } | {
        oneofKind: "netIq";
        /**
         * NetIQ holds status details for the NetIQ plugin.
         *
         * @generated from protobuf field: types.PluginNetIQStatusV1 net_iq = 9;
         */
        netIq: PluginNetIQStatusV1;
    } | {
        oneofKind: undefined;
    };
    /**
     * last_raw_error variable stores the most recent raw error message received from an API or service.
     * It is intended to capture the original error message without any modifications or formatting.
     * This can be useful for debugging purposes, providing detailed information about what went wrong
     * in the interaction with the external service.
     *
     * @generated from protobuf field: string last_raw_error = 6;
     */
    lastRawError: string;
}
/**
 * PluginNetIQStatusV1 is the status details for the NetIQ plugin.
 *
 * @generated from protobuf message types.PluginNetIQStatusV1
 */
export interface PluginNetIQStatusV1 {
    /**
     * imported_users is the number of users imported from NetIQ eDirectory.
     *
     * @generated from protobuf field: uint32 imported_users = 1;
     */
    importedUsers: number;
    /**
     * imported_groups is the number of groups imported from NetIQ eDirectory.
     *
     * @generated from protobuf field: uint32 imported_groups = 2;
     */
    importedGroups: number;
    /**
     * imported_roles is the number of roles imported from NetIQ eDirectory.
     *
     * @generated from protobuf field: uint32 imported_roles = 3;
     */
    importedRoles: number;
    /**
     * imported_resources is the number of resources imported from NetIQ eDirectory.
     *
     * @generated from protobuf field: uint32 imported_resources = 4;
     */
    importedResources: number;
}
/**
 * PluginGitlabStatusV1 is the status details for the Gitlab plugin.
 *
 * @generated from protobuf message types.PluginGitlabStatusV1
 */
export interface PluginGitlabStatusV1 {
    /**
     * imported_users is the number of users imported from Gitlab.
     *
     * @generated from protobuf field: uint32 imported_users = 1;
     */
    importedUsers: number;
    /**
     * imported_groups is the number of groups imported from Gitlab.
     *
     * @generated from protobuf field: uint32 imported_groups = 2;
     */
    importedGroups: number;
    /**
     * imported_projects is the number of projects imported from Gitlab.
     *
     * @generated from protobuf field: uint32 imported_projects = 3;
     */
    importedProjects: number;
}
/**
 * PluginEntraIDStatusV1 is the status details for the Entra ID plugin.
 *
 * @generated from protobuf message types.PluginEntraIDStatusV1
 */
export interface PluginEntraIDStatusV1 {
    /**
     * imported_users is the number of users imported from Entra ID.
     *
     * @generated from protobuf field: uint32 imported_users = 1;
     */
    importedUsers: number;
    /**
     * imported_groups is the number of groups imported from Entra ID.
     *
     * @generated from protobuf field: uint32 imported_groups = 2;
     */
    importedGroups: number;
}
/**
 * PluginOktaStatusV1 contains the details for the running Okta plugin.
 *
 * @generated from protobuf message types.PluginOktaStatusV1
 */
export interface PluginOktaStatusV1 {
    /**
     * SSODetails are status details relating to SSO.
     *
     * @generated from protobuf field: types.PluginOktaStatusDetailsSSO sso_details = 1;
     */
    ssoDetails?: PluginOktaStatusDetailsSSO;
    /**
     * AppGroupSyncDetails are status details relating to synchronizing apps and
     * groups from Okta.
     *
     * @generated from protobuf field: types.PluginOktaStatusDetailsAppGroupSync app_group_sync_details = 2;
     */
    appGroupSyncDetails?: PluginOktaStatusDetailsAppGroupSync;
    /**
     * UsersSyncDetails are status details relating to synchronizing users from
     * Okta.
     *
     * @generated from protobuf field: types.PluginOktaStatusDetailsUsersSync users_sync_details = 3;
     */
    usersSyncDetails?: PluginOktaStatusDetailsUsersSync;
    /**
     * ScimDetails are status details relating to SCIM integration with
     * Okta.
     *
     * @generated from protobuf field: types.PluginOktaStatusDetailsSCIM scim_details = 4;
     */
    scimDetails?: PluginOktaStatusDetailsSCIM;
    /**
     * AccessListSyncDetails are status details relating to synchronizing access
     * lists from Okta.
     *
     * @generated from protobuf field: types.PluginOktaStatusDetailsAccessListsSync access_lists_sync_details = 5;
     */
    accessListsSyncDetails?: PluginOktaStatusDetailsAccessListsSync;
}
/**
 * PluginOktaStatusDetailsSSO are details related to the
 * current status of the Okta integration w/r/t SSO.
 *
 * @generated from protobuf message types.PluginOktaStatusDetailsSSO
 */
export interface PluginOktaStatusDetailsSSO {
    /**
     * Enabled indicates whether SSO login is enabled.
     *
     * @generated from protobuf field: bool enabled = 1;
     */
    enabled: boolean;
    /**
     * AppId is the unique Okta application ID of the Okta Applicaion used for
     * SSO login.
     *
     * @generated from protobuf field: string app_id = 2;
     */
    appId: string;
    /**
     * AppName is the Okta-assigned unique name of the Okta App that Teleport uses
     * as a gateway to interact with Okta for SAML login, SCIM provisioning and user
     * sync.
     *
     * @generated from protobuf field: string app_name = 3;
     */
    appName: string;
    /**
     * OktaGroupEveryoneMappedRoles are the role(s) that will be granted to Okta users
     * through SSO or synchronization.
     *
     * @generated from protobuf field: repeated string okta_group_everyone_mapped_roles = 4;
     */
    oktaGroupEveryoneMappedRoles: string[];
}
/**
 * PluginOktaStatusDetailsAppGroupSync are details related to the
 * current status of the Okta integration w/r/t application and group
 * sync.
 *
 * @generated from protobuf message types.PluginOktaStatusDetailsAppGroupSync
 */
export interface PluginOktaStatusDetailsAppGroupSync {
    /**
     * Enabled is whether the users sync is enabled.
     *
     * @generated from protobuf field: bool enabled = 1;
     */
    enabled: boolean;
    /**
     * StatusCode indicates the current state of the App & Group sync service
     *
     * @generated from protobuf field: types.OktaPluginSyncStatusCode status_code = 2;
     */
    statusCode: OktaPluginSyncStatusCode;
    /**
     * LastSuccessful is the date of the last successful run.
     *
     * @generated from protobuf field: google.protobuf.Timestamp last_successful = 3;
     */
    lastSuccessful?: Timestamp;
    /**
     * LastFailed is the date of the last failed run.
     *
     * @generated from protobuf field: google.protobuf.Timestamp last_failed = 4;
     */
    lastFailed?: Timestamp;
    /**
     * NumAppsSynced is the total number of apps synchronized.
     *
     * @generated from protobuf field: int32 num_apps_synced = 5;
     */
    numAppsSynced: number;
    /**
     * NumAppsSynced is the total number of groups synchronized.
     *
     * @generated from protobuf field: int32 num_groups_synced = 6;
     */
    numGroupsSynced: number;
    /**
     * Error contains a textual description of the reason the last synchronization
     * failed. Only valid when StatusCode is OKTA_PLUGIN_SYNC_STATUS_CODE_ERROR.
     *
     * @generated from protobuf field: string error = 7;
     */
    error: string;
}
/**
 * PluginOktaStatusDetailsUsersSync are details related to the
 * current status of the Okta integration w/r/t users sync.
 *
 * @generated from protobuf message types.PluginOktaStatusDetailsUsersSync
 */
export interface PluginOktaStatusDetailsUsersSync {
    /**
     * Enabled is whether the users sync is enabled.
     *
     * @generated from protobuf field: bool enabled = 1;
     */
    enabled: boolean;
    /**
     * StatusCode indicates the current state of the User sync service
     *
     * @generated from protobuf field: types.OktaPluginSyncStatusCode status_code = 2;
     */
    statusCode: OktaPluginSyncStatusCode;
    /**
     * LastSuccessful is the date of the last successful run.
     *
     * @generated from protobuf field: google.protobuf.Timestamp last_successful = 3;
     */
    lastSuccessful?: Timestamp;
    /**
     * LastFailed is the date of the last failed run.
     *
     * @generated from protobuf field: google.protobuf.Timestamp last_failed = 4;
     */
    lastFailed?: Timestamp;
    /**
     * NumUsersSynced is the total number of users synchronized.
     *
     * @generated from protobuf field: int32 num_users_synced = 5;
     */
    numUsersSynced: number;
    /**
     * Error contains a textual description of the reason the last synchronization
     * failed. Only valid when StatusCode is OKTA_PLUGIN_SYNC_STATUS_CODE_ERROR.
     *
     * @generated from protobuf field: string error = 6;
     */
    error: string;
}
/**
 * PluginOktaStatusDetailsSCIM are details related to the
 * current status of the Okta integration w/r/t SCIM.
 *
 * @generated from protobuf message types.PluginOktaStatusDetailsSCIM
 */
export interface PluginOktaStatusDetailsSCIM {
    /**
     * Enabled is whether SCIM is enabled.
     *
     * @generated from protobuf field: bool enabled = 1;
     */
    enabled: boolean;
}
/**
 * PluginOktaStatusDetailsAccessListsSync are details related to the
 * current status of the Okta integration w/r/t access list sync.
 *
 * @generated from protobuf message types.PluginOktaStatusDetailsAccessListsSync
 */
export interface PluginOktaStatusDetailsAccessListsSync {
    /**
     * Enabled is whether access lists sync is enabled.
     *
     * @generated from protobuf field: bool enabled = 1;
     */
    enabled: boolean;
    /**
     * StatusCode indicates the current state of the AccessList sync service
     *
     * @generated from protobuf field: types.OktaPluginSyncStatusCode status_code = 2;
     */
    statusCode: OktaPluginSyncStatusCode;
    /**
     * LastSuccessful is the date of the last successful run.
     *
     * @generated from protobuf field: google.protobuf.Timestamp last_successful = 3;
     */
    lastSuccessful?: Timestamp;
    /**
     * LastFailed is the date of the last failed run.
     *
     * @generated from protobuf field: google.protobuf.Timestamp last_failed = 4;
     */
    lastFailed?: Timestamp;
    /**
     * AppFilters are the app filters used for the access list sync.
     *
     * @generated from protobuf field: repeated string app_filters = 5;
     */
    appFilters: string[];
    /**
     * NumAppsSynced are the number of applications synchronized as access lists.
     *
     * @generated from protobuf field: int32 num_apps_synced = 6;
     */
    numAppsSynced: number;
    /**
     * GroupFilters are the group filters used for the access list sync.
     *
     * @generated from protobuf field: repeated string group_filters = 7;
     */
    groupFilters: string[];
    /**
     * NumGroupsSynced are the number of groups synchronized as access lists.
     *
     * @generated from protobuf field: int32 num_groups_synced = 8;
     */
    numGroupsSynced: number;
    /**
     * Error contains a textual description of the reason the last synchronization
     * failed. Only valid when StatusCode is OKTA_PLUGIN_SYNC_STATUS_CODE_ERROR.
     *
     * @generated from protobuf field: string error = 9;
     */
    error: string;
}
/**
 * PluginCredentialsV1 represents "live" credentials
 * that are used by the plugin to authenticate to the 3rd party API.
 *
 * @generated from protobuf message types.PluginCredentialsV1
 */
export interface PluginCredentialsV1 {
    /**
     * @generated from protobuf oneof: credentials
     */
    credentials: {
        oneofKind: "oauth2AccessToken";
        /**
         * @generated from protobuf field: types.PluginOAuth2AccessTokenCredentials oauth2_access_token = 1;
         */
        oauth2AccessToken: PluginOAuth2AccessTokenCredentials;
    } | {
        oneofKind: "bearerToken";
        /**
         * @generated from protobuf field: types.PluginBearerTokenCredentials bearer_token = 2;
         */
        bearerToken: PluginBearerTokenCredentials;
    } | {
        oneofKind: "idSecret";
        /**
         * @generated from protobuf field: types.PluginIdSecretCredential id_secret = 3;
         */
        idSecret: PluginIdSecretCredential;
    } | {
        oneofKind: "staticCredentialsRef";
        /**
         * @generated from protobuf field: types.PluginStaticCredentialsRef static_credentials_ref = 4;
         */
        staticCredentialsRef: PluginStaticCredentialsRef;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message types.PluginOAuth2AccessTokenCredentials
 */
export interface PluginOAuth2AccessTokenCredentials {
    /**
     * @generated from protobuf field: string access_token = 1;
     */
    accessToken: string;
    /**
     * @generated from protobuf field: string refresh_token = 2;
     */
    refreshToken: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp expires = 3;
     */
    expires?: Timestamp;
}
/**
 * @generated from protobuf message types.PluginBearerTokenCredentials
 */
export interface PluginBearerTokenCredentials {
    /**
     * Token is the literal bearer token to be submitted to the 3rd-party API provider.
     *
     * @generated from protobuf field: string token = 1;
     */
    token: string;
}
/**
 * PluginStaticCredentialsRef is a reference to plugin static credentials by labels.
 *
 * @generated from protobuf message types.PluginStaticCredentialsRef
 */
export interface PluginStaticCredentialsRef {
    /**
     * Labels is the set of labels to use to match against a set of static credentials.
     *
     * @generated from protobuf field: map<string, string> Labels = 1 [json_name = "Labels"];
     */
    labels: {
        [key: string]: string;
    };
}
/**
 * PluginList represents a list of plugin resources
 *
 * @generated from protobuf message types.PluginListV1
 */
export interface PluginListV1 {
    /**
     * Plugins is a list of plugin resources.
     *
     * @generated from protobuf field: repeated types.PluginV1 plugins = 1;
     */
    plugins: PluginV1[];
}
/**
 * PluginStaticCredentialsV1 is a representation of static credentials for plugins.
 *
 * @generated from protobuf message types.PluginStaticCredentialsV1
 */
export interface PluginStaticCredentialsV1 {
    /**
     * Header is the resource header for the plugin static credentials object.
     *
     * @generated from protobuf field: types.ResourceHeader Header = 1 [json_name = "Header"];
     */
    header?: ResourceHeader;
    /**
     * Spec contains the actual credentials for the object.
     *
     * @generated from protobuf field: types.PluginStaticCredentialsSpecV1 Spec = 2 [json_name = "Spec"];
     */
    spec?: PluginStaticCredentialsSpecV1;
}
/**
 * PluginStaticCredentialsSpecV1 is the specification for the static credentials object.
 *
 * @generated from protobuf message types.PluginStaticCredentialsSpecV1
 */
export interface PluginStaticCredentialsSpecV1 {
    /**
     * @generated from protobuf oneof: credentials
     */
    credentials: {
        oneofKind: "aPIToken";
        /**
         * @generated from protobuf field: string APIToken = 1 [json_name = "APIToken"];
         */
        aPIToken: string;
    } | {
        oneofKind: "basicAuth";
        /**
         * @generated from protobuf field: types.PluginStaticCredentialsBasicAuth BasicAuth = 2 [json_name = "BasicAuth"];
         */
        basicAuth: PluginStaticCredentialsBasicAuth;
    } | {
        oneofKind: "oAuthClientSecret";
        /**
         * @generated from protobuf field: types.PluginStaticCredentialsOAuthClientSecret OAuthClientSecret = 3 [json_name = "OAuthClientSecret"];
         */
        oAuthClientSecret: PluginStaticCredentialsOAuthClientSecret;
    } | {
        oneofKind: "sSHCertAuthorities";
        /**
         * @generated from protobuf field: types.PluginStaticCredentialsSSHCertAuthorities SSHCertAuthorities = 4 [json_name = "SSHCertAuthorities"];
         */
        sSHCertAuthorities: PluginStaticCredentialsSSHCertAuthorities;
    } | {
        oneofKind: "privateKey";
        /**
         * @generated from protobuf field: bytes private_key = 5;
         */
        privateKey: Uint8Array;
    } | {
        oneofKind: undefined;
    };
}
/**
 * PluginStaticCredentialsBasicAuth represents username and password credentials for a plugin.
 *
 * @generated from protobuf message types.PluginStaticCredentialsBasicAuth
 */
export interface PluginStaticCredentialsBasicAuth {
    /**
     * Username is the username to use for basic auth.
     *
     * @generated from protobuf field: string Username = 1 [json_name = "Username"];
     */
    username: string;
    /**
     * Password is the password to use for basic auth.
     *
     * @generated from protobuf field: string Password = 2 [json_name = "Password"];
     */
    password: string;
}
/**
 * PluginStaticCredentialsOAuthClientSecret represents an oauth client id and secret.
 *
 * @generated from protobuf message types.PluginStaticCredentialsOAuthClientSecret
 */
export interface PluginStaticCredentialsOAuthClientSecret {
    /**
     * ClientId is the client ID to use for OAuth client secret.
     *
     * @generated from protobuf field: string ClientId = 1 [json_name = "ClientId"];
     */
    clientId: string;
    /**
     * ClientSecret is the client secret to use.
     *
     * @generated from protobuf field: string ClientSecret = 2 [json_name = "ClientSecret"];
     */
    clientSecret: string;
}
/**
 * PluginStaticCredentialsSSHCertAuthorities contains the active SSH CAs used
 * for the integration or plugin.
 *
 * @generated from protobuf message types.PluginStaticCredentialsSSHCertAuthorities
 */
export interface PluginStaticCredentialsSSHCertAuthorities {
    /**
     * CertAuthorities contains the active SSH CAs used for the integration or
     * plugin.
     *
     * @generated from protobuf field: repeated types.SSHKeyPair cert_authorities = 1;
     */
    certAuthorities: SSHKeyPair[];
}
/**
 * SAMLIdPServiceProviderV1 is the representation of a SAML IdP service provider.
 *
 * @generated from protobuf message types.SAMLIdPServiceProviderV1
 */
export interface SAMLIdPServiceProviderV1 {
    /**
     * Header is the resource header for the SAML IdP service provider.
     *
     * @generated from protobuf field: types.ResourceHeader Header = 1 [json_name = "Header"];
     */
    header?: ResourceHeader;
    /**
     * Spec is the SAML IdP service provider spec.
     *
     * @generated from protobuf field: types.SAMLIdPServiceProviderSpecV1 Spec = 2 [json_name = "Spec"];
     */
    spec?: SAMLIdPServiceProviderSpecV1;
}
/**
 * SAMLIdPServiceProviderSpecV1 is the SAMLIdPServiceProviderV1 resource spec.
 *
 * @generated from protobuf message types.SAMLIdPServiceProviderSpecV1
 */
export interface SAMLIdPServiceProviderSpecV1 {
    /**
     * EntityDescriptor is the entity descriptor for the service provider
     *
     * @generated from protobuf field: string EntityDescriptor = 1 [json_name = "EntityDescriptor"];
     */
    entityDescriptor: string;
    /**
     * EntityID is the entity ID for the entity descriptor. If entity descriptor is provided,
     * this value is checked that it matches the entity ID in the entity descriptor
     * at upsert time to avoid having to parse the XML blob in the entity descriptor
     * every time we need to use this resource.
     *
     * @generated from protobuf field: string EntityID = 2 [json_name = "EntityID"];
     */
    entityID: string;
    /**
     * ACSURL is the endpoint where SAML authentication response will be redirected.
     *
     * @generated from protobuf field: string ACSURL = 3 [json_name = "ACSURL"];
     */
    aCSURL: string;
    /**
     * AttributeMapping is used to map service provider requested attributes to
     * username, role and traits in Teleport.
     *
     * @generated from protobuf field: repeated types.SAMLAttributeMapping AttributeMapping = 4 [json_name = "AttributeMapping"];
     */
    attributeMapping: SAMLAttributeMapping[];
    /**
     * Preset is used to define service provider profile that will have a custom behavior
     * processed by Teleport.
     *
     * @generated from protobuf field: string Preset = 5 [json_name = "Preset"];
     */
    preset: string;
    /**
     * RelayState is used to add custom value in the SAML response as a relay_state HTTP parameter.
     * The value can contain service provider specific redirect URL, static state token etc.
     * The value is only applied in the IdP initiated SSO flow.
     *
     * @generated from protobuf field: string RelayState = 6 [json_name = "RelayState"];
     */
    relayState: string;
    /**
     * LaunchURLs is used to configure custom landing URLs for service provider. It is useful in
     * the following scenarios:
     * 1. If a service provider does not support IdP initiated authentication, launch url can be
     *    configured to launch users directly into the service provider authentication endpoint.
     * 2. If a service provider does support IdP initiated authentication, it can be useful if
     *    that service provider acts as a master authentication service provider for internal services.
     *    In such case, Teleport administrator can configure launch URL, that lets user pick a specific
     *    internal service URL from the Log In tile in the UI, which would take them to that particular
     *    service for authentication instead of directly launching to the master service provider.
     * Each launch URL value must be an HTTPs endpoint.
     *
     * @generated from protobuf field: repeated string LaunchURLs = 7 [json_name = "LaunchURLs"];
     */
    launchURLs: string[];
}
/**
 * SAMLAttributeMapping represents SAML service provider requested attribute
 * name, format and its values.
 *
 * @generated from protobuf message types.SAMLAttributeMapping
 */
export interface SAMLAttributeMapping {
    /**
     *  name is an attribute name.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     *  name_format is an attribute name format.
     *
     * @generated from protobuf field: string name_format = 2;
     */
    nameFormat: string;
    /**
     *  value is an attribute value definable with predicate expression.
     *
     * @generated from protobuf field: string value = 3;
     */
    value: string;
}
/**
 * IdPOptions specify options related to access Teleport IdPs.
 *
 * @generated from protobuf message types.IdPOptions
 */
export interface IdPOptions {
    /**
     * SAML are options related to the Teleport SAML IdP.
     *
     * @generated from protobuf field: types.IdPSAMLOptions SAML = 1 [json_name = "SAML"];
     */
    sAML?: IdPSAMLOptions;
}
/**
 * IdPSAMLOptions specifies options related to accessing the Teleport SAML IdP.
 *
 * @generated from protobuf message types.IdPSAMLOptions
 */
export interface IdPSAMLOptions {
    /**
     * Enabled is set to true if this option allows access to the Teleport SAML IdP.
     *
     * @generated from protobuf field: types.BoolValue Enabled = 1 [json_name = "Enabled"];
     */
    enabled?: BoolValue;
}
/**
 * KubernetesResourceV1 represents a Kubernetes resource.
 *
 * @generated from protobuf message types.KubernetesResourceV1
 */
export interface KubernetesResourceV1 {
    /**
     * Kind is a resource kind
     *
     * @generated from protobuf field: string Kind = 1 [json_name = "Kind"];
     */
    kind: string;
    /**
     * SubKind is an optional resource sub kind, used in some resources
     *
     * @generated from protobuf field: string SubKind = 2 [json_name = "SubKind"];
     */
    subKind: string;
    /**
     * Version is version
     *
     * @generated from protobuf field: string Version = 3 [json_name = "Version"];
     */
    version: string;
    /**
     * Metadata is KubernetesResourceV1 metadata
     *
     * @generated from protobuf field: types.Metadata Metadata = 4 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Spec contains the Kubernetes resource data.
     *
     * @generated from protobuf field: types.KubernetesResourceSpecV1 Spec = 5 [json_name = "Spec"];
     */
    spec?: KubernetesResourceSpecV1;
}
/**
 * KubernetesResourceSpecV1 is the Kubernetes resource spec.
 *
 * @generated from protobuf message types.KubernetesResourceSpecV1
 */
export interface KubernetesResourceSpecV1 {
    /**
     * Namespace is the resource namespace.
     *
     * @generated from protobuf field: string Namespace = 1 [json_name = "Namespace"];
     */
    namespace: string;
}
/**
 * ClusterMaintenanceConfigV1 is a config singleton used to configure infrequent
 * cluster maintenance operations.
 *
 * @generated from protobuf message types.ClusterMaintenanceConfigV1
 */
export interface ClusterMaintenanceConfigV1 {
    /**
     * @generated from protobuf field: types.ResourceHeader Header = 1 [json_name = "Header"];
     */
    header?: ResourceHeader;
    /**
     * @generated from protobuf field: types.ClusterMaintenanceConfigSpecV1 Spec = 2 [json_name = "Spec"];
     */
    spec?: ClusterMaintenanceConfigSpecV1;
    /**
     * Nonce is used to protect against concurrent modification of the maintenance
     * window. Clients should treat nonces as opaque.
     *
     * @generated from protobuf field: uint64 Nonce = 3 [json_name = "Nonce"];
     */
    nonce: bigint;
}
/**
 * ClusterMaintenanceConfigSpecV1 encodes the parameters of the upgrade window config object.
 *
 * @generated from protobuf message types.ClusterMaintenanceConfigSpecV1
 */
export interface ClusterMaintenanceConfigSpecV1 {
    /**
     * AgentUpgrades encodes the agent upgrade window.
     *
     * @generated from protobuf field: types.AgentUpgradeWindow AgentUpgrades = 1 [json_name = "AgentUpgrades"];
     */
    agentUpgrades?: AgentUpgradeWindow;
}
/**
 * AgentUpgradeWindow is the config object used to determine upcoming agent
 * upgrade windows.
 *
 * @generated from protobuf message types.AgentUpgradeWindow
 */
export interface AgentUpgradeWindow {
    /**
     * UTCStartHour is the start hour of the maintenance window in UTC.
     *
     * @generated from protobuf field: uint32 UTCStartHour = 1 [json_name = "UTCStartHour"];
     */
    uTCStartHour: number;
    /**
     * Weekdays is an optional list of weekdays. If not specified, an agent upgrade window
     * occurs every day.
     *
     * @generated from protobuf field: repeated string Weekdays = 2 [json_name = "Weekdays"];
     */
    weekdays: string[];
}
/**
 * ScheduledAgentUpgradeWindow is a derived value representing a single
 * upgrade window. Upgraders deal with discrete start/end times, so we use the
 * agent upgrade window configuration object to generate a sequence of specific
 * scheduled windows.
 *
 * @generated from protobuf message types.ScheduledAgentUpgradeWindow
 */
export interface ScheduledAgentUpgradeWindow {
    /**
     * Start is the start time of the upgrade window.
     *
     * @generated from protobuf field: google.protobuf.Timestamp Start = 1 [json_name = "Start"];
     */
    start?: Timestamp;
    /**
     * Stop is the stop time of the upgrade window.
     *
     * @generated from protobuf field: google.protobuf.Timestamp Stop = 2 [json_name = "Stop"];
     */
    stop?: Timestamp;
}
/**
 * AgentUpgradeSchedule is the canonical representation of upcoming
 * agent upgrade windows as generated by the AgentUpgradeWindow config object.
 *
 * @generated from protobuf message types.AgentUpgradeSchedule
 */
export interface AgentUpgradeSchedule {
    /**
     * Windows is the list of upcoming windows.
     *
     * @generated from protobuf field: repeated types.ScheduledAgentUpgradeWindow Windows = 1 [json_name = "Windows"];
     */
    windows: ScheduledAgentUpgradeWindow[];
}
/**
 * UserGroupV1 is a representation of an externally sourced user group.
 *
 * @generated from protobuf message types.UserGroupV1
 */
export interface UserGroupV1 {
    /**
     * Header is the resource header for the user group.
     *
     * @generated from protobuf field: types.ResourceHeader Header = 1 [json_name = "Header"];
     */
    header?: ResourceHeader;
    /**
     * Spec is the user group resource spec.
     *
     * @generated from protobuf field: types.UserGroupSpecV1 Spec = 2 [json_name = "Spec"];
     */
    spec?: UserGroupSpecV1;
}
/**
 * UserGroupSpecV1 is the specification of a user group.
 *
 * @generated from protobuf message types.UserGroupSpecV1
 */
export interface UserGroupSpecV1 {
    /**
     * Applications are a list of application IDs belonging to this user group.
     *
     * @generated from protobuf field: repeated string Applications = 1 [json_name = "Applications"];
     */
    applications: string[];
}
/**
 * OktaImportRuleSpecV1 is a Okta import rule specification.
 *
 * @generated from protobuf message types.OktaImportRuleSpecV1
 */
export interface OktaImportRuleSpecV1 {
    /**
     * Priority represents the priority of the rule application. Lower numbered rules will be applied first.
     *
     * @generated from protobuf field: int32 Priority = 1 [json_name = "Priority"];
     */
    priority: number;
    /**
     * Mappings is a list of matches that will map match conditions to labels.
     *
     * @generated from protobuf field: repeated types.OktaImportRuleMappingV1 Mappings = 2 [json_name = "Mappings"];
     */
    mappings: OktaImportRuleMappingV1[];
}
/**
 * OktaImportRuleMappingV1 is a list of matches that map match rules to labels.
 *
 * @generated from protobuf message types.OktaImportRuleMappingV1
 */
export interface OktaImportRuleMappingV1 {
    /**
     * Match is a set of matching rules for this mapping. If any of these match, then the mapping will be applied.
     *
     * @generated from protobuf field: repeated types.OktaImportRuleMatchV1 Match = 1 [json_name = "Match"];
     */
    match: OktaImportRuleMatchV1[];
    /**
     * AddLabels specifies which labels to add if any of the previous matches match.
     *
     * @generated from protobuf field: map<string, string> AddLabels = 2 [json_name = "AddLabels"];
     */
    addLabels: {
        [key: string]: string;
    };
}
/**
 * OktaImportRuleV1 is a representation of labeling rules for importing of Okta objects.
 *
 * @generated from protobuf message types.OktaImportRuleV1
 */
export interface OktaImportRuleV1 {
    /**
     * Header is the resource header for the SAML IdP service provider.
     *
     * @generated from protobuf field: types.ResourceHeader Header = 1 [json_name = "Header"];
     */
    header?: ResourceHeader;
    /**
     * Spec is the specification for the Okta import rule.
     *
     * @generated from protobuf field: types.OktaImportRuleSpecV1 Spec = 2 [json_name = "Spec"];
     */
    spec?: OktaImportRuleSpecV1;
}
/**
 * OktaImportRuleMatchV1 is a match rule for a mapping.
 *
 * @generated from protobuf message types.OktaImportRuleMatchV1
 */
export interface OktaImportRuleMatchV1 {
    /**
     * AppIDs is a list of app IDs to match against.
     *
     * @generated from protobuf field: repeated string AppIDs = 1 [json_name = "AppIDs"];
     */
    appIDs: string[];
    /**
     * GroupIDs is a list of group IDs to match against.
     *
     * @generated from protobuf field: repeated string GroupIDs = 2 [json_name = "GroupIDs"];
     */
    groupIDs: string[];
    /**
     * AppNameRegexes is a list of regexes to match against app names.
     *
     * @generated from protobuf field: repeated string AppNameRegexes = 3 [json_name = "AppNameRegexes"];
     */
    appNameRegexes: string[];
    /**
     * GroupNameRegexes is a list of regexes to match against group names.
     *
     * @generated from protobuf field: repeated string GroupNameRegexes = 4 [json_name = "GroupNameRegexes"];
     */
    groupNameRegexes: string[];
}
/**
 * OktaAssignmentV1 is a representation of an action or set of actions taken by Teleport to assign Okta users to applications or groups.
 *
 * @generated from protobuf message types.OktaAssignmentV1
 */
export interface OktaAssignmentV1 {
    /**
     * Header is the resource header for the Okta assignment.
     *
     * @generated from protobuf field: types.ResourceHeader Header = 1 [json_name = "Header"];
     */
    header?: ResourceHeader;
    /**
     * Spec is the specification for the Okta assignment.
     *
     * @generated from protobuf field: types.OktaAssignmentSpecV1 Spec = 2 [json_name = "Spec"];
     */
    spec?: OktaAssignmentSpecV1;
}
/**
 * OktaAssignmentSpecV1 is a Okta assignment specification.
 *
 * @generated from protobuf message types.OktaAssignmentSpecV1
 */
export interface OktaAssignmentSpecV1 {
    /**
     * User is the user that these actions will be applied to.
     *
     * @generated from protobuf field: string User = 1 [json_name = "User"];
     */
    user: string;
    /**
     * Targets is a list of Okta targets to take on a user.
     *
     * @generated from protobuf field: repeated types.OktaAssignmentTargetV1 Targets = 2 [json_name = "Targets"];
     */
    targets: OktaAssignmentTargetV1[];
    /**
     * CleanupTime is an optional field that notes when the assignment should be cleaned up.
     * If absent, the assignment will never be cleaned up.
     *
     * @generated from protobuf field: google.protobuf.Timestamp CleanupTime = 3 [json_name = "CleanupTime"];
     */
    cleanupTime?: Timestamp;
    /**
     * Status is the status of the assignment.
     *
     * @generated from protobuf field: types.OktaAssignmentSpecV1.OktaAssignmentStatus status = 4;
     */
    status: OktaAssignmentSpecV1_OktaAssignmentStatus;
    /**
     * LastTransition is an optional field that notes when the last state transition
     * occurred for this action. If absent, this object has never transitioned.
     *
     * @generated from protobuf field: google.protobuf.Timestamp LastTransition = 5 [json_name = "LastTransition"];
     */
    lastTransition?: Timestamp;
    /**
     * Finalized is set when the assignment has been properly cleaned up.
     *
     * @generated from protobuf field: bool Finalized = 6 [json_name = "Finalized"];
     */
    finalized: boolean;
}
/**
 * OktaAssignmentStatus represents the status of an Okta assignment.
 *
 * @generated from protobuf enum types.OktaAssignmentSpecV1.OktaAssignmentStatus
 */
export enum OktaAssignmentSpecV1_OktaAssignmentStatus {
    /**
     * UNKNOWN indicates the status is not set.
     *
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * PENDING indicates the action has not yet been applied.
     *
     * @generated from protobuf enum value: PENDING = 1;
     */
    PENDING = 1,
    /**
     * PROCESSSING indicates that the assignment is being applied.
     *
     * @generated from protobuf enum value: PROCESSING = 2;
     */
    PROCESSING = 2,
    /**
     * SUCCESSFUL indicates the action was applied successfully.
     *
     * @generated from protobuf enum value: SUCCESSFUL = 3;
     */
    SUCCESSFUL = 3,
    /**
     * FAILED indicates the action was not applied successfully. It will be retried.
     *
     * @generated from protobuf enum value: FAILED = 4;
     */
    FAILED = 4
}
/**
 * OktaAssignmentTargetV1 is a target of an Okta assignment.
 *
 * @generated from protobuf message types.OktaAssignmentTargetV1
 */
export interface OktaAssignmentTargetV1 {
    /**
     * Type is the type of Okta resource this assignment is targeting.
     *
     * @generated from protobuf field: types.OktaAssignmentTargetV1.OktaAssignmentTargetType type = 1;
     */
    type: OktaAssignmentTargetV1_OktaAssignmentTargetType;
    /**
     * ID is the ID of the Okta resource that's being targeted.
     *
     * @generated from protobuf field: string id = 2;
     */
    id: string;
}
/**
 * OktaAssignmentTargetType is the type of Okta object that an assignment is targeting.
 *
 * @generated from protobuf enum types.OktaAssignmentTargetV1.OktaAssignmentTargetType
 */
export enum OktaAssignmentTargetV1_OktaAssignmentTargetType {
    /**
     * UNKNOWN indicates the target is unknown.
     *
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * APPLICATION indicates the target is an application.
     *
     * @generated from protobuf enum value: APPLICATION = 1;
     */
    APPLICATION = 1,
    /**
     * GROUP indicates the target is a group.
     *
     * @generated from protobuf enum value: GROUP = 2;
     */
    GROUP = 2
}
/**
 * IntegrationV1 represents a connection between Teleport and some other 3rd party system.
 * This connection allows API access to that service from Teleport.
 * Each Integration instance must have a SubKind defined which identifies the external system.
 *
 * @generated from protobuf message types.IntegrationV1
 */
export interface IntegrationV1 {
    /**
     * Header is the resource header.
     *
     * @generated from protobuf field: types.ResourceHeader Header = 1 [json_name = "Header"];
     */
    header?: ResourceHeader;
    /**
     * Spec is an Integration specification.
     *
     * @generated from protobuf field: types.IntegrationSpecV1 Spec = 2 [json_name = "Spec"];
     */
    spec?: IntegrationSpecV1;
}
/**
 * IntegrationSpecV1 contains properties of all the supported integrations.
 *
 * @generated from protobuf message types.IntegrationSpecV1
 */
export interface IntegrationSpecV1 {
    /**
     * @generated from protobuf oneof: SubKindSpec
     */
    subKindSpec: {
        oneofKind: "aWSOIDC";
        /**
         * AWSOIDC contains the specific fields to handle the AWS OIDC Integration subkind
         *
         * @generated from protobuf field: types.AWSOIDCIntegrationSpecV1 AWSOIDC = 1 [json_name = "AWSOIDC"];
         */
        aWSOIDC: AWSOIDCIntegrationSpecV1;
    } | {
        oneofKind: "azureOIDC";
        /**
         * AzureOIDC contains the specific fields to handle the Azure OIDC Integration subkind
         *
         * @generated from protobuf field: types.AzureOIDCIntegrationSpecV1 AzureOIDC = 2 [json_name = "AzureOIDC"];
         */
        azureOIDC: AzureOIDCIntegrationSpecV1;
    } | {
        oneofKind: "gitHub";
        /**
         * GitHub contains the specific fields to handle the GitHub integration subkind.
         *
         * @generated from protobuf field: types.GitHubIntegrationSpecV1 GitHub = 3 [json_name = "GitHub"];
         */
        gitHub: GitHubIntegrationSpecV1;
    } | {
        oneofKind: "aWSRA";
        /**
         * AWSRA contains the specific fields to handle the AWS Roles Anywhere Integration subkind.
         *
         * @generated from protobuf field: types.AWSRAIntegrationSpecV1 AWSRA = 5 [json_name = "AWSRA"];
         */
        aWSRA: AWSRAIntegrationSpecV1;
    } | {
        oneofKind: undefined;
    };
    /**
     * Credentials contains credentials for the integration.
     *
     * @generated from protobuf field: types.PluginCredentialsV1 credentials = 4;
     */
    credentials?: PluginCredentialsV1;
}
/**
 * AWSOIDCIntegrationSpecV1 contains the spec properties for the AWS OIDC SubKind Integration.
 *
 * @generated from protobuf message types.AWSOIDCIntegrationSpecV1
 */
export interface AWSOIDCIntegrationSpecV1 {
    /**
     * RoleARN contains the Role ARN used to set up the Integration.
     * This is the AWS Role that Teleport will use to issue tokens for API Calls.
     *
     * @generated from protobuf field: string RoleARN = 1 [json_name = "RoleARN"];
     */
    roleARN: string;
    /**
     * IssuerS3URI is the Identity Provider that was configured in AWS.
     * This bucket/prefix/* files must be publicly accessible and contain the following:
     * > .well-known/openid-configuration
     * > .well-known/jwks
     * Format: s3://<bucket>/<prefix>
     * Optional. The proxy's endpoint is used if it is not specified.
     *
     * DEPRECATED: Thumbprint validation requires the issuer to update the IdP in AWS everytime the issuer changes the certificate.
     * Amazon had some whitelisted providers where the thumbprint was ignored. S3 hosted providers was in that list.
     * Amazon is now trusting all the root certificate authorities, and this workaround is no longer needed.
     * DELETE IN 18.0.
     *
     * @deprecated
     * @generated from protobuf field: string IssuerS3URI = 2 [deprecated = true, json_name = "IssuerS3URI"];
     */
    issuerS3URI: string;
    /**
     * Audience is used to record a name of a plugin or a discover service in Teleport
     * that depends on this integration.
     * Audience value can be empty or configured with supported preset audience type.
     * Preset audience may impose specific behavior on the integration CRUD API,
     * such as preventing integration from update or deletion. Empty audience value
     * should be treated as a default and backward-compatible behavior of the integration.
     *
     * @generated from protobuf field: string audience = 3;
     */
    audience: string;
}
/**
 * AzureOIDCIntegrationSpecV1 contains the spec properties for the Azure OIDC SubKind Integration.
 *
 * @generated from protobuf message types.AzureOIDCIntegrationSpecV1
 */
export interface AzureOIDCIntegrationSpecV1 {
    /**
     * TenantID specifies the ID of Entra Tenant (Directory)
     * that this plugin integrates with.
     *
     * @generated from protobuf field: string TenantID = 1 [json_name = "TenantID"];
     */
    tenantID: string;
    /**
     * ClientID specifies the ID of Azure enterprise application (client)
     * that corresponds to this plugin.
     *
     * @generated from protobuf field: string ClientID = 2 [json_name = "ClientID"];
     */
    clientID: string;
}
/**
 * GitHubIntegrationSpecV1 contains the specific fields to handle the GitHub integration subkind.
 *
 * @generated from protobuf message types.GitHubIntegrationSpecV1
 */
export interface GitHubIntegrationSpecV1 {
    /**
     * Organization specifies the name of the organization for the GitHub integration.
     *
     * @generated from protobuf field: string Organization = 1 [json_name = "Organization"];
     */
    organization: string;
}
/**
 * AWSRAIntegrationSpecV1 contains the spec properties for the AWS IAM Roles Anywhere SubKind Integration.
 *
 * @generated from protobuf message types.AWSRAIntegrationSpecV1
 */
export interface AWSRAIntegrationSpecV1 {
    /**
     * TrustAnchorARN contains the AWS IAM Roles Anywhere Trust Anchor ARN used to set up the Integration.
     *
     * @generated from protobuf field: string TrustAnchorARN = 1 [json_name = "TrustAnchorARN"];
     */
    trustAnchorARN: string;
    /**
     * ProfileSyncConfig contains the configuration for the AWS Roles Anywhere Profile sync.
     * This is used to create AWS Roles Anywhere profiles as application servers.
     *
     * @generated from protobuf field: types.AWSRolesAnywhereProfileSyncConfig ProfileSyncConfig = 2 [json_name = "ProfileSyncConfig"];
     */
    profileSyncConfig?: AWSRolesAnywhereProfileSyncConfig;
}
/**
 * AWSRolesAnywhereProfileSyncConfig contains the configuration for the AWS Roles Anywhere Profile sync.
 * This is used to sync AWS Roles Anywhere profiles as application servers.
 *
 * @generated from protobuf message types.AWSRolesAnywhereProfileSyncConfig
 */
export interface AWSRolesAnywhereProfileSyncConfig {
    /**
     * Enabled is set to true if this integration should sync profiles as application servers.
     *
     * @generated from protobuf field: bool Enabled = 1 [json_name = "Enabled"];
     */
    enabled: boolean;
    /**
     * ProfileARN is the ARN of the Roles Anywhere Profile used to generate credentials to access the AWS APIs.
     *
     * @generated from protobuf field: string ProfileARN = 2 [json_name = "ProfileARN"];
     */
    profileARN: string;
    /**
     * ProfileAcceptsRoleSessionName indicates whether the profile accepts a custom Role Session name.
     *
     * @generated from protobuf field: bool ProfileAcceptsRoleSessionName = 3 [json_name = "ProfileAcceptsRoleSessionName"];
     */
    profileAcceptsRoleSessionName: boolean;
    /**
     * RoleARN is the ARN of the IAM Role to assume when accessing the AWS APIs.
     *
     * @generated from protobuf field: string RoleARN = 4 [json_name = "RoleARN"];
     */
    roleARN: string;
}
/**
 * HeadlessAuthentication holds data for an ongoing headless authentication attempt.
 *
 * @generated from protobuf message types.HeadlessAuthentication
 */
export interface HeadlessAuthentication {
    /**
     * Header is the resource header.
     *
     * @generated from protobuf field: types.ResourceHeader header = 1;
     */
    header?: ResourceHeader;
    /**
     * User is a teleport user name.
     *
     * @generated from protobuf field: string user = 2;
     */
    user: string;
    /**
     * PublicKey is an ssh public key to sign in case of successful auth.
     *
     * Deprecated: prefer SshPublicKey and/or TlsPublicKey.
     *
     * @deprecated
     * @generated from protobuf field: bytes public_key = 3 [deprecated = true];
     */
    publicKey: Uint8Array;
    /**
     * State is the headless authentication request state.
     *
     * @generated from protobuf field: types.HeadlessAuthenticationState state = 4;
     */
    state: HeadlessAuthenticationState;
    /**
     * MFADevice is the mfa device used to approve the request in case of successful auth.
     *
     * @generated from protobuf field: types.MFADevice mfa_device = 5;
     */
    mfaDevice?: MFADevice;
    /**
     * ClientIPAddress is the IP address of the client being authenticated.
     *
     * @generated from protobuf field: string client_ip_address = 6;
     */
    clientIpAddress: string;
    /**
     * SshPublicKey is a public key that will be used as the subject of the issued
     * SSH certificate in case of successful auth. It must be in SSH authorized_keys format.
     *
     * @generated from protobuf field: bytes ssh_public_key = 7;
     */
    sshPublicKey: Uint8Array;
    /**
     * TlsPublicKey is a public key that will be used as the subject of the issued
     * TLS certificate in case of successful auth. It must be in PEM-encoded
     * PKCS#1 or PKIX format.
     *
     * @generated from protobuf field: bytes tls_public_key = 8;
     */
    tlsPublicKey: Uint8Array;
}
/**
 * WatchKind specifies resource kind to watch
 * When adding fields to this struct, make sure to review/update WatchKind.Contains method.
 *
 * @generated from protobuf message types.WatchKind
 */
export interface WatchKind {
    /**
     * Kind is a resource kind to watch
     *
     * @generated from protobuf field: string Kind = 1 [json_name = "Kind"];
     */
    kind: string;
    /**
     * LoadSecrets specifies whether to load secrets
     *
     * @generated from protobuf field: bool LoadSecrets = 2 [json_name = "LoadSecrets"];
     */
    loadSecrets: boolean;
    /**
     * Name is an optional specific resource type to watch,
     * if specified only the events with a specific resource
     * name will be sent
     *
     * @generated from protobuf field: string Name = 3 [json_name = "Name"];
     */
    name: string;
    /**
     * Filter is an optional mapping of custom filter parameters.
     * Valid values vary by resource kind.
     *
     * @generated from protobuf field: map<string, string> Filter = 4 [json_name = "Filter"];
     */
    filter: {
        [key: string]: string;
    };
    /**
     * SubKind is a resource subkind to watch
     *
     * @generated from protobuf field: string SubKind = 5 [json_name = "SubKind"];
     */
    subKind: string;
    /**
     * Version optionally specifies the resource version to watch.
     * Currently this field is ignored.
     *
     * @generated from protobuf field: string Version = 6 [json_name = "Version"];
     */
    version: string;
}
/**
 * WatchStatusV1 is intended to be attached to OpInit events and contain information about a successful WatchEvents call.
 *
 * @generated from protobuf message types.WatchStatusV1
 */
export interface WatchStatusV1 {
    /**
     * Kind is the resource kind.
     *
     * @generated from protobuf field: string Kind = 1 [json_name = "Kind"];
     */
    kind: string;
    /**
     * SubKind is an optional resource subkind. Currently unused for this resource.
     *
     * @generated from protobuf field: string SubKind = 2 [json_name = "SubKind"];
     */
    subKind: string;
    /**
     * Version is the resource version.
     *
     * @generated from protobuf field: string Version = 3 [json_name = "Version"];
     */
    version: string;
    /**
     * Metadata is the resource metadata.
     *
     * @generated from protobuf field: types.Metadata Metadata = 4 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Spec is the resource spec.
     *
     * @generated from protobuf field: types.WatchStatusSpecV1 Spec = 5 [json_name = "Spec"];
     */
    spec?: WatchStatusSpecV1;
}
/**
 * WatchStatusSpecV1 contains resource kinds confirmed by WatchEvents to be included in the event stream.
 *
 * @generated from protobuf message types.WatchStatusSpecV1
 */
export interface WatchStatusSpecV1 {
    /**
     * @generated from protobuf field: repeated types.WatchKind Kinds = 1 [json_name = "Kinds"];
     */
    kinds: WatchKind[];
}
/**
 * ServerInfoV1 contains info that should be applied to joining Nodes.
 *
 * @generated from protobuf message types.ServerInfoV1
 */
export interface ServerInfoV1 {
    /**
     * Kind is the resource kind.
     *
     * @generated from protobuf field: string Kind = 1 [json_name = "Kind"];
     */
    kind: string;
    /**
     * SubKind is an optional resource subkind.
     *
     * @generated from protobuf field: string SubKind = 2 [json_name = "SubKind"];
     */
    subKind: string;
    /**
     * Version is the resource version.
     *
     * @generated from protobuf field: string Version = 3 [json_name = "Version"];
     */
    version: string;
    /**
     * Metadata is the resource metadata.
     *
     * @generated from protobuf field: types.Metadata Metadata = 4 [json_name = "Metadata"];
     */
    metadata?: Metadata;
    /**
     * Spec is the resource spec.
     *
     * @generated from protobuf field: types.ServerInfoSpecV1 Spec = 5 [json_name = "Spec"];
     */
    spec?: ServerInfoSpecV1;
}
/**
 * ServerInfoSpecV1 contains fields used to match Nodes to this ServerInfo.
 *
 * @generated from protobuf message types.ServerInfoSpecV1
 */
export interface ServerInfoSpecV1 {
    /**
     * NewLabels is the set of labels to add to nodes matching this ServerInfo.
     *
     * @generated from protobuf field: map<string, string> NewLabels = 2 [json_name = "NewLabels"];
     */
    newLabels: {
        [key: string]: string;
    };
}
/**
 * JamfSpecV1 is the base configuration for the Jamf MDM service.
 *
 * @generated from protobuf message types.JamfSpecV1
 */
export interface JamfSpecV1 {
    /**
     * Enabled toggles the service on or off.
     *
     * @generated from protobuf field: bool enabled = 1;
     */
    enabled: boolean;
    /**
     * Name of the service device source.
     * See the teleport.devicetrust.v1.DeviceSource proto.
     * Defaults to "jamf".
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * Initial sync delay for the service.
     * Set to negative to perform syncs immediately on startup.
     * Defaults to a random delay (a few minutes max).
     *
     * @generated from protobuf field: int64 sync_delay = 3;
     */
    syncDelay: bigint;
    /**
     * Jamf Pro API endpoint.
     * Example: "https://yourtenant.jamfcloud.com/api".
     * Required.
     *
     * @generated from protobuf field: string api_endpoint = 4;
     */
    apiEndpoint: string;
    /**
     * Inventory sync entries.
     * If empty a default sync configuration is used.
     *
     * @generated from protobuf field: repeated types.JamfInventoryEntry inventory = 7;
     */
    inventory: JamfInventoryEntry[];
}
/**
 * JamfInventoryEntry is an inventory sync entry for [JamfSpecV1].
 *
 * @generated from protobuf message types.JamfInventoryEntry
 */
export interface JamfInventoryEntry {
    /**
     * Jamf Pro API RSQL filter, used when querying endpoints like
     * "/api/v1/computers-inventory".
     * See https://developer.jamf.com/jamf-pro/reference/get_v1-computers-inventory.
     *
     * @generated from protobuf field: string filter_rsql = 1;
     */
    filterRsql: string;
    /**
     * Sync period for PARTIAL syncs.
     * PARTIAL syncs are scheduled in the time window between FULL syncs, so
     * sync_period_partial must always be smaller than sync_period_full, otherwise
     * it would never trigger.
     * Set to zero or negative to disable PARTIAL syncs.
     *
     * @generated from protobuf field: int64 sync_period_partial = 2;
     */
    syncPeriodPartial: bigint;
    /**
     * Sync period for FULL syncs.
     * Ideally sync_period_full is a multiple of sync_period_partial, so schedules
     * line up perfectly.
     * Set to zero or negative to disable FULL syncs.
     *
     * @generated from protobuf field: int64 sync_period_full = 3;
     */
    syncPeriodFull: bigint;
    /**
     * on_missing is the trigger used on devices missing from the MDM view in a
     * FULL sync.
     * Only runs on successful FULL syncs.
     * Corresponds to [teleport.devicetrust.v1.SyncInventoryDeviceAction].
     * Must be either "NOOP" or "DELETE".
     * Defaults to "NOOP".
     *
     * @generated from protobuf field: string on_missing = 4;
     */
    onMissing: string;
    /**
     * Custom page size for inventory queries.
     * A server default is used if zeroed or negative.
     *
     * @generated from protobuf field: int32 page_size = 5;
     */
    pageSize: number;
}
/**
 * MessageWithHeader is a message with a resource header. This is used primarily
 * for parsing of resource headers and isn't expected to be used directly by any
 * resources.
 *
 * When using a oneof in a protobuf messages, the existing utils.FastMarshal
 * utility does not work, so using something like protojson or jsonpb is required.
 * However, these do not respect gogoproto's extensions. When using a ResourceHeader,
 * protojson will not recognize that the ResourceHeader is intended to be embedded and
 * the resulting JSON will have the header as a separate field. This means that using
 * utils.FastUnmarshal will not work for extracting a ResourceHeader from the
 * JSON, and we explicitly extract this header to do things like version checking in
 * lib/services.
 *
 * This can be avoided by explicitly embedding the members of the ResourceHeader in
 * a message. However, if we would like to avoid this, we can use this MessageWitHheader
 * to extract the resource header and its elements, which can later be used for the
 * aforementioned processing in lib/services.
 *
 * @generated from protobuf message types.MessageWithHeader
 */
export interface MessageWithHeader {
    /**
     * Header is the resource header for a resource.
     *
     * @generated from protobuf field: types.ResourceHeader Header = 1 [json_name = "Header"];
     */
    header?: ResourceHeader;
}
/**
 * AWSMatcher matches AWS EC2 instances and AWS Databases
 *
 * @generated from protobuf message types.AWSMatcher
 */
export interface AWSMatcher {
    /**
     * Types are AWS database types to match, "ec2", "rds", "redshift", "elasticache",
     * or "memorydb".
     *
     * @generated from protobuf field: repeated string Types = 1 [json_name = "Types"];
     */
    types: string[];
    /**
     * Regions are AWS regions to query for databases.
     *
     * @generated from protobuf field: repeated string Regions = 2 [json_name = "Regions"];
     */
    regions: string[];
    /**
     * AssumeRoleARN is the AWS role to assume for database discovery.
     *
     * @generated from protobuf field: types.AssumeRole AssumeRole = 3 [json_name = "AssumeRole"];
     */
    assumeRole?: AssumeRole;
    /**
     * Tags are AWS resource Tags to match.
     *
     * @generated from protobuf field: wrappers.LabelValues Tags = 4 [json_name = "Tags"];
     */
    tags?: LabelValues;
    /**
     * Params sets the join method when installing on discovered EC2 nodes
     *
     * @generated from protobuf field: types.InstallerParams Params = 5 [json_name = "Params"];
     */
    params?: InstallerParams;
    /**
     * SSM provides options to use when sending a document command to
     * an EC2 node
     *
     * @generated from protobuf field: types.AWSSSM SSM = 6 [json_name = "SSM"];
     */
    sSM?: AWSSSM;
    /**
     * Integration is the integration name used to generate credentials to interact with AWS APIs.
     * Environment credentials will not be used when this value is set.
     *
     * @generated from protobuf field: string Integration = 7 [json_name = "Integration"];
     */
    integration: string;
    /**
     * KubeAppDiscovery controls whether Kubernetes App Discovery will be enabled for agents running on
     * discovered clusters, currently only affects AWS EKS discovery in integration mode.
     *
     * @generated from protobuf field: bool KubeAppDiscovery = 8 [json_name = "KubeAppDiscovery"];
     */
    kubeAppDiscovery: boolean;
    /**
     * SetupAccessForARN is the role that the discovery service should create EKS Access Entries for.
     * This value should match the IAM identity that Teleport Kubernetes Service uses.
     * If this value is empty, the discovery service will attempt to set up access for its own identity (self).
     *
     * @generated from protobuf field: string SetupAccessForARN = 9 [json_name = "SetupAccessForARN"];
     */
    setupAccessForARN: string;
}
/**
 * AssumeRole provides a role ARN and ExternalID to assume an AWS role
 * when interacting with AWS resources.
 *
 * @generated from protobuf message types.AssumeRole
 */
export interface AssumeRole {
    /**
     * RoleARN is the fully specified AWS IAM role ARN.
     *
     * @generated from protobuf field: string RoleARN = 1 [json_name = "RoleARN"];
     */
    roleARN: string;
    /**
     * ExternalID is the external ID used to assume a role in another account.
     *
     * @generated from protobuf field: string ExternalID = 2 [json_name = "ExternalID"];
     */
    externalID: string;
}
/**
 * InstallParams sets join method to use on discovered nodes
 *
 * @generated from protobuf message types.InstallerParams
 */
export interface InstallerParams {
    /**
     * JoinMethod is the method to use when joining the cluster
     *
     * @generated from protobuf field: string JoinMethod = 1 [json_name = "JoinMethod"];
     */
    joinMethod: string;
    /**
     * JoinToken is the token to use when joining the cluster
     *
     * @generated from protobuf field: string JoinToken = 2 [json_name = "JoinToken"];
     */
    joinToken: string;
    /**
     * ScriptName is the name of the teleport installer script
     * resource for the cloud instance to execute
     *
     * @generated from protobuf field: string ScriptName = 3 [json_name = "ScriptName"];
     */
    scriptName: string;
    /**
     * InstallTeleport disables agentless discovery
     *
     * @generated from protobuf field: bool InstallTeleport = 4 [json_name = "InstallTeleport"];
     */
    installTeleport: boolean;
    /**
     * SSHDConfig provides the path to write sshd configuration changes
     *
     * @generated from protobuf field: string SSHDConfig = 5 [json_name = "SSHDConfig"];
     */
    sSHDConfig: string;
    /**
     * PublicProxyAddr is the address of the proxy the discovered node should use
     * to connect to the cluster.
     *
     * @generated from protobuf field: string PublicProxyAddr = 6 [json_name = "PublicProxyAddr"];
     */
    publicProxyAddr: string;
    /**
     * Azure is the set of Azure-specific installation parameters.
     *
     * @generated from protobuf field: types.AzureInstallerParams Azure = 7 [json_name = "Azure"];
     */
    azure?: AzureInstallerParams;
    /**
     * EnrollMode indicates the enrollment mode to be used when adding a node.
     * Valid values:
     * 0: uses eice for EC2 matchers which use an integration and script for all the other methods
     * 1: uses script mode
     * 2: uses eice mode
     *
     * @generated from protobuf field: types.InstallParamEnrollMode EnrollMode = 8 [json_name = "EnrollMode"];
     */
    enrollMode: InstallParamEnrollMode;
}
/**
 * AWSSSM provides options to use when executing SSM documents
 *
 * @generated from protobuf message types.AWSSSM
 */
export interface AWSSSM {
    /**
     * DocumentName is the name of the document to use when executing an
     * SSM command
     *
     * @generated from protobuf field: string DocumentName = 1 [json_name = "DocumentName"];
     */
    documentName: string;
}
/**
 * AzureInstallerParams is the set of Azure-specific installation parameters.
 *
 * @generated from protobuf message types.AzureInstallerParams
 */
export interface AzureInstallerParams {
    /**
     * ClientID is the client ID of the managed identity discovered nodes
     * should use to join the cluster.
     *
     * @generated from protobuf field: string ClientID = 1 [json_name = "ClientID"];
     */
    clientID: string;
}
/**
 * AzureMatcher matches Azure resources.
 * It defines which resource types, filters and some configuration params.
 *
 * @generated from protobuf message types.AzureMatcher
 */
export interface AzureMatcher {
    /**
     * Subscriptions are Azure subscriptions to query for resources.
     *
     * @generated from protobuf field: repeated string Subscriptions = 1 [json_name = "Subscriptions"];
     */
    subscriptions: string[];
    /**
     * ResourceGroups are Azure resource groups to query for resources.
     *
     * @generated from protobuf field: repeated string ResourceGroups = 2 [json_name = "ResourceGroups"];
     */
    resourceGroups: string[];
    /**
     * Types are Azure types to match: "mysql", "postgres", "aks", "vm"
     *
     * @generated from protobuf field: repeated string Types = 3 [json_name = "Types"];
     */
    types: string[];
    /**
     * Regions are Azure locations to match for databases.
     *
     * @generated from protobuf field: repeated string Regions = 4 [json_name = "Regions"];
     */
    regions: string[];
    /**
     * ResourceTags are Azure tags on resources to match.
     *
     * @generated from protobuf field: wrappers.LabelValues ResourceTags = 5 [json_name = "ResourceTags"];
     */
    resourceTags?: LabelValues;
    /**
     * Params sets the join method when installing on
     * discovered Azure nodes.
     *
     * @generated from protobuf field: types.InstallerParams Params = 6 [json_name = "Params"];
     */
    params?: InstallerParams;
}
/**
 * GCPMatcher matches GCP resources.
 *
 * @generated from protobuf message types.GCPMatcher
 */
export interface GCPMatcher {
    /**
     * Types are GKE resource types to match: "gke", "vm".
     *
     * @generated from protobuf field: repeated string Types = 1 [json_name = "Types"];
     */
    types: string[];
    /**
     * Locations are GKE locations to search resources for.
     *
     * @generated from protobuf field: repeated string Locations = 2 [json_name = "Locations"];
     */
    locations: string[];
    /**
     * Tags is obsolete and only exists for backwards compatibility. Use Labels instead.
     *
     * @generated from protobuf field: wrappers.LabelValues Tags = 3 [json_name = "Tags"];
     */
    tags?: LabelValues;
    /**
     * ProjectIDs are the GCP project ID where the resources are deployed.
     *
     * @generated from protobuf field: repeated string ProjectIDs = 4 [json_name = "ProjectIDs"];
     */
    projectIDs: string[];
    /**
     * ServiceAccounts are the emails of service accounts attached to VMs.
     *
     * @generated from protobuf field: repeated string ServiceAccounts = 5 [json_name = "ServiceAccounts"];
     */
    serviceAccounts: string[];
    /**
     * Params sets the join method when installing on
     * discovered GCP nodes.
     *
     * @generated from protobuf field: types.InstallerParams Params = 6 [json_name = "Params"];
     */
    params?: InstallerParams;
    /**
     * Labels are GCP labels to match.
     *
     * @generated from protobuf field: wrappers.LabelValues Labels = 7 [json_name = "Labels"];
     */
    labels?: LabelValues;
}
/**
 * KubernetesMatcher matches Kubernetes services.
 *
 * @generated from protobuf message types.KubernetesMatcher
 */
export interface KubernetesMatcher {
    /**
     * Types are Kubernetes services types to match. Currently only 'app' is supported.
     *
     * @generated from protobuf field: repeated string Types = 1 [json_name = "Types"];
     */
    types: string[];
    /**
     * Namespaces are Kubernetes namespaces in which to discover services
     *
     * @generated from protobuf field: repeated string Namespaces = 2 [json_name = "Namespaces"];
     */
    namespaces: string[];
    /**
     * Labels are Kubernetes services labels to match.
     *
     * @generated from protobuf field: wrappers.LabelValues Labels = 3 [json_name = "Labels"];
     */
    labels?: LabelValues;
}
/**
 * OktaOptions specify options related to the Okta service.
 *
 * @generated from protobuf message types.OktaOptions
 */
export interface OktaOptions {
    /**
     * SyncPeriod is the duration between synchronization calls in nanoseconds.
     *
     * @generated from protobuf field: int64 SyncPeriod = 1 [json_name = "SyncPeriod"];
     */
    syncPeriod: bigint;
}
/**
 * AccessGraphSync is a configuration for Access Graph service.
 *
 * @generated from protobuf message types.AccessGraphSync
 */
export interface AccessGraphSync {
    /**
     * AWS is a configuration for AWS Access Graph service poll service.
     *
     * @generated from protobuf field: repeated types.AccessGraphAWSSync AWS = 1 [json_name = "AWS"];
     */
    aWS: AccessGraphAWSSync[];
    /**
     * PollInterval is the frequency at which to poll for resources
     *
     * @generated from protobuf field: google.protobuf.Duration PollInterval = 2 [json_name = "PollInterval"];
     */
    pollInterval?: Duration;
    /**
     * Azure is a configuration for Azure Access Graph service poll service.
     *
     * @generated from protobuf field: repeated types.AccessGraphAzureSync Azure = 3 [json_name = "Azure"];
     */
    azure: AccessGraphAzureSync[];
}
/**
 * AccessGraphAWSSyncCloudTrailLogs defines settings for ingesting AWS CloudTrail logs
 * by polling an SQS queue that receives notifications about new log files.
 *
 * @generated from protobuf message types.AccessGraphAWSSyncCloudTrailLogs
 */
export interface AccessGraphAWSSyncCloudTrailLogs {
    /**
     * The AWS region of the SQS queue for CloudTrail notifications, ex.: "us-east-2".
     *
     * @generated from protobuf field: string Region = 1 [json_name = "Region"];
     */
    region: string;
    /**
     * The name or URL for CloudTrail log events, ex.: "demo-cloudtrail-queue".
     *
     * @generated from protobuf field: string SQSQueue = 2 [json_name = "SQSQueue"];
     */
    sQSQueue: string;
}
/**
 * AccessGraphAWSSync is a configuration for AWS Access Graph service poll service.
 *
 * @generated from protobuf message types.AccessGraphAWSSync
 */
export interface AccessGraphAWSSync {
    /**
     * Regions are AWS regions to import resources from.
     *
     * @generated from protobuf field: repeated string Regions = 1 [json_name = "Regions"];
     */
    regions: string[];
    /**
     * AssumeRoleARN is the AWS role to assume for database discovery.
     *
     * @generated from protobuf field: types.AssumeRole AssumeRole = 3 [json_name = "AssumeRole"];
     */
    assumeRole?: AssumeRole;
    /**
     * Integration is the integration name used to generate credentials to interact with AWS APIs.
     *
     * @generated from protobuf field: string Integration = 4 [json_name = "Integration"];
     */
    integration: string;
    /**
     * Configuration settings for collecting AWS CloudTrail logs via an SQS queue.
     *
     * @generated from protobuf field: types.AccessGraphAWSSyncCloudTrailLogs cloud_trail_logs = 5;
     */
    cloudTrailLogs?: AccessGraphAWSSyncCloudTrailLogs;
}
/**
 * AccessGraphAzureSync is a configuration for Azure Access Graph service poll service.
 *
 * @generated from protobuf message types.AccessGraphAzureSync
 */
export interface AccessGraphAzureSync {
    /**
     * SubscriptionID Is the ID of the Azure subscription to sync resources from
     *
     * @generated from protobuf field: string SubscriptionID = 1 [json_name = "SubscriptionID"];
     */
    subscriptionID: string;
    /**
     * Integration is the integration name used to generate credentials to interact with AWS APIs.
     *
     * @generated from protobuf field: string Integration = 2 [json_name = "Integration"];
     */
    integration: string;
}
/**
 * TargetHealth describes the health status of network connectivity between
 * an agent and a resource.
 *
 * @generated from protobuf message types.TargetHealth
 */
export interface TargetHealth {
    /**
     * Address is the resource address.
     *
     * @generated from protobuf field: string Address = 1 [json_name = "Address"];
     */
    address: string;
    /**
     * Protocol is the health check protocol such as "tcp".
     *
     * @generated from protobuf field: string Protocol = 2 [json_name = "Protocol"];
     */
    protocol: string;
    /**
     * Status is the health status, one of "", "unknown", "healthy", "unhealthy".
     *
     * @generated from protobuf field: string Status = 3 [json_name = "Status"];
     */
    status: string;
    /**
     * TransitionTimestamp is the time that the last status transition occurred.
     *
     * @generated from protobuf field: google.protobuf.Timestamp TransitionTimestamp = 4 [json_name = "TransitionTimestamp"];
     */
    transitionTimestamp?: Timestamp;
    /**
     * TransitionReason is a unique single word reason why the last transition occurred.
     *
     * @generated from protobuf field: string TransitionReason = 5 [json_name = "TransitionReason"];
     */
    transitionReason: string;
    /**
     * TransitionError shows the health check error observed when the transition
     * happened. Empty when transitioning to "healthy".
     *
     * @generated from protobuf field: string TransitionError = 6 [json_name = "TransitionError"];
     */
    transitionError: string;
    /**
     * Message is additional information meant for a user.
     *
     * @generated from protobuf field: string Message = 7 [json_name = "Message"];
     */
    message: string;
}
/**
 * IAMPolicyStatus represents states that describe if an AWS database
 * has its IAM policy properly configured or not.
 * This enum is set in a Sync.Map during an IAM task that checks for the
 * validity of IAM policy, and the database gets updated with the value
 * from this map during a heartbeat.
 *
 * @generated from protobuf enum types.IAMPolicyStatus
 */
export enum IAMPolicyStatus {
    /**
     * IAM_POLICY_STATUS_UNSPECIFIED represents a zero value where
     * nothing has been attempted yet.
     *
     * @generated from protobuf enum value: IAM_POLICY_STATUS_UNSPECIFIED = 0;
     */
    IAM_POLICY_STATUS_UNSPECIFIED = 0,
    /**
     * IAM_POLICY_STATUS_PENDING represents a state where iam policy status
     * is pending to be checked. This enum value is set at the start of
     * registering a database -> IAM setup (before the db heartbeat starts).
     *
     * This state was required for two reasons:
     *   1) To be able to tell apart from an older service that do not update
     *      the IAMPolicyStatus (in which case the enum value will remain the
     *      zero value).
     *   2) When starting a database, the heartbeat and its IAM task starts,
     *      and the heartbeat may run first before the IAM task finishes.
     *
     * @generated from protobuf enum value: IAM_POLICY_STATUS_PENDING = 1;
     */
    IAM_POLICY_STATUS_PENDING = 1,
    /**
     * IAM_POLICY_STATUS_FAILED represents a state where an error occured
     * while checking for IAM policy status eg: no AWS credentials provider found
     * or the policy was misconfigured.
     *
     * @generated from protobuf enum value: IAM_POLICY_STATUS_FAILED = 2;
     */
    IAM_POLICY_STATUS_FAILED = 2,
    /**
     * IAM_POLICY_STATUS_SUCCESS represents a state where IAM policy was configured
     * correctly.
     *
     * @generated from protobuf enum value: IAM_POLICY_STATUS_SUCCESS = 3;
     */
    IAM_POLICY_STATUS_SUCCESS = 3
}
/**
 * DatabaseTLSMode represents the level of TLS verification performed by
 * DB agent when connecting to a database.
 *
 * @generated from protobuf enum types.DatabaseTLSMode
 */
export enum DatabaseTLSMode {
    /**
     * VERIFY_FULL performs full certificate validation.
     *
     * @generated from protobuf enum value: VERIFY_FULL = 0;
     */
    VERIFY_FULL = 0,
    /**
     * VERIFY_CA works the same as VERIFY_FULL, but it skips the hostname check.
     *
     * @generated from protobuf enum value: VERIFY_CA = 1;
     */
    VERIFY_CA = 1,
    /**
     * INSECURE accepts any certificate provided by server. This is the least secure option.
     *
     * @generated from protobuf enum value: INSECURE = 2;
     */
    INSECURE = 2
}
/**
 * @generated from protobuf enum types.UpdaterStatus
 */
export enum UpdaterStatus {
    /**
     * UPDATER_STATUS_UNSPECIFIED is the zero value.
     *
     * @generated from protobuf enum value: UPDATER_STATUS_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * UPDATER_STATUS_OK means that everything looks OK from the agent pov.
     *
     * @generated from protobuf enum value: UPDATER_STATUS_OK = 1;
     */
    OK = 1,
    /**
     * UPDATER_STATUS_DISABLED means that automatic updates seem disabled or paused.
     *
     * @generated from protobuf enum value: UPDATER_STATUS_DISABLED = 2;
     */
    DISABLED = 2,
    /**
     * UPDATER_STATUS_PINNED means that a specific version is pinned.
     *
     * @generated from protobuf enum value: UPDATER_STATUS_PINNED = 3;
     */
    PINNED = 3,
    /**
     * UPDATER_STATUS_UNREADABLE means that the agent failed to read its update status.
     *
     * @generated from protobuf enum value: UPDATER_STATUS_UNREADABLE = 4;
     */
    UNREADABLE = 4
}
/**
 * PrivateKeyType is the storage type of a private key.
 *
 * @generated from protobuf enum types.PrivateKeyType
 */
export enum PrivateKeyType {
    /**
     * RAW is a plaintext private key.
     *
     * @generated from protobuf enum value: RAW = 0;
     */
    RAW = 0,
    /**
     * PKCS11 is a private key backed by a PKCS11 device such as HSM.
     *
     * @generated from protobuf enum value: PKCS11 = 1;
     */
    PKCS11 = 1,
    /**
     * GCP_KMS is a private key backed by GCP KMS.
     *
     * @generated from protobuf enum value: GCP_KMS = 2;
     */
    GCP_KMS = 2,
    /**
     * AWS_KMS is a private key backed by AWS KMS.
     *
     * @generated from protobuf enum value: AWS_KMS = 3;
     */
    AWS_KMS = 3
}
/**
 * ProxyListenerMode represents the cluster proxy listener mode.
 *
 * @generated from protobuf enum types.ProxyListenerMode
 */
export enum ProxyListenerMode {
    /**
     * Separate is the proxy listener mode indicating that proxies are running
     * in separate listener mode where Teleport Proxy services use different listeners.
     *
     * @generated from protobuf enum value: Separate = 0;
     */
    Separate = 0,
    /**
     * Multiplex is the proxy listener mode indicating the proxy should use multiplex mode
     * where all proxy services are multiplexed on a single proxy port.
     *
     * @generated from protobuf enum value: Multiplex = 1;
     */
    Multiplex = 1
}
/**
 * RoutingStrategy determines the strategy used to route to nodes.
 *
 * @generated from protobuf enum types.RoutingStrategy
 */
export enum RoutingStrategy {
    /**
     * UnambiguousMatch only routes to distinct nodes.
     *
     * @generated from protobuf enum value: UNAMBIGUOUS_MATCH = 0;
     */
    UNAMBIGUOUS_MATCH = 0,
    /**
     * MostRecent routes to the most recently heartbeated node if duplicates are present.
     *
     * @generated from protobuf enum value: MOST_RECENT = 1;
     */
    MOST_RECENT = 1
}
/**
 * SecondFactorType is a type of second factor.
 *
 * @generated from protobuf enum types.SecondFactorType
 */
export enum SecondFactorType {
    /**
     * @generated from protobuf enum value: SECOND_FACTOR_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * SECOND_FACTOR_TYPE_OTP is OTP second factor.
     *
     * @generated from protobuf enum value: SECOND_FACTOR_TYPE_OTP = 1;
     */
    OTP = 1,
    /**
     * SECOND_FACTOR_TYPE_WEBAUTHN is WebAuthn second factor.
     *
     * @generated from protobuf enum value: SECOND_FACTOR_TYPE_WEBAUTHN = 2;
     */
    WEBAUTHN = 2,
    /**
     * SECOND_FACTOR_TYPE_SSO is SSO second factor.
     *
     * @generated from protobuf enum value: SECOND_FACTOR_TYPE_SSO = 3;
     */
    SSO = 3
}
/**
 * UserTokenUsage contains additional information about the intended usage of a user token.
 *
 * @generated from protobuf enum types.UserTokenUsage
 */
export enum UserTokenUsage {
    /**
     * Default value that implies token usage was not set.
     *
     * @generated from protobuf enum value: USER_TOKEN_USAGE_UNSPECIFIED = 0;
     */
    USER_TOKEN_USAGE_UNSPECIFIED = 0,
    /**
     * USER_TOKEN_RECOVER_PASSWORD is a request to recover password.
     *
     * @generated from protobuf enum value: USER_TOKEN_RECOVER_PASSWORD = 1;
     */
    USER_TOKEN_RECOVER_PASSWORD = 1,
    /**
     * USER_TOKEN_RECOVER_MFA is a request to recover a MFA.
     *
     * @generated from protobuf enum value: USER_TOKEN_RECOVER_MFA = 2;
     */
    USER_TOKEN_RECOVER_MFA = 2,
    /**
     * USER_TOKEN_RENEWAL_BOT is a request to generate certificates
     * for a bot user.
     *
     * @generated from protobuf enum value: USER_TOKEN_RENEWAL_BOT = 3;
     */
    USER_TOKEN_RENEWAL_BOT = 3
}
/**
 * RequestState represents the state of a request for escalated privilege.
 *
 * @generated from protobuf enum types.RequestState
 */
export enum RequestState {
    /**
     * NONE variant exists to allow RequestState to be explicitly omitted
     * in certain circumstances (e.g. in an AccessRequestFilter).
     *
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * PENDING variant is the default for newly created requests.
     *
     * @generated from protobuf enum value: PENDING = 1;
     */
    PENDING = 1,
    /**
     * APPROVED variant indicates that a request has been accepted by
     * an administrating party.
     *
     * @generated from protobuf enum value: APPROVED = 2;
     */
    APPROVED = 2,
    /**
     * DENIED variant indicates that a request has been rejected by
     * an administrating party.
     *
     * @generated from protobuf enum value: DENIED = 3;
     */
    DENIED = 3,
    /**
     * PROMOTED variant indicates that a request has been promoted to
     * an access list.
     *
     * @generated from protobuf enum value: PROMOTED = 4;
     */
    PROMOTED = 4
}
/**
 * @generated from protobuf enum types.AccessRequestScope
 */
export enum AccessRequestScope {
    /**
     * DEFAULT allows all requests to be viewed
     *
     * @generated from protobuf enum value: DEFAULT = 0;
     */
    DEFAULT = 0,
    /**
     * MY_REQUESTS will return only requests created by the requester
     *
     * @generated from protobuf enum value: MY_REQUESTS = 1;
     */
    MY_REQUESTS = 1,
    /**
     * NEEDS_REVIEW will return only requests that were not created by
     * the requester and do not include a review made by the requester
     *
     * @generated from protobuf enum value: NEEDS_REVIEW = 2;
     */
    NEEDS_REVIEW = 2,
    /**
     * REVIEWED will return only requests that were not created by
     * the requester and have a review submitted by the requester. This
     * can include requests that have no yet been completely approved/denied.
     *
     * @generated from protobuf enum value: REVIEWED = 3;
     */
    REVIEWED = 3
}
/**
 * CreateHostUserMode determines whether host user creation should be
 * disabled or if host users should be cleaned up or kept after
 * sessions end.
 *
 * @generated from protobuf enum types.CreateHostUserMode
 */
export enum CreateHostUserMode {
    /**
     * @generated from protobuf enum value: HOST_USER_MODE_UNSPECIFIED = 0;
     */
    HOST_USER_MODE_UNSPECIFIED = 0,
    /**
     * HOST_USER_MODE_OFF disables host user creation.
     *
     * @generated from protobuf enum value: HOST_USER_MODE_OFF = 1;
     */
    HOST_USER_MODE_OFF = 1,
    /**
     * HOST_USER_MODE_DROP enables host user creation and deletes users at session end.
     * Deprecated: replaced by HOST_USER_MODE_INSECURE_DROP.
     *
     * @deprecated
     * @generated from protobuf enum value: HOST_USER_MODE_DROP = 2 [deprecated = true];
     */
    HOST_USER_MODE_DROP = 2,
    /**
     * HOST_USER_MODE_KEEP enables host user creation and leaves users behind at session end.
     *
     * @generated from protobuf enum value: HOST_USER_MODE_KEEP = 3;
     */
    HOST_USER_MODE_KEEP = 3,
    /**
     * HOST_USER_MODE_INSECURE_DROP enables host user creation without a home directory and deletes
     * users at session end.
     *
     * @generated from protobuf enum value: HOST_USER_MODE_INSECURE_DROP = 4;
     */
    HOST_USER_MODE_INSECURE_DROP = 4
}
/**
 * CreateDatabaseUserMode determines whether database user creation should be
 * disabled or if users should be cleaned up or kept after sessions end.
 *
 * @generated from protobuf enum types.CreateDatabaseUserMode
 */
export enum CreateDatabaseUserMode {
    /**
     * @generated from protobuf enum value: DB_USER_MODE_UNSPECIFIED = 0;
     */
    DB_USER_MODE_UNSPECIFIED = 0,
    /**
     * DB_USER_MODE_OFF disables user creation.
     *
     * @generated from protobuf enum value: DB_USER_MODE_OFF = 1;
     */
    DB_USER_MODE_OFF = 1,
    /**
     * DB_USER_MODE_KEEP allows user creation and disable users at session end.
     *
     * @generated from protobuf enum value: DB_USER_MODE_KEEP = 2;
     */
    DB_USER_MODE_KEEP = 2,
    /**
     * DB_USER_MODE_BEST_EFFORT_DROP allows user creation and tries to drop user
     * at session end. If the drop fails, fallback to disabling them.
     *
     * @generated from protobuf enum value: DB_USER_MODE_BEST_EFFORT_DROP = 3;
     */
    DB_USER_MODE_BEST_EFFORT_DROP = 3
}
/**
 * CertExtensionMode specifies the type of extension to use in the cert.
 *
 * @generated from protobuf enum types.CertExtensionMode
 */
export enum CertExtensionMode {
    /**
     * EXTENSION represents a cert extension that may or may not be
     * honored by the server.
     *
     * @generated from protobuf enum value: EXTENSION = 0;
     */
    EXTENSION = 0
}
/**
 * CertExtensionType represents the certificate type the extension is for.
 * Currently only ssh is supported.
 *
 * @generated from protobuf enum types.CertExtensionType
 */
export enum CertExtensionType {
    /**
     * SSH is used when extending an ssh certificate
     *
     * @generated from protobuf enum value: SSH = 0;
     */
    SSH = 0
}
/**
 * PasswordState indicates what is known about existence of user's password.
 *
 * @generated from protobuf enum types.PasswordState
 */
export enum PasswordState {
    /**
     * Unable to tell whether the password has been configured.
     *
     * @generated from protobuf enum value: PASSWORD_STATE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Password is known to be not configured.
     *
     * @generated from protobuf enum value: PASSWORD_STATE_UNSET = 1;
     */
    UNSET = 1,
    /**
     * Password is known to be configured.
     *
     * @generated from protobuf enum value: PASSWORD_STATE_SET = 2;
     */
    SET = 2
}
/**
 * MFADeviceKind indicates what is known about existence of user's MFA device.
 *
 * @generated from protobuf enum types.MFADeviceKind
 */
export enum MFADeviceKind {
    /**
     * Unable to tell whether the MFA device has been configured.
     *
     * @generated from protobuf enum value: MFA_DEVICE_KIND_UNSPECIFIED = 0;
     */
    MFA_DEVICE_KIND_UNSPECIFIED = 0,
    /**
     * MFA device is known to be not configured.
     *
     * @generated from protobuf enum value: MFA_DEVICE_KIND_UNSET = 1;
     */
    MFA_DEVICE_KIND_UNSET = 1,
    /**
     * MFA device is known to be configured using TOTP as the weakest form of MFA.
     *
     * @generated from protobuf enum value: MFA_DEVICE_KIND_TOTP = 2;
     */
    MFA_DEVICE_KIND_TOTP = 2,
    /**
     * MFA device is known to be configured using WebAuthn as the weakest form of MFA.
     *
     * @generated from protobuf enum value: MFA_DEVICE_KIND_WEBAUTHN = 3;
     */
    MFA_DEVICE_KIND_WEBAUTHN = 3
}
/**
 * SAMLForceAuthn specified whether existing SAML sessions should be accepted or re-authentication
 * should be forced.
 *
 * @generated from protobuf enum types.SAMLForceAuthn
 */
export enum SAMLForceAuthn {
    /**
     * UNSPECIFIED is treated as the default value for the context; NO for login, YES for MFA checks.
     *
     * @generated from protobuf enum value: FORCE_AUTHN_UNSPECIFIED = 0;
     */
    FORCE_AUTHN_UNSPECIFIED = 0,
    /**
     * YES re-authentication should be forced for existing SAML sessions..
     *
     * @generated from protobuf enum value: FORCE_AUTHN_YES = 1;
     */
    FORCE_AUTHN_YES = 1,
    /**
     * NO re-authentication should not be forced for existing SAML sessions.
     *
     * @generated from protobuf enum value: FORCE_AUTHN_NO = 2;
     */
    FORCE_AUTHN_NO = 2
}
/**
 * SessionState represents the state of a session.
 *
 * @generated from protobuf enum types.SessionState
 */
export enum SessionState {
    /**
     * Pending variant represents a session that is waiting on participants to fulfill the criteria
     * to start the session.
     *
     * @generated from protobuf enum value: SessionStatePending = 0;
     */
    SessionStatePending = 0,
    /**
     * Running variant represents a session that has had it's criteria for starting
     * fulfilled at least once and has transitioned to a RUNNING state.
     *
     * @generated from protobuf enum value: SessionStateRunning = 1;
     */
    SessionStateRunning = 1,
    /**
     * Terminated variant represents a session that is no longer running and due for removal.
     *
     * @generated from protobuf enum value: SessionStateTerminated = 2;
     */
    SessionStateTerminated = 2
}
/**
 * AlertSeverity represents how problematic/urgent an alert is, and is used to assist
 * in sorting alerts for display.
 *
 * @generated from protobuf enum types.AlertSeverity
 */
export enum AlertSeverity {
    /**
     * @generated from protobuf enum value: LOW = 0;
     */
    LOW = 0,
    /**
     * @generated from protobuf enum value: MEDIUM = 5;
     */
    MEDIUM = 5,
    /**
     * @generated from protobuf enum value: HIGH = 10;
     */
    HIGH = 10
}
/**
 * RequireMFAType is a type of MFA requirement enforced outside of login,
 * such as per-session MFA or per-request PIV touch.
 *
 * @generated from protobuf enum types.RequireMFAType
 */
export enum RequireMFAType {
    /**
     * OFF means additional MFA enforcement is not enabled.
     *
     * @generated from protobuf enum value: OFF = 0;
     */
    OFF = 0,
    /**
     * SESSION means MFA is required to begin server sessions.
     *
     * @generated from protobuf enum value: SESSION = 1;
     */
    SESSION = 1,
    /**
     * SESSION_AND_HARDWARE_KEY means MFA is required to begin server sessions,
     * and login sessions must use a private key backed by a hardware key.
     *
     * @generated from protobuf enum value: SESSION_AND_HARDWARE_KEY = 2;
     */
    SESSION_AND_HARDWARE_KEY = 2,
    /**
     * HARDWARE_KEY_TOUCH means login sessions must use a hardware private key that
     * requires touch to be used.
     *
     * @generated from protobuf enum value: HARDWARE_KEY_TOUCH = 3;
     */
    HARDWARE_KEY_TOUCH = 3,
    /**
     * HARDWARE_KEY_PIN means login sessions must use a hardware private key that
     * requires pin to be used.
     *
     * @generated from protobuf enum value: HARDWARE_KEY_PIN = 4;
     */
    HARDWARE_KEY_PIN = 4,
    /**
     * HARDWARE_KEY_TOUCH_AND_PIN means login sessions must use a hardware private key that
     * requires touch and pin to be used.
     *
     * @generated from protobuf enum value: HARDWARE_KEY_TOUCH_AND_PIN = 5;
     */
    HARDWARE_KEY_TOUCH_AND_PIN = 5
}
/**
 * SignatureAlgorithmSuite represents the suite of cryptographic signature algorithms used in the cluster.
 *
 * @generated from protobuf enum types.SignatureAlgorithmSuite
 */
export enum SignatureAlgorithmSuite {
    /**
     * SIGNATURE_ALGORITHM_SUITE_UNSPECIFIED represents an unspecified signature algorithm suite.
     *
     * @generated from protobuf enum value: SIGNATURE_ALGORITHM_SUITE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * SIGNATURE_ALGORITHM_SUITE_LEGACY is the original algorithm suite used in
     * Teleport, it almost exclusively uses 2048-bit RSA.
     *
     * @generated from protobuf enum value: SIGNATURE_ALGORITHM_SUITE_LEGACY = 1;
     */
    LEGACY = 1,
    /**
     * SIGNATURE_ALGORITHM_SUITE_BALANCED_V1 aims to strikes a balance between
     * security, compatibility, and performance. It uses Ed25519 for most SSH
     * keys, ECDSA on the NIST P256 curve for most TLS keys, and 2048-bit RSA
     * where necessary for compatibility with third-party software.
     *
     * @generated from protobuf enum value: SIGNATURE_ALGORITHM_SUITE_BALANCED_V1 = 2;
     */
    BALANCED_V1 = 2,
    /**
     * SIGNATURE_ALGORITHM_SUITE_FIPS_V1 is tailored for FIPS compliance. It is
     * based on the BALANCED_V1 suite but replaces all instances of Ed25519 with
     * ECDSA on the NIST P256 curve.
     *
     * @generated from protobuf enum value: SIGNATURE_ALGORITHM_SUITE_FIPS_V1 = 3;
     */
    FIPS_V1 = 3,
    /**
     * SIGNATURE_ALGORITHM_SUITE_HSM_V1 is tailored for clusters using an HSM or
     * KMS service to back CA private material. It is based on the BALANCED suite
     * but replaces Ed25519 with ECDSA on the NIST P256 curve for CA keys only,
     * not for server or client keys. It is also valid to use the LEGACY for FIPS
     * suites if your cluster uses an HSM or KMS.
     *
     * @generated from protobuf enum value: SIGNATURE_ALGORITHM_SUITE_HSM_V1 = 4;
     */
    HSM_V1 = 4
}
/**
 * EntraIDCredentialsSource defines the credentials source for Entra ID.
 *
 * @generated from protobuf enum types.EntraIDCredentialsSource
 */
export enum EntraIDCredentialsSource {
    /**
     * ENTRAID_CREDENTIALS_SOURCE_UNKNOWN is used when the credentials source is not specified.
     * Due to legacy reasons, UNKNOWN is handled as OIDC.
     *
     * @generated from protobuf enum value: ENTRAID_CREDENTIALS_SOURCE_UNKNOWN = 0;
     */
    ENTRAID_CREDENTIALS_SOURCE_UNKNOWN = 0,
    /**
     * ENTRAID_CREDENTIALS_SOURCE_OIDC indicates that the plugin will authenticate with Azure/Entra ID using OIDC.
     *
     * @generated from protobuf enum value: ENTRAID_CREDENTIALS_SOURCE_OIDC = 1;
     */
    ENTRAID_CREDENTIALS_SOURCE_OIDC = 1,
    /**
     * ENTRAID_CREDENTIALS_SOURCE_SYSTEM_CREDENTIALS means the plugin will rely on system-provided credentials
     * for authentication with Azure Entra ID, especially for clusters with no internet access.
     *
     * @generated from protobuf enum value: ENTRAID_CREDENTIALS_SOURCE_SYSTEM_CREDENTIALS = 2;
     */
    ENTRAID_CREDENTIALS_SOURCE_SYSTEM_CREDENTIALS = 2
}
/**
 * AWSICCredentialsSource indicates where the AWS Identity Center plugin will
 * draw its AWS credentials from.
 *
 * DEPRECATED: Superceded by individual message types.
 * TODO(tcsc): Remove in Teleport 19+
 *
 * @generated from protobuf enum types.AWSICCredentialsSource
 */
export enum AWSICCredentialsSource {
    /**
     * AWSIC_CREDENTIALS_SOURCE_UNKNOWN is used when the credentials source is not
     * specified. For backwards compatability, UNKNOWN is handled as OIDC.
     *
     * @generated from protobuf enum value: AWSIC_CREDENTIALS_SOURCE_UNKNOWN = 0;
     */
    AWSIC_CREDENTIALS_SOURCE_UNKNOWN = 0,
    /**
     * AWSIC_CREDENTIALS_SOURCE_OIDC indicates that the Identity Center plugin will
     * draw its credentials from a configured Teleport OIDC integration and
     * authenticate  woth OIDC
     *
     * @generated from protobuf enum value: AWSIC_CREDENTIALS_SOURCE_OIDC = 1;
     */
    AWSIC_CREDENTIALS_SOURCE_OIDC = 1,
    /**
     * AWSIC_CREDENTIALS_SOURCE_SYSTEM indicates that the Identity Center plugin
     * will rely on system-provided credentials
     *
     * @generated from protobuf enum value: AWSIC_CREDENTIALS_SOURCE_SYSTEM = 2;
     */
    AWSIC_CREDENTIALS_SOURCE_SYSTEM = 2
}
/**
 * AWSICGroupImportStatus defines Identity Center group and group members
 * import status codes.
 *
 * @generated from protobuf enum types.AWSICGroupImportStatusCode
 */
export enum AWSICGroupImportStatusCode {
    /**
     * UNSPECIFIED denotes that a status is unknown.
     *
     * @generated from protobuf enum value: UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * DONE denotes that the group and group members import operation was
     * completed.
     *
     * @generated from protobuf enum value: DONE = 1;
     */
    DONE = 1,
    /**
     * FAILED denotes that the group and group members import met with an error.
     *
     * @generated from protobuf enum value: FAILED = 2;
     */
    FAILED = 2,
    /**
     * REIMPORT_REQUESTED denotes that the user has requested that the import
     * process be re-run.
     *
     * @generated from protobuf enum value: REIMPORT_REQUESTED = 3;
     */
    REIMPORT_REQUESTED = 3
}
/**
 * @generated from protobuf enum types.PluginStatusCode
 */
export enum PluginStatusCode {
    /**
     * UNKNOWN is the default value when the plugin has not reported its status yet.
     *
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * RUNNING means the plugin reports running successfully.
     *
     * @generated from protobuf enum value: RUNNING = 1;
     */
    RUNNING = 1,
    /**
     * OTHER_ERROR indicates that an otherwise-unspecified error has been encountered.
     *
     * @generated from protobuf enum value: OTHER_ERROR = 2;
     */
    OTHER_ERROR = 2,
    /**
     * UNAUTHORIZED indicates that plugin is not able to authenticate to the 3rd party API.
     * This could be a result of e.g. the user revoking the authorization on the API provider's side.
     *
     * @generated from protobuf enum value: UNAUTHORIZED = 3;
     */
    UNAUTHORIZED = 3,
    /**
     * SLACK_NOT_IN_CHANNEL is a Slack-specific status code that indicates
     * that the bot has not been invited to a channel that it is configured to post in.
     *
     * @generated from protobuf enum value: SLACK_NOT_IN_CHANNEL = 10;
     */
    SLACK_NOT_IN_CHANNEL = 10,
    /**
     * OKTA_CONFIG_ERROR is an Okta-specific code that indicates a configuration error with setup or
     * permissions within Okta.
     *
     * @generated from protobuf enum value: OKTA_CONFIG_ERROR = 20;
     */
    OKTA_CONFIG_ERROR = 20
}
/**
 * OktaPluginSyncStatusCode indicates the possible states of an Okta
 * synchronization service.
 *
 * @generated from protobuf enum types.OktaPluginSyncStatusCode
 */
export enum OktaPluginSyncStatusCode {
    /**
     * OKTA_PLUGIN_SYNC_STATUS_CODE_UNSPECIFIED is the status code zero value,
     * indicating that the service has not yet reported a status code.
     *
     * @generated from protobuf enum value: OKTA_PLUGIN_SYNC_STATUS_CODE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * OKTA_PLUGIN_SYNC_STATUS_CODE_SUCCESS indicates that the service is running
     * without error
     *
     * @generated from protobuf enum value: OKTA_PLUGIN_SYNC_STATUS_CODE_SUCCESS = 1;
     */
    SUCCESS = 1,
    /**
     * OKTA_PLUGIN_SYNC_STATUS_CODE_ERROR indicates that the service is currently
     * in an error state.
     *
     * @generated from protobuf enum value: OKTA_PLUGIN_SYNC_STATUS_CODE_ERROR = 2;
     */
    ERROR = 2
}
/**
 * HeadlessAuthenticationState is a headless authentication state.
 *
 * @generated from protobuf enum types.HeadlessAuthenticationState
 */
export enum HeadlessAuthenticationState {
    /**
     * @generated from protobuf enum value: HEADLESS_AUTHENTICATION_STATE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * authentication pending.
     *
     * @generated from protobuf enum value: HEADLESS_AUTHENTICATION_STATE_PENDING = 1;
     */
    PENDING = 1,
    /**
     * authentication denied.
     *
     * @generated from protobuf enum value: HEADLESS_AUTHENTICATION_STATE_DENIED = 2;
     */
    DENIED = 2,
    /**
     * authentication approved.
     *
     * @generated from protobuf enum value: HEADLESS_AUTHENTICATION_STATE_APPROVED = 3;
     */
    APPROVED = 3
}
/**
 * InstallParamEnrollMode is the mode used to enroll the node into the cluster.
 *
 * @generated from protobuf enum types.InstallParamEnrollMode
 */
export enum InstallParamEnrollMode {
    /**
     * INSTALL_PARAM_ENROLL_MODE_UNSPECIFIED uses the EICE mode for EC2 Matchers with an Integration and SCRIPT mode otherwise.
     *
     * @generated from protobuf enum value: INSTALL_PARAM_ENROLL_MODE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * INSTALL_PARAM_ENROLL_MODE_SCRIPT runs a script on the target host.
     *
     * @generated from protobuf enum value: INSTALL_PARAM_ENROLL_MODE_SCRIPT = 1;
     */
    SCRIPT = 1,
    /**
     * INSTALL_PARAM_ENROLL_MODE_EICE uses EC2 Instance Connect Endpoint to access the node and DiscoveryService handles the heartbeat.
     * Only available for AWS EC2 instances.
     *
     * @generated from protobuf enum value: INSTALL_PARAM_ENROLL_MODE_EICE = 2;
     */
    EICE = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class KeepAlive$Type extends MessageType<KeepAlive> {
    constructor() {
        super("types.KeepAlive", [
            { no: 1, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "server_name" } },
            { no: 2, name: "Namespace", kind: "scalar", jsonName: "Namespace", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "namespace" } },
            { no: 4, name: "Expires", kind: "message", jsonName: "Expires", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "expires", "gogoproto.stdtime": true } },
            { no: 9, name: "Type", kind: "enum", jsonName: "Type", T: () => ["types.KeepAlive.KeepAliveType", KeepAlive_KeepAliveType], options: { "gogoproto.jsontag": "type" } },
            { no: 10, name: "HostID", kind: "scalar", jsonName: "HostID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "host_id,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<KeepAlive>): KeepAlive {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.namespace = "";
        message.type = 0;
        message.hostID = "";
        if (value !== undefined)
            reflectionMergePartial<KeepAlive>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KeepAlive): KeepAlive {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Name = 1 [json_name = "Name"];*/ 1:
                    message.name = reader.string();
                    break;
                case /* string Namespace = 2 [json_name = "Namespace"];*/ 2:
                    message.namespace = reader.string();
                    break;
                case /* google.protobuf.Timestamp Expires = 4 [json_name = "Expires"];*/ 4:
                    message.expires = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expires);
                    break;
                case /* types.KeepAlive.KeepAliveType Type = 9 [json_name = "Type"];*/ 9:
                    message.type = reader.int32();
                    break;
                case /* string HostID = 10 [json_name = "HostID"];*/ 10:
                    message.hostID = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: KeepAlive, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Name = 1 [json_name = "Name"]; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string Namespace = 2 [json_name = "Namespace"]; */
        if (message.namespace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.namespace);
        /* google.protobuf.Timestamp Expires = 4 [json_name = "Expires"]; */
        if (message.expires)
            Timestamp.internalBinaryWrite(message.expires, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.KeepAlive.KeepAliveType Type = 9 [json_name = "Type"]; */
        if (message.type !== 0)
            writer.tag(9, WireType.Varint).int32(message.type);
        /* string HostID = 10 [json_name = "HostID"]; */
        if (message.hostID !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.hostID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.KeepAlive
 */
export const KeepAlive = new KeepAlive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Metadata$Type extends MessageType<Metadata> {
    constructor() {
        super("types.Metadata", [
            { no: 1, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "name" } },
            { no: 2, name: "Namespace", kind: "scalar", jsonName: "Namespace", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "-" } },
            { no: 3, name: "Description", kind: "scalar", jsonName: "Description", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "description,omitempty" } },
            { no: 5, name: "Labels", kind: "map", jsonName: "Labels", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ }, options: { "gogoproto.jsontag": "labels,omitempty" } },
            { no: 6, name: "Expires", kind: "message", jsonName: "Expires", T: () => Timestamp, options: { "gogoproto.nullable": true, "gogoproto.jsontag": "expires,omitempty", "gogoproto.stdtime": true } },
            { no: 8, name: "Revision", kind: "scalar", jsonName: "Revision", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "revision,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<Metadata>): Metadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.namespace = "";
        message.description = "";
        message.labels = {};
        message.revision = "";
        if (value !== undefined)
            reflectionMergePartial<Metadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Metadata): Metadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Name = 1 [json_name = "Name"];*/ 1:
                    message.name = reader.string();
                    break;
                case /* string Namespace = 2 [json_name = "Namespace"];*/ 2:
                    message.namespace = reader.string();
                    break;
                case /* string Description = 3 [json_name = "Description"];*/ 3:
                    message.description = reader.string();
                    break;
                case /* map<string, string> Labels = 5 [json_name = "Labels"];*/ 5:
                    this.binaryReadMap5(message.labels, reader, options);
                    break;
                case /* google.protobuf.Timestamp Expires = 6 [json_name = "Expires"];*/ 6:
                    message.expires = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expires);
                    break;
                case /* string Revision = 8 [json_name = "Revision"];*/ 8:
                    message.revision = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap5(map: Metadata["labels"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Metadata["labels"] | undefined, val: Metadata["labels"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field types.Metadata.Labels");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: Metadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Name = 1 [json_name = "Name"]; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string Namespace = 2 [json_name = "Namespace"]; */
        if (message.namespace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.namespace);
        /* string Description = 3 [json_name = "Description"]; */
        if (message.description !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* map<string, string> Labels = 5 [json_name = "Labels"]; */
        for (let k of globalThis.Object.keys(message.labels))
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.labels[k]).join();
        /* google.protobuf.Timestamp Expires = 6 [json_name = "Expires"]; */
        if (message.expires)
            Timestamp.internalBinaryWrite(message.expires, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* string Revision = 8 [json_name = "Revision"]; */
        if (message.revision !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.revision);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.Metadata
 */
export const Metadata = new Metadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Rotation$Type extends MessageType<Rotation> {
    constructor() {
        super("types.Rotation", [
            { no: 1, name: "State", kind: "scalar", jsonName: "State", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "state,omitempty" } },
            { no: 2, name: "Phase", kind: "scalar", jsonName: "Phase", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "phase,omitempty" } },
            { no: 3, name: "Mode", kind: "scalar", jsonName: "Mode", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "mode,omitempty" } },
            { no: 4, name: "CurrentID", kind: "scalar", jsonName: "CurrentID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "current_id" } },
            { no: 5, name: "Started", kind: "message", jsonName: "Started", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "started,omitempty", "gogoproto.stdtime": true } },
            { no: 6, name: "GracePeriod", kind: "scalar", jsonName: "GracePeriod", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "grace_period,omitempty", "gogoproto.casttype": "Duration" } },
            { no: 7, name: "LastRotated", kind: "message", jsonName: "LastRotated", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "last_rotated,omitempty", "gogoproto.stdtime": true } },
            { no: 8, name: "Schedule", kind: "message", jsonName: "Schedule", T: () => RotationSchedule, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "schedule,omitempty" } }
        ], { "gogoproto.goproto_stringer": false, "gogoproto.stringer": false });
    }
    create(value?: PartialMessage<Rotation>): Rotation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.state = "";
        message.phase = "";
        message.mode = "";
        message.currentID = "";
        message.gracePeriod = 0n;
        if (value !== undefined)
            reflectionMergePartial<Rotation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Rotation): Rotation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string State = 1 [json_name = "State"];*/ 1:
                    message.state = reader.string();
                    break;
                case /* string Phase = 2 [json_name = "Phase"];*/ 2:
                    message.phase = reader.string();
                    break;
                case /* string Mode = 3 [json_name = "Mode"];*/ 3:
                    message.mode = reader.string();
                    break;
                case /* string CurrentID = 4 [json_name = "CurrentID"];*/ 4:
                    message.currentID = reader.string();
                    break;
                case /* google.protobuf.Timestamp Started = 5 [json_name = "Started"];*/ 5:
                    message.started = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.started);
                    break;
                case /* int64 GracePeriod = 6 [json_name = "GracePeriod"];*/ 6:
                    message.gracePeriod = reader.int64().toBigInt();
                    break;
                case /* google.protobuf.Timestamp LastRotated = 7 [json_name = "LastRotated"];*/ 7:
                    message.lastRotated = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastRotated);
                    break;
                case /* types.RotationSchedule Schedule = 8 [json_name = "Schedule"];*/ 8:
                    message.schedule = RotationSchedule.internalBinaryRead(reader, reader.uint32(), options, message.schedule);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Rotation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string State = 1 [json_name = "State"]; */
        if (message.state !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.state);
        /* string Phase = 2 [json_name = "Phase"]; */
        if (message.phase !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.phase);
        /* string Mode = 3 [json_name = "Mode"]; */
        if (message.mode !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.mode);
        /* string CurrentID = 4 [json_name = "CurrentID"]; */
        if (message.currentID !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.currentID);
        /* google.protobuf.Timestamp Started = 5 [json_name = "Started"]; */
        if (message.started)
            Timestamp.internalBinaryWrite(message.started, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* int64 GracePeriod = 6 [json_name = "GracePeriod"]; */
        if (message.gracePeriod !== 0n)
            writer.tag(6, WireType.Varint).int64(message.gracePeriod);
        /* google.protobuf.Timestamp LastRotated = 7 [json_name = "LastRotated"]; */
        if (message.lastRotated)
            Timestamp.internalBinaryWrite(message.lastRotated, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* types.RotationSchedule Schedule = 8 [json_name = "Schedule"]; */
        if (message.schedule)
            RotationSchedule.internalBinaryWrite(message.schedule, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.Rotation
 */
export const Rotation = new Rotation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RotationSchedule$Type extends MessageType<RotationSchedule> {
    constructor() {
        super("types.RotationSchedule", [
            { no: 1, name: "UpdateClients", kind: "message", jsonName: "UpdateClients", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "update_clients,omitempty", "gogoproto.stdtime": true } },
            { no: 2, name: "UpdateServers", kind: "message", jsonName: "UpdateServers", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "update_servers,omitempty", "gogoproto.stdtime": true } },
            { no: 3, name: "Standby", kind: "message", jsonName: "Standby", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "standby,omitempty", "gogoproto.stdtime": true } }
        ]);
    }
    create(value?: PartialMessage<RotationSchedule>): RotationSchedule {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RotationSchedule>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RotationSchedule): RotationSchedule {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Timestamp UpdateClients = 1 [json_name = "UpdateClients"];*/ 1:
                    message.updateClients = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updateClients);
                    break;
                case /* google.protobuf.Timestamp UpdateServers = 2 [json_name = "UpdateServers"];*/ 2:
                    message.updateServers = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updateServers);
                    break;
                case /* google.protobuf.Timestamp Standby = 3 [json_name = "Standby"];*/ 3:
                    message.standby = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.standby);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RotationSchedule, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Timestamp UpdateClients = 1 [json_name = "UpdateClients"]; */
        if (message.updateClients)
            Timestamp.internalBinaryWrite(message.updateClients, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp UpdateServers = 2 [json_name = "UpdateServers"]; */
        if (message.updateServers)
            Timestamp.internalBinaryWrite(message.updateServers, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp Standby = 3 [json_name = "Standby"]; */
        if (message.standby)
            Timestamp.internalBinaryWrite(message.standby, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.RotationSchedule
 */
export const RotationSchedule = new RotationSchedule$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResourceHeader$Type extends MessageType<ResourceHeader> {
    constructor() {
        super("types.ResourceHeader", [
            { no: 1, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind,omitempty" } },
            { no: 2, name: "SubKind", kind: "scalar", jsonName: "SubKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub_kind,omitempty" } },
            { no: 3, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version,omitempty" } },
            { no: 4, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "metadata,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ResourceHeader>): ResourceHeader {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.subKind = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<ResourceHeader>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResourceHeader): ResourceHeader {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Kind = 1 [json_name = "Kind"];*/ 1:
                    message.kind = reader.string();
                    break;
                case /* string SubKind = 2 [json_name = "SubKind"];*/ 2:
                    message.subKind = reader.string();
                    break;
                case /* string Version = 3 [json_name = "Version"];*/ 3:
                    message.version = reader.string();
                    break;
                case /* types.Metadata Metadata = 4 [json_name = "Metadata"];*/ 4:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResourceHeader, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Kind = 1 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string SubKind = 2 [json_name = "SubKind"]; */
        if (message.subKind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subKind);
        /* string Version = 3 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* types.Metadata Metadata = 4 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ResourceHeader
 */
export const ResourceHeader = new ResourceHeader$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DatabaseServerV3$Type extends MessageType<DatabaseServerV3> {
    constructor() {
        super("types.DatabaseServerV3", [
            { no: 1, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 2, name: "SubKind", kind: "scalar", jsonName: "SubKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub_kind,omitempty" } },
            { no: 3, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version" } },
            { no: 4, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "metadata" } },
            { no: 5, name: "Spec", kind: "message", jsonName: "Spec", T: () => DatabaseServerSpecV3, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } },
            { no: 6, name: "Status", kind: "message", jsonName: "Status", T: () => DatabaseServerStatusV3, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "status" } }
        ], { "gogoproto.goproto_stringer": false, "gogoproto.stringer": false });
    }
    create(value?: PartialMessage<DatabaseServerV3>): DatabaseServerV3 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.subKind = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<DatabaseServerV3>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DatabaseServerV3): DatabaseServerV3 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Kind = 1 [json_name = "Kind"];*/ 1:
                    message.kind = reader.string();
                    break;
                case /* string SubKind = 2 [json_name = "SubKind"];*/ 2:
                    message.subKind = reader.string();
                    break;
                case /* string Version = 3 [json_name = "Version"];*/ 3:
                    message.version = reader.string();
                    break;
                case /* types.Metadata Metadata = 4 [json_name = "Metadata"];*/ 4:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* types.DatabaseServerSpecV3 Spec = 5 [json_name = "Spec"];*/ 5:
                    message.spec = DatabaseServerSpecV3.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                case /* types.DatabaseServerStatusV3 Status = 6 [json_name = "Status"];*/ 6:
                    message.status = DatabaseServerStatusV3.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DatabaseServerV3, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Kind = 1 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string SubKind = 2 [json_name = "SubKind"]; */
        if (message.subKind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subKind);
        /* string Version = 3 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* types.Metadata Metadata = 4 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.DatabaseServerSpecV3 Spec = 5 [json_name = "Spec"]; */
        if (message.spec)
            DatabaseServerSpecV3.internalBinaryWrite(message.spec, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* types.DatabaseServerStatusV3 Status = 6 [json_name = "Status"]; */
        if (message.status)
            DatabaseServerStatusV3.internalBinaryWrite(message.status, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.DatabaseServerV3
 */
export const DatabaseServerV3 = new DatabaseServerV3$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DatabaseServerSpecV3$Type extends MessageType<DatabaseServerSpecV3> {
    constructor() {
        super("types.DatabaseServerSpecV3", [
            { no: 6, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version" } },
            { no: 7, name: "Hostname", kind: "scalar", jsonName: "Hostname", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "hostname" } },
            { no: 8, name: "HostID", kind: "scalar", jsonName: "HostID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "host_id" } },
            { no: 10, name: "Rotation", kind: "message", jsonName: "Rotation", T: () => Rotation, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "rotation,omitempty" } },
            { no: 12, name: "Database", kind: "message", jsonName: "Database", T: () => DatabaseV3, options: { "gogoproto.jsontag": "database,omitempty" } },
            { no: 13, name: "ProxyIDs", kind: "scalar", jsonName: "ProxyIDs", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "proxy_ids,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<DatabaseServerSpecV3>): DatabaseServerSpecV3 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.version = "";
        message.hostname = "";
        message.hostID = "";
        message.proxyIDs = [];
        if (value !== undefined)
            reflectionMergePartial<DatabaseServerSpecV3>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DatabaseServerSpecV3): DatabaseServerSpecV3 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Version = 6 [json_name = "Version"];*/ 6:
                    message.version = reader.string();
                    break;
                case /* string Hostname = 7 [json_name = "Hostname"];*/ 7:
                    message.hostname = reader.string();
                    break;
                case /* string HostID = 8 [json_name = "HostID"];*/ 8:
                    message.hostID = reader.string();
                    break;
                case /* types.Rotation Rotation = 10 [json_name = "Rotation"];*/ 10:
                    message.rotation = Rotation.internalBinaryRead(reader, reader.uint32(), options, message.rotation);
                    break;
                case /* types.DatabaseV3 Database = 12 [json_name = "Database"];*/ 12:
                    message.database = DatabaseV3.internalBinaryRead(reader, reader.uint32(), options, message.database);
                    break;
                case /* repeated string ProxyIDs = 13 [json_name = "ProxyIDs"];*/ 13:
                    message.proxyIDs.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DatabaseServerSpecV3, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Version = 6 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.version);
        /* string Hostname = 7 [json_name = "Hostname"]; */
        if (message.hostname !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.hostname);
        /* string HostID = 8 [json_name = "HostID"]; */
        if (message.hostID !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.hostID);
        /* types.Rotation Rotation = 10 [json_name = "Rotation"]; */
        if (message.rotation)
            Rotation.internalBinaryWrite(message.rotation, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* types.DatabaseV3 Database = 12 [json_name = "Database"]; */
        if (message.database)
            DatabaseV3.internalBinaryWrite(message.database, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* repeated string ProxyIDs = 13 [json_name = "ProxyIDs"]; */
        for (let i = 0; i < message.proxyIDs.length; i++)
            writer.tag(13, WireType.LengthDelimited).string(message.proxyIDs[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.DatabaseServerSpecV3
 */
export const DatabaseServerSpecV3 = new DatabaseServerSpecV3$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DatabaseServerStatusV3$Type extends MessageType<DatabaseServerStatusV3> {
    constructor() {
        super("types.DatabaseServerStatusV3", [
            { no: 14, name: "TargetHealth", kind: "message", jsonName: "TargetHealth", T: () => TargetHealth, options: { "gogoproto.jsontag": "target_health,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<DatabaseServerStatusV3>): DatabaseServerStatusV3 {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DatabaseServerStatusV3>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DatabaseServerStatusV3): DatabaseServerStatusV3 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.TargetHealth TargetHealth = 14 [json_name = "TargetHealth"];*/ 14:
                    message.targetHealth = TargetHealth.internalBinaryRead(reader, reader.uint32(), options, message.targetHealth);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DatabaseServerStatusV3, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.TargetHealth TargetHealth = 14 [json_name = "TargetHealth"]; */
        if (message.targetHealth)
            TargetHealth.internalBinaryWrite(message.targetHealth, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.DatabaseServerStatusV3
 */
export const DatabaseServerStatusV3 = new DatabaseServerStatusV3$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DatabaseV3List$Type extends MessageType<DatabaseV3List> {
    constructor() {
        super("types.DatabaseV3List", [
            { no: 1, name: "Databases", kind: "message", jsonName: "Databases", repeat: 1 /*RepeatType.PACKED*/, T: () => DatabaseV3 }
        ]);
    }
    create(value?: PartialMessage<DatabaseV3List>): DatabaseV3List {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.databases = [];
        if (value !== undefined)
            reflectionMergePartial<DatabaseV3List>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DatabaseV3List): DatabaseV3List {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.DatabaseV3 Databases = 1 [json_name = "Databases"];*/ 1:
                    message.databases.push(DatabaseV3.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DatabaseV3List, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.DatabaseV3 Databases = 1 [json_name = "Databases"]; */
        for (let i = 0; i < message.databases.length; i++)
            DatabaseV3.internalBinaryWrite(message.databases[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.DatabaseV3List
 */
export const DatabaseV3List = new DatabaseV3List$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DatabaseV3$Type extends MessageType<DatabaseV3> {
    constructor() {
        super("types.DatabaseV3", [
            { no: 1, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 2, name: "SubKind", kind: "scalar", jsonName: "SubKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub_kind,omitempty" } },
            { no: 3, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version" } },
            { no: 4, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "metadata" } },
            { no: 5, name: "Spec", kind: "message", jsonName: "Spec", T: () => DatabaseSpecV3, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } },
            { no: 6, name: "Status", kind: "message", jsonName: "Status", T: () => DatabaseStatusV3, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "status" } }
        ], { "gogoproto.goproto_stringer": false, "gogoproto.stringer": false });
    }
    create(value?: PartialMessage<DatabaseV3>): DatabaseV3 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.subKind = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<DatabaseV3>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DatabaseV3): DatabaseV3 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Kind = 1 [json_name = "Kind"];*/ 1:
                    message.kind = reader.string();
                    break;
                case /* string SubKind = 2 [json_name = "SubKind"];*/ 2:
                    message.subKind = reader.string();
                    break;
                case /* string Version = 3 [json_name = "Version"];*/ 3:
                    message.version = reader.string();
                    break;
                case /* types.Metadata Metadata = 4 [json_name = "Metadata"];*/ 4:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* types.DatabaseSpecV3 Spec = 5 [json_name = "Spec"];*/ 5:
                    message.spec = DatabaseSpecV3.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                case /* types.DatabaseStatusV3 Status = 6 [json_name = "Status"];*/ 6:
                    message.status = DatabaseStatusV3.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DatabaseV3, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Kind = 1 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string SubKind = 2 [json_name = "SubKind"]; */
        if (message.subKind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subKind);
        /* string Version = 3 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* types.Metadata Metadata = 4 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.DatabaseSpecV3 Spec = 5 [json_name = "Spec"]; */
        if (message.spec)
            DatabaseSpecV3.internalBinaryWrite(message.spec, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* types.DatabaseStatusV3 Status = 6 [json_name = "Status"]; */
        if (message.status)
            DatabaseStatusV3.internalBinaryWrite(message.status, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.DatabaseV3
 */
export const DatabaseV3 = new DatabaseV3$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DatabaseSpecV3$Type extends MessageType<DatabaseSpecV3> {
    constructor() {
        super("types.DatabaseSpecV3", [
            { no: 1, name: "Protocol", kind: "scalar", jsonName: "Protocol", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "protocol" } },
            { no: 2, name: "URI", kind: "scalar", jsonName: "URI", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "uri" } },
            { no: 3, name: "CACert", kind: "scalar", jsonName: "CACert", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "ca_cert,omitempty" } },
            { no: 4, name: "DynamicLabels", kind: "map", jsonName: "DynamicLabels", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => CommandLabelV2 }, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "dynamic_labels,omitempty" } },
            { no: 5, name: "AWS", kind: "message", jsonName: "AWS", T: () => AWS, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "aws,omitempty" } },
            { no: 6, name: "GCP", kind: "message", jsonName: "GCP", T: () => GCPCloudSQL, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "gcp,omitempty" } },
            { no: 7, name: "Azure", kind: "message", jsonName: "Azure", T: () => Azure, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "azure,omitempty" } },
            { no: 8, name: "TLS", kind: "message", jsonName: "TLS", T: () => DatabaseTLS, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "tls,omitempty" } },
            { no: 9, name: "AD", kind: "message", jsonName: "AD", T: () => AD, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "ad,omitempty" } },
            { no: 10, name: "MySQL", kind: "message", jsonName: "MySQL", T: () => MySQLOptions, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "mysql,omitempty" } },
            { no: 11, name: "AdminUser", kind: "message", jsonName: "AdminUser", T: () => DatabaseAdminUser, options: { "gogoproto.jsontag": "admin_user,omitempty" } },
            { no: 12, name: "MongoAtlas", kind: "message", jsonName: "MongoAtlas", T: () => MongoAtlas, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "mongo_atlas,omitempty" } },
            { no: 13, name: "Oracle", kind: "message", jsonName: "Oracle", T: () => OracleOptions, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "oracle,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<DatabaseSpecV3>): DatabaseSpecV3 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.protocol = "";
        message.uRI = "";
        message.cACert = "";
        message.dynamicLabels = {};
        if (value !== undefined)
            reflectionMergePartial<DatabaseSpecV3>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DatabaseSpecV3): DatabaseSpecV3 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Protocol = 1 [json_name = "Protocol"];*/ 1:
                    message.protocol = reader.string();
                    break;
                case /* string URI = 2 [json_name = "URI"];*/ 2:
                    message.uRI = reader.string();
                    break;
                case /* string CACert = 3 [deprecated = true, json_name = "CACert"];*/ 3:
                    message.cACert = reader.string();
                    break;
                case /* map<string, types.CommandLabelV2> DynamicLabels = 4 [json_name = "DynamicLabels"];*/ 4:
                    this.binaryReadMap4(message.dynamicLabels, reader, options);
                    break;
                case /* types.AWS AWS = 5 [json_name = "AWS"];*/ 5:
                    message.aWS = AWS.internalBinaryRead(reader, reader.uint32(), options, message.aWS);
                    break;
                case /* types.GCPCloudSQL GCP = 6 [json_name = "GCP"];*/ 6:
                    message.gCP = GCPCloudSQL.internalBinaryRead(reader, reader.uint32(), options, message.gCP);
                    break;
                case /* types.Azure Azure = 7 [json_name = "Azure"];*/ 7:
                    message.azure = Azure.internalBinaryRead(reader, reader.uint32(), options, message.azure);
                    break;
                case /* types.DatabaseTLS TLS = 8 [json_name = "TLS"];*/ 8:
                    message.tLS = DatabaseTLS.internalBinaryRead(reader, reader.uint32(), options, message.tLS);
                    break;
                case /* types.AD AD = 9 [json_name = "AD"];*/ 9:
                    message.aD = AD.internalBinaryRead(reader, reader.uint32(), options, message.aD);
                    break;
                case /* types.MySQLOptions MySQL = 10 [json_name = "MySQL"];*/ 10:
                    message.mySQL = MySQLOptions.internalBinaryRead(reader, reader.uint32(), options, message.mySQL);
                    break;
                case /* types.DatabaseAdminUser AdminUser = 11 [json_name = "AdminUser"];*/ 11:
                    message.adminUser = DatabaseAdminUser.internalBinaryRead(reader, reader.uint32(), options, message.adminUser);
                    break;
                case /* types.MongoAtlas MongoAtlas = 12 [json_name = "MongoAtlas"];*/ 12:
                    message.mongoAtlas = MongoAtlas.internalBinaryRead(reader, reader.uint32(), options, message.mongoAtlas);
                    break;
                case /* types.OracleOptions Oracle = 13 [json_name = "Oracle"];*/ 13:
                    message.oracle = OracleOptions.internalBinaryRead(reader, reader.uint32(), options, message.oracle);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap4(map: DatabaseSpecV3["dynamicLabels"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof DatabaseSpecV3["dynamicLabels"] | undefined, val: DatabaseSpecV3["dynamicLabels"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = CommandLabelV2.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field types.DatabaseSpecV3.DynamicLabels");
            }
        }
        map[key ?? ""] = val ?? CommandLabelV2.create();
    }
    internalBinaryWrite(message: DatabaseSpecV3, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Protocol = 1 [json_name = "Protocol"]; */
        if (message.protocol !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.protocol);
        /* string URI = 2 [json_name = "URI"]; */
        if (message.uRI !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.uRI);
        /* string CACert = 3 [deprecated = true, json_name = "CACert"]; */
        if (message.cACert !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.cACert);
        /* map<string, types.CommandLabelV2> DynamicLabels = 4 [json_name = "DynamicLabels"]; */
        for (let k of globalThis.Object.keys(message.dynamicLabels)) {
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            CommandLabelV2.internalBinaryWrite(message.dynamicLabels[k], writer, options);
            writer.join().join();
        }
        /* types.AWS AWS = 5 [json_name = "AWS"]; */
        if (message.aWS)
            AWS.internalBinaryWrite(message.aWS, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* types.GCPCloudSQL GCP = 6 [json_name = "GCP"]; */
        if (message.gCP)
            GCPCloudSQL.internalBinaryWrite(message.gCP, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* types.Azure Azure = 7 [json_name = "Azure"]; */
        if (message.azure)
            Azure.internalBinaryWrite(message.azure, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* types.DatabaseTLS TLS = 8 [json_name = "TLS"]; */
        if (message.tLS)
            DatabaseTLS.internalBinaryWrite(message.tLS, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* types.AD AD = 9 [json_name = "AD"]; */
        if (message.aD)
            AD.internalBinaryWrite(message.aD, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* types.MySQLOptions MySQL = 10 [json_name = "MySQL"]; */
        if (message.mySQL)
            MySQLOptions.internalBinaryWrite(message.mySQL, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* types.DatabaseAdminUser AdminUser = 11 [json_name = "AdminUser"]; */
        if (message.adminUser)
            DatabaseAdminUser.internalBinaryWrite(message.adminUser, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* types.MongoAtlas MongoAtlas = 12 [json_name = "MongoAtlas"]; */
        if (message.mongoAtlas)
            MongoAtlas.internalBinaryWrite(message.mongoAtlas, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* types.OracleOptions Oracle = 13 [json_name = "Oracle"]; */
        if (message.oracle)
            OracleOptions.internalBinaryWrite(message.oracle, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.DatabaseSpecV3
 */
export const DatabaseSpecV3 = new DatabaseSpecV3$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DatabaseAdminUser$Type extends MessageType<DatabaseAdminUser> {
    constructor() {
        super("types.DatabaseAdminUser", [
            { no: 1, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "name" } },
            { no: 2, name: "DefaultDatabase", kind: "scalar", jsonName: "DefaultDatabase", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "default_database" } }
        ]);
    }
    create(value?: PartialMessage<DatabaseAdminUser>): DatabaseAdminUser {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.defaultDatabase = "";
        if (value !== undefined)
            reflectionMergePartial<DatabaseAdminUser>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DatabaseAdminUser): DatabaseAdminUser {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Name = 1 [json_name = "Name"];*/ 1:
                    message.name = reader.string();
                    break;
                case /* string DefaultDatabase = 2 [json_name = "DefaultDatabase"];*/ 2:
                    message.defaultDatabase = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DatabaseAdminUser, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Name = 1 [json_name = "Name"]; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string DefaultDatabase = 2 [json_name = "DefaultDatabase"]; */
        if (message.defaultDatabase !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.defaultDatabase);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.DatabaseAdminUser
 */
export const DatabaseAdminUser = new DatabaseAdminUser$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OracleOptions$Type extends MessageType<OracleOptions> {
    constructor() {
        super("types.OracleOptions", [
            { no: 1, name: "AuditUser", kind: "scalar", jsonName: "AuditUser", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "audit_user" } }
        ]);
    }
    create(value?: PartialMessage<OracleOptions>): OracleOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.auditUser = "";
        if (value !== undefined)
            reflectionMergePartial<OracleOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OracleOptions): OracleOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string AuditUser = 1 [json_name = "AuditUser"];*/ 1:
                    message.auditUser = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OracleOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string AuditUser = 1 [json_name = "AuditUser"]; */
        if (message.auditUser !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.auditUser);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.OracleOptions
 */
export const OracleOptions = new OracleOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DatabaseStatusV3$Type extends MessageType<DatabaseStatusV3> {
    constructor() {
        super("types.DatabaseStatusV3", [
            { no: 1, name: "CACert", kind: "scalar", jsonName: "CACert", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "ca_cert,omitempty" } },
            { no: 2, name: "AWS", kind: "message", jsonName: "AWS", T: () => AWS, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "aws" } },
            { no: 3, name: "MySQL", kind: "message", jsonName: "MySQL", T: () => MySQLOptions, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "mysql,omitempty" } },
            { no: 4, name: "ManagedUsers", kind: "scalar", jsonName: "ManagedUsers", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "managed_users,omitempty" } },
            { no: 5, name: "Azure", kind: "message", jsonName: "Azure", T: () => Azure, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "azure" } }
        ]);
    }
    create(value?: PartialMessage<DatabaseStatusV3>): DatabaseStatusV3 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cACert = "";
        message.managedUsers = [];
        if (value !== undefined)
            reflectionMergePartial<DatabaseStatusV3>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DatabaseStatusV3): DatabaseStatusV3 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string CACert = 1 [json_name = "CACert"];*/ 1:
                    message.cACert = reader.string();
                    break;
                case /* types.AWS AWS = 2 [json_name = "AWS"];*/ 2:
                    message.aWS = AWS.internalBinaryRead(reader, reader.uint32(), options, message.aWS);
                    break;
                case /* types.MySQLOptions MySQL = 3 [json_name = "MySQL"];*/ 3:
                    message.mySQL = MySQLOptions.internalBinaryRead(reader, reader.uint32(), options, message.mySQL);
                    break;
                case /* repeated string ManagedUsers = 4 [json_name = "ManagedUsers"];*/ 4:
                    message.managedUsers.push(reader.string());
                    break;
                case /* types.Azure Azure = 5 [json_name = "Azure"];*/ 5:
                    message.azure = Azure.internalBinaryRead(reader, reader.uint32(), options, message.azure);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DatabaseStatusV3, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string CACert = 1 [json_name = "CACert"]; */
        if (message.cACert !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.cACert);
        /* types.AWS AWS = 2 [json_name = "AWS"]; */
        if (message.aWS)
            AWS.internalBinaryWrite(message.aWS, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* types.MySQLOptions MySQL = 3 [json_name = "MySQL"]; */
        if (message.mySQL)
            MySQLOptions.internalBinaryWrite(message.mySQL, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated string ManagedUsers = 4 [json_name = "ManagedUsers"]; */
        for (let i = 0; i < message.managedUsers.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.managedUsers[i]);
        /* types.Azure Azure = 5 [json_name = "Azure"]; */
        if (message.azure)
            Azure.internalBinaryWrite(message.azure, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.DatabaseStatusV3
 */
export const DatabaseStatusV3 = new DatabaseStatusV3$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AWS$Type extends MessageType<AWS> {
    constructor() {
        super("types.AWS", [
            { no: 1, name: "Region", kind: "scalar", jsonName: "Region", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "region,omitempty" } },
            { no: 2, name: "Redshift", kind: "message", jsonName: "Redshift", T: () => Redshift, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "redshift,omitempty" } },
            { no: 3, name: "RDS", kind: "message", jsonName: "RDS", T: () => RDS, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "rds,omitempty" } },
            { no: 4, name: "AccountID", kind: "scalar", jsonName: "AccountID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "account_id,omitempty" } },
            { no: 5, name: "ElastiCache", kind: "message", jsonName: "ElastiCache", T: () => ElastiCache, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "elasticache,omitempty" } },
            { no: 6, name: "SecretStore", kind: "message", jsonName: "SecretStore", T: () => SecretStore, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "secret_store,omitempty" } },
            { no: 7, name: "MemoryDB", kind: "message", jsonName: "MemoryDB", T: () => MemoryDB, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "memorydb,omitempty" } },
            { no: 8, name: "RDSProxy", kind: "message", jsonName: "RDSProxy", T: () => RDSProxy, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "rdsproxy,omitempty" } },
            { no: 9, name: "RedshiftServerless", kind: "message", jsonName: "RedshiftServerless", T: () => RedshiftServerless, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "redshift_serverless,omitempty" } },
            { no: 10, name: "ExternalID", kind: "scalar", jsonName: "ExternalID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "external_id,omitempty" } },
            { no: 11, name: "AssumeRoleARN", kind: "scalar", jsonName: "AssumeRoleARN", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "assume_role_arn,omitempty" } },
            { no: 12, name: "OpenSearch", kind: "message", jsonName: "OpenSearch", T: () => OpenSearch, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "opensearch,omitempty" } },
            { no: 14, name: "IAMPolicyStatus", kind: "enum", jsonName: "IAMPolicyStatus", T: () => ["types.IAMPolicyStatus", IAMPolicyStatus], options: { "gogoproto.jsontag": "iam_policy_status" } },
            { no: 15, name: "SessionTags", kind: "map", jsonName: "SessionTags", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ }, options: { "gogoproto.jsontag": "session_tags,omitempty" } },
            { no: 16, name: "DocumentDB", kind: "message", jsonName: "DocumentDB", T: () => DocumentDB, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "docdb,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<AWS>): AWS {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.region = "";
        message.accountID = "";
        message.externalID = "";
        message.assumeRoleARN = "";
        message.iAMPolicyStatus = 0;
        message.sessionTags = {};
        if (value !== undefined)
            reflectionMergePartial<AWS>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AWS): AWS {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Region = 1 [json_name = "Region"];*/ 1:
                    message.region = reader.string();
                    break;
                case /* types.Redshift Redshift = 2 [json_name = "Redshift"];*/ 2:
                    message.redshift = Redshift.internalBinaryRead(reader, reader.uint32(), options, message.redshift);
                    break;
                case /* types.RDS RDS = 3 [json_name = "RDS"];*/ 3:
                    message.rDS = RDS.internalBinaryRead(reader, reader.uint32(), options, message.rDS);
                    break;
                case /* string AccountID = 4 [json_name = "AccountID"];*/ 4:
                    message.accountID = reader.string();
                    break;
                case /* types.ElastiCache ElastiCache = 5 [json_name = "ElastiCache"];*/ 5:
                    message.elastiCache = ElastiCache.internalBinaryRead(reader, reader.uint32(), options, message.elastiCache);
                    break;
                case /* types.SecretStore SecretStore = 6 [json_name = "SecretStore"];*/ 6:
                    message.secretStore = SecretStore.internalBinaryRead(reader, reader.uint32(), options, message.secretStore);
                    break;
                case /* types.MemoryDB MemoryDB = 7 [json_name = "MemoryDB"];*/ 7:
                    message.memoryDB = MemoryDB.internalBinaryRead(reader, reader.uint32(), options, message.memoryDB);
                    break;
                case /* types.RDSProxy RDSProxy = 8 [json_name = "RDSProxy"];*/ 8:
                    message.rDSProxy = RDSProxy.internalBinaryRead(reader, reader.uint32(), options, message.rDSProxy);
                    break;
                case /* types.RedshiftServerless RedshiftServerless = 9 [json_name = "RedshiftServerless"];*/ 9:
                    message.redshiftServerless = RedshiftServerless.internalBinaryRead(reader, reader.uint32(), options, message.redshiftServerless);
                    break;
                case /* string ExternalID = 10 [json_name = "ExternalID"];*/ 10:
                    message.externalID = reader.string();
                    break;
                case /* string AssumeRoleARN = 11 [json_name = "AssumeRoleARN"];*/ 11:
                    message.assumeRoleARN = reader.string();
                    break;
                case /* types.OpenSearch OpenSearch = 12 [json_name = "OpenSearch"];*/ 12:
                    message.openSearch = OpenSearch.internalBinaryRead(reader, reader.uint32(), options, message.openSearch);
                    break;
                case /* types.IAMPolicyStatus IAMPolicyStatus = 14 [json_name = "IAMPolicyStatus"];*/ 14:
                    message.iAMPolicyStatus = reader.int32();
                    break;
                case /* map<string, string> SessionTags = 15 [json_name = "SessionTags"];*/ 15:
                    this.binaryReadMap15(message.sessionTags, reader, options);
                    break;
                case /* types.DocumentDB DocumentDB = 16 [json_name = "DocumentDB"];*/ 16:
                    message.documentDB = DocumentDB.internalBinaryRead(reader, reader.uint32(), options, message.documentDB);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap15(map: AWS["sessionTags"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AWS["sessionTags"] | undefined, val: AWS["sessionTags"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field types.AWS.SessionTags");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: AWS, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Region = 1 [json_name = "Region"]; */
        if (message.region !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.region);
        /* types.Redshift Redshift = 2 [json_name = "Redshift"]; */
        if (message.redshift)
            Redshift.internalBinaryWrite(message.redshift, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* types.RDS RDS = 3 [json_name = "RDS"]; */
        if (message.rDS)
            RDS.internalBinaryWrite(message.rDS, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string AccountID = 4 [json_name = "AccountID"]; */
        if (message.accountID !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.accountID);
        /* types.ElastiCache ElastiCache = 5 [json_name = "ElastiCache"]; */
        if (message.elastiCache)
            ElastiCache.internalBinaryWrite(message.elastiCache, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* types.SecretStore SecretStore = 6 [json_name = "SecretStore"]; */
        if (message.secretStore)
            SecretStore.internalBinaryWrite(message.secretStore, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* types.MemoryDB MemoryDB = 7 [json_name = "MemoryDB"]; */
        if (message.memoryDB)
            MemoryDB.internalBinaryWrite(message.memoryDB, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* types.RDSProxy RDSProxy = 8 [json_name = "RDSProxy"]; */
        if (message.rDSProxy)
            RDSProxy.internalBinaryWrite(message.rDSProxy, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* types.RedshiftServerless RedshiftServerless = 9 [json_name = "RedshiftServerless"]; */
        if (message.redshiftServerless)
            RedshiftServerless.internalBinaryWrite(message.redshiftServerless, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* string ExternalID = 10 [json_name = "ExternalID"]; */
        if (message.externalID !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.externalID);
        /* string AssumeRoleARN = 11 [json_name = "AssumeRoleARN"]; */
        if (message.assumeRoleARN !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.assumeRoleARN);
        /* types.OpenSearch OpenSearch = 12 [json_name = "OpenSearch"]; */
        if (message.openSearch)
            OpenSearch.internalBinaryWrite(message.openSearch, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* types.IAMPolicyStatus IAMPolicyStatus = 14 [json_name = "IAMPolicyStatus"]; */
        if (message.iAMPolicyStatus !== 0)
            writer.tag(14, WireType.Varint).int32(message.iAMPolicyStatus);
        /* map<string, string> SessionTags = 15 [json_name = "SessionTags"]; */
        for (let k of globalThis.Object.keys(message.sessionTags))
            writer.tag(15, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.sessionTags[k]).join();
        /* types.DocumentDB DocumentDB = 16 [json_name = "DocumentDB"]; */
        if (message.documentDB)
            DocumentDB.internalBinaryWrite(message.documentDB, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AWS
 */
export const AWS = new AWS$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SecretStore$Type extends MessageType<SecretStore> {
    constructor() {
        super("types.SecretStore", [
            { no: 1, name: "KeyPrefix", kind: "scalar", jsonName: "KeyPrefix", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "key_prefix,omitempty" } },
            { no: 2, name: "KMSKeyID", kind: "scalar", jsonName: "KMSKeyID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kms_key_id,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<SecretStore>): SecretStore {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyPrefix = "";
        message.kMSKeyID = "";
        if (value !== undefined)
            reflectionMergePartial<SecretStore>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SecretStore): SecretStore {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string KeyPrefix = 1 [json_name = "KeyPrefix"];*/ 1:
                    message.keyPrefix = reader.string();
                    break;
                case /* string KMSKeyID = 2 [json_name = "KMSKeyID"];*/ 2:
                    message.kMSKeyID = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SecretStore, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string KeyPrefix = 1 [json_name = "KeyPrefix"]; */
        if (message.keyPrefix !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyPrefix);
        /* string KMSKeyID = 2 [json_name = "KMSKeyID"]; */
        if (message.kMSKeyID !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.kMSKeyID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.SecretStore
 */
export const SecretStore = new SecretStore$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Redshift$Type extends MessageType<Redshift> {
    constructor() {
        super("types.Redshift", [
            { no: 1, name: "ClusterID", kind: "scalar", jsonName: "ClusterID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "cluster_id,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<Redshift>): Redshift {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterID = "";
        if (value !== undefined)
            reflectionMergePartial<Redshift>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Redshift): Redshift {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ClusterID = 1 [json_name = "ClusterID"];*/ 1:
                    message.clusterID = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Redshift, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ClusterID = 1 [json_name = "ClusterID"]; */
        if (message.clusterID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.Redshift
 */
export const Redshift = new Redshift$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RDS$Type extends MessageType<RDS> {
    constructor() {
        super("types.RDS", [
            { no: 1, name: "InstanceID", kind: "scalar", jsonName: "InstanceID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "instance_id,omitempty" } },
            { no: 2, name: "ClusterID", kind: "scalar", jsonName: "ClusterID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "cluster_id,omitempty" } },
            { no: 3, name: "ResourceID", kind: "scalar", jsonName: "ResourceID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "resource_id,omitempty" } },
            { no: 4, name: "IAMAuth", kind: "scalar", jsonName: "IAMAuth", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "iam_auth" } },
            { no: 5, name: "Subnets", kind: "scalar", jsonName: "Subnets", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "subnets,omitempty" } },
            { no: 6, name: "VPCID", kind: "scalar", jsonName: "VPCID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "vpc_id,omitempty" } },
            { no: 7, name: "SecurityGroups", kind: "scalar", jsonName: "SecurityGroups", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "security_groups,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<RDS>): RDS {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.instanceID = "";
        message.clusterID = "";
        message.resourceID = "";
        message.iAMAuth = false;
        message.subnets = [];
        message.vPCID = "";
        message.securityGroups = [];
        if (value !== undefined)
            reflectionMergePartial<RDS>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RDS): RDS {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string InstanceID = 1 [json_name = "InstanceID"];*/ 1:
                    message.instanceID = reader.string();
                    break;
                case /* string ClusterID = 2 [json_name = "ClusterID"];*/ 2:
                    message.clusterID = reader.string();
                    break;
                case /* string ResourceID = 3 [json_name = "ResourceID"];*/ 3:
                    message.resourceID = reader.string();
                    break;
                case /* bool IAMAuth = 4 [json_name = "IAMAuth"];*/ 4:
                    message.iAMAuth = reader.bool();
                    break;
                case /* repeated string Subnets = 5 [json_name = "Subnets"];*/ 5:
                    message.subnets.push(reader.string());
                    break;
                case /* string VPCID = 6 [json_name = "VPCID"];*/ 6:
                    message.vPCID = reader.string();
                    break;
                case /* repeated string SecurityGroups = 7 [json_name = "SecurityGroups"];*/ 7:
                    message.securityGroups.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RDS, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string InstanceID = 1 [json_name = "InstanceID"]; */
        if (message.instanceID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.instanceID);
        /* string ClusterID = 2 [json_name = "ClusterID"]; */
        if (message.clusterID !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.clusterID);
        /* string ResourceID = 3 [json_name = "ResourceID"]; */
        if (message.resourceID !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.resourceID);
        /* bool IAMAuth = 4 [json_name = "IAMAuth"]; */
        if (message.iAMAuth !== false)
            writer.tag(4, WireType.Varint).bool(message.iAMAuth);
        /* repeated string Subnets = 5 [json_name = "Subnets"]; */
        for (let i = 0; i < message.subnets.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.subnets[i]);
        /* string VPCID = 6 [json_name = "VPCID"]; */
        if (message.vPCID !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.vPCID);
        /* repeated string SecurityGroups = 7 [json_name = "SecurityGroups"]; */
        for (let i = 0; i < message.securityGroups.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.securityGroups[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.RDS
 */
export const RDS = new RDS$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RDSProxy$Type extends MessageType<RDSProxy> {
    constructor() {
        super("types.RDSProxy", [
            { no: 1, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "name,omitempty" } },
            { no: 2, name: "CustomEndpointName", kind: "scalar", jsonName: "CustomEndpointName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "custom_endpoint_name,omitempty" } },
            { no: 3, name: "ResourceID", kind: "scalar", jsonName: "ResourceID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "resource_id,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<RDSProxy>): RDSProxy {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.customEndpointName = "";
        message.resourceID = "";
        if (value !== undefined)
            reflectionMergePartial<RDSProxy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RDSProxy): RDSProxy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Name = 1 [json_name = "Name"];*/ 1:
                    message.name = reader.string();
                    break;
                case /* string CustomEndpointName = 2 [json_name = "CustomEndpointName"];*/ 2:
                    message.customEndpointName = reader.string();
                    break;
                case /* string ResourceID = 3 [json_name = "ResourceID"];*/ 3:
                    message.resourceID = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RDSProxy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Name = 1 [json_name = "Name"]; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string CustomEndpointName = 2 [json_name = "CustomEndpointName"]; */
        if (message.customEndpointName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.customEndpointName);
        /* string ResourceID = 3 [json_name = "ResourceID"]; */
        if (message.resourceID !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.resourceID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.RDSProxy
 */
export const RDSProxy = new RDSProxy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ElastiCache$Type extends MessageType<ElastiCache> {
    constructor() {
        super("types.ElastiCache", [
            { no: 1, name: "ReplicationGroupID", kind: "scalar", jsonName: "ReplicationGroupID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "replication_group_id,omitempty" } },
            { no: 2, name: "UserGroupIDs", kind: "scalar", jsonName: "UserGroupIDs", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "user_group_ids,omitempty" } },
            { no: 3, name: "TransitEncryptionEnabled", kind: "scalar", jsonName: "TransitEncryptionEnabled", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "transit_encryption_enabled,omitempty" } },
            { no: 4, name: "EndpointType", kind: "scalar", jsonName: "EndpointType", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "endpoint_type,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ElastiCache>): ElastiCache {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.replicationGroupID = "";
        message.userGroupIDs = [];
        message.transitEncryptionEnabled = false;
        message.endpointType = "";
        if (value !== undefined)
            reflectionMergePartial<ElastiCache>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ElastiCache): ElastiCache {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ReplicationGroupID = 1 [json_name = "ReplicationGroupID"];*/ 1:
                    message.replicationGroupID = reader.string();
                    break;
                case /* repeated string UserGroupIDs = 2 [json_name = "UserGroupIDs"];*/ 2:
                    message.userGroupIDs.push(reader.string());
                    break;
                case /* bool TransitEncryptionEnabled = 3 [json_name = "TransitEncryptionEnabled"];*/ 3:
                    message.transitEncryptionEnabled = reader.bool();
                    break;
                case /* string EndpointType = 4 [json_name = "EndpointType"];*/ 4:
                    message.endpointType = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ElastiCache, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ReplicationGroupID = 1 [json_name = "ReplicationGroupID"]; */
        if (message.replicationGroupID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.replicationGroupID);
        /* repeated string UserGroupIDs = 2 [json_name = "UserGroupIDs"]; */
        for (let i = 0; i < message.userGroupIDs.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.userGroupIDs[i]);
        /* bool TransitEncryptionEnabled = 3 [json_name = "TransitEncryptionEnabled"]; */
        if (message.transitEncryptionEnabled !== false)
            writer.tag(3, WireType.Varint).bool(message.transitEncryptionEnabled);
        /* string EndpointType = 4 [json_name = "EndpointType"]; */
        if (message.endpointType !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.endpointType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ElastiCache
 */
export const ElastiCache = new ElastiCache$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MemoryDB$Type extends MessageType<MemoryDB> {
    constructor() {
        super("types.MemoryDB", [
            { no: 1, name: "ClusterName", kind: "scalar", jsonName: "ClusterName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "cluster_name,omitempty" } },
            { no: 2, name: "ACLName", kind: "scalar", jsonName: "ACLName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "acl_name,omitempty" } },
            { no: 3, name: "TLSEnabled", kind: "scalar", jsonName: "TLSEnabled", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "tls_enabled,omitempty" } },
            { no: 4, name: "EndpointType", kind: "scalar", jsonName: "EndpointType", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "endpoint_type,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<MemoryDB>): MemoryDB {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterName = "";
        message.aCLName = "";
        message.tLSEnabled = false;
        message.endpointType = "";
        if (value !== undefined)
            reflectionMergePartial<MemoryDB>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MemoryDB): MemoryDB {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ClusterName = 1 [json_name = "ClusterName"];*/ 1:
                    message.clusterName = reader.string();
                    break;
                case /* string ACLName = 2 [json_name = "ACLName"];*/ 2:
                    message.aCLName = reader.string();
                    break;
                case /* bool TLSEnabled = 3 [json_name = "TLSEnabled"];*/ 3:
                    message.tLSEnabled = reader.bool();
                    break;
                case /* string EndpointType = 4 [json_name = "EndpointType"];*/ 4:
                    message.endpointType = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MemoryDB, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ClusterName = 1 [json_name = "ClusterName"]; */
        if (message.clusterName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterName);
        /* string ACLName = 2 [json_name = "ACLName"]; */
        if (message.aCLName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.aCLName);
        /* bool TLSEnabled = 3 [json_name = "TLSEnabled"]; */
        if (message.tLSEnabled !== false)
            writer.tag(3, WireType.Varint).bool(message.tLSEnabled);
        /* string EndpointType = 4 [json_name = "EndpointType"]; */
        if (message.endpointType !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.endpointType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.MemoryDB
 */
export const MemoryDB = new MemoryDB$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RedshiftServerless$Type extends MessageType<RedshiftServerless> {
    constructor() {
        super("types.RedshiftServerless", [
            { no: 1, name: "WorkgroupName", kind: "scalar", jsonName: "WorkgroupName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "workgroup_name,omitempty" } },
            { no: 2, name: "EndpointName", kind: "scalar", jsonName: "EndpointName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "endpoint_name,omitempty" } },
            { no: 3, name: "WorkgroupID", kind: "scalar", jsonName: "WorkgroupID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "workgroup_id,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<RedshiftServerless>): RedshiftServerless {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workgroupName = "";
        message.endpointName = "";
        message.workgroupID = "";
        if (value !== undefined)
            reflectionMergePartial<RedshiftServerless>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RedshiftServerless): RedshiftServerless {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string WorkgroupName = 1 [json_name = "WorkgroupName"];*/ 1:
                    message.workgroupName = reader.string();
                    break;
                case /* string EndpointName = 2 [json_name = "EndpointName"];*/ 2:
                    message.endpointName = reader.string();
                    break;
                case /* string WorkgroupID = 3 [json_name = "WorkgroupID"];*/ 3:
                    message.workgroupID = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RedshiftServerless, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string WorkgroupName = 1 [json_name = "WorkgroupName"]; */
        if (message.workgroupName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.workgroupName);
        /* string EndpointName = 2 [json_name = "EndpointName"]; */
        if (message.endpointName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.endpointName);
        /* string WorkgroupID = 3 [json_name = "WorkgroupID"]; */
        if (message.workgroupID !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.workgroupID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.RedshiftServerless
 */
export const RedshiftServerless = new RedshiftServerless$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OpenSearch$Type extends MessageType<OpenSearch> {
    constructor() {
        super("types.OpenSearch", [
            { no: 1, name: "DomainName", kind: "scalar", jsonName: "DomainName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "domain_name,omitempty" } },
            { no: 2, name: "DomainID", kind: "scalar", jsonName: "DomainID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "domain_id,omitempty" } },
            { no: 3, name: "EndpointType", kind: "scalar", jsonName: "EndpointType", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "endpoint_type,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<OpenSearch>): OpenSearch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.domainName = "";
        message.domainID = "";
        message.endpointType = "";
        if (value !== undefined)
            reflectionMergePartial<OpenSearch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OpenSearch): OpenSearch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string DomainName = 1 [json_name = "DomainName"];*/ 1:
                    message.domainName = reader.string();
                    break;
                case /* string DomainID = 2 [json_name = "DomainID"];*/ 2:
                    message.domainID = reader.string();
                    break;
                case /* string EndpointType = 3 [json_name = "EndpointType"];*/ 3:
                    message.endpointType = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OpenSearch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string DomainName = 1 [json_name = "DomainName"]; */
        if (message.domainName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.domainName);
        /* string DomainID = 2 [json_name = "DomainID"]; */
        if (message.domainID !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.domainID);
        /* string EndpointType = 3 [json_name = "EndpointType"]; */
        if (message.endpointType !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.endpointType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.OpenSearch
 */
export const OpenSearch = new OpenSearch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentDB$Type extends MessageType<DocumentDB> {
    constructor() {
        super("types.DocumentDB", [
            { no: 1, name: "ClusterID", kind: "scalar", jsonName: "ClusterID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "cluster_id,omitempty" } },
            { no: 2, name: "InstanceID", kind: "scalar", jsonName: "InstanceID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "instance_id,omitempty" } },
            { no: 3, name: "EndpointType", kind: "scalar", jsonName: "EndpointType", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "endpoint_type,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<DocumentDB>): DocumentDB {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterID = "";
        message.instanceID = "";
        message.endpointType = "";
        if (value !== undefined)
            reflectionMergePartial<DocumentDB>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentDB): DocumentDB {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ClusterID = 1 [json_name = "ClusterID"];*/ 1:
                    message.clusterID = reader.string();
                    break;
                case /* string InstanceID = 2 [json_name = "InstanceID"];*/ 2:
                    message.instanceID = reader.string();
                    break;
                case /* string EndpointType = 3 [json_name = "EndpointType"];*/ 3:
                    message.endpointType = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentDB, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ClusterID = 1 [json_name = "ClusterID"]; */
        if (message.clusterID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterID);
        /* string InstanceID = 2 [json_name = "InstanceID"]; */
        if (message.instanceID !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.instanceID);
        /* string EndpointType = 3 [json_name = "EndpointType"]; */
        if (message.endpointType !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.endpointType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.DocumentDB
 */
export const DocumentDB = new DocumentDB$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCPCloudSQL$Type extends MessageType<GCPCloudSQL> {
    constructor() {
        super("types.GCPCloudSQL", [
            { no: 1, name: "ProjectID", kind: "scalar", jsonName: "ProjectID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "project_id,omitempty" } },
            { no: 2, name: "InstanceID", kind: "scalar", jsonName: "InstanceID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "instance_id,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<GCPCloudSQL>): GCPCloudSQL {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.projectID = "";
        message.instanceID = "";
        if (value !== undefined)
            reflectionMergePartial<GCPCloudSQL>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCPCloudSQL): GCPCloudSQL {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ProjectID = 1 [json_name = "ProjectID"];*/ 1:
                    message.projectID = reader.string();
                    break;
                case /* string InstanceID = 2 [json_name = "InstanceID"];*/ 2:
                    message.instanceID = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCPCloudSQL, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ProjectID = 1 [json_name = "ProjectID"]; */
        if (message.projectID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.projectID);
        /* string InstanceID = 2 [json_name = "InstanceID"]; */
        if (message.instanceID !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.instanceID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.GCPCloudSQL
 */
export const GCPCloudSQL = new GCPCloudSQL$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Azure$Type extends MessageType<Azure> {
    constructor() {
        super("types.Azure", [
            { no: 1, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "name,omitempty" } },
            { no: 2, name: "ResourceID", kind: "scalar", jsonName: "ResourceID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "resource_id,omitempty" } },
            { no: 3, name: "Redis", kind: "message", jsonName: "Redis", T: () => AzureRedis, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "redis,omitempty" } },
            { no: 4, name: "IsFlexiServer", kind: "scalar", jsonName: "IsFlexiServer", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "is_flexi_server,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<Azure>): Azure {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.resourceID = "";
        message.isFlexiServer = false;
        if (value !== undefined)
            reflectionMergePartial<Azure>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Azure): Azure {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Name = 1 [json_name = "Name"];*/ 1:
                    message.name = reader.string();
                    break;
                case /* string ResourceID = 2 [json_name = "ResourceID"];*/ 2:
                    message.resourceID = reader.string();
                    break;
                case /* types.AzureRedis Redis = 3 [json_name = "Redis"];*/ 3:
                    message.redis = AzureRedis.internalBinaryRead(reader, reader.uint32(), options, message.redis);
                    break;
                case /* bool IsFlexiServer = 4 [json_name = "IsFlexiServer"];*/ 4:
                    message.isFlexiServer = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Azure, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Name = 1 [json_name = "Name"]; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string ResourceID = 2 [json_name = "ResourceID"]; */
        if (message.resourceID !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.resourceID);
        /* types.AzureRedis Redis = 3 [json_name = "Redis"]; */
        if (message.redis)
            AzureRedis.internalBinaryWrite(message.redis, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool IsFlexiServer = 4 [json_name = "IsFlexiServer"]; */
        if (message.isFlexiServer !== false)
            writer.tag(4, WireType.Varint).bool(message.isFlexiServer);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.Azure
 */
export const Azure = new Azure$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AzureRedis$Type extends MessageType<AzureRedis> {
    constructor() {
        super("types.AzureRedis", [
            { no: 1, name: "ClusteringPolicy", kind: "scalar", jsonName: "ClusteringPolicy", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "clustering_policy,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<AzureRedis>): AzureRedis {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusteringPolicy = "";
        if (value !== undefined)
            reflectionMergePartial<AzureRedis>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AzureRedis): AzureRedis {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ClusteringPolicy = 1 [json_name = "ClusteringPolicy"];*/ 1:
                    message.clusteringPolicy = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AzureRedis, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ClusteringPolicy = 1 [json_name = "ClusteringPolicy"]; */
        if (message.clusteringPolicy !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusteringPolicy);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AzureRedis
 */
export const AzureRedis = new AzureRedis$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AD$Type extends MessageType<AD> {
    constructor() {
        super("types.AD", [
            { no: 1, name: "KeytabFile", kind: "scalar", jsonName: "KeytabFile", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "keytab_file,omitempty" } },
            { no: 2, name: "Krb5File", kind: "scalar", jsonName: "Krb5File", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "krb5_file,omitempty" } },
            { no: 3, name: "Domain", kind: "scalar", jsonName: "Domain", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "domain" } },
            { no: 4, name: "SPN", kind: "scalar", jsonName: "SPN", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "spn" } },
            { no: 5, name: "LDAPCert", kind: "scalar", jsonName: "LDAPCert", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "ldap_cert,omitempty" } },
            { no: 6, name: "KDCHostName", kind: "scalar", jsonName: "KDCHostName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kdc_host_name,omitempty" } },
            { no: 7, name: "LDAPServiceAccountName", kind: "scalar", jsonName: "LDAPServiceAccountName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "ldap_service_account_name,omitempty" } },
            { no: 8, name: "LDAPServiceAccountSID", kind: "scalar", jsonName: "LDAPServiceAccountSID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "ldap_service_account_sid,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<AD>): AD {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keytabFile = "";
        message.krb5File = "";
        message.domain = "";
        message.sPN = "";
        message.lDAPCert = "";
        message.kDCHostName = "";
        message.lDAPServiceAccountName = "";
        message.lDAPServiceAccountSID = "";
        if (value !== undefined)
            reflectionMergePartial<AD>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AD): AD {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string KeytabFile = 1 [json_name = "KeytabFile"];*/ 1:
                    message.keytabFile = reader.string();
                    break;
                case /* string Krb5File = 2 [json_name = "Krb5File"];*/ 2:
                    message.krb5File = reader.string();
                    break;
                case /* string Domain = 3 [json_name = "Domain"];*/ 3:
                    message.domain = reader.string();
                    break;
                case /* string SPN = 4 [json_name = "SPN"];*/ 4:
                    message.sPN = reader.string();
                    break;
                case /* string LDAPCert = 5 [json_name = "LDAPCert"];*/ 5:
                    message.lDAPCert = reader.string();
                    break;
                case /* string KDCHostName = 6 [json_name = "KDCHostName"];*/ 6:
                    message.kDCHostName = reader.string();
                    break;
                case /* string LDAPServiceAccountName = 7 [json_name = "LDAPServiceAccountName"];*/ 7:
                    message.lDAPServiceAccountName = reader.string();
                    break;
                case /* string LDAPServiceAccountSID = 8 [json_name = "LDAPServiceAccountSID"];*/ 8:
                    message.lDAPServiceAccountSID = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AD, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string KeytabFile = 1 [json_name = "KeytabFile"]; */
        if (message.keytabFile !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keytabFile);
        /* string Krb5File = 2 [json_name = "Krb5File"]; */
        if (message.krb5File !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.krb5File);
        /* string Domain = 3 [json_name = "Domain"]; */
        if (message.domain !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.domain);
        /* string SPN = 4 [json_name = "SPN"]; */
        if (message.sPN !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.sPN);
        /* string LDAPCert = 5 [json_name = "LDAPCert"]; */
        if (message.lDAPCert !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.lDAPCert);
        /* string KDCHostName = 6 [json_name = "KDCHostName"]; */
        if (message.kDCHostName !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.kDCHostName);
        /* string LDAPServiceAccountName = 7 [json_name = "LDAPServiceAccountName"]; */
        if (message.lDAPServiceAccountName !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.lDAPServiceAccountName);
        /* string LDAPServiceAccountSID = 8 [json_name = "LDAPServiceAccountSID"]; */
        if (message.lDAPServiceAccountSID !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.lDAPServiceAccountSID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AD
 */
export const AD = new AD$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DatabaseTLS$Type extends MessageType<DatabaseTLS> {
    constructor() {
        super("types.DatabaseTLS", [
            { no: 1, name: "Mode", kind: "enum", jsonName: "Mode", T: () => ["types.DatabaseTLSMode", DatabaseTLSMode], options: { "gogoproto.jsontag": "mode" } },
            { no: 2, name: "CACert", kind: "scalar", jsonName: "CACert", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "ca_cert,omitempty" } },
            { no: 3, name: "ServerName", kind: "scalar", jsonName: "ServerName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "server_name,omitempty" } },
            { no: 4, name: "TrustSystemCertPool", kind: "scalar", jsonName: "TrustSystemCertPool", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "trust_system_cert_pool,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<DatabaseTLS>): DatabaseTLS {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mode = 0;
        message.cACert = "";
        message.serverName = "";
        message.trustSystemCertPool = false;
        if (value !== undefined)
            reflectionMergePartial<DatabaseTLS>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DatabaseTLS): DatabaseTLS {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.DatabaseTLSMode Mode = 1 [json_name = "Mode"];*/ 1:
                    message.mode = reader.int32();
                    break;
                case /* string CACert = 2 [json_name = "CACert"];*/ 2:
                    message.cACert = reader.string();
                    break;
                case /* string ServerName = 3 [json_name = "ServerName"];*/ 3:
                    message.serverName = reader.string();
                    break;
                case /* bool TrustSystemCertPool = 4 [json_name = "TrustSystemCertPool"];*/ 4:
                    message.trustSystemCertPool = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DatabaseTLS, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.DatabaseTLSMode Mode = 1 [json_name = "Mode"]; */
        if (message.mode !== 0)
            writer.tag(1, WireType.Varint).int32(message.mode);
        /* string CACert = 2 [json_name = "CACert"]; */
        if (message.cACert !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.cACert);
        /* string ServerName = 3 [json_name = "ServerName"]; */
        if (message.serverName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.serverName);
        /* bool TrustSystemCertPool = 4 [json_name = "TrustSystemCertPool"]; */
        if (message.trustSystemCertPool !== false)
            writer.tag(4, WireType.Varint).bool(message.trustSystemCertPool);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.DatabaseTLS
 */
export const DatabaseTLS = new DatabaseTLS$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MySQLOptions$Type extends MessageType<MySQLOptions> {
    constructor() {
        super("types.MySQLOptions", [
            { no: 1, name: "ServerVersion", kind: "scalar", jsonName: "ServerVersion", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "server_version,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<MySQLOptions>): MySQLOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.serverVersion = "";
        if (value !== undefined)
            reflectionMergePartial<MySQLOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MySQLOptions): MySQLOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ServerVersion = 1 [json_name = "ServerVersion"];*/ 1:
                    message.serverVersion = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MySQLOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ServerVersion = 1 [json_name = "ServerVersion"]; */
        if (message.serverVersion !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.serverVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.MySQLOptions
 */
export const MySQLOptions = new MySQLOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MongoAtlas$Type extends MessageType<MongoAtlas> {
    constructor() {
        super("types.MongoAtlas", [
            { no: 1, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "name,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<MongoAtlas>): MongoAtlas {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<MongoAtlas>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MongoAtlas): MongoAtlas {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Name = 1 [json_name = "Name"];*/ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MongoAtlas, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Name = 1 [json_name = "Name"]; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.MongoAtlas
 */
export const MongoAtlas = new MongoAtlas$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InstanceV1$Type extends MessageType<InstanceV1> {
    constructor() {
        super("types.InstanceV1", [
            { no: 1, name: "Header", kind: "message", jsonName: "Header", T: () => ResourceHeader, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Spec", kind: "message", jsonName: "Spec", T: () => InstanceSpecV1, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ]);
    }
    create(value?: PartialMessage<InstanceV1>): InstanceV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<InstanceV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InstanceV1): InstanceV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.ResourceHeader Header = 1 [json_name = "Header"];*/ 1:
                    message.header = ResourceHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* types.InstanceSpecV1 Spec = 2 [json_name = "Spec"];*/ 2:
                    message.spec = InstanceSpecV1.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InstanceV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.ResourceHeader Header = 1 [json_name = "Header"]; */
        if (message.header)
            ResourceHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* types.InstanceSpecV1 Spec = 2 [json_name = "Spec"]; */
        if (message.spec)
            InstanceSpecV1.internalBinaryWrite(message.spec, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.InstanceV1
 */
export const InstanceV1 = new InstanceV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InstanceSpecV1$Type extends MessageType<InstanceSpecV1> {
    constructor() {
        super("types.InstanceSpecV1", [
            { no: 1, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version,omitempty" } },
            { no: 2, name: "Services", kind: "scalar", jsonName: "Services", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "services,omitempty", "gogoproto.casttype": "SystemRole" } },
            { no: 3, name: "Hostname", kind: "scalar", jsonName: "Hostname", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "hostname,omitempty" } },
            { no: 4, name: "AuthID", kind: "scalar", jsonName: "AuthID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "auth_id,omitempty" } },
            { no: 5, name: "LastSeen", kind: "message", jsonName: "LastSeen", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "last_seen,omitempty", "gogoproto.stdtime": true } },
            { no: 6, name: "ControlLog", kind: "message", jsonName: "ControlLog", repeat: 1 /*RepeatType.PACKED*/, T: () => InstanceControlLogEntry, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "control_log,omitempty" } },
            { no: 7, name: "ExternalUpgrader", kind: "scalar", jsonName: "ExternalUpgrader", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "ext_upgrader,omitempty" } },
            { no: 8, name: "ExternalUpgraderVersion", kind: "scalar", jsonName: "ExternalUpgraderVersion", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "ext_upgrader_version,omitempty" } },
            { no: 9, name: "LastMeasurement", kind: "message", jsonName: "LastMeasurement", T: () => SystemClockMeasurement },
            { no: 10, name: "UpdaterInfo", kind: "message", jsonName: "UpdaterInfo", T: () => UpdaterV2Info }
        ]);
    }
    create(value?: PartialMessage<InstanceSpecV1>): InstanceSpecV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.version = "";
        message.services = [];
        message.hostname = "";
        message.authID = "";
        message.controlLog = [];
        message.externalUpgrader = "";
        message.externalUpgraderVersion = "";
        if (value !== undefined)
            reflectionMergePartial<InstanceSpecV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InstanceSpecV1): InstanceSpecV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Version = 1 [json_name = "Version"];*/ 1:
                    message.version = reader.string();
                    break;
                case /* repeated string Services = 2 [json_name = "Services"];*/ 2:
                    message.services.push(reader.string());
                    break;
                case /* string Hostname = 3 [json_name = "Hostname"];*/ 3:
                    message.hostname = reader.string();
                    break;
                case /* string AuthID = 4 [json_name = "AuthID"];*/ 4:
                    message.authID = reader.string();
                    break;
                case /* google.protobuf.Timestamp LastSeen = 5 [json_name = "LastSeen"];*/ 5:
                    message.lastSeen = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastSeen);
                    break;
                case /* repeated types.InstanceControlLogEntry ControlLog = 6 [json_name = "ControlLog"];*/ 6:
                    message.controlLog.push(InstanceControlLogEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string ExternalUpgrader = 7 [json_name = "ExternalUpgrader"];*/ 7:
                    message.externalUpgrader = reader.string();
                    break;
                case /* string ExternalUpgraderVersion = 8 [json_name = "ExternalUpgraderVersion"];*/ 8:
                    message.externalUpgraderVersion = reader.string();
                    break;
                case /* types.SystemClockMeasurement LastMeasurement = 9 [json_name = "LastMeasurement"];*/ 9:
                    message.lastMeasurement = SystemClockMeasurement.internalBinaryRead(reader, reader.uint32(), options, message.lastMeasurement);
                    break;
                case /* types.UpdaterV2Info UpdaterInfo = 10 [json_name = "UpdaterInfo"];*/ 10:
                    message.updaterInfo = UpdaterV2Info.internalBinaryRead(reader, reader.uint32(), options, message.updaterInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InstanceSpecV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Version = 1 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.version);
        /* repeated string Services = 2 [json_name = "Services"]; */
        for (let i = 0; i < message.services.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.services[i]);
        /* string Hostname = 3 [json_name = "Hostname"]; */
        if (message.hostname !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.hostname);
        /* string AuthID = 4 [json_name = "AuthID"]; */
        if (message.authID !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.authID);
        /* google.protobuf.Timestamp LastSeen = 5 [json_name = "LastSeen"]; */
        if (message.lastSeen)
            Timestamp.internalBinaryWrite(message.lastSeen, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated types.InstanceControlLogEntry ControlLog = 6 [json_name = "ControlLog"]; */
        for (let i = 0; i < message.controlLog.length; i++)
            InstanceControlLogEntry.internalBinaryWrite(message.controlLog[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* string ExternalUpgrader = 7 [json_name = "ExternalUpgrader"]; */
        if (message.externalUpgrader !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.externalUpgrader);
        /* string ExternalUpgraderVersion = 8 [json_name = "ExternalUpgraderVersion"]; */
        if (message.externalUpgraderVersion !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.externalUpgraderVersion);
        /* types.SystemClockMeasurement LastMeasurement = 9 [json_name = "LastMeasurement"]; */
        if (message.lastMeasurement)
            SystemClockMeasurement.internalBinaryWrite(message.lastMeasurement, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* types.UpdaterV2Info UpdaterInfo = 10 [json_name = "UpdaterInfo"]; */
        if (message.updaterInfo)
            UpdaterV2Info.internalBinaryWrite(message.updaterInfo, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.InstanceSpecV1
 */
export const InstanceSpecV1 = new InstanceSpecV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SystemClockMeasurement$Type extends MessageType<SystemClockMeasurement> {
    constructor() {
        super("types.SystemClockMeasurement", [
            { no: 1, name: "ControllerSystemClock", kind: "message", jsonName: "ControllerSystemClock", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "controller_system_clock,omitempty", "gogoproto.stdtime": true } },
            { no: 2, name: "SystemClock", kind: "message", jsonName: "SystemClock", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "system_clock,omitempty", "gogoproto.stdtime": true } },
            { no: 3, name: "RequestDuration", kind: "message", jsonName: "RequestDuration", T: () => Duration, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "request_duration", "gogoproto.stdduration": true } }
        ]);
    }
    create(value?: PartialMessage<SystemClockMeasurement>): SystemClockMeasurement {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SystemClockMeasurement>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SystemClockMeasurement): SystemClockMeasurement {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Timestamp ControllerSystemClock = 1 [json_name = "ControllerSystemClock"];*/ 1:
                    message.controllerSystemClock = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.controllerSystemClock);
                    break;
                case /* google.protobuf.Timestamp SystemClock = 2 [json_name = "SystemClock"];*/ 2:
                    message.systemClock = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.systemClock);
                    break;
                case /* google.protobuf.Duration RequestDuration = 3 [json_name = "RequestDuration"];*/ 3:
                    message.requestDuration = Duration.internalBinaryRead(reader, reader.uint32(), options, message.requestDuration);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SystemClockMeasurement, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Timestamp ControllerSystemClock = 1 [json_name = "ControllerSystemClock"]; */
        if (message.controllerSystemClock)
            Timestamp.internalBinaryWrite(message.controllerSystemClock, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp SystemClock = 2 [json_name = "SystemClock"]; */
        if (message.systemClock)
            Timestamp.internalBinaryWrite(message.systemClock, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration RequestDuration = 3 [json_name = "RequestDuration"]; */
        if (message.requestDuration)
            Duration.internalBinaryWrite(message.requestDuration, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.SystemClockMeasurement
 */
export const SystemClockMeasurement = new SystemClockMeasurement$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InstanceControlLogEntry$Type extends MessageType<InstanceControlLogEntry> {
    constructor() {
        super("types.InstanceControlLogEntry", [
            { no: 1, name: "Type", kind: "scalar", jsonName: "Type", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "type,omitempty" } },
            { no: 2, name: "ID", kind: "scalar", jsonName: "ID", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "id,omitempty" } },
            { no: 3, name: "Time", kind: "message", jsonName: "Time", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "time,omitempty", "gogoproto.stdtime": true } },
            { no: 4, name: "TTL", kind: "scalar", jsonName: "TTL", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "ttl,omitempty", "gogoproto.casttype": "time.Duration" } },
            { no: 5, name: "Labels", kind: "map", jsonName: "Labels", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ }, options: { "gogoproto.jsontag": "labels,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<InstanceControlLogEntry>): InstanceControlLogEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        message.iD = 0n;
        message.tTL = 0n;
        message.labels = {};
        if (value !== undefined)
            reflectionMergePartial<InstanceControlLogEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InstanceControlLogEntry): InstanceControlLogEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Type = 1 [json_name = "Type"];*/ 1:
                    message.type = reader.string();
                    break;
                case /* uint64 ID = 2 [json_name = "ID"];*/ 2:
                    message.iD = reader.uint64().toBigInt();
                    break;
                case /* google.protobuf.Timestamp Time = 3 [json_name = "Time"];*/ 3:
                    message.time = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.time);
                    break;
                case /* int64 TTL = 4 [json_name = "TTL"];*/ 4:
                    message.tTL = reader.int64().toBigInt();
                    break;
                case /* map<string, string> Labels = 5 [json_name = "Labels"];*/ 5:
                    this.binaryReadMap5(message.labels, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap5(map: InstanceControlLogEntry["labels"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof InstanceControlLogEntry["labels"] | undefined, val: InstanceControlLogEntry["labels"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field types.InstanceControlLogEntry.Labels");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: InstanceControlLogEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Type = 1 [json_name = "Type"]; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* uint64 ID = 2 [json_name = "ID"]; */
        if (message.iD !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.iD);
        /* google.protobuf.Timestamp Time = 3 [json_name = "Time"]; */
        if (message.time)
            Timestamp.internalBinaryWrite(message.time, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* int64 TTL = 4 [json_name = "TTL"]; */
        if (message.tTL !== 0n)
            writer.tag(4, WireType.Varint).int64(message.tTL);
        /* map<string, string> Labels = 5 [json_name = "Labels"]; */
        for (let k of globalThis.Object.keys(message.labels))
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.labels[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.InstanceControlLogEntry
 */
export const InstanceControlLogEntry = new InstanceControlLogEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdaterV2Info$Type extends MessageType<UpdaterV2Info> {
    constructor() {
        super("types.UpdaterV2Info", [
            { no: 1, name: "UpdateGroup", kind: "scalar", jsonName: "UpdateGroup", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "UpdateUUID", kind: "scalar", jsonName: "UpdateUUID", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "UpdaterStatus", kind: "enum", jsonName: "UpdaterStatus", T: () => ["types.UpdaterStatus", UpdaterStatus, "UPDATER_STATUS_"] }
        ]);
    }
    create(value?: PartialMessage<UpdaterV2Info>): UpdaterV2Info {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.updateGroup = "";
        message.updateUUID = new Uint8Array(0);
        message.updaterStatus = 0;
        if (value !== undefined)
            reflectionMergePartial<UpdaterV2Info>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdaterV2Info): UpdaterV2Info {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string UpdateGroup = 1 [json_name = "UpdateGroup"];*/ 1:
                    message.updateGroup = reader.string();
                    break;
                case /* bytes UpdateUUID = 2 [json_name = "UpdateUUID"];*/ 2:
                    message.updateUUID = reader.bytes();
                    break;
                case /* types.UpdaterStatus UpdaterStatus = 3 [json_name = "UpdaterStatus"];*/ 3:
                    message.updaterStatus = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdaterV2Info, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string UpdateGroup = 1 [json_name = "UpdateGroup"]; */
        if (message.updateGroup !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.updateGroup);
        /* bytes UpdateUUID = 2 [json_name = "UpdateUUID"]; */
        if (message.updateUUID.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.updateUUID);
        /* types.UpdaterStatus UpdaterStatus = 3 [json_name = "UpdaterStatus"]; */
        if (message.updaterStatus !== 0)
            writer.tag(3, WireType.Varint).int32(message.updaterStatus);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.UpdaterV2Info
 */
export const UpdaterV2Info = new UpdaterV2Info$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InstanceFilter$Type extends MessageType<InstanceFilter> {
    constructor() {
        super("types.InstanceFilter", [
            { no: 1, name: "ServerID", kind: "scalar", jsonName: "ServerID", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "Services", kind: "scalar", jsonName: "Services", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.casttype": "SystemRole" } },
            { no: 4, name: "ExternalUpgrader", kind: "scalar", jsonName: "ExternalUpgrader", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "NoExtUpgrader", kind: "scalar", jsonName: "NoExtUpgrader", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "OlderThanVersion", kind: "scalar", jsonName: "OlderThanVersion", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "NewerThanVersion", kind: "scalar", jsonName: "NewerThanVersion", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "UpdateGroup", kind: "scalar", jsonName: "UpdateGroup", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<InstanceFilter>): InstanceFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.serverID = "";
        message.version = "";
        message.services = [];
        message.externalUpgrader = "";
        message.noExtUpgrader = false;
        message.olderThanVersion = "";
        message.newerThanVersion = "";
        message.updateGroup = "";
        if (value !== undefined)
            reflectionMergePartial<InstanceFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InstanceFilter): InstanceFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ServerID = 1 [json_name = "ServerID"];*/ 1:
                    message.serverID = reader.string();
                    break;
                case /* string Version = 2 [json_name = "Version"];*/ 2:
                    message.version = reader.string();
                    break;
                case /* repeated string Services = 3 [json_name = "Services"];*/ 3:
                    message.services.push(reader.string());
                    break;
                case /* string ExternalUpgrader = 4 [json_name = "ExternalUpgrader"];*/ 4:
                    message.externalUpgrader = reader.string();
                    break;
                case /* bool NoExtUpgrader = 5 [json_name = "NoExtUpgrader"];*/ 5:
                    message.noExtUpgrader = reader.bool();
                    break;
                case /* string OlderThanVersion = 6 [json_name = "OlderThanVersion"];*/ 6:
                    message.olderThanVersion = reader.string();
                    break;
                case /* string NewerThanVersion = 7 [json_name = "NewerThanVersion"];*/ 7:
                    message.newerThanVersion = reader.string();
                    break;
                case /* string UpdateGroup = 8 [json_name = "UpdateGroup"];*/ 8:
                    message.updateGroup = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InstanceFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ServerID = 1 [json_name = "ServerID"]; */
        if (message.serverID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.serverID);
        /* string Version = 2 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.version);
        /* repeated string Services = 3 [json_name = "Services"]; */
        for (let i = 0; i < message.services.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.services[i]);
        /* string ExternalUpgrader = 4 [json_name = "ExternalUpgrader"]; */
        if (message.externalUpgrader !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.externalUpgrader);
        /* bool NoExtUpgrader = 5 [json_name = "NoExtUpgrader"]; */
        if (message.noExtUpgrader !== false)
            writer.tag(5, WireType.Varint).bool(message.noExtUpgrader);
        /* string OlderThanVersion = 6 [json_name = "OlderThanVersion"]; */
        if (message.olderThanVersion !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.olderThanVersion);
        /* string NewerThanVersion = 7 [json_name = "NewerThanVersion"]; */
        if (message.newerThanVersion !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.newerThanVersion);
        /* string UpdateGroup = 8 [json_name = "UpdateGroup"]; */
        if (message.updateGroup !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.updateGroup);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.InstanceFilter
 */
export const InstanceFilter = new InstanceFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServerV2$Type extends MessageType<ServerV2> {
    constructor() {
        super("types.ServerV2", [
            { no: 1, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 2, name: "SubKind", kind: "scalar", jsonName: "SubKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub_kind,omitempty" } },
            { no: 3, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version" } },
            { no: 4, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "metadata" } },
            { no: 5, name: "Spec", kind: "message", jsonName: "Spec", T: () => ServerSpecV2, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ], { "gogoproto.goproto_stringer": false, "gogoproto.stringer": false });
    }
    create(value?: PartialMessage<ServerV2>): ServerV2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.subKind = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<ServerV2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServerV2): ServerV2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Kind = 1 [json_name = "Kind"];*/ 1:
                    message.kind = reader.string();
                    break;
                case /* string SubKind = 2 [json_name = "SubKind"];*/ 2:
                    message.subKind = reader.string();
                    break;
                case /* string Version = 3 [json_name = "Version"];*/ 3:
                    message.version = reader.string();
                    break;
                case /* types.Metadata Metadata = 4 [json_name = "Metadata"];*/ 4:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* types.ServerSpecV2 Spec = 5 [json_name = "Spec"];*/ 5:
                    message.spec = ServerSpecV2.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServerV2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Kind = 1 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string SubKind = 2 [json_name = "SubKind"]; */
        if (message.subKind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subKind);
        /* string Version = 3 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* types.Metadata Metadata = 4 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.ServerSpecV2 Spec = 5 [json_name = "Spec"]; */
        if (message.spec)
            ServerSpecV2.internalBinaryWrite(message.spec, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ServerV2
 */
export const ServerV2 = new ServerV2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServerSpecV2$Type extends MessageType<ServerSpecV2> {
    constructor() {
        super("types.ServerSpecV2", [
            { no: 1, name: "Addr", kind: "scalar", jsonName: "Addr", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "addr" } },
            { no: 3, name: "Hostname", kind: "scalar", jsonName: "Hostname", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "hostname" } },
            { no: 4, name: "CmdLabels", kind: "map", jsonName: "CmdLabels", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => CommandLabelV2 }, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "cmd_labels,omitempty" } },
            { no: 5, name: "Rotation", kind: "message", jsonName: "Rotation", T: () => Rotation, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "rotation,omitempty" } },
            { no: 6, name: "UseTunnel", kind: "scalar", jsonName: "UseTunnel", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "use_tunnel,omitempty" } },
            { no: 7, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version" } },
            { no: 11, name: "PeerAddr", kind: "scalar", jsonName: "PeerAddr", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "peer_addr,omitempty" } },
            { no: 12, name: "ProxyIDs", kind: "scalar", jsonName: "ProxyIDs", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "proxy_ids,omitempty" } },
            { no: 13, name: "public_addrs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "CloudMetadata", kind: "message", jsonName: "CloudMetadata", T: () => CloudMetadata, options: { "gogoproto.jsontag": "cloud_metadata,omitempty" } },
            { no: 15, name: "git_hub", kind: "message", T: () => GitHubServerMetadata, options: { "gogoproto.jsontag": "github,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ServerSpecV2>): ServerSpecV2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.addr = "";
        message.hostname = "";
        message.cmdLabels = {};
        message.useTunnel = false;
        message.version = "";
        message.peerAddr = "";
        message.proxyIDs = [];
        message.publicAddrs = [];
        if (value !== undefined)
            reflectionMergePartial<ServerSpecV2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServerSpecV2): ServerSpecV2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Addr = 1 [json_name = "Addr"];*/ 1:
                    message.addr = reader.string();
                    break;
                case /* string Hostname = 3 [json_name = "Hostname"];*/ 3:
                    message.hostname = reader.string();
                    break;
                case /* map<string, types.CommandLabelV2> CmdLabels = 4 [json_name = "CmdLabels"];*/ 4:
                    this.binaryReadMap4(message.cmdLabels, reader, options);
                    break;
                case /* types.Rotation Rotation = 5 [json_name = "Rotation"];*/ 5:
                    message.rotation = Rotation.internalBinaryRead(reader, reader.uint32(), options, message.rotation);
                    break;
                case /* bool UseTunnel = 6 [json_name = "UseTunnel"];*/ 6:
                    message.useTunnel = reader.bool();
                    break;
                case /* string Version = 7 [json_name = "Version"];*/ 7:
                    message.version = reader.string();
                    break;
                case /* string PeerAddr = 11 [json_name = "PeerAddr"];*/ 11:
                    message.peerAddr = reader.string();
                    break;
                case /* repeated string ProxyIDs = 12 [json_name = "ProxyIDs"];*/ 12:
                    message.proxyIDs.push(reader.string());
                    break;
                case /* repeated string public_addrs */ 13:
                    message.publicAddrs.push(reader.string());
                    break;
                case /* types.CloudMetadata CloudMetadata = 14 [json_name = "CloudMetadata"];*/ 14:
                    message.cloudMetadata = CloudMetadata.internalBinaryRead(reader, reader.uint32(), options, message.cloudMetadata);
                    break;
                case /* types.GitHubServerMetadata git_hub */ 15:
                    message.gitHub = GitHubServerMetadata.internalBinaryRead(reader, reader.uint32(), options, message.gitHub);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap4(map: ServerSpecV2["cmdLabels"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ServerSpecV2["cmdLabels"] | undefined, val: ServerSpecV2["cmdLabels"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = CommandLabelV2.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field types.ServerSpecV2.CmdLabels");
            }
        }
        map[key ?? ""] = val ?? CommandLabelV2.create();
    }
    internalBinaryWrite(message: ServerSpecV2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Addr = 1 [json_name = "Addr"]; */
        if (message.addr !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.addr);
        /* string Hostname = 3 [json_name = "Hostname"]; */
        if (message.hostname !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.hostname);
        /* map<string, types.CommandLabelV2> CmdLabels = 4 [json_name = "CmdLabels"]; */
        for (let k of globalThis.Object.keys(message.cmdLabels)) {
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            CommandLabelV2.internalBinaryWrite(message.cmdLabels[k], writer, options);
            writer.join().join();
        }
        /* types.Rotation Rotation = 5 [json_name = "Rotation"]; */
        if (message.rotation)
            Rotation.internalBinaryWrite(message.rotation, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* bool UseTunnel = 6 [json_name = "UseTunnel"]; */
        if (message.useTunnel !== false)
            writer.tag(6, WireType.Varint).bool(message.useTunnel);
        /* string Version = 7 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.version);
        /* string PeerAddr = 11 [json_name = "PeerAddr"]; */
        if (message.peerAddr !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.peerAddr);
        /* repeated string ProxyIDs = 12 [json_name = "ProxyIDs"]; */
        for (let i = 0; i < message.proxyIDs.length; i++)
            writer.tag(12, WireType.LengthDelimited).string(message.proxyIDs[i]);
        /* repeated string public_addrs = 13; */
        for (let i = 0; i < message.publicAddrs.length; i++)
            writer.tag(13, WireType.LengthDelimited).string(message.publicAddrs[i]);
        /* types.CloudMetadata CloudMetadata = 14 [json_name = "CloudMetadata"]; */
        if (message.cloudMetadata)
            CloudMetadata.internalBinaryWrite(message.cloudMetadata, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* types.GitHubServerMetadata git_hub = 15; */
        if (message.gitHub)
            GitHubServerMetadata.internalBinaryWrite(message.gitHub, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ServerSpecV2
 */
export const ServerSpecV2 = new ServerSpecV2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AWSInfo$Type extends MessageType<AWSInfo> {
    constructor() {
        super("types.AWSInfo", [
            { no: 1, name: "AccountID", kind: "scalar", jsonName: "AccountID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "account_id" } },
            { no: 2, name: "InstanceID", kind: "scalar", jsonName: "InstanceID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "instance_id" } },
            { no: 3, name: "Region", kind: "scalar", jsonName: "Region", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "region,omitempty" } },
            { no: 4, name: "VPCID", kind: "scalar", jsonName: "VPCID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "vpc_id,omitempty" } },
            { no: 5, name: "Integration", kind: "scalar", jsonName: "Integration", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "integration,omitempty" } },
            { no: 6, name: "SubnetID", kind: "scalar", jsonName: "SubnetID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "subnet_id,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<AWSInfo>): AWSInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accountID = "";
        message.instanceID = "";
        message.region = "";
        message.vPCID = "";
        message.integration = "";
        message.subnetID = "";
        if (value !== undefined)
            reflectionMergePartial<AWSInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AWSInfo): AWSInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string AccountID = 1 [json_name = "AccountID"];*/ 1:
                    message.accountID = reader.string();
                    break;
                case /* string InstanceID = 2 [json_name = "InstanceID"];*/ 2:
                    message.instanceID = reader.string();
                    break;
                case /* string Region = 3 [json_name = "Region"];*/ 3:
                    message.region = reader.string();
                    break;
                case /* string VPCID = 4 [json_name = "VPCID"];*/ 4:
                    message.vPCID = reader.string();
                    break;
                case /* string Integration = 5 [json_name = "Integration"];*/ 5:
                    message.integration = reader.string();
                    break;
                case /* string SubnetID = 6 [json_name = "SubnetID"];*/ 6:
                    message.subnetID = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AWSInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string AccountID = 1 [json_name = "AccountID"]; */
        if (message.accountID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountID);
        /* string InstanceID = 2 [json_name = "InstanceID"]; */
        if (message.instanceID !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.instanceID);
        /* string Region = 3 [json_name = "Region"]; */
        if (message.region !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.region);
        /* string VPCID = 4 [json_name = "VPCID"]; */
        if (message.vPCID !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.vPCID);
        /* string Integration = 5 [json_name = "Integration"]; */
        if (message.integration !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.integration);
        /* string SubnetID = 6 [json_name = "SubnetID"]; */
        if (message.subnetID !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.subnetID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AWSInfo
 */
export const AWSInfo = new AWSInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CloudMetadata$Type extends MessageType<CloudMetadata> {
    constructor() {
        super("types.CloudMetadata", [
            { no: 1, name: "AWS", kind: "message", jsonName: "AWS", T: () => AWSInfo, options: { "gogoproto.jsontag": "aws,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<CloudMetadata>): CloudMetadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CloudMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CloudMetadata): CloudMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.AWSInfo AWS = 1 [json_name = "AWS"];*/ 1:
                    message.aWS = AWSInfo.internalBinaryRead(reader, reader.uint32(), options, message.aWS);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CloudMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.AWSInfo AWS = 1 [json_name = "AWS"]; */
        if (message.aWS)
            AWSInfo.internalBinaryWrite(message.aWS, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.CloudMetadata
 */
export const CloudMetadata = new CloudMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GitHubServerMetadata$Type extends MessageType<GitHubServerMetadata> {
    constructor() {
        super("types.GitHubServerMetadata", [
            { no: 1, name: "organization", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "organization,omitempty" } },
            { no: 2, name: "integration", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "integration,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<GitHubServerMetadata>): GitHubServerMetadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.organization = "";
        message.integration = "";
        if (value !== undefined)
            reflectionMergePartial<GitHubServerMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GitHubServerMetadata): GitHubServerMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string organization */ 1:
                    message.organization = reader.string();
                    break;
                case /* string integration */ 2:
                    message.integration = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GitHubServerMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string organization = 1; */
        if (message.organization !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.organization);
        /* string integration = 2; */
        if (message.integration !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.integration);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.GitHubServerMetadata
 */
export const GitHubServerMetadata = new GitHubServerMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppServerV3$Type extends MessageType<AppServerV3> {
    constructor() {
        super("types.AppServerV3", [
            { no: 1, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 2, name: "SubKind", kind: "scalar", jsonName: "SubKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub_kind,omitempty" } },
            { no: 3, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version" } },
            { no: 4, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "metadata" } },
            { no: 5, name: "Spec", kind: "message", jsonName: "Spec", T: () => AppServerSpecV3, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ], { "gogoproto.goproto_stringer": false, "gogoproto.stringer": false });
    }
    create(value?: PartialMessage<AppServerV3>): AppServerV3 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.subKind = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<AppServerV3>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppServerV3): AppServerV3 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Kind = 1 [json_name = "Kind"];*/ 1:
                    message.kind = reader.string();
                    break;
                case /* string SubKind = 2 [json_name = "SubKind"];*/ 2:
                    message.subKind = reader.string();
                    break;
                case /* string Version = 3 [json_name = "Version"];*/ 3:
                    message.version = reader.string();
                    break;
                case /* types.Metadata Metadata = 4 [json_name = "Metadata"];*/ 4:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* types.AppServerSpecV3 Spec = 5 [json_name = "Spec"];*/ 5:
                    message.spec = AppServerSpecV3.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppServerV3, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Kind = 1 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string SubKind = 2 [json_name = "SubKind"]; */
        if (message.subKind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subKind);
        /* string Version = 3 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* types.Metadata Metadata = 4 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.AppServerSpecV3 Spec = 5 [json_name = "Spec"]; */
        if (message.spec)
            AppServerSpecV3.internalBinaryWrite(message.spec, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AppServerV3
 */
export const AppServerV3 = new AppServerV3$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppServerSpecV3$Type extends MessageType<AppServerSpecV3> {
    constructor() {
        super("types.AppServerSpecV3", [
            { no: 1, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version" } },
            { no: 2, name: "Hostname", kind: "scalar", jsonName: "Hostname", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "hostname" } },
            { no: 3, name: "HostID", kind: "scalar", jsonName: "HostID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "host_id" } },
            { no: 4, name: "Rotation", kind: "message", jsonName: "Rotation", T: () => Rotation, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "rotation,omitempty" } },
            { no: 5, name: "App", kind: "message", jsonName: "App", T: () => AppV3, options: { "gogoproto.jsontag": "app" } },
            { no: 6, name: "ProxyIDs", kind: "scalar", jsonName: "ProxyIDs", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "proxy_ids,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<AppServerSpecV3>): AppServerSpecV3 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.version = "";
        message.hostname = "";
        message.hostID = "";
        message.proxyIDs = [];
        if (value !== undefined)
            reflectionMergePartial<AppServerSpecV3>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppServerSpecV3): AppServerSpecV3 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Version = 1 [json_name = "Version"];*/ 1:
                    message.version = reader.string();
                    break;
                case /* string Hostname = 2 [json_name = "Hostname"];*/ 2:
                    message.hostname = reader.string();
                    break;
                case /* string HostID = 3 [json_name = "HostID"];*/ 3:
                    message.hostID = reader.string();
                    break;
                case /* types.Rotation Rotation = 4 [json_name = "Rotation"];*/ 4:
                    message.rotation = Rotation.internalBinaryRead(reader, reader.uint32(), options, message.rotation);
                    break;
                case /* types.AppV3 App = 5 [json_name = "App"];*/ 5:
                    message.app = AppV3.internalBinaryRead(reader, reader.uint32(), options, message.app);
                    break;
                case /* repeated string ProxyIDs = 6 [json_name = "ProxyIDs"];*/ 6:
                    message.proxyIDs.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppServerSpecV3, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Version = 1 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.version);
        /* string Hostname = 2 [json_name = "Hostname"]; */
        if (message.hostname !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.hostname);
        /* string HostID = 3 [json_name = "HostID"]; */
        if (message.hostID !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.hostID);
        /* types.Rotation Rotation = 4 [json_name = "Rotation"]; */
        if (message.rotation)
            Rotation.internalBinaryWrite(message.rotation, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.AppV3 App = 5 [json_name = "App"]; */
        if (message.app)
            AppV3.internalBinaryWrite(message.app, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated string ProxyIDs = 6 [json_name = "ProxyIDs"]; */
        for (let i = 0; i < message.proxyIDs.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.proxyIDs[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AppServerSpecV3
 */
export const AppServerSpecV3 = new AppServerSpecV3$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppV3List$Type extends MessageType<AppV3List> {
    constructor() {
        super("types.AppV3List", [
            { no: 1, name: "Apps", kind: "message", jsonName: "Apps", repeat: 1 /*RepeatType.PACKED*/, T: () => AppV3 }
        ]);
    }
    create(value?: PartialMessage<AppV3List>): AppV3List {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.apps = [];
        if (value !== undefined)
            reflectionMergePartial<AppV3List>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppV3List): AppV3List {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.AppV3 Apps = 1 [json_name = "Apps"];*/ 1:
                    message.apps.push(AppV3.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppV3List, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.AppV3 Apps = 1 [json_name = "Apps"]; */
        for (let i = 0; i < message.apps.length; i++)
            AppV3.internalBinaryWrite(message.apps[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AppV3List
 */
export const AppV3List = new AppV3List$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppV3$Type extends MessageType<AppV3> {
    constructor() {
        super("types.AppV3", [
            { no: 1, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 2, name: "SubKind", kind: "scalar", jsonName: "SubKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub_kind,omitempty" } },
            { no: 3, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version" } },
            { no: 4, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "metadata" } },
            { no: 5, name: "Spec", kind: "message", jsonName: "Spec", T: () => AppSpecV3, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ], { "gogoproto.goproto_stringer": false, "gogoproto.stringer": false });
    }
    create(value?: PartialMessage<AppV3>): AppV3 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.subKind = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<AppV3>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppV3): AppV3 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Kind = 1 [json_name = "Kind"];*/ 1:
                    message.kind = reader.string();
                    break;
                case /* string SubKind = 2 [json_name = "SubKind"];*/ 2:
                    message.subKind = reader.string();
                    break;
                case /* string Version = 3 [json_name = "Version"];*/ 3:
                    message.version = reader.string();
                    break;
                case /* types.Metadata Metadata = 4 [json_name = "Metadata"];*/ 4:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* types.AppSpecV3 Spec = 5 [json_name = "Spec"];*/ 5:
                    message.spec = AppSpecV3.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppV3, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Kind = 1 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string SubKind = 2 [json_name = "SubKind"]; */
        if (message.subKind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subKind);
        /* string Version = 3 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* types.Metadata Metadata = 4 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.AppSpecV3 Spec = 5 [json_name = "Spec"]; */
        if (message.spec)
            AppSpecV3.internalBinaryWrite(message.spec, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AppV3
 */
export const AppV3 = new AppV3$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CORSPolicy$Type extends MessageType<CORSPolicy> {
    constructor() {
        super("types.CORSPolicy", [
            { no: 1, name: "allowed_origins", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "allowed_origins,omitempty" } },
            { no: 2, name: "allowed_methods", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "allowed_methods,omitempty" } },
            { no: 3, name: "allowed_headers", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "allowed_headers,omitempty" } },
            { no: 4, name: "allow_credentials", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "allow_credentials,omitempty" } },
            { no: 5, name: "max_age", kind: "scalar", T: 13 /*ScalarType.UINT32*/, options: { "gogoproto.jsontag": "max_age,omitempty" } },
            { no: 6, name: "exposed_headers", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "exposed_headers,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<CORSPolicy>): CORSPolicy {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.allowedOrigins = [];
        message.allowedMethods = [];
        message.allowedHeaders = [];
        message.allowCredentials = false;
        message.maxAge = 0;
        message.exposedHeaders = [];
        if (value !== undefined)
            reflectionMergePartial<CORSPolicy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CORSPolicy): CORSPolicy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string allowed_origins */ 1:
                    message.allowedOrigins.push(reader.string());
                    break;
                case /* repeated string allowed_methods */ 2:
                    message.allowedMethods.push(reader.string());
                    break;
                case /* repeated string allowed_headers */ 3:
                    message.allowedHeaders.push(reader.string());
                    break;
                case /* bool allow_credentials */ 4:
                    message.allowCredentials = reader.bool();
                    break;
                case /* uint32 max_age */ 5:
                    message.maxAge = reader.uint32();
                    break;
                case /* repeated string exposed_headers */ 6:
                    message.exposedHeaders.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CORSPolicy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string allowed_origins = 1; */
        for (let i = 0; i < message.allowedOrigins.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.allowedOrigins[i]);
        /* repeated string allowed_methods = 2; */
        for (let i = 0; i < message.allowedMethods.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.allowedMethods[i]);
        /* repeated string allowed_headers = 3; */
        for (let i = 0; i < message.allowedHeaders.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.allowedHeaders[i]);
        /* bool allow_credentials = 4; */
        if (message.allowCredentials !== false)
            writer.tag(4, WireType.Varint).bool(message.allowCredentials);
        /* uint32 max_age = 5; */
        if (message.maxAge !== 0)
            writer.tag(5, WireType.Varint).uint32(message.maxAge);
        /* repeated string exposed_headers = 6; */
        for (let i = 0; i < message.exposedHeaders.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.exposedHeaders[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.CORSPolicy
 */
export const CORSPolicy = new CORSPolicy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IdentityCenterPermissionSet$Type extends MessageType<IdentityCenterPermissionSet> {
    constructor() {
        super("types.IdentityCenterPermissionSet", [
            { no: 1, name: "ARN", kind: "scalar", jsonName: "ARN", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "arn,omitempty" } },
            { no: 2, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "name,omitempty" } },
            { no: 3, name: "AssignmentID", kind: "scalar", jsonName: "AssignmentID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "assignment_name,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<IdentityCenterPermissionSet>): IdentityCenterPermissionSet {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.aRN = "";
        message.name = "";
        message.assignmentID = "";
        if (value !== undefined)
            reflectionMergePartial<IdentityCenterPermissionSet>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IdentityCenterPermissionSet): IdentityCenterPermissionSet {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ARN = 1 [json_name = "ARN"];*/ 1:
                    message.aRN = reader.string();
                    break;
                case /* string Name = 2 [json_name = "Name"];*/ 2:
                    message.name = reader.string();
                    break;
                case /* string AssignmentID = 3 [json_name = "AssignmentID"];*/ 3:
                    message.assignmentID = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IdentityCenterPermissionSet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ARN = 1 [json_name = "ARN"]; */
        if (message.aRN !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.aRN);
        /* string Name = 2 [json_name = "Name"]; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string AssignmentID = 3 [json_name = "AssignmentID"]; */
        if (message.assignmentID !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.assignmentID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.IdentityCenterPermissionSet
 */
export const IdentityCenterPermissionSet = new IdentityCenterPermissionSet$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppIdentityCenter$Type extends MessageType<AppIdentityCenter> {
    constructor() {
        super("types.AppIdentityCenter", [
            { no: 1, name: "AccountID", kind: "scalar", jsonName: "AccountID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "account_id,omitempty" } },
            { no: 2, name: "PermissionSets", kind: "message", jsonName: "PermissionSets", repeat: 1 /*RepeatType.PACKED*/, T: () => IdentityCenterPermissionSet, options: { "gogoproto.jsontag": "permission_sets,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<AppIdentityCenter>): AppIdentityCenter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accountID = "";
        message.permissionSets = [];
        if (value !== undefined)
            reflectionMergePartial<AppIdentityCenter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppIdentityCenter): AppIdentityCenter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string AccountID = 1 [json_name = "AccountID"];*/ 1:
                    message.accountID = reader.string();
                    break;
                case /* repeated types.IdentityCenterPermissionSet PermissionSets = 2 [json_name = "PermissionSets"];*/ 2:
                    message.permissionSets.push(IdentityCenterPermissionSet.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppIdentityCenter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string AccountID = 1 [json_name = "AccountID"]; */
        if (message.accountID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountID);
        /* repeated types.IdentityCenterPermissionSet PermissionSets = 2 [json_name = "PermissionSets"]; */
        for (let i = 0; i < message.permissionSets.length; i++)
            IdentityCenterPermissionSet.internalBinaryWrite(message.permissionSets[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AppIdentityCenter
 */
export const AppIdentityCenter = new AppIdentityCenter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppSpecV3$Type extends MessageType<AppSpecV3> {
    constructor() {
        super("types.AppSpecV3", [
            { no: 1, name: "URI", kind: "scalar", jsonName: "URI", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "uri" } },
            { no: 2, name: "PublicAddr", kind: "scalar", jsonName: "PublicAddr", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "public_addr,omitempty" } },
            { no: 3, name: "DynamicLabels", kind: "map", jsonName: "DynamicLabels", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => CommandLabelV2 }, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "dynamic_labels,omitempty" } },
            { no: 4, name: "InsecureSkipVerify", kind: "scalar", jsonName: "InsecureSkipVerify", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "insecure_skip_verify" } },
            { no: 5, name: "Rewrite", kind: "message", jsonName: "Rewrite", T: () => Rewrite, options: { "gogoproto.jsontag": "rewrite,omitempty" } },
            { no: 6, name: "AWS", kind: "message", jsonName: "AWS", T: () => AppAWS, options: { "gogoproto.jsontag": "aws,omitempty" } },
            { no: 7, name: "Cloud", kind: "scalar", jsonName: "Cloud", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "cloud,omitempty" } },
            { no: 8, name: "UserGroups", kind: "scalar", jsonName: "UserGroups", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "Integration", kind: "scalar", jsonName: "Integration", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "integration,omitempty" } },
            { no: 10, name: "RequiredAppNames", kind: "scalar", jsonName: "RequiredAppNames", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "required_app_names,omitempty" } },
            { no: 11, name: "CORS", kind: "message", jsonName: "CORS", T: () => CORSPolicy, options: { "gogoproto.jsontag": "cors,omitempty" } },
            { no: 12, name: "IdentityCenter", kind: "message", jsonName: "IdentityCenter", T: () => AppIdentityCenter, options: { "gogoproto.jsontag": "identity_center,omitempty" } },
            { no: 13, name: "TCPPorts", kind: "message", jsonName: "TCPPorts", repeat: 1 /*RepeatType.PACKED*/, T: () => PortRange, options: { "gogoproto.jsontag": "tcp_ports,omitempty" } },
            { no: 14, name: "UseAnyProxyPublicAddr", kind: "scalar", jsonName: "UseAnyProxyPublicAddr", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "use_any_proxy_public_addr,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<AppSpecV3>): AppSpecV3 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uRI = "";
        message.publicAddr = "";
        message.dynamicLabels = {};
        message.insecureSkipVerify = false;
        message.cloud = "";
        message.userGroups = [];
        message.integration = "";
        message.requiredAppNames = [];
        message.tCPPorts = [];
        message.useAnyProxyPublicAddr = false;
        if (value !== undefined)
            reflectionMergePartial<AppSpecV3>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppSpecV3): AppSpecV3 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string URI = 1 [json_name = "URI"];*/ 1:
                    message.uRI = reader.string();
                    break;
                case /* string PublicAddr = 2 [json_name = "PublicAddr"];*/ 2:
                    message.publicAddr = reader.string();
                    break;
                case /* map<string, types.CommandLabelV2> DynamicLabels = 3 [json_name = "DynamicLabels"];*/ 3:
                    this.binaryReadMap3(message.dynamicLabels, reader, options);
                    break;
                case /* bool InsecureSkipVerify = 4 [json_name = "InsecureSkipVerify"];*/ 4:
                    message.insecureSkipVerify = reader.bool();
                    break;
                case /* types.Rewrite Rewrite = 5 [json_name = "Rewrite"];*/ 5:
                    message.rewrite = Rewrite.internalBinaryRead(reader, reader.uint32(), options, message.rewrite);
                    break;
                case /* types.AppAWS AWS = 6 [json_name = "AWS"];*/ 6:
                    message.aWS = AppAWS.internalBinaryRead(reader, reader.uint32(), options, message.aWS);
                    break;
                case /* string Cloud = 7 [json_name = "Cloud"];*/ 7:
                    message.cloud = reader.string();
                    break;
                case /* repeated string UserGroups = 8 [json_name = "UserGroups"];*/ 8:
                    message.userGroups.push(reader.string());
                    break;
                case /* string Integration = 9 [json_name = "Integration"];*/ 9:
                    message.integration = reader.string();
                    break;
                case /* repeated string RequiredAppNames = 10 [json_name = "RequiredAppNames"];*/ 10:
                    message.requiredAppNames.push(reader.string());
                    break;
                case /* types.CORSPolicy CORS = 11 [json_name = "CORS"];*/ 11:
                    message.cORS = CORSPolicy.internalBinaryRead(reader, reader.uint32(), options, message.cORS);
                    break;
                case /* types.AppIdentityCenter IdentityCenter = 12 [json_name = "IdentityCenter"];*/ 12:
                    message.identityCenter = AppIdentityCenter.internalBinaryRead(reader, reader.uint32(), options, message.identityCenter);
                    break;
                case /* repeated types.PortRange TCPPorts = 13 [json_name = "TCPPorts"];*/ 13:
                    message.tCPPorts.push(PortRange.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool UseAnyProxyPublicAddr = 14 [json_name = "UseAnyProxyPublicAddr"];*/ 14:
                    message.useAnyProxyPublicAddr = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: AppSpecV3["dynamicLabels"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AppSpecV3["dynamicLabels"] | undefined, val: AppSpecV3["dynamicLabels"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = CommandLabelV2.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field types.AppSpecV3.DynamicLabels");
            }
        }
        map[key ?? ""] = val ?? CommandLabelV2.create();
    }
    internalBinaryWrite(message: AppSpecV3, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string URI = 1 [json_name = "URI"]; */
        if (message.uRI !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uRI);
        /* string PublicAddr = 2 [json_name = "PublicAddr"]; */
        if (message.publicAddr !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.publicAddr);
        /* map<string, types.CommandLabelV2> DynamicLabels = 3 [json_name = "DynamicLabels"]; */
        for (let k of globalThis.Object.keys(message.dynamicLabels)) {
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            CommandLabelV2.internalBinaryWrite(message.dynamicLabels[k], writer, options);
            writer.join().join();
        }
        /* bool InsecureSkipVerify = 4 [json_name = "InsecureSkipVerify"]; */
        if (message.insecureSkipVerify !== false)
            writer.tag(4, WireType.Varint).bool(message.insecureSkipVerify);
        /* types.Rewrite Rewrite = 5 [json_name = "Rewrite"]; */
        if (message.rewrite)
            Rewrite.internalBinaryWrite(message.rewrite, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* types.AppAWS AWS = 6 [json_name = "AWS"]; */
        if (message.aWS)
            AppAWS.internalBinaryWrite(message.aWS, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* string Cloud = 7 [json_name = "Cloud"]; */
        if (message.cloud !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.cloud);
        /* repeated string UserGroups = 8 [json_name = "UserGroups"]; */
        for (let i = 0; i < message.userGroups.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.userGroups[i]);
        /* string Integration = 9 [json_name = "Integration"]; */
        if (message.integration !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.integration);
        /* repeated string RequiredAppNames = 10 [json_name = "RequiredAppNames"]; */
        for (let i = 0; i < message.requiredAppNames.length; i++)
            writer.tag(10, WireType.LengthDelimited).string(message.requiredAppNames[i]);
        /* types.CORSPolicy CORS = 11 [json_name = "CORS"]; */
        if (message.cORS)
            CORSPolicy.internalBinaryWrite(message.cORS, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* types.AppIdentityCenter IdentityCenter = 12 [json_name = "IdentityCenter"]; */
        if (message.identityCenter)
            AppIdentityCenter.internalBinaryWrite(message.identityCenter, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* repeated types.PortRange TCPPorts = 13 [json_name = "TCPPorts"]; */
        for (let i = 0; i < message.tCPPorts.length; i++)
            PortRange.internalBinaryWrite(message.tCPPorts[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* bool UseAnyProxyPublicAddr = 14 [json_name = "UseAnyProxyPublicAddr"]; */
        if (message.useAnyProxyPublicAddr !== false)
            writer.tag(14, WireType.Varint).bool(message.useAnyProxyPublicAddr);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AppSpecV3
 */
export const AppSpecV3 = new AppSpecV3$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Rewrite$Type extends MessageType<Rewrite> {
    constructor() {
        super("types.Rewrite", [
            { no: 1, name: "Redirect", kind: "scalar", jsonName: "Redirect", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "redirect,omitempty" } },
            { no: 2, name: "Headers", kind: "message", jsonName: "Headers", repeat: 1 /*RepeatType.PACKED*/, T: () => Header, options: { "gogoproto.jsontag": "headers,omitempty" } },
            { no: 3, name: "JWTClaims", kind: "scalar", jsonName: "JWTClaims", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "jwt_claims,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<Rewrite>): Rewrite {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.redirect = [];
        message.headers = [];
        message.jWTClaims = "";
        if (value !== undefined)
            reflectionMergePartial<Rewrite>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Rewrite): Rewrite {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string Redirect = 1 [json_name = "Redirect"];*/ 1:
                    message.redirect.push(reader.string());
                    break;
                case /* repeated types.Header Headers = 2 [json_name = "Headers"];*/ 2:
                    message.headers.push(Header.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string JWTClaims = 3 [json_name = "JWTClaims"];*/ 3:
                    message.jWTClaims = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Rewrite, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string Redirect = 1 [json_name = "Redirect"]; */
        for (let i = 0; i < message.redirect.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.redirect[i]);
        /* repeated types.Header Headers = 2 [json_name = "Headers"]; */
        for (let i = 0; i < message.headers.length; i++)
            Header.internalBinaryWrite(message.headers[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string JWTClaims = 3 [json_name = "JWTClaims"]; */
        if (message.jWTClaims !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.jWTClaims);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.Rewrite
 */
export const Rewrite = new Rewrite$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Header$Type extends MessageType<Header> {
    constructor() {
        super("types.Header", [
            { no: 1, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "name" } },
            { no: 2, name: "Value", kind: "scalar", jsonName: "Value", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "value" } }
        ]);
    }
    create(value?: PartialMessage<Header>): Header {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.value = "";
        if (value !== undefined)
            reflectionMergePartial<Header>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Header): Header {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Name = 1 [json_name = "Name"];*/ 1:
                    message.name = reader.string();
                    break;
                case /* string Value = 2 [json_name = "Value"];*/ 2:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Header, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Name = 1 [json_name = "Name"]; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string Value = 2 [json_name = "Value"]; */
        if (message.value !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.Header
 */
export const Header = new Header$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PortRange$Type extends MessageType<PortRange> {
    constructor() {
        super("types.PortRange", [
            { no: 1, name: "Port", kind: "scalar", jsonName: "Port", T: 13 /*ScalarType.UINT32*/, options: { "gogoproto.jsontag": "port" } },
            { no: 2, name: "EndPort", kind: "scalar", jsonName: "EndPort", T: 13 /*ScalarType.UINT32*/, options: { "gogoproto.jsontag": "end_port,omitempty" } }
        ], { "gogoproto.goproto_stringer": false, "gogoproto.stringer": false });
    }
    create(value?: PartialMessage<PortRange>): PortRange {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.port = 0;
        message.endPort = 0;
        if (value !== undefined)
            reflectionMergePartial<PortRange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PortRange): PortRange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 Port = 1 [json_name = "Port"];*/ 1:
                    message.port = reader.uint32();
                    break;
                case /* uint32 EndPort = 2 [json_name = "EndPort"];*/ 2:
                    message.endPort = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PortRange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 Port = 1 [json_name = "Port"]; */
        if (message.port !== 0)
            writer.tag(1, WireType.Varint).uint32(message.port);
        /* uint32 EndPort = 2 [json_name = "EndPort"]; */
        if (message.endPort !== 0)
            writer.tag(2, WireType.Varint).uint32(message.endPort);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PortRange
 */
export const PortRange = new PortRange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandLabelV2$Type extends MessageType<CommandLabelV2> {
    constructor() {
        super("types.CommandLabelV2", [
            { no: 1, name: "Period", kind: "scalar", jsonName: "Period", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "period", "gogoproto.casttype": "Duration" } },
            { no: 2, name: "Command", kind: "scalar", jsonName: "Command", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "command" } },
            { no: 3, name: "Result", kind: "scalar", jsonName: "Result", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "result" } }
        ]);
    }
    create(value?: PartialMessage<CommandLabelV2>): CommandLabelV2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.period = 0n;
        message.command = [];
        message.result = "";
        if (value !== undefined)
            reflectionMergePartial<CommandLabelV2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CommandLabelV2): CommandLabelV2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 Period = 1 [json_name = "Period"];*/ 1:
                    message.period = reader.int64().toBigInt();
                    break;
                case /* repeated string Command = 2 [json_name = "Command"];*/ 2:
                    message.command.push(reader.string());
                    break;
                case /* string Result = 3 [json_name = "Result"];*/ 3:
                    message.result = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CommandLabelV2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 Period = 1 [json_name = "Period"]; */
        if (message.period !== 0n)
            writer.tag(1, WireType.Varint).int64(message.period);
        /* repeated string Command = 2 [json_name = "Command"]; */
        for (let i = 0; i < message.command.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.command[i]);
        /* string Result = 3 [json_name = "Result"]; */
        if (message.result !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.result);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.CommandLabelV2
 */
export const CommandLabelV2 = new CommandLabelV2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppAWS$Type extends MessageType<AppAWS> {
    constructor() {
        super("types.AppAWS", [
            { no: 1, name: "ExternalID", kind: "scalar", jsonName: "ExternalID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "external_id,omitempty" } },
            { no: 2, name: "RolesAnywhereProfile", kind: "message", jsonName: "RolesAnywhereProfile", T: () => AppAWSRolesAnywhereProfile, options: { "gogoproto.jsontag": "roles_anywhere_profile,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<AppAWS>): AppAWS {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.externalID = "";
        if (value !== undefined)
            reflectionMergePartial<AppAWS>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppAWS): AppAWS {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ExternalID = 1 [json_name = "ExternalID"];*/ 1:
                    message.externalID = reader.string();
                    break;
                case /* types.AppAWSRolesAnywhereProfile RolesAnywhereProfile = 2 [json_name = "RolesAnywhereProfile"];*/ 2:
                    message.rolesAnywhereProfile = AppAWSRolesAnywhereProfile.internalBinaryRead(reader, reader.uint32(), options, message.rolesAnywhereProfile);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppAWS, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ExternalID = 1 [json_name = "ExternalID"]; */
        if (message.externalID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.externalID);
        /* types.AppAWSRolesAnywhereProfile RolesAnywhereProfile = 2 [json_name = "RolesAnywhereProfile"]; */
        if (message.rolesAnywhereProfile)
            AppAWSRolesAnywhereProfile.internalBinaryWrite(message.rolesAnywhereProfile, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AppAWS
 */
export const AppAWS = new AppAWS$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppAWSRolesAnywhereProfile$Type extends MessageType<AppAWSRolesAnywhereProfile> {
    constructor() {
        super("types.AppAWSRolesAnywhereProfile", [
            { no: 1, name: "ProfileARN", kind: "scalar", jsonName: "ProfileARN", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "profile_arn,omitempty" } },
            { no: 2, name: "AcceptRoleSessionName", kind: "scalar", jsonName: "AcceptRoleSessionName", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "accept_role_session_name" } }
        ]);
    }
    create(value?: PartialMessage<AppAWSRolesAnywhereProfile>): AppAWSRolesAnywhereProfile {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.profileARN = "";
        message.acceptRoleSessionName = false;
        if (value !== undefined)
            reflectionMergePartial<AppAWSRolesAnywhereProfile>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppAWSRolesAnywhereProfile): AppAWSRolesAnywhereProfile {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ProfileARN = 1 [json_name = "ProfileARN"];*/ 1:
                    message.profileARN = reader.string();
                    break;
                case /* bool AcceptRoleSessionName = 2 [json_name = "AcceptRoleSessionName"];*/ 2:
                    message.acceptRoleSessionName = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppAWSRolesAnywhereProfile, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ProfileARN = 1 [json_name = "ProfileARN"]; */
        if (message.profileARN !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.profileARN);
        /* bool AcceptRoleSessionName = 2 [json_name = "AcceptRoleSessionName"]; */
        if (message.acceptRoleSessionName !== false)
            writer.tag(2, WireType.Varint).bool(message.acceptRoleSessionName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AppAWSRolesAnywhereProfile
 */
export const AppAWSRolesAnywhereProfile = new AppAWSRolesAnywhereProfile$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SSHKeyPair$Type extends MessageType<SSHKeyPair> {
    constructor() {
        super("types.SSHKeyPair", [
            { no: 1, name: "PublicKey", kind: "scalar", jsonName: "PublicKey", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.jsontag": "public_key,omitempty" } },
            { no: 2, name: "PrivateKey", kind: "scalar", jsonName: "PrivateKey", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.jsontag": "private_key,omitempty" } },
            { no: 3, name: "PrivateKeyType", kind: "enum", jsonName: "PrivateKeyType", T: () => ["types.PrivateKeyType", PrivateKeyType], options: { "gogoproto.jsontag": "private_key_type,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<SSHKeyPair>): SSHKeyPair {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.publicKey = new Uint8Array(0);
        message.privateKey = new Uint8Array(0);
        message.privateKeyType = 0;
        if (value !== undefined)
            reflectionMergePartial<SSHKeyPair>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SSHKeyPair): SSHKeyPair {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes PublicKey = 1 [json_name = "PublicKey"];*/ 1:
                    message.publicKey = reader.bytes();
                    break;
                case /* bytes PrivateKey = 2 [json_name = "PrivateKey"];*/ 2:
                    message.privateKey = reader.bytes();
                    break;
                case /* types.PrivateKeyType PrivateKeyType = 3 [json_name = "PrivateKeyType"];*/ 3:
                    message.privateKeyType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SSHKeyPair, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes PublicKey = 1 [json_name = "PublicKey"]; */
        if (message.publicKey.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.publicKey);
        /* bytes PrivateKey = 2 [json_name = "PrivateKey"]; */
        if (message.privateKey.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.privateKey);
        /* types.PrivateKeyType PrivateKeyType = 3 [json_name = "PrivateKeyType"]; */
        if (message.privateKeyType !== 0)
            writer.tag(3, WireType.Varint).int32(message.privateKeyType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.SSHKeyPair
 */
export const SSHKeyPair = new SSHKeyPair$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TLSKeyPair$Type extends MessageType<TLSKeyPair> {
    constructor() {
        super("types.TLSKeyPair", [
            { no: 1, name: "Cert", kind: "scalar", jsonName: "Cert", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.jsontag": "cert,omitempty" } },
            { no: 2, name: "Key", kind: "scalar", jsonName: "Key", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.jsontag": "key,omitempty" } },
            { no: 3, name: "KeyType", kind: "enum", jsonName: "KeyType", T: () => ["types.PrivateKeyType", PrivateKeyType], options: { "gogoproto.jsontag": "key_type,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<TLSKeyPair>): TLSKeyPair {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cert = new Uint8Array(0);
        message.key = new Uint8Array(0);
        message.keyType = 0;
        if (value !== undefined)
            reflectionMergePartial<TLSKeyPair>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TLSKeyPair): TLSKeyPair {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes Cert = 1 [json_name = "Cert"];*/ 1:
                    message.cert = reader.bytes();
                    break;
                case /* bytes Key = 2 [json_name = "Key"];*/ 2:
                    message.key = reader.bytes();
                    break;
                case /* types.PrivateKeyType KeyType = 3 [json_name = "KeyType"];*/ 3:
                    message.keyType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TLSKeyPair, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes Cert = 1 [json_name = "Cert"]; */
        if (message.cert.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.cert);
        /* bytes Key = 2 [json_name = "Key"]; */
        if (message.key.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.key);
        /* types.PrivateKeyType KeyType = 3 [json_name = "KeyType"]; */
        if (message.keyType !== 0)
            writer.tag(3, WireType.Varint).int32(message.keyType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.TLSKeyPair
 */
export const TLSKeyPair = new TLSKeyPair$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JWTKeyPair$Type extends MessageType<JWTKeyPair> {
    constructor() {
        super("types.JWTKeyPair", [
            { no: 1, name: "PublicKey", kind: "scalar", jsonName: "PublicKey", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.jsontag": "public_key,omitempty" } },
            { no: 2, name: "PrivateKey", kind: "scalar", jsonName: "PrivateKey", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.jsontag": "private_key,omitempty" } },
            { no: 3, name: "PrivateKeyType", kind: "enum", jsonName: "PrivateKeyType", T: () => ["types.PrivateKeyType", PrivateKeyType], options: { "gogoproto.jsontag": "private_key_type,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<JWTKeyPair>): JWTKeyPair {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.publicKey = new Uint8Array(0);
        message.privateKey = new Uint8Array(0);
        message.privateKeyType = 0;
        if (value !== undefined)
            reflectionMergePartial<JWTKeyPair>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JWTKeyPair): JWTKeyPair {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes PublicKey = 1 [json_name = "PublicKey"];*/ 1:
                    message.publicKey = reader.bytes();
                    break;
                case /* bytes PrivateKey = 2 [json_name = "PrivateKey"];*/ 2:
                    message.privateKey = reader.bytes();
                    break;
                case /* types.PrivateKeyType PrivateKeyType = 3 [json_name = "PrivateKeyType"];*/ 3:
                    message.privateKeyType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JWTKeyPair, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes PublicKey = 1 [json_name = "PublicKey"]; */
        if (message.publicKey.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.publicKey);
        /* bytes PrivateKey = 2 [json_name = "PrivateKey"]; */
        if (message.privateKey.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.privateKey);
        /* types.PrivateKeyType PrivateKeyType = 3 [json_name = "PrivateKeyType"]; */
        if (message.privateKeyType !== 0)
            writer.tag(3, WireType.Varint).int32(message.privateKeyType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.JWTKeyPair
 */
export const JWTKeyPair = new JWTKeyPair$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CertAuthorityV2$Type extends MessageType<CertAuthorityV2> {
    constructor() {
        super("types.CertAuthorityV2", [
            { no: 1, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 2, name: "SubKind", kind: "scalar", jsonName: "SubKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub_kind,omitempty" } },
            { no: 3, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version" } },
            { no: 4, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "metadata" } },
            { no: 5, name: "Spec", kind: "message", jsonName: "Spec", T: () => CertAuthoritySpecV2, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ], { "gogoproto.goproto_stringer": false, "gogoproto.stringer": false });
    }
    create(value?: PartialMessage<CertAuthorityV2>): CertAuthorityV2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.subKind = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<CertAuthorityV2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CertAuthorityV2): CertAuthorityV2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Kind = 1 [json_name = "Kind"];*/ 1:
                    message.kind = reader.string();
                    break;
                case /* string SubKind = 2 [json_name = "SubKind"];*/ 2:
                    message.subKind = reader.string();
                    break;
                case /* string Version = 3 [json_name = "Version"];*/ 3:
                    message.version = reader.string();
                    break;
                case /* types.Metadata Metadata = 4 [json_name = "Metadata"];*/ 4:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* types.CertAuthoritySpecV2 Spec = 5 [json_name = "Spec"];*/ 5:
                    message.spec = CertAuthoritySpecV2.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CertAuthorityV2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Kind = 1 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string SubKind = 2 [json_name = "SubKind"]; */
        if (message.subKind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subKind);
        /* string Version = 3 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* types.Metadata Metadata = 4 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.CertAuthoritySpecV2 Spec = 5 [json_name = "Spec"]; */
        if (message.spec)
            CertAuthoritySpecV2.internalBinaryWrite(message.spec, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.CertAuthorityV2
 */
export const CertAuthorityV2 = new CertAuthorityV2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CertAuthoritySpecV2$Type extends MessageType<CertAuthoritySpecV2> {
    constructor() {
        super("types.CertAuthoritySpecV2", [
            { no: 1, name: "Type", kind: "scalar", jsonName: "Type", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "type", "gogoproto.casttype": "CertAuthType" } },
            { no: 2, name: "ClusterName", kind: "scalar", jsonName: "ClusterName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "cluster_name" } },
            { no: 5, name: "Roles", kind: "scalar", jsonName: "Roles", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "roles,omitempty" } },
            { no: 6, name: "RoleMap", kind: "message", jsonName: "RoleMap", repeat: 1 /*RepeatType.PACKED*/, T: () => RoleMapping, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "role_map,omitempty" } },
            { no: 8, name: "Rotation", kind: "message", jsonName: "Rotation", T: () => Rotation, options: { "gogoproto.nullable": true, "gogoproto.jsontag": "rotation,omitempty" } },
            { no: 9, name: "SigningAlg", kind: "enum", jsonName: "SigningAlg", T: () => ["types.CertAuthoritySpecV2.SigningAlgType", CertAuthoritySpecV2_SigningAlgType], options: { "gogoproto.jsontag": "signing_alg,omitempty" } },
            { no: 11, name: "ActiveKeys", kind: "message", jsonName: "ActiveKeys", T: () => CAKeySet, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "active_keys,omitempty" } },
            { no: 12, name: "AdditionalTrustedKeys", kind: "message", jsonName: "AdditionalTrustedKeys", T: () => CAKeySet, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "additional_trusted_keys,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<CertAuthoritySpecV2>): CertAuthoritySpecV2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        message.clusterName = "";
        message.roles = [];
        message.roleMap = [];
        message.signingAlg = 0;
        if (value !== undefined)
            reflectionMergePartial<CertAuthoritySpecV2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CertAuthoritySpecV2): CertAuthoritySpecV2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Type = 1 [json_name = "Type"];*/ 1:
                    message.type = reader.string();
                    break;
                case /* string ClusterName = 2 [json_name = "ClusterName"];*/ 2:
                    message.clusterName = reader.string();
                    break;
                case /* repeated string Roles = 5 [json_name = "Roles"];*/ 5:
                    message.roles.push(reader.string());
                    break;
                case /* repeated types.RoleMapping RoleMap = 6 [json_name = "RoleMap"];*/ 6:
                    message.roleMap.push(RoleMapping.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* types.Rotation Rotation = 8 [json_name = "Rotation"];*/ 8:
                    message.rotation = Rotation.internalBinaryRead(reader, reader.uint32(), options, message.rotation);
                    break;
                case /* types.CertAuthoritySpecV2.SigningAlgType SigningAlg = 9 [deprecated = true, json_name = "SigningAlg"];*/ 9:
                    message.signingAlg = reader.int32();
                    break;
                case /* types.CAKeySet ActiveKeys = 11 [json_name = "ActiveKeys"];*/ 11:
                    message.activeKeys = CAKeySet.internalBinaryRead(reader, reader.uint32(), options, message.activeKeys);
                    break;
                case /* types.CAKeySet AdditionalTrustedKeys = 12 [json_name = "AdditionalTrustedKeys"];*/ 12:
                    message.additionalTrustedKeys = CAKeySet.internalBinaryRead(reader, reader.uint32(), options, message.additionalTrustedKeys);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CertAuthoritySpecV2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Type = 1 [json_name = "Type"]; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* string ClusterName = 2 [json_name = "ClusterName"]; */
        if (message.clusterName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.clusterName);
        /* repeated string Roles = 5 [json_name = "Roles"]; */
        for (let i = 0; i < message.roles.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.roles[i]);
        /* repeated types.RoleMapping RoleMap = 6 [json_name = "RoleMap"]; */
        for (let i = 0; i < message.roleMap.length; i++)
            RoleMapping.internalBinaryWrite(message.roleMap[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* types.Rotation Rotation = 8 [json_name = "Rotation"]; */
        if (message.rotation)
            Rotation.internalBinaryWrite(message.rotation, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* types.CertAuthoritySpecV2.SigningAlgType SigningAlg = 9 [deprecated = true, json_name = "SigningAlg"]; */
        if (message.signingAlg !== 0)
            writer.tag(9, WireType.Varint).int32(message.signingAlg);
        /* types.CAKeySet ActiveKeys = 11 [json_name = "ActiveKeys"]; */
        if (message.activeKeys)
            CAKeySet.internalBinaryWrite(message.activeKeys, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* types.CAKeySet AdditionalTrustedKeys = 12 [json_name = "AdditionalTrustedKeys"]; */
        if (message.additionalTrustedKeys)
            CAKeySet.internalBinaryWrite(message.additionalTrustedKeys, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.CertAuthoritySpecV2
 */
export const CertAuthoritySpecV2 = new CertAuthoritySpecV2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CAKeySet$Type extends MessageType<CAKeySet> {
    constructor() {
        super("types.CAKeySet", [
            { no: 1, name: "SSH", kind: "message", jsonName: "SSH", repeat: 1 /*RepeatType.PACKED*/, T: () => SSHKeyPair, options: { "gogoproto.jsontag": "ssh,omitempty" } },
            { no: 2, name: "TLS", kind: "message", jsonName: "TLS", repeat: 1 /*RepeatType.PACKED*/, T: () => TLSKeyPair, options: { "gogoproto.jsontag": "tls,omitempty" } },
            { no: 3, name: "JWT", kind: "message", jsonName: "JWT", repeat: 1 /*RepeatType.PACKED*/, T: () => JWTKeyPair, options: { "gogoproto.jsontag": "jwt,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<CAKeySet>): CAKeySet {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sSH = [];
        message.tLS = [];
        message.jWT = [];
        if (value !== undefined)
            reflectionMergePartial<CAKeySet>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CAKeySet): CAKeySet {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.SSHKeyPair SSH = 1 [json_name = "SSH"];*/ 1:
                    message.sSH.push(SSHKeyPair.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated types.TLSKeyPair TLS = 2 [json_name = "TLS"];*/ 2:
                    message.tLS.push(TLSKeyPair.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated types.JWTKeyPair JWT = 3 [json_name = "JWT"];*/ 3:
                    message.jWT.push(JWTKeyPair.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CAKeySet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.SSHKeyPair SSH = 1 [json_name = "SSH"]; */
        for (let i = 0; i < message.sSH.length; i++)
            SSHKeyPair.internalBinaryWrite(message.sSH[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated types.TLSKeyPair TLS = 2 [json_name = "TLS"]; */
        for (let i = 0; i < message.tLS.length; i++)
            TLSKeyPair.internalBinaryWrite(message.tLS[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated types.JWTKeyPair JWT = 3 [json_name = "JWT"]; */
        for (let i = 0; i < message.jWT.length; i++)
            JWTKeyPair.internalBinaryWrite(message.jWT[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.CAKeySet
 */
export const CAKeySet = new CAKeySet$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RoleMapping$Type extends MessageType<RoleMapping> {
    constructor() {
        super("types.RoleMapping", [
            { no: 1, name: "Remote", kind: "scalar", jsonName: "Remote", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "remote" } },
            { no: 2, name: "Local", kind: "scalar", jsonName: "Local", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "local" } }
        ]);
    }
    create(value?: PartialMessage<RoleMapping>): RoleMapping {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.remote = "";
        message.local = [];
        if (value !== undefined)
            reflectionMergePartial<RoleMapping>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RoleMapping): RoleMapping {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Remote = 1 [json_name = "Remote"];*/ 1:
                    message.remote = reader.string();
                    break;
                case /* repeated string Local = 2 [json_name = "Local"];*/ 2:
                    message.local.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RoleMapping, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Remote = 1 [json_name = "Remote"]; */
        if (message.remote !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.remote);
        /* repeated string Local = 2 [json_name = "Local"]; */
        for (let i = 0; i < message.local.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.local[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.RoleMapping
 */
export const RoleMapping = new RoleMapping$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProvisionTokenV1$Type extends MessageType<ProvisionTokenV1> {
    constructor() {
        super("types.ProvisionTokenV1", [
            { no: 1, name: "Roles", kind: "scalar", jsonName: "Roles", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "roles", "gogoproto.casttype": "SystemRole" } },
            { no: 2, name: "Expires", kind: "message", jsonName: "Expires", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "expires,omitempty", "gogoproto.stdtime": true } },
            { no: 3, name: "Token", kind: "scalar", jsonName: "Token", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "token" } }
        ], { "gogoproto.goproto_stringer": false, "gogoproto.stringer": false });
    }
    create(value?: PartialMessage<ProvisionTokenV1>): ProvisionTokenV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.roles = [];
        message.token = "";
        if (value !== undefined)
            reflectionMergePartial<ProvisionTokenV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProvisionTokenV1): ProvisionTokenV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string Roles = 1 [json_name = "Roles"];*/ 1:
                    message.roles.push(reader.string());
                    break;
                case /* google.protobuf.Timestamp Expires = 2 [json_name = "Expires"];*/ 2:
                    message.expires = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expires);
                    break;
                case /* string Token = 3 [json_name = "Token"];*/ 3:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProvisionTokenV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string Roles = 1 [json_name = "Roles"]; */
        for (let i = 0; i < message.roles.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.roles[i]);
        /* google.protobuf.Timestamp Expires = 2 [json_name = "Expires"]; */
        if (message.expires)
            Timestamp.internalBinaryWrite(message.expires, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string Token = 3 [json_name = "Token"]; */
        if (message.token !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ProvisionTokenV1
 */
export const ProvisionTokenV1 = new ProvisionTokenV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProvisionTokenV2$Type extends MessageType<ProvisionTokenV2> {
    constructor() {
        super("types.ProvisionTokenV2", [
            { no: 1, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 2, name: "SubKind", kind: "scalar", jsonName: "SubKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub_kind,omitempty" } },
            { no: 3, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version" } },
            { no: 4, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "metadata" } },
            { no: 5, name: "Spec", kind: "message", jsonName: "Spec", T: () => ProvisionTokenSpecV2, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } },
            { no: 6, name: "Status", kind: "message", jsonName: "Status", T: () => ProvisionTokenStatusV2, options: { "gogoproto.jsontag": "status,omitempty" } }
        ], { "gogoproto.goproto_stringer": false, "gogoproto.stringer": false });
    }
    create(value?: PartialMessage<ProvisionTokenV2>): ProvisionTokenV2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.subKind = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<ProvisionTokenV2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProvisionTokenV2): ProvisionTokenV2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Kind = 1 [json_name = "Kind"];*/ 1:
                    message.kind = reader.string();
                    break;
                case /* string SubKind = 2 [json_name = "SubKind"];*/ 2:
                    message.subKind = reader.string();
                    break;
                case /* string Version = 3 [json_name = "Version"];*/ 3:
                    message.version = reader.string();
                    break;
                case /* types.Metadata Metadata = 4 [json_name = "Metadata"];*/ 4:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* types.ProvisionTokenSpecV2 Spec = 5 [json_name = "Spec"];*/ 5:
                    message.spec = ProvisionTokenSpecV2.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                case /* types.ProvisionTokenStatusV2 Status = 6 [json_name = "Status"];*/ 6:
                    message.status = ProvisionTokenStatusV2.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProvisionTokenV2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Kind = 1 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string SubKind = 2 [json_name = "SubKind"]; */
        if (message.subKind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subKind);
        /* string Version = 3 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* types.Metadata Metadata = 4 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.ProvisionTokenSpecV2 Spec = 5 [json_name = "Spec"]; */
        if (message.spec)
            ProvisionTokenSpecV2.internalBinaryWrite(message.spec, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* types.ProvisionTokenStatusV2 Status = 6 [json_name = "Status"]; */
        if (message.status)
            ProvisionTokenStatusV2.internalBinaryWrite(message.status, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ProvisionTokenV2
 */
export const ProvisionTokenV2 = new ProvisionTokenV2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProvisionTokenV2List$Type extends MessageType<ProvisionTokenV2List> {
    constructor() {
        super("types.ProvisionTokenV2List", [
            { no: 1, name: "ProvisionTokens", kind: "message", jsonName: "ProvisionTokens", repeat: 1 /*RepeatType.PACKED*/, T: () => ProvisionTokenV2 }
        ]);
    }
    create(value?: PartialMessage<ProvisionTokenV2List>): ProvisionTokenV2List {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.provisionTokens = [];
        if (value !== undefined)
            reflectionMergePartial<ProvisionTokenV2List>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProvisionTokenV2List): ProvisionTokenV2List {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.ProvisionTokenV2 ProvisionTokens = 1 [json_name = "ProvisionTokens"];*/ 1:
                    message.provisionTokens.push(ProvisionTokenV2.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProvisionTokenV2List, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.ProvisionTokenV2 ProvisionTokens = 1 [json_name = "ProvisionTokens"]; */
        for (let i = 0; i < message.provisionTokens.length; i++)
            ProvisionTokenV2.internalBinaryWrite(message.provisionTokens[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ProvisionTokenV2List
 */
export const ProvisionTokenV2List = new ProvisionTokenV2List$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenRule$Type extends MessageType<TokenRule> {
    constructor() {
        super("types.TokenRule", [
            { no: 1, name: "AWSAccount", kind: "scalar", jsonName: "AWSAccount", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "aws_account,omitempty" } },
            { no: 2, name: "AWSRegions", kind: "scalar", jsonName: "AWSRegions", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "aws_regions,omitempty" } },
            { no: 3, name: "AWSRole", kind: "scalar", jsonName: "AWSRole", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "aws_role,omitempty" } },
            { no: 4, name: "AWSARN", kind: "scalar", jsonName: "AWSARN", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "aws_arn,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<TokenRule>): TokenRule {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.aWSAccount = "";
        message.aWSRegions = [];
        message.aWSRole = "";
        message.aWSARN = "";
        if (value !== undefined)
            reflectionMergePartial<TokenRule>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenRule): TokenRule {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string AWSAccount = 1 [json_name = "AWSAccount"];*/ 1:
                    message.aWSAccount = reader.string();
                    break;
                case /* repeated string AWSRegions = 2 [json_name = "AWSRegions"];*/ 2:
                    message.aWSRegions.push(reader.string());
                    break;
                case /* string AWSRole = 3 [json_name = "AWSRole"];*/ 3:
                    message.aWSRole = reader.string();
                    break;
                case /* string AWSARN = 4 [json_name = "AWSARN"];*/ 4:
                    message.aWSARN = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TokenRule, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string AWSAccount = 1 [json_name = "AWSAccount"]; */
        if (message.aWSAccount !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.aWSAccount);
        /* repeated string AWSRegions = 2 [json_name = "AWSRegions"]; */
        for (let i = 0; i < message.aWSRegions.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.aWSRegions[i]);
        /* string AWSRole = 3 [json_name = "AWSRole"]; */
        if (message.aWSRole !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.aWSRole);
        /* string AWSARN = 4 [json_name = "AWSARN"]; */
        if (message.aWSARN !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.aWSARN);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.TokenRule
 */
export const TokenRule = new TokenRule$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProvisionTokenSpecV2$Type extends MessageType<ProvisionTokenSpecV2> {
    constructor() {
        super("types.ProvisionTokenSpecV2", [
            { no: 1, name: "Roles", kind: "scalar", jsonName: "Roles", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "roles", "gogoproto.casttype": "SystemRole" } },
            { no: 2, name: "Allow", kind: "message", jsonName: "Allow", repeat: 1 /*RepeatType.PACKED*/, T: () => TokenRule, options: { "gogoproto.jsontag": "allow,omitempty" } },
            { no: 3, name: "AWSIIDTTL", kind: "scalar", jsonName: "AWSIIDTTL", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "aws_iid_ttl,omitempty", "gogoproto.casttype": "Duration" } },
            { no: 4, name: "JoinMethod", kind: "scalar", jsonName: "JoinMethod", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "join_method", "gogoproto.casttype": "JoinMethod" } },
            { no: 5, name: "BotName", kind: "scalar", jsonName: "BotName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "bot_name,omitempty" } },
            { no: 6, name: "SuggestedLabels", kind: "message", jsonName: "SuggestedLabels", T: () => LabelValues, options: { "gogoproto.nullable": false, "gogoproto.customtype": "Labels", "gogoproto.jsontag": "suggested_labels,omitempty" } },
            { no: 7, name: "GitHub", kind: "message", jsonName: "GitHub", T: () => ProvisionTokenSpecV2GitHub, options: { "gogoproto.jsontag": "github,omitempty" } },
            { no: 8, name: "CircleCI", kind: "message", jsonName: "CircleCI", T: () => ProvisionTokenSpecV2CircleCI, options: { "gogoproto.jsontag": "circleci,omitempty" } },
            { no: 9, name: "SuggestedAgentMatcherLabels", kind: "message", jsonName: "SuggestedAgentMatcherLabels", T: () => LabelValues, options: { "gogoproto.nullable": false, "gogoproto.customtype": "Labels", "gogoproto.jsontag": "suggested_agent_matcher_labels,omitempty" } },
            { no: 10, name: "Kubernetes", kind: "message", jsonName: "Kubernetes", T: () => ProvisionTokenSpecV2Kubernetes, options: { "gogoproto.jsontag": "kubernetes,omitempty" } },
            { no: 11, name: "Azure", kind: "message", jsonName: "Azure", T: () => ProvisionTokenSpecV2Azure, options: { "gogoproto.jsontag": "azure,omitempty" } },
            { no: 12, name: "GitLab", kind: "message", jsonName: "GitLab", T: () => ProvisionTokenSpecV2GitLab, options: { "gogoproto.jsontag": "gitlab,omitempty" } },
            { no: 13, name: "GCP", kind: "message", jsonName: "GCP", T: () => ProvisionTokenSpecV2GCP, options: { "gogoproto.jsontag": "gcp,omitempty" } },
            { no: 14, name: "Spacelift", kind: "message", jsonName: "Spacelift", T: () => ProvisionTokenSpecV2Spacelift, options: { "gogoproto.jsontag": "spacelift,omitempty" } },
            { no: 15, name: "TPM", kind: "message", jsonName: "TPM", T: () => ProvisionTokenSpecV2TPM, options: { "gogoproto.jsontag": "tpm,omitempty" } },
            { no: 16, name: "TerraformCloud", kind: "message", jsonName: "TerraformCloud", T: () => ProvisionTokenSpecV2TerraformCloud, options: { "gogoproto.jsontag": "terraform_cloud,omitempty" } },
            { no: 17, name: "Bitbucket", kind: "message", jsonName: "Bitbucket", T: () => ProvisionTokenSpecV2Bitbucket, options: { "gogoproto.jsontag": "bitbucket,omitempty" } },
            { no: 18, name: "Oracle", kind: "message", jsonName: "Oracle", T: () => ProvisionTokenSpecV2Oracle, options: { "gogoproto.jsontag": "oracle,omitempty" } },
            { no: 19, name: "BoundKeypair", kind: "message", jsonName: "BoundKeypair", T: () => ProvisionTokenSpecV2BoundKeypair, options: { "gogoproto.jsontag": "bound_keypair,omitempty" } },
            { no: 20, name: "AzureDevops", kind: "message", jsonName: "AzureDevops", T: () => ProvisionTokenSpecV2AzureDevops, options: { "gogoproto.jsontag": "azure_devops,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ProvisionTokenSpecV2>): ProvisionTokenSpecV2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.roles = [];
        message.allow = [];
        message.aWSIIDTTL = 0n;
        message.joinMethod = "";
        message.botName = "";
        if (value !== undefined)
            reflectionMergePartial<ProvisionTokenSpecV2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProvisionTokenSpecV2): ProvisionTokenSpecV2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string Roles = 1 [json_name = "Roles"];*/ 1:
                    message.roles.push(reader.string());
                    break;
                case /* repeated types.TokenRule Allow = 2 [json_name = "Allow"];*/ 2:
                    message.allow.push(TokenRule.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int64 AWSIIDTTL = 3 [json_name = "AWSIIDTTL"];*/ 3:
                    message.aWSIIDTTL = reader.int64().toBigInt();
                    break;
                case /* string JoinMethod = 4 [json_name = "JoinMethod"];*/ 4:
                    message.joinMethod = reader.string();
                    break;
                case /* string BotName = 5 [json_name = "BotName"];*/ 5:
                    message.botName = reader.string();
                    break;
                case /* wrappers.LabelValues SuggestedLabels = 6 [json_name = "SuggestedLabels"];*/ 6:
                    message.suggestedLabels = LabelValues.internalBinaryRead(reader, reader.uint32(), options, message.suggestedLabels);
                    break;
                case /* types.ProvisionTokenSpecV2GitHub GitHub = 7 [json_name = "GitHub"];*/ 7:
                    message.gitHub = ProvisionTokenSpecV2GitHub.internalBinaryRead(reader, reader.uint32(), options, message.gitHub);
                    break;
                case /* types.ProvisionTokenSpecV2CircleCI CircleCI = 8 [json_name = "CircleCI"];*/ 8:
                    message.circleCI = ProvisionTokenSpecV2CircleCI.internalBinaryRead(reader, reader.uint32(), options, message.circleCI);
                    break;
                case /* wrappers.LabelValues SuggestedAgentMatcherLabels = 9 [json_name = "SuggestedAgentMatcherLabels"];*/ 9:
                    message.suggestedAgentMatcherLabels = LabelValues.internalBinaryRead(reader, reader.uint32(), options, message.suggestedAgentMatcherLabels);
                    break;
                case /* types.ProvisionTokenSpecV2Kubernetes Kubernetes = 10 [json_name = "Kubernetes"];*/ 10:
                    message.kubernetes = ProvisionTokenSpecV2Kubernetes.internalBinaryRead(reader, reader.uint32(), options, message.kubernetes);
                    break;
                case /* types.ProvisionTokenSpecV2Azure Azure = 11 [json_name = "Azure"];*/ 11:
                    message.azure = ProvisionTokenSpecV2Azure.internalBinaryRead(reader, reader.uint32(), options, message.azure);
                    break;
                case /* types.ProvisionTokenSpecV2GitLab GitLab = 12 [json_name = "GitLab"];*/ 12:
                    message.gitLab = ProvisionTokenSpecV2GitLab.internalBinaryRead(reader, reader.uint32(), options, message.gitLab);
                    break;
                case /* types.ProvisionTokenSpecV2GCP GCP = 13 [json_name = "GCP"];*/ 13:
                    message.gCP = ProvisionTokenSpecV2GCP.internalBinaryRead(reader, reader.uint32(), options, message.gCP);
                    break;
                case /* types.ProvisionTokenSpecV2Spacelift Spacelift = 14 [json_name = "Spacelift"];*/ 14:
                    message.spacelift = ProvisionTokenSpecV2Spacelift.internalBinaryRead(reader, reader.uint32(), options, message.spacelift);
                    break;
                case /* types.ProvisionTokenSpecV2TPM TPM = 15 [json_name = "TPM"];*/ 15:
                    message.tPM = ProvisionTokenSpecV2TPM.internalBinaryRead(reader, reader.uint32(), options, message.tPM);
                    break;
                case /* types.ProvisionTokenSpecV2TerraformCloud TerraformCloud = 16 [json_name = "TerraformCloud"];*/ 16:
                    message.terraformCloud = ProvisionTokenSpecV2TerraformCloud.internalBinaryRead(reader, reader.uint32(), options, message.terraformCloud);
                    break;
                case /* types.ProvisionTokenSpecV2Bitbucket Bitbucket = 17 [json_name = "Bitbucket"];*/ 17:
                    message.bitbucket = ProvisionTokenSpecV2Bitbucket.internalBinaryRead(reader, reader.uint32(), options, message.bitbucket);
                    break;
                case /* types.ProvisionTokenSpecV2Oracle Oracle = 18 [json_name = "Oracle"];*/ 18:
                    message.oracle = ProvisionTokenSpecV2Oracle.internalBinaryRead(reader, reader.uint32(), options, message.oracle);
                    break;
                case /* types.ProvisionTokenSpecV2BoundKeypair BoundKeypair = 19 [json_name = "BoundKeypair"];*/ 19:
                    message.boundKeypair = ProvisionTokenSpecV2BoundKeypair.internalBinaryRead(reader, reader.uint32(), options, message.boundKeypair);
                    break;
                case /* types.ProvisionTokenSpecV2AzureDevops AzureDevops = 20 [json_name = "AzureDevops"];*/ 20:
                    message.azureDevops = ProvisionTokenSpecV2AzureDevops.internalBinaryRead(reader, reader.uint32(), options, message.azureDevops);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProvisionTokenSpecV2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string Roles = 1 [json_name = "Roles"]; */
        for (let i = 0; i < message.roles.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.roles[i]);
        /* repeated types.TokenRule Allow = 2 [json_name = "Allow"]; */
        for (let i = 0; i < message.allow.length; i++)
            TokenRule.internalBinaryWrite(message.allow[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int64 AWSIIDTTL = 3 [json_name = "AWSIIDTTL"]; */
        if (message.aWSIIDTTL !== 0n)
            writer.tag(3, WireType.Varint).int64(message.aWSIIDTTL);
        /* string JoinMethod = 4 [json_name = "JoinMethod"]; */
        if (message.joinMethod !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.joinMethod);
        /* string BotName = 5 [json_name = "BotName"]; */
        if (message.botName !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.botName);
        /* wrappers.LabelValues SuggestedLabels = 6 [json_name = "SuggestedLabels"]; */
        if (message.suggestedLabels)
            LabelValues.internalBinaryWrite(message.suggestedLabels, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* types.ProvisionTokenSpecV2GitHub GitHub = 7 [json_name = "GitHub"]; */
        if (message.gitHub)
            ProvisionTokenSpecV2GitHub.internalBinaryWrite(message.gitHub, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* types.ProvisionTokenSpecV2CircleCI CircleCI = 8 [json_name = "CircleCI"]; */
        if (message.circleCI)
            ProvisionTokenSpecV2CircleCI.internalBinaryWrite(message.circleCI, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* wrappers.LabelValues SuggestedAgentMatcherLabels = 9 [json_name = "SuggestedAgentMatcherLabels"]; */
        if (message.suggestedAgentMatcherLabels)
            LabelValues.internalBinaryWrite(message.suggestedAgentMatcherLabels, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* types.ProvisionTokenSpecV2Kubernetes Kubernetes = 10 [json_name = "Kubernetes"]; */
        if (message.kubernetes)
            ProvisionTokenSpecV2Kubernetes.internalBinaryWrite(message.kubernetes, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* types.ProvisionTokenSpecV2Azure Azure = 11 [json_name = "Azure"]; */
        if (message.azure)
            ProvisionTokenSpecV2Azure.internalBinaryWrite(message.azure, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* types.ProvisionTokenSpecV2GitLab GitLab = 12 [json_name = "GitLab"]; */
        if (message.gitLab)
            ProvisionTokenSpecV2GitLab.internalBinaryWrite(message.gitLab, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* types.ProvisionTokenSpecV2GCP GCP = 13 [json_name = "GCP"]; */
        if (message.gCP)
            ProvisionTokenSpecV2GCP.internalBinaryWrite(message.gCP, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* types.ProvisionTokenSpecV2Spacelift Spacelift = 14 [json_name = "Spacelift"]; */
        if (message.spacelift)
            ProvisionTokenSpecV2Spacelift.internalBinaryWrite(message.spacelift, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* types.ProvisionTokenSpecV2TPM TPM = 15 [json_name = "TPM"]; */
        if (message.tPM)
            ProvisionTokenSpecV2TPM.internalBinaryWrite(message.tPM, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* types.ProvisionTokenSpecV2TerraformCloud TerraformCloud = 16 [json_name = "TerraformCloud"]; */
        if (message.terraformCloud)
            ProvisionTokenSpecV2TerraformCloud.internalBinaryWrite(message.terraformCloud, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* types.ProvisionTokenSpecV2Bitbucket Bitbucket = 17 [json_name = "Bitbucket"]; */
        if (message.bitbucket)
            ProvisionTokenSpecV2Bitbucket.internalBinaryWrite(message.bitbucket, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* types.ProvisionTokenSpecV2Oracle Oracle = 18 [json_name = "Oracle"]; */
        if (message.oracle)
            ProvisionTokenSpecV2Oracle.internalBinaryWrite(message.oracle, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* types.ProvisionTokenSpecV2BoundKeypair BoundKeypair = 19 [json_name = "BoundKeypair"]; */
        if (message.boundKeypair)
            ProvisionTokenSpecV2BoundKeypair.internalBinaryWrite(message.boundKeypair, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* types.ProvisionTokenSpecV2AzureDevops AzureDevops = 20 [json_name = "AzureDevops"]; */
        if (message.azureDevops)
            ProvisionTokenSpecV2AzureDevops.internalBinaryWrite(message.azureDevops, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ProvisionTokenSpecV2
 */
export const ProvisionTokenSpecV2 = new ProvisionTokenSpecV2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProvisionTokenSpecV2AzureDevops$Type extends MessageType<ProvisionTokenSpecV2AzureDevops> {
    constructor() {
        super("types.ProvisionTokenSpecV2AzureDevops", [
            { no: 1, name: "Allow", kind: "message", jsonName: "Allow", repeat: 1 /*RepeatType.PACKED*/, T: () => ProvisionTokenSpecV2AzureDevops_Rule, options: { "gogoproto.jsontag": "allow,omitempty" } },
            { no: 2, name: "OrganizationID", kind: "scalar", jsonName: "OrganizationID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "organization_id" } }
        ]);
    }
    create(value?: PartialMessage<ProvisionTokenSpecV2AzureDevops>): ProvisionTokenSpecV2AzureDevops {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.allow = [];
        message.organizationID = "";
        if (value !== undefined)
            reflectionMergePartial<ProvisionTokenSpecV2AzureDevops>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProvisionTokenSpecV2AzureDevops): ProvisionTokenSpecV2AzureDevops {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.ProvisionTokenSpecV2AzureDevops.Rule Allow = 1 [json_name = "Allow"];*/ 1:
                    message.allow.push(ProvisionTokenSpecV2AzureDevops_Rule.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string OrganizationID = 2 [json_name = "OrganizationID"];*/ 2:
                    message.organizationID = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProvisionTokenSpecV2AzureDevops, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.ProvisionTokenSpecV2AzureDevops.Rule Allow = 1 [json_name = "Allow"]; */
        for (let i = 0; i < message.allow.length; i++)
            ProvisionTokenSpecV2AzureDevops_Rule.internalBinaryWrite(message.allow[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string OrganizationID = 2 [json_name = "OrganizationID"]; */
        if (message.organizationID !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.organizationID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ProvisionTokenSpecV2AzureDevops
 */
export const ProvisionTokenSpecV2AzureDevops = new ProvisionTokenSpecV2AzureDevops$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProvisionTokenSpecV2AzureDevops_Rule$Type extends MessageType<ProvisionTokenSpecV2AzureDevops_Rule> {
    constructor() {
        super("types.ProvisionTokenSpecV2AzureDevops.Rule", [
            { no: 1, name: "Sub", kind: "scalar", jsonName: "Sub", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub,omitempty" } },
            { no: 2, name: "ProjectName", kind: "scalar", jsonName: "ProjectName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "project_name,omitempty" } },
            { no: 3, name: "PipelineName", kind: "scalar", jsonName: "PipelineName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "pipeline_name,omitempty" } },
            { no: 4, name: "ProjectID", kind: "scalar", jsonName: "ProjectID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "project_id,omitempty" } },
            { no: 5, name: "DefinitionID", kind: "scalar", jsonName: "DefinitionID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "definition_id,omitempty" } },
            { no: 6, name: "RepositoryURI", kind: "scalar", jsonName: "RepositoryURI", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "repository_uri,omitempty" } },
            { no: 7, name: "RepositoryVersion", kind: "scalar", jsonName: "RepositoryVersion", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "repository_version,omitempty" } },
            { no: 8, name: "RepositoryRef", kind: "scalar", jsonName: "RepositoryRef", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "repository_ref,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ProvisionTokenSpecV2AzureDevops_Rule>): ProvisionTokenSpecV2AzureDevops_Rule {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sub = "";
        message.projectName = "";
        message.pipelineName = "";
        message.projectID = "";
        message.definitionID = "";
        message.repositoryURI = "";
        message.repositoryVersion = "";
        message.repositoryRef = "";
        if (value !== undefined)
            reflectionMergePartial<ProvisionTokenSpecV2AzureDevops_Rule>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProvisionTokenSpecV2AzureDevops_Rule): ProvisionTokenSpecV2AzureDevops_Rule {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Sub = 1 [json_name = "Sub"];*/ 1:
                    message.sub = reader.string();
                    break;
                case /* string ProjectName = 2 [json_name = "ProjectName"];*/ 2:
                    message.projectName = reader.string();
                    break;
                case /* string PipelineName = 3 [json_name = "PipelineName"];*/ 3:
                    message.pipelineName = reader.string();
                    break;
                case /* string ProjectID = 4 [json_name = "ProjectID"];*/ 4:
                    message.projectID = reader.string();
                    break;
                case /* string DefinitionID = 5 [json_name = "DefinitionID"];*/ 5:
                    message.definitionID = reader.string();
                    break;
                case /* string RepositoryURI = 6 [json_name = "RepositoryURI"];*/ 6:
                    message.repositoryURI = reader.string();
                    break;
                case /* string RepositoryVersion = 7 [json_name = "RepositoryVersion"];*/ 7:
                    message.repositoryVersion = reader.string();
                    break;
                case /* string RepositoryRef = 8 [json_name = "RepositoryRef"];*/ 8:
                    message.repositoryRef = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProvisionTokenSpecV2AzureDevops_Rule, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Sub = 1 [json_name = "Sub"]; */
        if (message.sub !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sub);
        /* string ProjectName = 2 [json_name = "ProjectName"]; */
        if (message.projectName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.projectName);
        /* string PipelineName = 3 [json_name = "PipelineName"]; */
        if (message.pipelineName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.pipelineName);
        /* string ProjectID = 4 [json_name = "ProjectID"]; */
        if (message.projectID !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.projectID);
        /* string DefinitionID = 5 [json_name = "DefinitionID"]; */
        if (message.definitionID !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.definitionID);
        /* string RepositoryURI = 6 [json_name = "RepositoryURI"]; */
        if (message.repositoryURI !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.repositoryURI);
        /* string RepositoryVersion = 7 [json_name = "RepositoryVersion"]; */
        if (message.repositoryVersion !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.repositoryVersion);
        /* string RepositoryRef = 8 [json_name = "RepositoryRef"]; */
        if (message.repositoryRef !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.repositoryRef);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ProvisionTokenSpecV2AzureDevops.Rule
 */
export const ProvisionTokenSpecV2AzureDevops_Rule = new ProvisionTokenSpecV2AzureDevops_Rule$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProvisionTokenSpecV2TPM$Type extends MessageType<ProvisionTokenSpecV2TPM> {
    constructor() {
        super("types.ProvisionTokenSpecV2TPM", [
            { no: 1, name: "Allow", kind: "message", jsonName: "Allow", repeat: 1 /*RepeatType.PACKED*/, T: () => ProvisionTokenSpecV2TPM_Rule, options: { "gogoproto.jsontag": "allow,omitempty" } },
            { no: 2, name: "EKCertAllowedCAs", kind: "scalar", jsonName: "EKCertAllowedCAs", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "ekcert_allowed_cas,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ProvisionTokenSpecV2TPM>): ProvisionTokenSpecV2TPM {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.allow = [];
        message.eKCertAllowedCAs = [];
        if (value !== undefined)
            reflectionMergePartial<ProvisionTokenSpecV2TPM>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProvisionTokenSpecV2TPM): ProvisionTokenSpecV2TPM {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.ProvisionTokenSpecV2TPM.Rule Allow = 1 [json_name = "Allow"];*/ 1:
                    message.allow.push(ProvisionTokenSpecV2TPM_Rule.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string EKCertAllowedCAs = 2 [json_name = "EKCertAllowedCAs"];*/ 2:
                    message.eKCertAllowedCAs.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProvisionTokenSpecV2TPM, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.ProvisionTokenSpecV2TPM.Rule Allow = 1 [json_name = "Allow"]; */
        for (let i = 0; i < message.allow.length; i++)
            ProvisionTokenSpecV2TPM_Rule.internalBinaryWrite(message.allow[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string EKCertAllowedCAs = 2 [json_name = "EKCertAllowedCAs"]; */
        for (let i = 0; i < message.eKCertAllowedCAs.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.eKCertAllowedCAs[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ProvisionTokenSpecV2TPM
 */
export const ProvisionTokenSpecV2TPM = new ProvisionTokenSpecV2TPM$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProvisionTokenSpecV2TPM_Rule$Type extends MessageType<ProvisionTokenSpecV2TPM_Rule> {
    constructor() {
        super("types.ProvisionTokenSpecV2TPM.Rule", [
            { no: 1, name: "Description", kind: "scalar", jsonName: "Description", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "description,omitempty" } },
            { no: 4, name: "EKPublicHash", kind: "scalar", jsonName: "EKPublicHash", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "ek_public_hash,omitempty" } },
            { no: 5, name: "EKCertificateSerial", kind: "scalar", jsonName: "EKCertificateSerial", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "ek_certificate_serial,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ProvisionTokenSpecV2TPM_Rule>): ProvisionTokenSpecV2TPM_Rule {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.description = "";
        message.eKPublicHash = "";
        message.eKCertificateSerial = "";
        if (value !== undefined)
            reflectionMergePartial<ProvisionTokenSpecV2TPM_Rule>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProvisionTokenSpecV2TPM_Rule): ProvisionTokenSpecV2TPM_Rule {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Description = 1 [json_name = "Description"];*/ 1:
                    message.description = reader.string();
                    break;
                case /* string EKPublicHash = 4 [json_name = "EKPublicHash"];*/ 4:
                    message.eKPublicHash = reader.string();
                    break;
                case /* string EKCertificateSerial = 5 [json_name = "EKCertificateSerial"];*/ 5:
                    message.eKCertificateSerial = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProvisionTokenSpecV2TPM_Rule, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Description = 1 [json_name = "Description"]; */
        if (message.description !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.description);
        /* string EKPublicHash = 4 [json_name = "EKPublicHash"]; */
        if (message.eKPublicHash !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.eKPublicHash);
        /* string EKCertificateSerial = 5 [json_name = "EKCertificateSerial"]; */
        if (message.eKCertificateSerial !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.eKCertificateSerial);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ProvisionTokenSpecV2TPM.Rule
 */
export const ProvisionTokenSpecV2TPM_Rule = new ProvisionTokenSpecV2TPM_Rule$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProvisionTokenSpecV2GitHub$Type extends MessageType<ProvisionTokenSpecV2GitHub> {
    constructor() {
        super("types.ProvisionTokenSpecV2GitHub", [
            { no: 1, name: "Allow", kind: "message", jsonName: "Allow", repeat: 1 /*RepeatType.PACKED*/, T: () => ProvisionTokenSpecV2GitHub_Rule, options: { "gogoproto.jsontag": "allow,omitempty" } },
            { no: 2, name: "EnterpriseServerHost", kind: "scalar", jsonName: "EnterpriseServerHost", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "enterprise_server_host,omitempty" } },
            { no: 3, name: "EnterpriseSlug", kind: "scalar", jsonName: "EnterpriseSlug", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "enterprise_slug,omitempty" } },
            { no: 4, name: "StaticJWKS", kind: "scalar", jsonName: "StaticJWKS", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "static_jwks,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ProvisionTokenSpecV2GitHub>): ProvisionTokenSpecV2GitHub {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.allow = [];
        message.enterpriseServerHost = "";
        message.enterpriseSlug = "";
        message.staticJWKS = "";
        if (value !== undefined)
            reflectionMergePartial<ProvisionTokenSpecV2GitHub>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProvisionTokenSpecV2GitHub): ProvisionTokenSpecV2GitHub {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.ProvisionTokenSpecV2GitHub.Rule Allow = 1 [json_name = "Allow"];*/ 1:
                    message.allow.push(ProvisionTokenSpecV2GitHub_Rule.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string EnterpriseServerHost = 2 [json_name = "EnterpriseServerHost"];*/ 2:
                    message.enterpriseServerHost = reader.string();
                    break;
                case /* string EnterpriseSlug = 3 [json_name = "EnterpriseSlug"];*/ 3:
                    message.enterpriseSlug = reader.string();
                    break;
                case /* string StaticJWKS = 4 [json_name = "StaticJWKS"];*/ 4:
                    message.staticJWKS = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProvisionTokenSpecV2GitHub, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.ProvisionTokenSpecV2GitHub.Rule Allow = 1 [json_name = "Allow"]; */
        for (let i = 0; i < message.allow.length; i++)
            ProvisionTokenSpecV2GitHub_Rule.internalBinaryWrite(message.allow[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string EnterpriseServerHost = 2 [json_name = "EnterpriseServerHost"]; */
        if (message.enterpriseServerHost !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.enterpriseServerHost);
        /* string EnterpriseSlug = 3 [json_name = "EnterpriseSlug"]; */
        if (message.enterpriseSlug !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.enterpriseSlug);
        /* string StaticJWKS = 4 [json_name = "StaticJWKS"]; */
        if (message.staticJWKS !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.staticJWKS);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ProvisionTokenSpecV2GitHub
 */
export const ProvisionTokenSpecV2GitHub = new ProvisionTokenSpecV2GitHub$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProvisionTokenSpecV2GitHub_Rule$Type extends MessageType<ProvisionTokenSpecV2GitHub_Rule> {
    constructor() {
        super("types.ProvisionTokenSpecV2GitHub.Rule", [
            { no: 1, name: "Sub", kind: "scalar", jsonName: "Sub", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub,omitempty" } },
            { no: 2, name: "Repository", kind: "scalar", jsonName: "Repository", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "repository,omitempty" } },
            { no: 3, name: "RepositoryOwner", kind: "scalar", jsonName: "RepositoryOwner", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "repository_owner,omitempty" } },
            { no: 4, name: "Workflow", kind: "scalar", jsonName: "Workflow", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "workflow,omitempty" } },
            { no: 5, name: "Environment", kind: "scalar", jsonName: "Environment", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "environment,omitempty" } },
            { no: 6, name: "Actor", kind: "scalar", jsonName: "Actor", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "actor,omitempty" } },
            { no: 7, name: "Ref", kind: "scalar", jsonName: "Ref", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "ref,omitempty" } },
            { no: 8, name: "RefType", kind: "scalar", jsonName: "RefType", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "ref_type,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ProvisionTokenSpecV2GitHub_Rule>): ProvisionTokenSpecV2GitHub_Rule {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sub = "";
        message.repository = "";
        message.repositoryOwner = "";
        message.workflow = "";
        message.environment = "";
        message.actor = "";
        message.ref = "";
        message.refType = "";
        if (value !== undefined)
            reflectionMergePartial<ProvisionTokenSpecV2GitHub_Rule>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProvisionTokenSpecV2GitHub_Rule): ProvisionTokenSpecV2GitHub_Rule {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Sub = 1 [json_name = "Sub"];*/ 1:
                    message.sub = reader.string();
                    break;
                case /* string Repository = 2 [json_name = "Repository"];*/ 2:
                    message.repository = reader.string();
                    break;
                case /* string RepositoryOwner = 3 [json_name = "RepositoryOwner"];*/ 3:
                    message.repositoryOwner = reader.string();
                    break;
                case /* string Workflow = 4 [json_name = "Workflow"];*/ 4:
                    message.workflow = reader.string();
                    break;
                case /* string Environment = 5 [json_name = "Environment"];*/ 5:
                    message.environment = reader.string();
                    break;
                case /* string Actor = 6 [json_name = "Actor"];*/ 6:
                    message.actor = reader.string();
                    break;
                case /* string Ref = 7 [json_name = "Ref"];*/ 7:
                    message.ref = reader.string();
                    break;
                case /* string RefType = 8 [json_name = "RefType"];*/ 8:
                    message.refType = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProvisionTokenSpecV2GitHub_Rule, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Sub = 1 [json_name = "Sub"]; */
        if (message.sub !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sub);
        /* string Repository = 2 [json_name = "Repository"]; */
        if (message.repository !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.repository);
        /* string RepositoryOwner = 3 [json_name = "RepositoryOwner"]; */
        if (message.repositoryOwner !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.repositoryOwner);
        /* string Workflow = 4 [json_name = "Workflow"]; */
        if (message.workflow !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.workflow);
        /* string Environment = 5 [json_name = "Environment"]; */
        if (message.environment !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.environment);
        /* string Actor = 6 [json_name = "Actor"]; */
        if (message.actor !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.actor);
        /* string Ref = 7 [json_name = "Ref"]; */
        if (message.ref !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.ref);
        /* string RefType = 8 [json_name = "RefType"]; */
        if (message.refType !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.refType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ProvisionTokenSpecV2GitHub.Rule
 */
export const ProvisionTokenSpecV2GitHub_Rule = new ProvisionTokenSpecV2GitHub_Rule$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProvisionTokenSpecV2GitLab$Type extends MessageType<ProvisionTokenSpecV2GitLab> {
    constructor() {
        super("types.ProvisionTokenSpecV2GitLab", [
            { no: 1, name: "Allow", kind: "message", jsonName: "Allow", repeat: 1 /*RepeatType.PACKED*/, T: () => ProvisionTokenSpecV2GitLab_Rule, options: { "gogoproto.jsontag": "allow,omitempty" } },
            { no: 2, name: "Domain", kind: "scalar", jsonName: "Domain", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "domain,omitempty" } },
            { no: 3, name: "StaticJWKS", kind: "scalar", jsonName: "StaticJWKS", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "static_jwks,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ProvisionTokenSpecV2GitLab>): ProvisionTokenSpecV2GitLab {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.allow = [];
        message.domain = "";
        message.staticJWKS = "";
        if (value !== undefined)
            reflectionMergePartial<ProvisionTokenSpecV2GitLab>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProvisionTokenSpecV2GitLab): ProvisionTokenSpecV2GitLab {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.ProvisionTokenSpecV2GitLab.Rule Allow = 1 [json_name = "Allow"];*/ 1:
                    message.allow.push(ProvisionTokenSpecV2GitLab_Rule.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string Domain = 2 [json_name = "Domain"];*/ 2:
                    message.domain = reader.string();
                    break;
                case /* string StaticJWKS = 3 [json_name = "StaticJWKS"];*/ 3:
                    message.staticJWKS = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProvisionTokenSpecV2GitLab, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.ProvisionTokenSpecV2GitLab.Rule Allow = 1 [json_name = "Allow"]; */
        for (let i = 0; i < message.allow.length; i++)
            ProvisionTokenSpecV2GitLab_Rule.internalBinaryWrite(message.allow[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string Domain = 2 [json_name = "Domain"]; */
        if (message.domain !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.domain);
        /* string StaticJWKS = 3 [json_name = "StaticJWKS"]; */
        if (message.staticJWKS !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.staticJWKS);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ProvisionTokenSpecV2GitLab
 */
export const ProvisionTokenSpecV2GitLab = new ProvisionTokenSpecV2GitLab$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProvisionTokenSpecV2GitLab_Rule$Type extends MessageType<ProvisionTokenSpecV2GitLab_Rule> {
    constructor() {
        super("types.ProvisionTokenSpecV2GitLab.Rule", [
            { no: 1, name: "Sub", kind: "scalar", jsonName: "Sub", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub,omitempty" } },
            { no: 2, name: "Ref", kind: "scalar", jsonName: "Ref", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "ref,omitempty" } },
            { no: 3, name: "RefType", kind: "scalar", jsonName: "RefType", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "ref_type,omitempty" } },
            { no: 4, name: "NamespacePath", kind: "scalar", jsonName: "NamespacePath", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "namespace_path,omitempty" } },
            { no: 5, name: "ProjectPath", kind: "scalar", jsonName: "ProjectPath", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "project_path,omitempty" } },
            { no: 6, name: "PipelineSource", kind: "scalar", jsonName: "PipelineSource", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "pipeline_source,omitempty" } },
            { no: 7, name: "Environment", kind: "scalar", jsonName: "Environment", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "environment,omitempty" } },
            { no: 8, name: "UserLogin", kind: "scalar", jsonName: "UserLogin", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "user_login,omitempty" } },
            { no: 9, name: "UserID", kind: "scalar", jsonName: "UserID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "user_id,omitempty" } },
            { no: 10, name: "UserEmail", kind: "scalar", jsonName: "UserEmail", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "user_email,omitempty" } },
            { no: 11, name: "RefProtected", kind: "message", jsonName: "RefProtected", T: () => BoolValue, options: { "gogoproto.nullable": true, "gogoproto.customtype": "BoolOption", "gogoproto.jsontag": "ref_protected,omitempty" } },
            { no: 12, name: "EnvironmentProtected", kind: "message", jsonName: "EnvironmentProtected", T: () => BoolValue, options: { "gogoproto.nullable": true, "gogoproto.customtype": "BoolOption", "gogoproto.jsontag": "environment_protected,omitempty" } },
            { no: 13, name: "CIConfigSHA", kind: "scalar", jsonName: "CIConfigSHA", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "ci_config_sha,omitempty" } },
            { no: 14, name: "CIConfigRefURI", kind: "scalar", jsonName: "CIConfigRefURI", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "ci_config_ref_uri,omitempty" } },
            { no: 15, name: "DeploymentTier", kind: "scalar", jsonName: "DeploymentTier", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "deployment_tier,omitempty" } },
            { no: 16, name: "ProjectVisibility", kind: "scalar", jsonName: "ProjectVisibility", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "project_visibility,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ProvisionTokenSpecV2GitLab_Rule>): ProvisionTokenSpecV2GitLab_Rule {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sub = "";
        message.ref = "";
        message.refType = "";
        message.namespacePath = "";
        message.projectPath = "";
        message.pipelineSource = "";
        message.environment = "";
        message.userLogin = "";
        message.userID = "";
        message.userEmail = "";
        message.cIConfigSHA = "";
        message.cIConfigRefURI = "";
        message.deploymentTier = "";
        message.projectVisibility = "";
        if (value !== undefined)
            reflectionMergePartial<ProvisionTokenSpecV2GitLab_Rule>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProvisionTokenSpecV2GitLab_Rule): ProvisionTokenSpecV2GitLab_Rule {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Sub = 1 [json_name = "Sub"];*/ 1:
                    message.sub = reader.string();
                    break;
                case /* string Ref = 2 [json_name = "Ref"];*/ 2:
                    message.ref = reader.string();
                    break;
                case /* string RefType = 3 [json_name = "RefType"];*/ 3:
                    message.refType = reader.string();
                    break;
                case /* string NamespacePath = 4 [json_name = "NamespacePath"];*/ 4:
                    message.namespacePath = reader.string();
                    break;
                case /* string ProjectPath = 5 [json_name = "ProjectPath"];*/ 5:
                    message.projectPath = reader.string();
                    break;
                case /* string PipelineSource = 6 [json_name = "PipelineSource"];*/ 6:
                    message.pipelineSource = reader.string();
                    break;
                case /* string Environment = 7 [json_name = "Environment"];*/ 7:
                    message.environment = reader.string();
                    break;
                case /* string UserLogin = 8 [json_name = "UserLogin"];*/ 8:
                    message.userLogin = reader.string();
                    break;
                case /* string UserID = 9 [json_name = "UserID"];*/ 9:
                    message.userID = reader.string();
                    break;
                case /* string UserEmail = 10 [json_name = "UserEmail"];*/ 10:
                    message.userEmail = reader.string();
                    break;
                case /* types.BoolValue RefProtected = 11 [json_name = "RefProtected"];*/ 11:
                    message.refProtected = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.refProtected);
                    break;
                case /* types.BoolValue EnvironmentProtected = 12 [json_name = "EnvironmentProtected"];*/ 12:
                    message.environmentProtected = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.environmentProtected);
                    break;
                case /* string CIConfigSHA = 13 [json_name = "CIConfigSHA"];*/ 13:
                    message.cIConfigSHA = reader.string();
                    break;
                case /* string CIConfigRefURI = 14 [json_name = "CIConfigRefURI"];*/ 14:
                    message.cIConfigRefURI = reader.string();
                    break;
                case /* string DeploymentTier = 15 [json_name = "DeploymentTier"];*/ 15:
                    message.deploymentTier = reader.string();
                    break;
                case /* string ProjectVisibility = 16 [json_name = "ProjectVisibility"];*/ 16:
                    message.projectVisibility = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProvisionTokenSpecV2GitLab_Rule, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Sub = 1 [json_name = "Sub"]; */
        if (message.sub !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sub);
        /* string Ref = 2 [json_name = "Ref"]; */
        if (message.ref !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.ref);
        /* string RefType = 3 [json_name = "RefType"]; */
        if (message.refType !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.refType);
        /* string NamespacePath = 4 [json_name = "NamespacePath"]; */
        if (message.namespacePath !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.namespacePath);
        /* string ProjectPath = 5 [json_name = "ProjectPath"]; */
        if (message.projectPath !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.projectPath);
        /* string PipelineSource = 6 [json_name = "PipelineSource"]; */
        if (message.pipelineSource !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.pipelineSource);
        /* string Environment = 7 [json_name = "Environment"]; */
        if (message.environment !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.environment);
        /* string UserLogin = 8 [json_name = "UserLogin"]; */
        if (message.userLogin !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.userLogin);
        /* string UserID = 9 [json_name = "UserID"]; */
        if (message.userID !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.userID);
        /* string UserEmail = 10 [json_name = "UserEmail"]; */
        if (message.userEmail !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.userEmail);
        /* types.BoolValue RefProtected = 11 [json_name = "RefProtected"]; */
        if (message.refProtected)
            BoolValue.internalBinaryWrite(message.refProtected, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* types.BoolValue EnvironmentProtected = 12 [json_name = "EnvironmentProtected"]; */
        if (message.environmentProtected)
            BoolValue.internalBinaryWrite(message.environmentProtected, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* string CIConfigSHA = 13 [json_name = "CIConfigSHA"]; */
        if (message.cIConfigSHA !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.cIConfigSHA);
        /* string CIConfigRefURI = 14 [json_name = "CIConfigRefURI"]; */
        if (message.cIConfigRefURI !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.cIConfigRefURI);
        /* string DeploymentTier = 15 [json_name = "DeploymentTier"]; */
        if (message.deploymentTier !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.deploymentTier);
        /* string ProjectVisibility = 16 [json_name = "ProjectVisibility"]; */
        if (message.projectVisibility !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.projectVisibility);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ProvisionTokenSpecV2GitLab.Rule
 */
export const ProvisionTokenSpecV2GitLab_Rule = new ProvisionTokenSpecV2GitLab_Rule$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProvisionTokenSpecV2CircleCI$Type extends MessageType<ProvisionTokenSpecV2CircleCI> {
    constructor() {
        super("types.ProvisionTokenSpecV2CircleCI", [
            { no: 1, name: "Allow", kind: "message", jsonName: "Allow", repeat: 1 /*RepeatType.PACKED*/, T: () => ProvisionTokenSpecV2CircleCI_Rule, options: { "gogoproto.jsontag": "allow,omitempty" } },
            { no: 2, name: "OrganizationID", kind: "scalar", jsonName: "OrganizationID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "organization_id,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ProvisionTokenSpecV2CircleCI>): ProvisionTokenSpecV2CircleCI {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.allow = [];
        message.organizationID = "";
        if (value !== undefined)
            reflectionMergePartial<ProvisionTokenSpecV2CircleCI>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProvisionTokenSpecV2CircleCI): ProvisionTokenSpecV2CircleCI {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.ProvisionTokenSpecV2CircleCI.Rule Allow = 1 [json_name = "Allow"];*/ 1:
                    message.allow.push(ProvisionTokenSpecV2CircleCI_Rule.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string OrganizationID = 2 [json_name = "OrganizationID"];*/ 2:
                    message.organizationID = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProvisionTokenSpecV2CircleCI, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.ProvisionTokenSpecV2CircleCI.Rule Allow = 1 [json_name = "Allow"]; */
        for (let i = 0; i < message.allow.length; i++)
            ProvisionTokenSpecV2CircleCI_Rule.internalBinaryWrite(message.allow[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string OrganizationID = 2 [json_name = "OrganizationID"]; */
        if (message.organizationID !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.organizationID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ProvisionTokenSpecV2CircleCI
 */
export const ProvisionTokenSpecV2CircleCI = new ProvisionTokenSpecV2CircleCI$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProvisionTokenSpecV2CircleCI_Rule$Type extends MessageType<ProvisionTokenSpecV2CircleCI_Rule> {
    constructor() {
        super("types.ProvisionTokenSpecV2CircleCI.Rule", [
            { no: 1, name: "ProjectID", kind: "scalar", jsonName: "ProjectID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "project_id,omitempty" } },
            { no: 2, name: "ContextID", kind: "scalar", jsonName: "ContextID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "context_id,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ProvisionTokenSpecV2CircleCI_Rule>): ProvisionTokenSpecV2CircleCI_Rule {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.projectID = "";
        message.contextID = "";
        if (value !== undefined)
            reflectionMergePartial<ProvisionTokenSpecV2CircleCI_Rule>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProvisionTokenSpecV2CircleCI_Rule): ProvisionTokenSpecV2CircleCI_Rule {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ProjectID = 1 [json_name = "ProjectID"];*/ 1:
                    message.projectID = reader.string();
                    break;
                case /* string ContextID = 2 [json_name = "ContextID"];*/ 2:
                    message.contextID = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProvisionTokenSpecV2CircleCI_Rule, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ProjectID = 1 [json_name = "ProjectID"]; */
        if (message.projectID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.projectID);
        /* string ContextID = 2 [json_name = "ContextID"]; */
        if (message.contextID !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.contextID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ProvisionTokenSpecV2CircleCI.Rule
 */
export const ProvisionTokenSpecV2CircleCI_Rule = new ProvisionTokenSpecV2CircleCI_Rule$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProvisionTokenSpecV2Spacelift$Type extends MessageType<ProvisionTokenSpecV2Spacelift> {
    constructor() {
        super("types.ProvisionTokenSpecV2Spacelift", [
            { no: 1, name: "Allow", kind: "message", jsonName: "Allow", repeat: 1 /*RepeatType.PACKED*/, T: () => ProvisionTokenSpecV2Spacelift_Rule, options: { "gogoproto.jsontag": "allow,omitempty" } },
            { no: 2, name: "Hostname", kind: "scalar", jsonName: "Hostname", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "hostname,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ProvisionTokenSpecV2Spacelift>): ProvisionTokenSpecV2Spacelift {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.allow = [];
        message.hostname = "";
        if (value !== undefined)
            reflectionMergePartial<ProvisionTokenSpecV2Spacelift>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProvisionTokenSpecV2Spacelift): ProvisionTokenSpecV2Spacelift {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.ProvisionTokenSpecV2Spacelift.Rule Allow = 1 [json_name = "Allow"];*/ 1:
                    message.allow.push(ProvisionTokenSpecV2Spacelift_Rule.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string Hostname = 2 [json_name = "Hostname"];*/ 2:
                    message.hostname = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProvisionTokenSpecV2Spacelift, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.ProvisionTokenSpecV2Spacelift.Rule Allow = 1 [json_name = "Allow"]; */
        for (let i = 0; i < message.allow.length; i++)
            ProvisionTokenSpecV2Spacelift_Rule.internalBinaryWrite(message.allow[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string Hostname = 2 [json_name = "Hostname"]; */
        if (message.hostname !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.hostname);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ProvisionTokenSpecV2Spacelift
 */
export const ProvisionTokenSpecV2Spacelift = new ProvisionTokenSpecV2Spacelift$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProvisionTokenSpecV2Spacelift_Rule$Type extends MessageType<ProvisionTokenSpecV2Spacelift_Rule> {
    constructor() {
        super("types.ProvisionTokenSpecV2Spacelift.Rule", [
            { no: 1, name: "SpaceID", kind: "scalar", jsonName: "SpaceID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "space_id,omitempty" } },
            { no: 2, name: "CallerID", kind: "scalar", jsonName: "CallerID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "caller_id,omitempty" } },
            { no: 3, name: "CallerType", kind: "scalar", jsonName: "CallerType", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "caller_type,omitempty" } },
            { no: 4, name: "Scope", kind: "scalar", jsonName: "Scope", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "scope,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ProvisionTokenSpecV2Spacelift_Rule>): ProvisionTokenSpecV2Spacelift_Rule {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.spaceID = "";
        message.callerID = "";
        message.callerType = "";
        message.scope = "";
        if (value !== undefined)
            reflectionMergePartial<ProvisionTokenSpecV2Spacelift_Rule>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProvisionTokenSpecV2Spacelift_Rule): ProvisionTokenSpecV2Spacelift_Rule {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string SpaceID = 1 [json_name = "SpaceID"];*/ 1:
                    message.spaceID = reader.string();
                    break;
                case /* string CallerID = 2 [json_name = "CallerID"];*/ 2:
                    message.callerID = reader.string();
                    break;
                case /* string CallerType = 3 [json_name = "CallerType"];*/ 3:
                    message.callerType = reader.string();
                    break;
                case /* string Scope = 4 [json_name = "Scope"];*/ 4:
                    message.scope = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProvisionTokenSpecV2Spacelift_Rule, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string SpaceID = 1 [json_name = "SpaceID"]; */
        if (message.spaceID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.spaceID);
        /* string CallerID = 2 [json_name = "CallerID"]; */
        if (message.callerID !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.callerID);
        /* string CallerType = 3 [json_name = "CallerType"]; */
        if (message.callerType !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.callerType);
        /* string Scope = 4 [json_name = "Scope"]; */
        if (message.scope !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.scope);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ProvisionTokenSpecV2Spacelift.Rule
 */
export const ProvisionTokenSpecV2Spacelift_Rule = new ProvisionTokenSpecV2Spacelift_Rule$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProvisionTokenSpecV2Kubernetes$Type extends MessageType<ProvisionTokenSpecV2Kubernetes> {
    constructor() {
        super("types.ProvisionTokenSpecV2Kubernetes", [
            { no: 1, name: "Allow", kind: "message", jsonName: "Allow", repeat: 1 /*RepeatType.PACKED*/, T: () => ProvisionTokenSpecV2Kubernetes_Rule, options: { "gogoproto.jsontag": "allow,omitempty" } },
            { no: 2, name: "Type", kind: "scalar", jsonName: "Type", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "type,omitempty", "gogoproto.casttype": "KubernetesJoinType" } },
            { no: 3, name: "StaticJWKS", kind: "message", jsonName: "StaticJWKS", T: () => ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig, options: { "gogoproto.jsontag": "static_jwks,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ProvisionTokenSpecV2Kubernetes>): ProvisionTokenSpecV2Kubernetes {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.allow = [];
        message.type = "";
        if (value !== undefined)
            reflectionMergePartial<ProvisionTokenSpecV2Kubernetes>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProvisionTokenSpecV2Kubernetes): ProvisionTokenSpecV2Kubernetes {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.ProvisionTokenSpecV2Kubernetes.Rule Allow = 1 [json_name = "Allow"];*/ 1:
                    message.allow.push(ProvisionTokenSpecV2Kubernetes_Rule.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string Type = 2 [json_name = "Type"];*/ 2:
                    message.type = reader.string();
                    break;
                case /* types.ProvisionTokenSpecV2Kubernetes.StaticJWKSConfig StaticJWKS = 3 [json_name = "StaticJWKS"];*/ 3:
                    message.staticJWKS = ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig.internalBinaryRead(reader, reader.uint32(), options, message.staticJWKS);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProvisionTokenSpecV2Kubernetes, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.ProvisionTokenSpecV2Kubernetes.Rule Allow = 1 [json_name = "Allow"]; */
        for (let i = 0; i < message.allow.length; i++)
            ProvisionTokenSpecV2Kubernetes_Rule.internalBinaryWrite(message.allow[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string Type = 2 [json_name = "Type"]; */
        if (message.type !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.type);
        /* types.ProvisionTokenSpecV2Kubernetes.StaticJWKSConfig StaticJWKS = 3 [json_name = "StaticJWKS"]; */
        if (message.staticJWKS)
            ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig.internalBinaryWrite(message.staticJWKS, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ProvisionTokenSpecV2Kubernetes
 */
export const ProvisionTokenSpecV2Kubernetes = new ProvisionTokenSpecV2Kubernetes$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig$Type extends MessageType<ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig> {
    constructor() {
        super("types.ProvisionTokenSpecV2Kubernetes.StaticJWKSConfig", [
            { no: 1, name: "JWKS", kind: "scalar", jsonName: "JWKS", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "jwks,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig>): ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.jWKS = "";
        if (value !== undefined)
            reflectionMergePartial<ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig): ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string JWKS = 1 [json_name = "JWKS"];*/ 1:
                    message.jWKS = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string JWKS = 1 [json_name = "JWKS"]; */
        if (message.jWKS !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.jWKS);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ProvisionTokenSpecV2Kubernetes.StaticJWKSConfig
 */
export const ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig = new ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProvisionTokenSpecV2Kubernetes_Rule$Type extends MessageType<ProvisionTokenSpecV2Kubernetes_Rule> {
    constructor() {
        super("types.ProvisionTokenSpecV2Kubernetes.Rule", [
            { no: 1, name: "ServiceAccount", kind: "scalar", jsonName: "ServiceAccount", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "service_account,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ProvisionTokenSpecV2Kubernetes_Rule>): ProvisionTokenSpecV2Kubernetes_Rule {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.serviceAccount = "";
        if (value !== undefined)
            reflectionMergePartial<ProvisionTokenSpecV2Kubernetes_Rule>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProvisionTokenSpecV2Kubernetes_Rule): ProvisionTokenSpecV2Kubernetes_Rule {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ServiceAccount = 1 [json_name = "ServiceAccount"];*/ 1:
                    message.serviceAccount = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProvisionTokenSpecV2Kubernetes_Rule, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ServiceAccount = 1 [json_name = "ServiceAccount"]; */
        if (message.serviceAccount !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.serviceAccount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ProvisionTokenSpecV2Kubernetes.Rule
 */
export const ProvisionTokenSpecV2Kubernetes_Rule = new ProvisionTokenSpecV2Kubernetes_Rule$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProvisionTokenSpecV2Azure$Type extends MessageType<ProvisionTokenSpecV2Azure> {
    constructor() {
        super("types.ProvisionTokenSpecV2Azure", [
            { no: 1, name: "Allow", kind: "message", jsonName: "Allow", repeat: 1 /*RepeatType.PACKED*/, T: () => ProvisionTokenSpecV2Azure_Rule, options: { "gogoproto.jsontag": "allow,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ProvisionTokenSpecV2Azure>): ProvisionTokenSpecV2Azure {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.allow = [];
        if (value !== undefined)
            reflectionMergePartial<ProvisionTokenSpecV2Azure>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProvisionTokenSpecV2Azure): ProvisionTokenSpecV2Azure {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.ProvisionTokenSpecV2Azure.Rule Allow = 1 [json_name = "Allow"];*/ 1:
                    message.allow.push(ProvisionTokenSpecV2Azure_Rule.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProvisionTokenSpecV2Azure, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.ProvisionTokenSpecV2Azure.Rule Allow = 1 [json_name = "Allow"]; */
        for (let i = 0; i < message.allow.length; i++)
            ProvisionTokenSpecV2Azure_Rule.internalBinaryWrite(message.allow[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ProvisionTokenSpecV2Azure
 */
export const ProvisionTokenSpecV2Azure = new ProvisionTokenSpecV2Azure$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProvisionTokenSpecV2Azure_Rule$Type extends MessageType<ProvisionTokenSpecV2Azure_Rule> {
    constructor() {
        super("types.ProvisionTokenSpecV2Azure.Rule", [
            { no: 1, name: "Subscription", kind: "scalar", jsonName: "Subscription", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "subscription,omitempty" } },
            { no: 2, name: "ResourceGroups", kind: "scalar", jsonName: "ResourceGroups", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "resource_groups,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ProvisionTokenSpecV2Azure_Rule>): ProvisionTokenSpecV2Azure_Rule {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subscription = "";
        message.resourceGroups = [];
        if (value !== undefined)
            reflectionMergePartial<ProvisionTokenSpecV2Azure_Rule>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProvisionTokenSpecV2Azure_Rule): ProvisionTokenSpecV2Azure_Rule {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Subscription = 1 [json_name = "Subscription"];*/ 1:
                    message.subscription = reader.string();
                    break;
                case /* repeated string ResourceGroups = 2 [json_name = "ResourceGroups"];*/ 2:
                    message.resourceGroups.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProvisionTokenSpecV2Azure_Rule, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Subscription = 1 [json_name = "Subscription"]; */
        if (message.subscription !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subscription);
        /* repeated string ResourceGroups = 2 [json_name = "ResourceGroups"]; */
        for (let i = 0; i < message.resourceGroups.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.resourceGroups[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ProvisionTokenSpecV2Azure.Rule
 */
export const ProvisionTokenSpecV2Azure_Rule = new ProvisionTokenSpecV2Azure_Rule$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProvisionTokenSpecV2GCP$Type extends MessageType<ProvisionTokenSpecV2GCP> {
    constructor() {
        super("types.ProvisionTokenSpecV2GCP", [
            { no: 1, name: "Allow", kind: "message", jsonName: "Allow", repeat: 1 /*RepeatType.PACKED*/, T: () => ProvisionTokenSpecV2GCP_Rule, options: { "gogoproto.jsontag": "allow,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ProvisionTokenSpecV2GCP>): ProvisionTokenSpecV2GCP {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.allow = [];
        if (value !== undefined)
            reflectionMergePartial<ProvisionTokenSpecV2GCP>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProvisionTokenSpecV2GCP): ProvisionTokenSpecV2GCP {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.ProvisionTokenSpecV2GCP.Rule Allow = 1 [json_name = "Allow"];*/ 1:
                    message.allow.push(ProvisionTokenSpecV2GCP_Rule.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProvisionTokenSpecV2GCP, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.ProvisionTokenSpecV2GCP.Rule Allow = 1 [json_name = "Allow"]; */
        for (let i = 0; i < message.allow.length; i++)
            ProvisionTokenSpecV2GCP_Rule.internalBinaryWrite(message.allow[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ProvisionTokenSpecV2GCP
 */
export const ProvisionTokenSpecV2GCP = new ProvisionTokenSpecV2GCP$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProvisionTokenSpecV2GCP_Rule$Type extends MessageType<ProvisionTokenSpecV2GCP_Rule> {
    constructor() {
        super("types.ProvisionTokenSpecV2GCP.Rule", [
            { no: 1, name: "ProjectIDs", kind: "scalar", jsonName: "ProjectIDs", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "project_ids,omitempty" } },
            { no: 2, name: "Locations", kind: "scalar", jsonName: "Locations", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "locations,omitempty" } },
            { no: 3, name: "ServiceAccounts", kind: "scalar", jsonName: "ServiceAccounts", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "service_accounts,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ProvisionTokenSpecV2GCP_Rule>): ProvisionTokenSpecV2GCP_Rule {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.projectIDs = [];
        message.locations = [];
        message.serviceAccounts = [];
        if (value !== undefined)
            reflectionMergePartial<ProvisionTokenSpecV2GCP_Rule>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProvisionTokenSpecV2GCP_Rule): ProvisionTokenSpecV2GCP_Rule {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string ProjectIDs = 1 [json_name = "ProjectIDs"];*/ 1:
                    message.projectIDs.push(reader.string());
                    break;
                case /* repeated string Locations = 2 [json_name = "Locations"];*/ 2:
                    message.locations.push(reader.string());
                    break;
                case /* repeated string ServiceAccounts = 3 [json_name = "ServiceAccounts"];*/ 3:
                    message.serviceAccounts.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProvisionTokenSpecV2GCP_Rule, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string ProjectIDs = 1 [json_name = "ProjectIDs"]; */
        for (let i = 0; i < message.projectIDs.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.projectIDs[i]);
        /* repeated string Locations = 2 [json_name = "Locations"]; */
        for (let i = 0; i < message.locations.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.locations[i]);
        /* repeated string ServiceAccounts = 3 [json_name = "ServiceAccounts"]; */
        for (let i = 0; i < message.serviceAccounts.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.serviceAccounts[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ProvisionTokenSpecV2GCP.Rule
 */
export const ProvisionTokenSpecV2GCP_Rule = new ProvisionTokenSpecV2GCP_Rule$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProvisionTokenSpecV2TerraformCloud$Type extends MessageType<ProvisionTokenSpecV2TerraformCloud> {
    constructor() {
        super("types.ProvisionTokenSpecV2TerraformCloud", [
            { no: 1, name: "Allow", kind: "message", jsonName: "Allow", repeat: 1 /*RepeatType.PACKED*/, T: () => ProvisionTokenSpecV2TerraformCloud_Rule, options: { "gogoproto.jsontag": "allow,omitempty" } },
            { no: 2, name: "Audience", kind: "scalar", jsonName: "Audience", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "audience,omitempty" } },
            { no: 3, name: "Hostname", kind: "scalar", jsonName: "Hostname", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "hostname,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ProvisionTokenSpecV2TerraformCloud>): ProvisionTokenSpecV2TerraformCloud {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.allow = [];
        message.audience = "";
        message.hostname = "";
        if (value !== undefined)
            reflectionMergePartial<ProvisionTokenSpecV2TerraformCloud>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProvisionTokenSpecV2TerraformCloud): ProvisionTokenSpecV2TerraformCloud {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.ProvisionTokenSpecV2TerraformCloud.Rule Allow = 1 [json_name = "Allow"];*/ 1:
                    message.allow.push(ProvisionTokenSpecV2TerraformCloud_Rule.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string Audience = 2 [json_name = "Audience"];*/ 2:
                    message.audience = reader.string();
                    break;
                case /* string Hostname = 3 [json_name = "Hostname"];*/ 3:
                    message.hostname = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProvisionTokenSpecV2TerraformCloud, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.ProvisionTokenSpecV2TerraformCloud.Rule Allow = 1 [json_name = "Allow"]; */
        for (let i = 0; i < message.allow.length; i++)
            ProvisionTokenSpecV2TerraformCloud_Rule.internalBinaryWrite(message.allow[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string Audience = 2 [json_name = "Audience"]; */
        if (message.audience !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.audience);
        /* string Hostname = 3 [json_name = "Hostname"]; */
        if (message.hostname !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.hostname);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ProvisionTokenSpecV2TerraformCloud
 */
export const ProvisionTokenSpecV2TerraformCloud = new ProvisionTokenSpecV2TerraformCloud$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProvisionTokenSpecV2TerraformCloud_Rule$Type extends MessageType<ProvisionTokenSpecV2TerraformCloud_Rule> {
    constructor() {
        super("types.ProvisionTokenSpecV2TerraformCloud.Rule", [
            { no: 1, name: "OrganizationID", kind: "scalar", jsonName: "OrganizationID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "organization_id,omitempty" } },
            { no: 2, name: "OrganizationName", kind: "scalar", jsonName: "OrganizationName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "organization_name,omitempty" } },
            { no: 3, name: "ProjectID", kind: "scalar", jsonName: "ProjectID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "project_id,omitempty" } },
            { no: 4, name: "ProjectName", kind: "scalar", jsonName: "ProjectName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "project_name,omitempty" } },
            { no: 5, name: "WorkspaceID", kind: "scalar", jsonName: "WorkspaceID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "workspace_id,omitempty" } },
            { no: 6, name: "WorkspaceName", kind: "scalar", jsonName: "WorkspaceName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "workspace_name,omitempty" } },
            { no: 7, name: "RunPhase", kind: "scalar", jsonName: "RunPhase", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "run_phase,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ProvisionTokenSpecV2TerraformCloud_Rule>): ProvisionTokenSpecV2TerraformCloud_Rule {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.organizationID = "";
        message.organizationName = "";
        message.projectID = "";
        message.projectName = "";
        message.workspaceID = "";
        message.workspaceName = "";
        message.runPhase = "";
        if (value !== undefined)
            reflectionMergePartial<ProvisionTokenSpecV2TerraformCloud_Rule>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProvisionTokenSpecV2TerraformCloud_Rule): ProvisionTokenSpecV2TerraformCloud_Rule {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string OrganizationID = 1 [json_name = "OrganizationID"];*/ 1:
                    message.organizationID = reader.string();
                    break;
                case /* string OrganizationName = 2 [json_name = "OrganizationName"];*/ 2:
                    message.organizationName = reader.string();
                    break;
                case /* string ProjectID = 3 [json_name = "ProjectID"];*/ 3:
                    message.projectID = reader.string();
                    break;
                case /* string ProjectName = 4 [json_name = "ProjectName"];*/ 4:
                    message.projectName = reader.string();
                    break;
                case /* string WorkspaceID = 5 [json_name = "WorkspaceID"];*/ 5:
                    message.workspaceID = reader.string();
                    break;
                case /* string WorkspaceName = 6 [json_name = "WorkspaceName"];*/ 6:
                    message.workspaceName = reader.string();
                    break;
                case /* string RunPhase = 7 [json_name = "RunPhase"];*/ 7:
                    message.runPhase = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProvisionTokenSpecV2TerraformCloud_Rule, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string OrganizationID = 1 [json_name = "OrganizationID"]; */
        if (message.organizationID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.organizationID);
        /* string OrganizationName = 2 [json_name = "OrganizationName"]; */
        if (message.organizationName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.organizationName);
        /* string ProjectID = 3 [json_name = "ProjectID"]; */
        if (message.projectID !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.projectID);
        /* string ProjectName = 4 [json_name = "ProjectName"]; */
        if (message.projectName !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.projectName);
        /* string WorkspaceID = 5 [json_name = "WorkspaceID"]; */
        if (message.workspaceID !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.workspaceID);
        /* string WorkspaceName = 6 [json_name = "WorkspaceName"]; */
        if (message.workspaceName !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.workspaceName);
        /* string RunPhase = 7 [json_name = "RunPhase"]; */
        if (message.runPhase !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.runPhase);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ProvisionTokenSpecV2TerraformCloud.Rule
 */
export const ProvisionTokenSpecV2TerraformCloud_Rule = new ProvisionTokenSpecV2TerraformCloud_Rule$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProvisionTokenSpecV2Bitbucket$Type extends MessageType<ProvisionTokenSpecV2Bitbucket> {
    constructor() {
        super("types.ProvisionTokenSpecV2Bitbucket", [
            { no: 1, name: "Allow", kind: "message", jsonName: "Allow", repeat: 1 /*RepeatType.PACKED*/, T: () => ProvisionTokenSpecV2Bitbucket_Rule, options: { "gogoproto.jsontag": "allow,omitempty" } },
            { no: 2, name: "Audience", kind: "scalar", jsonName: "Audience", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "audience,omitempty" } },
            { no: 3, name: "IdentityProviderURL", kind: "scalar", jsonName: "IdentityProviderURL", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "identity_provider_url,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ProvisionTokenSpecV2Bitbucket>): ProvisionTokenSpecV2Bitbucket {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.allow = [];
        message.audience = "";
        message.identityProviderURL = "";
        if (value !== undefined)
            reflectionMergePartial<ProvisionTokenSpecV2Bitbucket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProvisionTokenSpecV2Bitbucket): ProvisionTokenSpecV2Bitbucket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.ProvisionTokenSpecV2Bitbucket.Rule Allow = 1 [json_name = "Allow"];*/ 1:
                    message.allow.push(ProvisionTokenSpecV2Bitbucket_Rule.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string Audience = 2 [json_name = "Audience"];*/ 2:
                    message.audience = reader.string();
                    break;
                case /* string IdentityProviderURL = 3 [json_name = "IdentityProviderURL"];*/ 3:
                    message.identityProviderURL = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProvisionTokenSpecV2Bitbucket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.ProvisionTokenSpecV2Bitbucket.Rule Allow = 1 [json_name = "Allow"]; */
        for (let i = 0; i < message.allow.length; i++)
            ProvisionTokenSpecV2Bitbucket_Rule.internalBinaryWrite(message.allow[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string Audience = 2 [json_name = "Audience"]; */
        if (message.audience !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.audience);
        /* string IdentityProviderURL = 3 [json_name = "IdentityProviderURL"]; */
        if (message.identityProviderURL !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.identityProviderURL);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ProvisionTokenSpecV2Bitbucket
 */
export const ProvisionTokenSpecV2Bitbucket = new ProvisionTokenSpecV2Bitbucket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProvisionTokenSpecV2Bitbucket_Rule$Type extends MessageType<ProvisionTokenSpecV2Bitbucket_Rule> {
    constructor() {
        super("types.ProvisionTokenSpecV2Bitbucket.Rule", [
            { no: 1, name: "WorkspaceUUID", kind: "scalar", jsonName: "WorkspaceUUID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "workspace_uuid,omitempty" } },
            { no: 2, name: "RepositoryUUID", kind: "scalar", jsonName: "RepositoryUUID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "repository_uuid,omitempty" } },
            { no: 3, name: "DeploymentEnvironmentUUID", kind: "scalar", jsonName: "DeploymentEnvironmentUUID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "deployment_environment_uuid,omitempty" } },
            { no: 4, name: "BranchName", kind: "scalar", jsonName: "BranchName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "branch_name,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ProvisionTokenSpecV2Bitbucket_Rule>): ProvisionTokenSpecV2Bitbucket_Rule {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workspaceUUID = "";
        message.repositoryUUID = "";
        message.deploymentEnvironmentUUID = "";
        message.branchName = "";
        if (value !== undefined)
            reflectionMergePartial<ProvisionTokenSpecV2Bitbucket_Rule>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProvisionTokenSpecV2Bitbucket_Rule): ProvisionTokenSpecV2Bitbucket_Rule {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string WorkspaceUUID = 1 [json_name = "WorkspaceUUID"];*/ 1:
                    message.workspaceUUID = reader.string();
                    break;
                case /* string RepositoryUUID = 2 [json_name = "RepositoryUUID"];*/ 2:
                    message.repositoryUUID = reader.string();
                    break;
                case /* string DeploymentEnvironmentUUID = 3 [json_name = "DeploymentEnvironmentUUID"];*/ 3:
                    message.deploymentEnvironmentUUID = reader.string();
                    break;
                case /* string BranchName = 4 [json_name = "BranchName"];*/ 4:
                    message.branchName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProvisionTokenSpecV2Bitbucket_Rule, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string WorkspaceUUID = 1 [json_name = "WorkspaceUUID"]; */
        if (message.workspaceUUID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.workspaceUUID);
        /* string RepositoryUUID = 2 [json_name = "RepositoryUUID"]; */
        if (message.repositoryUUID !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.repositoryUUID);
        /* string DeploymentEnvironmentUUID = 3 [json_name = "DeploymentEnvironmentUUID"]; */
        if (message.deploymentEnvironmentUUID !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.deploymentEnvironmentUUID);
        /* string BranchName = 4 [json_name = "BranchName"]; */
        if (message.branchName !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.branchName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ProvisionTokenSpecV2Bitbucket.Rule
 */
export const ProvisionTokenSpecV2Bitbucket_Rule = new ProvisionTokenSpecV2Bitbucket_Rule$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProvisionTokenSpecV2Oracle$Type extends MessageType<ProvisionTokenSpecV2Oracle> {
    constructor() {
        super("types.ProvisionTokenSpecV2Oracle", [
            { no: 1, name: "Allow", kind: "message", jsonName: "Allow", repeat: 1 /*RepeatType.PACKED*/, T: () => ProvisionTokenSpecV2Oracle_Rule, options: { "gogoproto.jsontag": "allow,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ProvisionTokenSpecV2Oracle>): ProvisionTokenSpecV2Oracle {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.allow = [];
        if (value !== undefined)
            reflectionMergePartial<ProvisionTokenSpecV2Oracle>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProvisionTokenSpecV2Oracle): ProvisionTokenSpecV2Oracle {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.ProvisionTokenSpecV2Oracle.Rule Allow = 1 [json_name = "Allow"];*/ 1:
                    message.allow.push(ProvisionTokenSpecV2Oracle_Rule.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProvisionTokenSpecV2Oracle, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.ProvisionTokenSpecV2Oracle.Rule Allow = 1 [json_name = "Allow"]; */
        for (let i = 0; i < message.allow.length; i++)
            ProvisionTokenSpecV2Oracle_Rule.internalBinaryWrite(message.allow[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ProvisionTokenSpecV2Oracle
 */
export const ProvisionTokenSpecV2Oracle = new ProvisionTokenSpecV2Oracle$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProvisionTokenSpecV2Oracle_Rule$Type extends MessageType<ProvisionTokenSpecV2Oracle_Rule> {
    constructor() {
        super("types.ProvisionTokenSpecV2Oracle.Rule", [
            { no: 1, name: "Tenancy", kind: "scalar", jsonName: "Tenancy", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "tenancy" } },
            { no: 2, name: "ParentCompartments", kind: "scalar", jsonName: "ParentCompartments", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "parent_compartments,omitempty" } },
            { no: 3, name: "Regions", kind: "scalar", jsonName: "Regions", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "regions,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ProvisionTokenSpecV2Oracle_Rule>): ProvisionTokenSpecV2Oracle_Rule {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tenancy = "";
        message.parentCompartments = [];
        message.regions = [];
        if (value !== undefined)
            reflectionMergePartial<ProvisionTokenSpecV2Oracle_Rule>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProvisionTokenSpecV2Oracle_Rule): ProvisionTokenSpecV2Oracle_Rule {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Tenancy = 1 [json_name = "Tenancy"];*/ 1:
                    message.tenancy = reader.string();
                    break;
                case /* repeated string ParentCompartments = 2 [json_name = "ParentCompartments"];*/ 2:
                    message.parentCompartments.push(reader.string());
                    break;
                case /* repeated string Regions = 3 [json_name = "Regions"];*/ 3:
                    message.regions.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProvisionTokenSpecV2Oracle_Rule, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Tenancy = 1 [json_name = "Tenancy"]; */
        if (message.tenancy !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tenancy);
        /* repeated string ParentCompartments = 2 [json_name = "ParentCompartments"]; */
        for (let i = 0; i < message.parentCompartments.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.parentCompartments[i]);
        /* repeated string Regions = 3 [json_name = "Regions"]; */
        for (let i = 0; i < message.regions.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.regions[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ProvisionTokenSpecV2Oracle.Rule
 */
export const ProvisionTokenSpecV2Oracle_Rule = new ProvisionTokenSpecV2Oracle_Rule$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProvisionTokenSpecV2BoundKeypair$Type extends MessageType<ProvisionTokenSpecV2BoundKeypair> {
    constructor() {
        super("types.ProvisionTokenSpecV2BoundKeypair", [
            { no: 1, name: "Onboarding", kind: "message", jsonName: "Onboarding", T: () => ProvisionTokenSpecV2BoundKeypair_OnboardingSpec, options: { "gogoproto.jsontag": "onboarding" } },
            { no: 2, name: "Recovery", kind: "message", jsonName: "Recovery", T: () => ProvisionTokenSpecV2BoundKeypair_RecoverySpec, options: { "gogoproto.jsontag": "recovery" } },
            { no: 3, name: "RotateAfter", kind: "message", jsonName: "RotateAfter", T: () => Timestamp, options: { "gogoproto.nullable": true, "gogoproto.jsontag": "rotate_after,omitempty", "gogoproto.stdtime": true } }
        ]);
    }
    create(value?: PartialMessage<ProvisionTokenSpecV2BoundKeypair>): ProvisionTokenSpecV2BoundKeypair {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ProvisionTokenSpecV2BoundKeypair>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProvisionTokenSpecV2BoundKeypair): ProvisionTokenSpecV2BoundKeypair {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.ProvisionTokenSpecV2BoundKeypair.OnboardingSpec Onboarding = 1 [json_name = "Onboarding"];*/ 1:
                    message.onboarding = ProvisionTokenSpecV2BoundKeypair_OnboardingSpec.internalBinaryRead(reader, reader.uint32(), options, message.onboarding);
                    break;
                case /* types.ProvisionTokenSpecV2BoundKeypair.RecoverySpec Recovery = 2 [json_name = "Recovery"];*/ 2:
                    message.recovery = ProvisionTokenSpecV2BoundKeypair_RecoverySpec.internalBinaryRead(reader, reader.uint32(), options, message.recovery);
                    break;
                case /* google.protobuf.Timestamp RotateAfter = 3 [json_name = "RotateAfter"];*/ 3:
                    message.rotateAfter = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.rotateAfter);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProvisionTokenSpecV2BoundKeypair, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.ProvisionTokenSpecV2BoundKeypair.OnboardingSpec Onboarding = 1 [json_name = "Onboarding"]; */
        if (message.onboarding)
            ProvisionTokenSpecV2BoundKeypair_OnboardingSpec.internalBinaryWrite(message.onboarding, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* types.ProvisionTokenSpecV2BoundKeypair.RecoverySpec Recovery = 2 [json_name = "Recovery"]; */
        if (message.recovery)
            ProvisionTokenSpecV2BoundKeypair_RecoverySpec.internalBinaryWrite(message.recovery, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp RotateAfter = 3 [json_name = "RotateAfter"]; */
        if (message.rotateAfter)
            Timestamp.internalBinaryWrite(message.rotateAfter, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ProvisionTokenSpecV2BoundKeypair
 */
export const ProvisionTokenSpecV2BoundKeypair = new ProvisionTokenSpecV2BoundKeypair$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProvisionTokenSpecV2BoundKeypair_OnboardingSpec$Type extends MessageType<ProvisionTokenSpecV2BoundKeypair_OnboardingSpec> {
    constructor() {
        super("types.ProvisionTokenSpecV2BoundKeypair.OnboardingSpec", [
            { no: 1, name: "InitialPublicKey", kind: "scalar", jsonName: "InitialPublicKey", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "initial_public_key,omitempty" } },
            { no: 2, name: "RegistrationSecret", kind: "scalar", jsonName: "RegistrationSecret", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "registration_secret,omitempty" } },
            { no: 3, name: "MustRegisterBefore", kind: "message", jsonName: "MustRegisterBefore", T: () => Timestamp, options: { "gogoproto.nullable": true, "gogoproto.jsontag": "must_register_before,omitempty", "gogoproto.stdtime": true } }
        ]);
    }
    create(value?: PartialMessage<ProvisionTokenSpecV2BoundKeypair_OnboardingSpec>): ProvisionTokenSpecV2BoundKeypair_OnboardingSpec {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.initialPublicKey = "";
        message.registrationSecret = "";
        if (value !== undefined)
            reflectionMergePartial<ProvisionTokenSpecV2BoundKeypair_OnboardingSpec>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProvisionTokenSpecV2BoundKeypair_OnboardingSpec): ProvisionTokenSpecV2BoundKeypair_OnboardingSpec {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string InitialPublicKey = 1 [json_name = "InitialPublicKey"];*/ 1:
                    message.initialPublicKey = reader.string();
                    break;
                case /* string RegistrationSecret = 2 [json_name = "RegistrationSecret"];*/ 2:
                    message.registrationSecret = reader.string();
                    break;
                case /* google.protobuf.Timestamp MustRegisterBefore = 3 [json_name = "MustRegisterBefore"];*/ 3:
                    message.mustRegisterBefore = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.mustRegisterBefore);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProvisionTokenSpecV2BoundKeypair_OnboardingSpec, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string InitialPublicKey = 1 [json_name = "InitialPublicKey"]; */
        if (message.initialPublicKey !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.initialPublicKey);
        /* string RegistrationSecret = 2 [json_name = "RegistrationSecret"]; */
        if (message.registrationSecret !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.registrationSecret);
        /* google.protobuf.Timestamp MustRegisterBefore = 3 [json_name = "MustRegisterBefore"]; */
        if (message.mustRegisterBefore)
            Timestamp.internalBinaryWrite(message.mustRegisterBefore, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ProvisionTokenSpecV2BoundKeypair.OnboardingSpec
 */
export const ProvisionTokenSpecV2BoundKeypair_OnboardingSpec = new ProvisionTokenSpecV2BoundKeypair_OnboardingSpec$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProvisionTokenSpecV2BoundKeypair_RecoverySpec$Type extends MessageType<ProvisionTokenSpecV2BoundKeypair_RecoverySpec> {
    constructor() {
        super("types.ProvisionTokenSpecV2BoundKeypair.RecoverySpec", [
            { no: 1, name: "Limit", kind: "scalar", jsonName: "Limit", T: 13 /*ScalarType.UINT32*/, options: { "gogoproto.jsontag": "limit" } },
            { no: 2, name: "Mode", kind: "scalar", jsonName: "Mode", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "mode" } }
        ]);
    }
    create(value?: PartialMessage<ProvisionTokenSpecV2BoundKeypair_RecoverySpec>): ProvisionTokenSpecV2BoundKeypair_RecoverySpec {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.limit = 0;
        message.mode = "";
        if (value !== undefined)
            reflectionMergePartial<ProvisionTokenSpecV2BoundKeypair_RecoverySpec>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProvisionTokenSpecV2BoundKeypair_RecoverySpec): ProvisionTokenSpecV2BoundKeypair_RecoverySpec {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 Limit = 1 [json_name = "Limit"];*/ 1:
                    message.limit = reader.uint32();
                    break;
                case /* string Mode = 2 [json_name = "Mode"];*/ 2:
                    message.mode = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProvisionTokenSpecV2BoundKeypair_RecoverySpec, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 Limit = 1 [json_name = "Limit"]; */
        if (message.limit !== 0)
            writer.tag(1, WireType.Varint).uint32(message.limit);
        /* string Mode = 2 [json_name = "Mode"]; */
        if (message.mode !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.mode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ProvisionTokenSpecV2BoundKeypair.RecoverySpec
 */
export const ProvisionTokenSpecV2BoundKeypair_RecoverySpec = new ProvisionTokenSpecV2BoundKeypair_RecoverySpec$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProvisionTokenStatusV2$Type extends MessageType<ProvisionTokenStatusV2> {
    constructor() {
        super("types.ProvisionTokenStatusV2", [
            { no: 1, name: "BoundKeypair", kind: "message", jsonName: "BoundKeypair", T: () => ProvisionTokenStatusV2BoundKeypair, options: { "gogoproto.jsontag": "bound_keypair,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ProvisionTokenStatusV2>): ProvisionTokenStatusV2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ProvisionTokenStatusV2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProvisionTokenStatusV2): ProvisionTokenStatusV2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.ProvisionTokenStatusV2BoundKeypair BoundKeypair = 1 [json_name = "BoundKeypair"];*/ 1:
                    message.boundKeypair = ProvisionTokenStatusV2BoundKeypair.internalBinaryRead(reader, reader.uint32(), options, message.boundKeypair);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProvisionTokenStatusV2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.ProvisionTokenStatusV2BoundKeypair BoundKeypair = 1 [json_name = "BoundKeypair"]; */
        if (message.boundKeypair)
            ProvisionTokenStatusV2BoundKeypair.internalBinaryWrite(message.boundKeypair, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ProvisionTokenStatusV2
 */
export const ProvisionTokenStatusV2 = new ProvisionTokenStatusV2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProvisionTokenStatusV2BoundKeypair$Type extends MessageType<ProvisionTokenStatusV2BoundKeypair> {
    constructor() {
        super("types.ProvisionTokenStatusV2BoundKeypair", [
            { no: 1, name: "RegistrationSecret", kind: "scalar", jsonName: "RegistrationSecret", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "registration_secret" } },
            { no: 2, name: "BoundPublicKey", kind: "scalar", jsonName: "BoundPublicKey", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "bound_public_key" } },
            { no: 3, name: "BoundBotInstanceID", kind: "scalar", jsonName: "BoundBotInstanceID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "bound_bot_instance_id" } },
            { no: 4, name: "RecoveryCount", kind: "scalar", jsonName: "RecoveryCount", T: 13 /*ScalarType.UINT32*/, options: { "gogoproto.jsontag": "recovery_count" } },
            { no: 5, name: "LastRecoveredAt", kind: "message", jsonName: "LastRecoveredAt", T: () => Timestamp, options: { "gogoproto.nullable": true, "gogoproto.jsontag": "last_recovered_at,omitempty", "gogoproto.stdtime": true } },
            { no: 6, name: "LastRotatedAt", kind: "message", jsonName: "LastRotatedAt", T: () => Timestamp, options: { "gogoproto.nullable": true, "gogoproto.jsontag": "last_rotated_at,omitempty", "gogoproto.stdtime": true } }
        ]);
    }
    create(value?: PartialMessage<ProvisionTokenStatusV2BoundKeypair>): ProvisionTokenStatusV2BoundKeypair {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.registrationSecret = "";
        message.boundPublicKey = "";
        message.boundBotInstanceID = "";
        message.recoveryCount = 0;
        if (value !== undefined)
            reflectionMergePartial<ProvisionTokenStatusV2BoundKeypair>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProvisionTokenStatusV2BoundKeypair): ProvisionTokenStatusV2BoundKeypair {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string RegistrationSecret = 1 [json_name = "RegistrationSecret"];*/ 1:
                    message.registrationSecret = reader.string();
                    break;
                case /* string BoundPublicKey = 2 [json_name = "BoundPublicKey"];*/ 2:
                    message.boundPublicKey = reader.string();
                    break;
                case /* string BoundBotInstanceID = 3 [json_name = "BoundBotInstanceID"];*/ 3:
                    message.boundBotInstanceID = reader.string();
                    break;
                case /* uint32 RecoveryCount = 4 [json_name = "RecoveryCount"];*/ 4:
                    message.recoveryCount = reader.uint32();
                    break;
                case /* google.protobuf.Timestamp LastRecoveredAt = 5 [json_name = "LastRecoveredAt"];*/ 5:
                    message.lastRecoveredAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastRecoveredAt);
                    break;
                case /* google.protobuf.Timestamp LastRotatedAt = 6 [json_name = "LastRotatedAt"];*/ 6:
                    message.lastRotatedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastRotatedAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProvisionTokenStatusV2BoundKeypair, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string RegistrationSecret = 1 [json_name = "RegistrationSecret"]; */
        if (message.registrationSecret !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.registrationSecret);
        /* string BoundPublicKey = 2 [json_name = "BoundPublicKey"]; */
        if (message.boundPublicKey !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.boundPublicKey);
        /* string BoundBotInstanceID = 3 [json_name = "BoundBotInstanceID"]; */
        if (message.boundBotInstanceID !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.boundBotInstanceID);
        /* uint32 RecoveryCount = 4 [json_name = "RecoveryCount"]; */
        if (message.recoveryCount !== 0)
            writer.tag(4, WireType.Varint).uint32(message.recoveryCount);
        /* google.protobuf.Timestamp LastRecoveredAt = 5 [json_name = "LastRecoveredAt"]; */
        if (message.lastRecoveredAt)
            Timestamp.internalBinaryWrite(message.lastRecoveredAt, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp LastRotatedAt = 6 [json_name = "LastRotatedAt"]; */
        if (message.lastRotatedAt)
            Timestamp.internalBinaryWrite(message.lastRotatedAt, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ProvisionTokenStatusV2BoundKeypair
 */
export const ProvisionTokenStatusV2BoundKeypair = new ProvisionTokenStatusV2BoundKeypair$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StaticTokensV2$Type extends MessageType<StaticTokensV2> {
    constructor() {
        super("types.StaticTokensV2", [
            { no: 1, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 2, name: "SubKind", kind: "scalar", jsonName: "SubKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub_kind,omitempty" } },
            { no: 3, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version" } },
            { no: 4, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "metadata" } },
            { no: 5, name: "Spec", kind: "message", jsonName: "Spec", T: () => StaticTokensSpecV2, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ], { "gogoproto.goproto_stringer": false, "gogoproto.stringer": false });
    }
    create(value?: PartialMessage<StaticTokensV2>): StaticTokensV2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.subKind = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<StaticTokensV2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StaticTokensV2): StaticTokensV2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Kind = 1 [json_name = "Kind"];*/ 1:
                    message.kind = reader.string();
                    break;
                case /* string SubKind = 2 [json_name = "SubKind"];*/ 2:
                    message.subKind = reader.string();
                    break;
                case /* string Version = 3 [json_name = "Version"];*/ 3:
                    message.version = reader.string();
                    break;
                case /* types.Metadata Metadata = 4 [json_name = "Metadata"];*/ 4:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* types.StaticTokensSpecV2 Spec = 5 [json_name = "Spec"];*/ 5:
                    message.spec = StaticTokensSpecV2.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StaticTokensV2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Kind = 1 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string SubKind = 2 [json_name = "SubKind"]; */
        if (message.subKind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subKind);
        /* string Version = 3 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* types.Metadata Metadata = 4 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.StaticTokensSpecV2 Spec = 5 [json_name = "Spec"]; */
        if (message.spec)
            StaticTokensSpecV2.internalBinaryWrite(message.spec, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.StaticTokensV2
 */
export const StaticTokensV2 = new StaticTokensV2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StaticTokensSpecV2$Type extends MessageType<StaticTokensSpecV2> {
    constructor() {
        super("types.StaticTokensSpecV2", [
            { no: 1, name: "StaticTokens", kind: "message", jsonName: "StaticTokens", repeat: 1 /*RepeatType.PACKED*/, T: () => ProvisionTokenV1, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "static_tokens" } }
        ]);
    }
    create(value?: PartialMessage<StaticTokensSpecV2>): StaticTokensSpecV2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.staticTokens = [];
        if (value !== undefined)
            reflectionMergePartial<StaticTokensSpecV2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StaticTokensSpecV2): StaticTokensSpecV2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.ProvisionTokenV1 StaticTokens = 1 [json_name = "StaticTokens"];*/ 1:
                    message.staticTokens.push(ProvisionTokenV1.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StaticTokensSpecV2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.ProvisionTokenV1 StaticTokens = 1 [json_name = "StaticTokens"]; */
        for (let i = 0; i < message.staticTokens.length; i++)
            ProvisionTokenV1.internalBinaryWrite(message.staticTokens[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.StaticTokensSpecV2
 */
export const StaticTokensSpecV2 = new StaticTokensSpecV2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClusterNameV2$Type extends MessageType<ClusterNameV2> {
    constructor() {
        super("types.ClusterNameV2", [
            { no: 1, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 2, name: "SubKind", kind: "scalar", jsonName: "SubKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub_kind,omitempty" } },
            { no: 3, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version" } },
            { no: 4, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "metadata" } },
            { no: 5, name: "Spec", kind: "message", jsonName: "Spec", T: () => ClusterNameSpecV2, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ], { "gogoproto.goproto_stringer": false, "gogoproto.stringer": false });
    }
    create(value?: PartialMessage<ClusterNameV2>): ClusterNameV2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.subKind = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<ClusterNameV2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClusterNameV2): ClusterNameV2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Kind = 1 [json_name = "Kind"];*/ 1:
                    message.kind = reader.string();
                    break;
                case /* string SubKind = 2 [json_name = "SubKind"];*/ 2:
                    message.subKind = reader.string();
                    break;
                case /* string Version = 3 [json_name = "Version"];*/ 3:
                    message.version = reader.string();
                    break;
                case /* types.Metadata Metadata = 4 [json_name = "Metadata"];*/ 4:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* types.ClusterNameSpecV2 Spec = 5 [json_name = "Spec"];*/ 5:
                    message.spec = ClusterNameSpecV2.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClusterNameV2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Kind = 1 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string SubKind = 2 [json_name = "SubKind"]; */
        if (message.subKind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subKind);
        /* string Version = 3 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* types.Metadata Metadata = 4 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.ClusterNameSpecV2 Spec = 5 [json_name = "Spec"]; */
        if (message.spec)
            ClusterNameSpecV2.internalBinaryWrite(message.spec, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ClusterNameV2
 */
export const ClusterNameV2 = new ClusterNameV2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClusterNameSpecV2$Type extends MessageType<ClusterNameSpecV2> {
    constructor() {
        super("types.ClusterNameSpecV2", [
            { no: 1, name: "ClusterName", kind: "scalar", jsonName: "ClusterName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "cluster_name" } },
            { no: 2, name: "ClusterID", kind: "scalar", jsonName: "ClusterID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "cluster_id" } }
        ]);
    }
    create(value?: PartialMessage<ClusterNameSpecV2>): ClusterNameSpecV2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterName = "";
        message.clusterID = "";
        if (value !== undefined)
            reflectionMergePartial<ClusterNameSpecV2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClusterNameSpecV2): ClusterNameSpecV2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ClusterName = 1 [json_name = "ClusterName"];*/ 1:
                    message.clusterName = reader.string();
                    break;
                case /* string ClusterID = 2 [json_name = "ClusterID"];*/ 2:
                    message.clusterID = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClusterNameSpecV2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ClusterName = 1 [json_name = "ClusterName"]; */
        if (message.clusterName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterName);
        /* string ClusterID = 2 [json_name = "ClusterID"]; */
        if (message.clusterID !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.clusterID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ClusterNameSpecV2
 */
export const ClusterNameSpecV2 = new ClusterNameSpecV2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClusterAuditConfigV2$Type extends MessageType<ClusterAuditConfigV2> {
    constructor() {
        super("types.ClusterAuditConfigV2", [
            { no: 1, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 2, name: "SubKind", kind: "scalar", jsonName: "SubKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub_kind,omitempty" } },
            { no: 3, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version" } },
            { no: 4, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "metadata" } },
            { no: 5, name: "Spec", kind: "message", jsonName: "Spec", T: () => ClusterAuditConfigSpecV2, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ]);
    }
    create(value?: PartialMessage<ClusterAuditConfigV2>): ClusterAuditConfigV2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.subKind = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<ClusterAuditConfigV2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClusterAuditConfigV2): ClusterAuditConfigV2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Kind = 1 [json_name = "Kind"];*/ 1:
                    message.kind = reader.string();
                    break;
                case /* string SubKind = 2 [json_name = "SubKind"];*/ 2:
                    message.subKind = reader.string();
                    break;
                case /* string Version = 3 [json_name = "Version"];*/ 3:
                    message.version = reader.string();
                    break;
                case /* types.Metadata Metadata = 4 [json_name = "Metadata"];*/ 4:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* types.ClusterAuditConfigSpecV2 Spec = 5 [json_name = "Spec"];*/ 5:
                    message.spec = ClusterAuditConfigSpecV2.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClusterAuditConfigV2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Kind = 1 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string SubKind = 2 [json_name = "SubKind"]; */
        if (message.subKind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subKind);
        /* string Version = 3 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* types.Metadata Metadata = 4 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.ClusterAuditConfigSpecV2 Spec = 5 [json_name = "Spec"]; */
        if (message.spec)
            ClusterAuditConfigSpecV2.internalBinaryWrite(message.spec, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ClusterAuditConfigV2
 */
export const ClusterAuditConfigV2 = new ClusterAuditConfigV2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClusterAuditConfigSpecV2$Type extends MessageType<ClusterAuditConfigSpecV2> {
    constructor() {
        super("types.ClusterAuditConfigSpecV2", [
            { no: 1, name: "Type", kind: "scalar", jsonName: "Type", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "type,omitempty" } },
            { no: 2, name: "Region", kind: "scalar", jsonName: "Region", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "region,omitempty" } },
            { no: 3, name: "AuditSessionsURI", kind: "scalar", jsonName: "AuditSessionsURI", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "audit_sessions_uri,omitempty" } },
            { no: 4, name: "AuditEventsURI", kind: "message", jsonName: "AuditEventsURI", T: () => StringValues, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/gravitational/teleport/api/types/wrappers.Strings", "gogoproto.jsontag": "audit_events_uri,omitempty" } },
            { no: 6, name: "EnableContinuousBackups", kind: "scalar", jsonName: "EnableContinuousBackups", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "continuous_backups,omitempty" } },
            { no: 7, name: "EnableAutoScaling", kind: "scalar", jsonName: "EnableAutoScaling", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "auto_scaling,omitempty" } },
            { no: 8, name: "ReadMaxCapacity", kind: "scalar", jsonName: "ReadMaxCapacity", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "read_max_capacity,omitempty" } },
            { no: 9, name: "ReadMinCapacity", kind: "scalar", jsonName: "ReadMinCapacity", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "read_min_capacity,omitempty" } },
            { no: 10, name: "ReadTargetValue", kind: "scalar", jsonName: "ReadTargetValue", T: 1 /*ScalarType.DOUBLE*/, options: { "gogoproto.jsontag": "read_target_value,omitempty" } },
            { no: 11, name: "WriteMaxCapacity", kind: "scalar", jsonName: "WriteMaxCapacity", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "write_max_capacity,omitempty" } },
            { no: 12, name: "WriteMinCapacity", kind: "scalar", jsonName: "WriteMinCapacity", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "write_min_capacity,omitempty" } },
            { no: 13, name: "WriteTargetValue", kind: "scalar", jsonName: "WriteTargetValue", T: 1 /*ScalarType.DOUBLE*/, options: { "gogoproto.jsontag": "write_target_value,omitempty" } },
            { no: 14, name: "RetentionPeriod", kind: "scalar", jsonName: "RetentionPeriod", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.nullable": true, "gogoproto.jsontag": "retention_period", "gogoproto.casttype": "Duration" } },
            { no: 15, name: "UseFIPSEndpoint", kind: "enum", jsonName: "UseFIPSEndpoint", T: () => ["types.ClusterAuditConfigSpecV2.FIPSEndpointState", ClusterAuditConfigSpecV2_FIPSEndpointState], options: { "gogoproto.jsontag": "use_fips_endpoint,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ClusterAuditConfigSpecV2>): ClusterAuditConfigSpecV2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        message.region = "";
        message.auditSessionsURI = "";
        message.enableContinuousBackups = false;
        message.enableAutoScaling = false;
        message.readMaxCapacity = 0n;
        message.readMinCapacity = 0n;
        message.readTargetValue = 0;
        message.writeMaxCapacity = 0n;
        message.writeMinCapacity = 0n;
        message.writeTargetValue = 0;
        message.retentionPeriod = 0n;
        message.useFIPSEndpoint = 0;
        if (value !== undefined)
            reflectionMergePartial<ClusterAuditConfigSpecV2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClusterAuditConfigSpecV2): ClusterAuditConfigSpecV2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Type = 1 [json_name = "Type"];*/ 1:
                    message.type = reader.string();
                    break;
                case /* string Region = 2 [json_name = "Region"];*/ 2:
                    message.region = reader.string();
                    break;
                case /* string AuditSessionsURI = 3 [json_name = "AuditSessionsURI"];*/ 3:
                    message.auditSessionsURI = reader.string();
                    break;
                case /* wrappers.StringValues AuditEventsURI = 4 [json_name = "AuditEventsURI"];*/ 4:
                    message.auditEventsURI = StringValues.internalBinaryRead(reader, reader.uint32(), options, message.auditEventsURI);
                    break;
                case /* bool EnableContinuousBackups = 6 [json_name = "EnableContinuousBackups"];*/ 6:
                    message.enableContinuousBackups = reader.bool();
                    break;
                case /* bool EnableAutoScaling = 7 [json_name = "EnableAutoScaling"];*/ 7:
                    message.enableAutoScaling = reader.bool();
                    break;
                case /* int64 ReadMaxCapacity = 8 [json_name = "ReadMaxCapacity"];*/ 8:
                    message.readMaxCapacity = reader.int64().toBigInt();
                    break;
                case /* int64 ReadMinCapacity = 9 [json_name = "ReadMinCapacity"];*/ 9:
                    message.readMinCapacity = reader.int64().toBigInt();
                    break;
                case /* double ReadTargetValue = 10 [json_name = "ReadTargetValue"];*/ 10:
                    message.readTargetValue = reader.double();
                    break;
                case /* int64 WriteMaxCapacity = 11 [json_name = "WriteMaxCapacity"];*/ 11:
                    message.writeMaxCapacity = reader.int64().toBigInt();
                    break;
                case /* int64 WriteMinCapacity = 12 [json_name = "WriteMinCapacity"];*/ 12:
                    message.writeMinCapacity = reader.int64().toBigInt();
                    break;
                case /* double WriteTargetValue = 13 [json_name = "WriteTargetValue"];*/ 13:
                    message.writeTargetValue = reader.double();
                    break;
                case /* int64 RetentionPeriod = 14 [json_name = "RetentionPeriod"];*/ 14:
                    message.retentionPeriod = reader.int64().toBigInt();
                    break;
                case /* types.ClusterAuditConfigSpecV2.FIPSEndpointState UseFIPSEndpoint = 15 [json_name = "UseFIPSEndpoint"];*/ 15:
                    message.useFIPSEndpoint = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClusterAuditConfigSpecV2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Type = 1 [json_name = "Type"]; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* string Region = 2 [json_name = "Region"]; */
        if (message.region !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.region);
        /* string AuditSessionsURI = 3 [json_name = "AuditSessionsURI"]; */
        if (message.auditSessionsURI !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.auditSessionsURI);
        /* wrappers.StringValues AuditEventsURI = 4 [json_name = "AuditEventsURI"]; */
        if (message.auditEventsURI)
            StringValues.internalBinaryWrite(message.auditEventsURI, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bool EnableContinuousBackups = 6 [json_name = "EnableContinuousBackups"]; */
        if (message.enableContinuousBackups !== false)
            writer.tag(6, WireType.Varint).bool(message.enableContinuousBackups);
        /* bool EnableAutoScaling = 7 [json_name = "EnableAutoScaling"]; */
        if (message.enableAutoScaling !== false)
            writer.tag(7, WireType.Varint).bool(message.enableAutoScaling);
        /* int64 ReadMaxCapacity = 8 [json_name = "ReadMaxCapacity"]; */
        if (message.readMaxCapacity !== 0n)
            writer.tag(8, WireType.Varint).int64(message.readMaxCapacity);
        /* int64 ReadMinCapacity = 9 [json_name = "ReadMinCapacity"]; */
        if (message.readMinCapacity !== 0n)
            writer.tag(9, WireType.Varint).int64(message.readMinCapacity);
        /* double ReadTargetValue = 10 [json_name = "ReadTargetValue"]; */
        if (message.readTargetValue !== 0)
            writer.tag(10, WireType.Bit64).double(message.readTargetValue);
        /* int64 WriteMaxCapacity = 11 [json_name = "WriteMaxCapacity"]; */
        if (message.writeMaxCapacity !== 0n)
            writer.tag(11, WireType.Varint).int64(message.writeMaxCapacity);
        /* int64 WriteMinCapacity = 12 [json_name = "WriteMinCapacity"]; */
        if (message.writeMinCapacity !== 0n)
            writer.tag(12, WireType.Varint).int64(message.writeMinCapacity);
        /* double WriteTargetValue = 13 [json_name = "WriteTargetValue"]; */
        if (message.writeTargetValue !== 0)
            writer.tag(13, WireType.Bit64).double(message.writeTargetValue);
        /* int64 RetentionPeriod = 14 [json_name = "RetentionPeriod"]; */
        if (message.retentionPeriod !== 0n)
            writer.tag(14, WireType.Varint).int64(message.retentionPeriod);
        /* types.ClusterAuditConfigSpecV2.FIPSEndpointState UseFIPSEndpoint = 15 [json_name = "UseFIPSEndpoint"]; */
        if (message.useFIPSEndpoint !== 0)
            writer.tag(15, WireType.Varint).int32(message.useFIPSEndpoint);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ClusterAuditConfigSpecV2
 */
export const ClusterAuditConfigSpecV2 = new ClusterAuditConfigSpecV2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClusterNetworkingConfigV2$Type extends MessageType<ClusterNetworkingConfigV2> {
    constructor() {
        super("types.ClusterNetworkingConfigV2", [
            { no: 1, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 2, name: "SubKind", kind: "scalar", jsonName: "SubKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub_kind,omitempty" } },
            { no: 3, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version" } },
            { no: 4, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "metadata" } },
            { no: 5, name: "Spec", kind: "message", jsonName: "Spec", T: () => ClusterNetworkingConfigSpecV2, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ]);
    }
    create(value?: PartialMessage<ClusterNetworkingConfigV2>): ClusterNetworkingConfigV2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.subKind = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<ClusterNetworkingConfigV2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClusterNetworkingConfigV2): ClusterNetworkingConfigV2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Kind = 1 [json_name = "Kind"];*/ 1:
                    message.kind = reader.string();
                    break;
                case /* string SubKind = 2 [json_name = "SubKind"];*/ 2:
                    message.subKind = reader.string();
                    break;
                case /* string Version = 3 [json_name = "Version"];*/ 3:
                    message.version = reader.string();
                    break;
                case /* types.Metadata Metadata = 4 [json_name = "Metadata"];*/ 4:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* types.ClusterNetworkingConfigSpecV2 Spec = 5 [json_name = "Spec"];*/ 5:
                    message.spec = ClusterNetworkingConfigSpecV2.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClusterNetworkingConfigV2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Kind = 1 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string SubKind = 2 [json_name = "SubKind"]; */
        if (message.subKind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subKind);
        /* string Version = 3 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* types.Metadata Metadata = 4 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.ClusterNetworkingConfigSpecV2 Spec = 5 [json_name = "Spec"]; */
        if (message.spec)
            ClusterNetworkingConfigSpecV2.internalBinaryWrite(message.spec, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ClusterNetworkingConfigV2
 */
export const ClusterNetworkingConfigV2 = new ClusterNetworkingConfigV2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClusterNetworkingConfigSpecV2$Type extends MessageType<ClusterNetworkingConfigSpecV2> {
    constructor() {
        super("types.ClusterNetworkingConfigSpecV2", [
            { no: 1, name: "ClientIdleTimeout", kind: "scalar", jsonName: "ClientIdleTimeout", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "client_idle_timeout", "gogoproto.casttype": "Duration" } },
            { no: 2, name: "KeepAliveInterval", kind: "scalar", jsonName: "KeepAliveInterval", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "keep_alive_interval", "gogoproto.casttype": "Duration" } },
            { no: 3, name: "KeepAliveCountMax", kind: "scalar", jsonName: "KeepAliveCountMax", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "keep_alive_count_max" } },
            { no: 4, name: "SessionControlTimeout", kind: "scalar", jsonName: "SessionControlTimeout", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "session_control_timeout", "gogoproto.casttype": "Duration" } },
            { no: 5, name: "ClientIdleTimeoutMessage", kind: "scalar", jsonName: "ClientIdleTimeoutMessage", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "idle_timeout_message" } },
            { no: 6, name: "WebIdleTimeout", kind: "scalar", jsonName: "WebIdleTimeout", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "web_idle_timeout", "gogoproto.casttype": "Duration" } },
            { no: 7, name: "ProxyListenerMode", kind: "enum", jsonName: "ProxyListenerMode", T: () => ["types.ProxyListenerMode", ProxyListenerMode], options: { "gogoproto.jsontag": "proxy_listener_mode,omitempty" } },
            { no: 8, name: "RoutingStrategy", kind: "enum", jsonName: "RoutingStrategy", T: () => ["types.RoutingStrategy", RoutingStrategy], options: { "gogoproto.jsontag": "routing_strategy,omitempty" } },
            { no: 9, name: "TunnelStrategy", kind: "message", jsonName: "TunnelStrategy", T: () => TunnelStrategyV1, options: { "gogoproto.jsontag": "tunnel_strategy,omitempty" } },
            { no: 10, name: "ProxyPingInterval", kind: "scalar", jsonName: "ProxyPingInterval", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "proxy_ping_interval,omitempty", "gogoproto.casttype": "Duration" } },
            { no: 11, name: "AssistCommandExecutionWorkers", kind: "scalar", jsonName: "AssistCommandExecutionWorkers", T: 5 /*ScalarType.INT32*/, options: { "gogoproto.jsontag": "assist_command_execution_workers,omitempty" } },
            { no: 12, name: "CaseInsensitiveRouting", kind: "scalar", jsonName: "CaseInsensitiveRouting", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "case_insensitive_routing,omitempty" } },
            { no: 13, name: "SSHDialTimeout", kind: "scalar", jsonName: "SSHDialTimeout", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "ssh_dial_timeout,omitempty", "gogoproto.casttype": "Duration" } }
        ]);
    }
    create(value?: PartialMessage<ClusterNetworkingConfigSpecV2>): ClusterNetworkingConfigSpecV2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clientIdleTimeout = 0n;
        message.keepAliveInterval = 0n;
        message.keepAliveCountMax = 0n;
        message.sessionControlTimeout = 0n;
        message.clientIdleTimeoutMessage = "";
        message.webIdleTimeout = 0n;
        message.proxyListenerMode = 0;
        message.routingStrategy = 0;
        message.proxyPingInterval = 0n;
        message.assistCommandExecutionWorkers = 0;
        message.caseInsensitiveRouting = false;
        message.sSHDialTimeout = 0n;
        if (value !== undefined)
            reflectionMergePartial<ClusterNetworkingConfigSpecV2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClusterNetworkingConfigSpecV2): ClusterNetworkingConfigSpecV2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 ClientIdleTimeout = 1 [json_name = "ClientIdleTimeout"];*/ 1:
                    message.clientIdleTimeout = reader.int64().toBigInt();
                    break;
                case /* int64 KeepAliveInterval = 2 [json_name = "KeepAliveInterval"];*/ 2:
                    message.keepAliveInterval = reader.int64().toBigInt();
                    break;
                case /* int64 KeepAliveCountMax = 3 [json_name = "KeepAliveCountMax"];*/ 3:
                    message.keepAliveCountMax = reader.int64().toBigInt();
                    break;
                case /* int64 SessionControlTimeout = 4 [json_name = "SessionControlTimeout"];*/ 4:
                    message.sessionControlTimeout = reader.int64().toBigInt();
                    break;
                case /* string ClientIdleTimeoutMessage = 5 [json_name = "ClientIdleTimeoutMessage"];*/ 5:
                    message.clientIdleTimeoutMessage = reader.string();
                    break;
                case /* int64 WebIdleTimeout = 6 [json_name = "WebIdleTimeout"];*/ 6:
                    message.webIdleTimeout = reader.int64().toBigInt();
                    break;
                case /* types.ProxyListenerMode ProxyListenerMode = 7 [json_name = "ProxyListenerMode"];*/ 7:
                    message.proxyListenerMode = reader.int32();
                    break;
                case /* types.RoutingStrategy RoutingStrategy = 8 [json_name = "RoutingStrategy"];*/ 8:
                    message.routingStrategy = reader.int32();
                    break;
                case /* types.TunnelStrategyV1 TunnelStrategy = 9 [json_name = "TunnelStrategy"];*/ 9:
                    message.tunnelStrategy = TunnelStrategyV1.internalBinaryRead(reader, reader.uint32(), options, message.tunnelStrategy);
                    break;
                case /* int64 ProxyPingInterval = 10 [json_name = "ProxyPingInterval"];*/ 10:
                    message.proxyPingInterval = reader.int64().toBigInt();
                    break;
                case /* int32 AssistCommandExecutionWorkers = 11 [json_name = "AssistCommandExecutionWorkers"];*/ 11:
                    message.assistCommandExecutionWorkers = reader.int32();
                    break;
                case /* bool CaseInsensitiveRouting = 12 [json_name = "CaseInsensitiveRouting"];*/ 12:
                    message.caseInsensitiveRouting = reader.bool();
                    break;
                case /* int64 SSHDialTimeout = 13 [json_name = "SSHDialTimeout"];*/ 13:
                    message.sSHDialTimeout = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClusterNetworkingConfigSpecV2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 ClientIdleTimeout = 1 [json_name = "ClientIdleTimeout"]; */
        if (message.clientIdleTimeout !== 0n)
            writer.tag(1, WireType.Varint).int64(message.clientIdleTimeout);
        /* int64 KeepAliveInterval = 2 [json_name = "KeepAliveInterval"]; */
        if (message.keepAliveInterval !== 0n)
            writer.tag(2, WireType.Varint).int64(message.keepAliveInterval);
        /* int64 KeepAliveCountMax = 3 [json_name = "KeepAliveCountMax"]; */
        if (message.keepAliveCountMax !== 0n)
            writer.tag(3, WireType.Varint).int64(message.keepAliveCountMax);
        /* int64 SessionControlTimeout = 4 [json_name = "SessionControlTimeout"]; */
        if (message.sessionControlTimeout !== 0n)
            writer.tag(4, WireType.Varint).int64(message.sessionControlTimeout);
        /* string ClientIdleTimeoutMessage = 5 [json_name = "ClientIdleTimeoutMessage"]; */
        if (message.clientIdleTimeoutMessage !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.clientIdleTimeoutMessage);
        /* int64 WebIdleTimeout = 6 [json_name = "WebIdleTimeout"]; */
        if (message.webIdleTimeout !== 0n)
            writer.tag(6, WireType.Varint).int64(message.webIdleTimeout);
        /* types.ProxyListenerMode ProxyListenerMode = 7 [json_name = "ProxyListenerMode"]; */
        if (message.proxyListenerMode !== 0)
            writer.tag(7, WireType.Varint).int32(message.proxyListenerMode);
        /* types.RoutingStrategy RoutingStrategy = 8 [json_name = "RoutingStrategy"]; */
        if (message.routingStrategy !== 0)
            writer.tag(8, WireType.Varint).int32(message.routingStrategy);
        /* types.TunnelStrategyV1 TunnelStrategy = 9 [json_name = "TunnelStrategy"]; */
        if (message.tunnelStrategy)
            TunnelStrategyV1.internalBinaryWrite(message.tunnelStrategy, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* int64 ProxyPingInterval = 10 [json_name = "ProxyPingInterval"]; */
        if (message.proxyPingInterval !== 0n)
            writer.tag(10, WireType.Varint).int64(message.proxyPingInterval);
        /* int32 AssistCommandExecutionWorkers = 11 [json_name = "AssistCommandExecutionWorkers"]; */
        if (message.assistCommandExecutionWorkers !== 0)
            writer.tag(11, WireType.Varint).int32(message.assistCommandExecutionWorkers);
        /* bool CaseInsensitiveRouting = 12 [json_name = "CaseInsensitiveRouting"]; */
        if (message.caseInsensitiveRouting !== false)
            writer.tag(12, WireType.Varint).bool(message.caseInsensitiveRouting);
        /* int64 SSHDialTimeout = 13 [json_name = "SSHDialTimeout"]; */
        if (message.sSHDialTimeout !== 0n)
            writer.tag(13, WireType.Varint).int64(message.sSHDialTimeout);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ClusterNetworkingConfigSpecV2
 */
export const ClusterNetworkingConfigSpecV2 = new ClusterNetworkingConfigSpecV2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TunnelStrategyV1$Type extends MessageType<TunnelStrategyV1> {
    constructor() {
        super("types.TunnelStrategyV1", [
            { no: 1, name: "AgentMesh", kind: "message", jsonName: "AgentMesh", oneof: "strategy", T: () => AgentMeshTunnelStrategy, options: { "gogoproto.jsontag": "agent_mesh,omitempty" } },
            { no: 2, name: "ProxyPeering", kind: "message", jsonName: "ProxyPeering", oneof: "strategy", T: () => ProxyPeeringTunnelStrategy, options: { "gogoproto.jsontag": "proxy_peering,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<TunnelStrategyV1>): TunnelStrategyV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.strategy = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<TunnelStrategyV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TunnelStrategyV1): TunnelStrategyV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.AgentMeshTunnelStrategy AgentMesh = 1 [json_name = "AgentMesh"];*/ 1:
                    message.strategy = {
                        oneofKind: "agentMesh",
                        agentMesh: AgentMeshTunnelStrategy.internalBinaryRead(reader, reader.uint32(), options, (message.strategy as any).agentMesh)
                    };
                    break;
                case /* types.ProxyPeeringTunnelStrategy ProxyPeering = 2 [json_name = "ProxyPeering"];*/ 2:
                    message.strategy = {
                        oneofKind: "proxyPeering",
                        proxyPeering: ProxyPeeringTunnelStrategy.internalBinaryRead(reader, reader.uint32(), options, (message.strategy as any).proxyPeering)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TunnelStrategyV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.AgentMeshTunnelStrategy AgentMesh = 1 [json_name = "AgentMesh"]; */
        if (message.strategy.oneofKind === "agentMesh")
            AgentMeshTunnelStrategy.internalBinaryWrite(message.strategy.agentMesh, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* types.ProxyPeeringTunnelStrategy ProxyPeering = 2 [json_name = "ProxyPeering"]; */
        if (message.strategy.oneofKind === "proxyPeering")
            ProxyPeeringTunnelStrategy.internalBinaryWrite(message.strategy.proxyPeering, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.TunnelStrategyV1
 */
export const TunnelStrategyV1 = new TunnelStrategyV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AgentMeshTunnelStrategy$Type extends MessageType<AgentMeshTunnelStrategy> {
    constructor() {
        super("types.AgentMeshTunnelStrategy", []);
    }
    create(value?: PartialMessage<AgentMeshTunnelStrategy>): AgentMeshTunnelStrategy {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AgentMeshTunnelStrategy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AgentMeshTunnelStrategy): AgentMeshTunnelStrategy {
        return target ?? this.create();
    }
    internalBinaryWrite(message: AgentMeshTunnelStrategy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AgentMeshTunnelStrategy
 */
export const AgentMeshTunnelStrategy = new AgentMeshTunnelStrategy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProxyPeeringTunnelStrategy$Type extends MessageType<ProxyPeeringTunnelStrategy> {
    constructor() {
        super("types.ProxyPeeringTunnelStrategy", [
            { no: 1, name: "AgentConnectionCount", kind: "scalar", jsonName: "AgentConnectionCount", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "agent_connection_count,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ProxyPeeringTunnelStrategy>): ProxyPeeringTunnelStrategy {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.agentConnectionCount = 0n;
        if (value !== undefined)
            reflectionMergePartial<ProxyPeeringTunnelStrategy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProxyPeeringTunnelStrategy): ProxyPeeringTunnelStrategy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 AgentConnectionCount = 1 [json_name = "AgentConnectionCount"];*/ 1:
                    message.agentConnectionCount = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProxyPeeringTunnelStrategy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 AgentConnectionCount = 1 [json_name = "AgentConnectionCount"]; */
        if (message.agentConnectionCount !== 0n)
            writer.tag(1, WireType.Varint).int64(message.agentConnectionCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ProxyPeeringTunnelStrategy
 */
export const ProxyPeeringTunnelStrategy = new ProxyPeeringTunnelStrategy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SessionRecordingConfigV2$Type extends MessageType<SessionRecordingConfigV2> {
    constructor() {
        super("types.SessionRecordingConfigV2", [
            { no: 1, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 2, name: "SubKind", kind: "scalar", jsonName: "SubKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub_kind,omitempty" } },
            { no: 3, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version" } },
            { no: 4, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "metadata" } },
            { no: 5, name: "Spec", kind: "message", jsonName: "Spec", T: () => SessionRecordingConfigSpecV2, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ]);
    }
    create(value?: PartialMessage<SessionRecordingConfigV2>): SessionRecordingConfigV2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.subKind = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<SessionRecordingConfigV2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SessionRecordingConfigV2): SessionRecordingConfigV2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Kind = 1 [json_name = "Kind"];*/ 1:
                    message.kind = reader.string();
                    break;
                case /* string SubKind = 2 [json_name = "SubKind"];*/ 2:
                    message.subKind = reader.string();
                    break;
                case /* string Version = 3 [json_name = "Version"];*/ 3:
                    message.version = reader.string();
                    break;
                case /* types.Metadata Metadata = 4 [json_name = "Metadata"];*/ 4:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* types.SessionRecordingConfigSpecV2 Spec = 5 [json_name = "Spec"];*/ 5:
                    message.spec = SessionRecordingConfigSpecV2.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SessionRecordingConfigV2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Kind = 1 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string SubKind = 2 [json_name = "SubKind"]; */
        if (message.subKind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subKind);
        /* string Version = 3 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* types.Metadata Metadata = 4 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.SessionRecordingConfigSpecV2 Spec = 5 [json_name = "Spec"]; */
        if (message.spec)
            SessionRecordingConfigSpecV2.internalBinaryWrite(message.spec, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.SessionRecordingConfigV2
 */
export const SessionRecordingConfigV2 = new SessionRecordingConfigV2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SessionRecordingConfigSpecV2$Type extends MessageType<SessionRecordingConfigSpecV2> {
    constructor() {
        super("types.SessionRecordingConfigSpecV2", [
            { no: 1, name: "Mode", kind: "scalar", jsonName: "Mode", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "mode" } },
            { no: 2, name: "ProxyChecksHostKeys", kind: "message", jsonName: "ProxyChecksHostKeys", T: () => BoolValue, options: { "gogoproto.nullable": true, "gogoproto.customtype": "BoolOption", "gogoproto.jsontag": "proxy_checks_host_keys" } }
        ]);
    }
    create(value?: PartialMessage<SessionRecordingConfigSpecV2>): SessionRecordingConfigSpecV2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mode = "";
        if (value !== undefined)
            reflectionMergePartial<SessionRecordingConfigSpecV2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SessionRecordingConfigSpecV2): SessionRecordingConfigSpecV2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Mode = 1 [json_name = "Mode"];*/ 1:
                    message.mode = reader.string();
                    break;
                case /* types.BoolValue ProxyChecksHostKeys = 2 [json_name = "ProxyChecksHostKeys"];*/ 2:
                    message.proxyChecksHostKeys = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.proxyChecksHostKeys);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SessionRecordingConfigSpecV2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Mode = 1 [json_name = "Mode"]; */
        if (message.mode !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.mode);
        /* types.BoolValue ProxyChecksHostKeys = 2 [json_name = "ProxyChecksHostKeys"]; */
        if (message.proxyChecksHostKeys)
            BoolValue.internalBinaryWrite(message.proxyChecksHostKeys, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.SessionRecordingConfigSpecV2
 */
export const SessionRecordingConfigSpecV2 = new SessionRecordingConfigSpecV2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthPreferenceV2$Type extends MessageType<AuthPreferenceV2> {
    constructor() {
        super("types.AuthPreferenceV2", [
            { no: 1, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 2, name: "SubKind", kind: "scalar", jsonName: "SubKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub_kind,omitempty" } },
            { no: 3, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version" } },
            { no: 4, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "metadata" } },
            { no: 5, name: "Spec", kind: "message", jsonName: "Spec", T: () => AuthPreferenceSpecV2, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ], { "gogoproto.goproto_stringer": false, "gogoproto.stringer": false });
    }
    create(value?: PartialMessage<AuthPreferenceV2>): AuthPreferenceV2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.subKind = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<AuthPreferenceV2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthPreferenceV2): AuthPreferenceV2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Kind = 1 [json_name = "Kind"];*/ 1:
                    message.kind = reader.string();
                    break;
                case /* string SubKind = 2 [json_name = "SubKind"];*/ 2:
                    message.subKind = reader.string();
                    break;
                case /* string Version = 3 [json_name = "Version"];*/ 3:
                    message.version = reader.string();
                    break;
                case /* types.Metadata Metadata = 4 [json_name = "Metadata"];*/ 4:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* types.AuthPreferenceSpecV2 Spec = 5 [json_name = "Spec"];*/ 5:
                    message.spec = AuthPreferenceSpecV2.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthPreferenceV2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Kind = 1 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string SubKind = 2 [json_name = "SubKind"]; */
        if (message.subKind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subKind);
        /* string Version = 3 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* types.Metadata Metadata = 4 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.AuthPreferenceSpecV2 Spec = 5 [json_name = "Spec"]; */
        if (message.spec)
            AuthPreferenceSpecV2.internalBinaryWrite(message.spec, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AuthPreferenceV2
 */
export const AuthPreferenceV2 = new AuthPreferenceV2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthPreferenceSpecV2$Type extends MessageType<AuthPreferenceSpecV2> {
    constructor() {
        super("types.AuthPreferenceSpecV2", [
            { no: 1, name: "Type", kind: "scalar", jsonName: "Type", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "type" } },
            { no: 2, name: "SecondFactor", kind: "scalar", jsonName: "SecondFactor", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "second_factor,omitempty", "gogoproto.casttype": "github.com/gravitational/teleport/api/constants.SecondFactorType" } },
            { no: 3, name: "ConnectorName", kind: "scalar", jsonName: "ConnectorName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "connector_name,omitempty" } },
            { no: 4, name: "U2F", kind: "message", jsonName: "U2F", T: () => U2F, options: { "gogoproto.nullable": true, "gogoproto.jsontag": "u2f,omitempty" } },
            { no: 6, name: "DisconnectExpiredCert", kind: "message", jsonName: "DisconnectExpiredCert", T: () => BoolValue, options: { "gogoproto.nullable": true, "gogoproto.customtype": "BoolOption", "gogoproto.jsontag": "disconnect_expired_cert,omitempty" } },
            { no: 7, name: "AllowLocalAuth", kind: "message", jsonName: "AllowLocalAuth", T: () => BoolValue, options: { "gogoproto.nullable": true, "gogoproto.customtype": "BoolOption", "gogoproto.jsontag": "allow_local_auth,omitempty" } },
            { no: 8, name: "MessageOfTheDay", kind: "scalar", jsonName: "MessageOfTheDay", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "message_of_the_day,omitempty" } },
            { no: 9, name: "LockingMode", kind: "scalar", jsonName: "LockingMode", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "locking_mode,omitempty", "gogoproto.casttype": "github.com/gravitational/teleport/api/constants.LockingMode" } },
            { no: 10, name: "Webauthn", kind: "message", jsonName: "Webauthn", T: () => Webauthn, options: { "gogoproto.jsontag": "webauthn,omitempty" } },
            { no: 11, name: "AllowPasswordless", kind: "message", jsonName: "AllowPasswordless", T: () => BoolValue, options: { "gogoproto.nullable": true, "gogoproto.customtype": "BoolOption", "gogoproto.jsontag": "allow_passwordless,omitempty" } },
            { no: 12, name: "RequireMFAType", kind: "enum", jsonName: "RequireMFAType", T: () => ["types.RequireMFAType", RequireMFAType], options: { "gogoproto.jsontag": "require_session_mfa,omitempty" } },
            { no: 13, name: "DeviceTrust", kind: "message", jsonName: "DeviceTrust", T: () => DeviceTrust, options: { "gogoproto.jsontag": "device_trust,omitempty" } },
            { no: 14, name: "IDP", kind: "message", jsonName: "IDP", T: () => IdPOptions, options: { "gogoproto.jsontag": "idp,omitempty" } },
            { no: 15, name: "AllowHeadless", kind: "message", jsonName: "AllowHeadless", T: () => BoolValue, options: { "gogoproto.nullable": true, "gogoproto.customtype": "BoolOption", "gogoproto.jsontag": "allow_headless,omitempty" } },
            { no: 16, name: "DefaultSessionTTL", kind: "scalar", jsonName: "DefaultSessionTTL", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "default_session_ttl,omitempty", "gogoproto.casttype": "Duration" } },
            { no: 17, name: "Okta", kind: "message", jsonName: "Okta", T: () => OktaOptions, options: { "gogoproto.jsontag": "okta,omitempty" } },
            { no: 19, name: "HardwareKey", kind: "message", jsonName: "HardwareKey", T: () => HardwareKey, options: { "gogoproto.jsontag": "hardware_key,omitempty" } },
            { no: 20, name: "signature_algorithm_suite", kind: "enum", T: () => ["types.SignatureAlgorithmSuite", SignatureAlgorithmSuite, "SIGNATURE_ALGORITHM_SUITE_"] },
            { no: 21, name: "SecondFactors", kind: "enum", jsonName: "SecondFactors", repeat: 1 /*RepeatType.PACKED*/, T: () => ["types.SecondFactorType", SecondFactorType, "SECOND_FACTOR_TYPE_"], options: { "gogoproto.jsontag": "second_factors,omitempty" } },
            { no: 22, name: "stable_unix_user_config", kind: "message", T: () => StableUNIXUserConfig }
        ]);
    }
    create(value?: PartialMessage<AuthPreferenceSpecV2>): AuthPreferenceSpecV2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        message.secondFactor = "";
        message.connectorName = "";
        message.messageOfTheDay = "";
        message.lockingMode = "";
        message.requireMFAType = 0;
        message.defaultSessionTTL = 0n;
        message.signatureAlgorithmSuite = 0;
        message.secondFactors = [];
        if (value !== undefined)
            reflectionMergePartial<AuthPreferenceSpecV2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthPreferenceSpecV2): AuthPreferenceSpecV2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Type = 1 [json_name = "Type"];*/ 1:
                    message.type = reader.string();
                    break;
                case /* string SecondFactor = 2 [deprecated = true, json_name = "SecondFactor"];*/ 2:
                    message.secondFactor = reader.string();
                    break;
                case /* string ConnectorName = 3 [json_name = "ConnectorName"];*/ 3:
                    message.connectorName = reader.string();
                    break;
                case /* types.U2F U2F = 4 [json_name = "U2F"];*/ 4:
                    message.u2F = U2F.internalBinaryRead(reader, reader.uint32(), options, message.u2F);
                    break;
                case /* types.BoolValue DisconnectExpiredCert = 6 [json_name = "DisconnectExpiredCert"];*/ 6:
                    message.disconnectExpiredCert = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.disconnectExpiredCert);
                    break;
                case /* types.BoolValue AllowLocalAuth = 7 [json_name = "AllowLocalAuth"];*/ 7:
                    message.allowLocalAuth = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.allowLocalAuth);
                    break;
                case /* string MessageOfTheDay = 8 [json_name = "MessageOfTheDay"];*/ 8:
                    message.messageOfTheDay = reader.string();
                    break;
                case /* string LockingMode = 9 [json_name = "LockingMode"];*/ 9:
                    message.lockingMode = reader.string();
                    break;
                case /* types.Webauthn Webauthn = 10 [json_name = "Webauthn"];*/ 10:
                    message.webauthn = Webauthn.internalBinaryRead(reader, reader.uint32(), options, message.webauthn);
                    break;
                case /* types.BoolValue AllowPasswordless = 11 [json_name = "AllowPasswordless"];*/ 11:
                    message.allowPasswordless = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.allowPasswordless);
                    break;
                case /* types.RequireMFAType RequireMFAType = 12 [json_name = "RequireMFAType"];*/ 12:
                    message.requireMFAType = reader.int32();
                    break;
                case /* types.DeviceTrust DeviceTrust = 13 [json_name = "DeviceTrust"];*/ 13:
                    message.deviceTrust = DeviceTrust.internalBinaryRead(reader, reader.uint32(), options, message.deviceTrust);
                    break;
                case /* types.IdPOptions IDP = 14 [json_name = "IDP"];*/ 14:
                    message.iDP = IdPOptions.internalBinaryRead(reader, reader.uint32(), options, message.iDP);
                    break;
                case /* types.BoolValue AllowHeadless = 15 [json_name = "AllowHeadless"];*/ 15:
                    message.allowHeadless = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.allowHeadless);
                    break;
                case /* int64 DefaultSessionTTL = 16 [json_name = "DefaultSessionTTL"];*/ 16:
                    message.defaultSessionTTL = reader.int64().toBigInt();
                    break;
                case /* types.OktaOptions Okta = 17 [json_name = "Okta"];*/ 17:
                    message.okta = OktaOptions.internalBinaryRead(reader, reader.uint32(), options, message.okta);
                    break;
                case /* types.HardwareKey HardwareKey = 19 [json_name = "HardwareKey"];*/ 19:
                    message.hardwareKey = HardwareKey.internalBinaryRead(reader, reader.uint32(), options, message.hardwareKey);
                    break;
                case /* types.SignatureAlgorithmSuite signature_algorithm_suite */ 20:
                    message.signatureAlgorithmSuite = reader.int32();
                    break;
                case /* repeated types.SecondFactorType SecondFactors = 21 [json_name = "SecondFactors"];*/ 21:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.secondFactors.push(reader.int32());
                    else
                        message.secondFactors.push(reader.int32());
                    break;
                case /* types.StableUNIXUserConfig stable_unix_user_config */ 22:
                    message.stableUnixUserConfig = StableUNIXUserConfig.internalBinaryRead(reader, reader.uint32(), options, message.stableUnixUserConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthPreferenceSpecV2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Type = 1 [json_name = "Type"]; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* string SecondFactor = 2 [deprecated = true, json_name = "SecondFactor"]; */
        if (message.secondFactor !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.secondFactor);
        /* string ConnectorName = 3 [json_name = "ConnectorName"]; */
        if (message.connectorName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.connectorName);
        /* types.U2F U2F = 4 [json_name = "U2F"]; */
        if (message.u2F)
            U2F.internalBinaryWrite(message.u2F, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.BoolValue DisconnectExpiredCert = 6 [json_name = "DisconnectExpiredCert"]; */
        if (message.disconnectExpiredCert)
            BoolValue.internalBinaryWrite(message.disconnectExpiredCert, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* types.BoolValue AllowLocalAuth = 7 [json_name = "AllowLocalAuth"]; */
        if (message.allowLocalAuth)
            BoolValue.internalBinaryWrite(message.allowLocalAuth, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* string MessageOfTheDay = 8 [json_name = "MessageOfTheDay"]; */
        if (message.messageOfTheDay !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.messageOfTheDay);
        /* string LockingMode = 9 [json_name = "LockingMode"]; */
        if (message.lockingMode !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.lockingMode);
        /* types.Webauthn Webauthn = 10 [json_name = "Webauthn"]; */
        if (message.webauthn)
            Webauthn.internalBinaryWrite(message.webauthn, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* types.BoolValue AllowPasswordless = 11 [json_name = "AllowPasswordless"]; */
        if (message.allowPasswordless)
            BoolValue.internalBinaryWrite(message.allowPasswordless, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* types.RequireMFAType RequireMFAType = 12 [json_name = "RequireMFAType"]; */
        if (message.requireMFAType !== 0)
            writer.tag(12, WireType.Varint).int32(message.requireMFAType);
        /* types.DeviceTrust DeviceTrust = 13 [json_name = "DeviceTrust"]; */
        if (message.deviceTrust)
            DeviceTrust.internalBinaryWrite(message.deviceTrust, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* types.IdPOptions IDP = 14 [json_name = "IDP"]; */
        if (message.iDP)
            IdPOptions.internalBinaryWrite(message.iDP, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* types.BoolValue AllowHeadless = 15 [json_name = "AllowHeadless"]; */
        if (message.allowHeadless)
            BoolValue.internalBinaryWrite(message.allowHeadless, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* int64 DefaultSessionTTL = 16 [json_name = "DefaultSessionTTL"]; */
        if (message.defaultSessionTTL !== 0n)
            writer.tag(16, WireType.Varint).int64(message.defaultSessionTTL);
        /* types.OktaOptions Okta = 17 [json_name = "Okta"]; */
        if (message.okta)
            OktaOptions.internalBinaryWrite(message.okta, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* types.HardwareKey HardwareKey = 19 [json_name = "HardwareKey"]; */
        if (message.hardwareKey)
            HardwareKey.internalBinaryWrite(message.hardwareKey, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* types.SignatureAlgorithmSuite signature_algorithm_suite = 20; */
        if (message.signatureAlgorithmSuite !== 0)
            writer.tag(20, WireType.Varint).int32(message.signatureAlgorithmSuite);
        /* repeated types.SecondFactorType SecondFactors = 21 [json_name = "SecondFactors"]; */
        if (message.secondFactors.length) {
            writer.tag(21, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.secondFactors.length; i++)
                writer.int32(message.secondFactors[i]);
            writer.join();
        }
        /* types.StableUNIXUserConfig stable_unix_user_config = 22; */
        if (message.stableUnixUserConfig)
            StableUNIXUserConfig.internalBinaryWrite(message.stableUnixUserConfig, writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AuthPreferenceSpecV2
 */
export const AuthPreferenceSpecV2 = new AuthPreferenceSpecV2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StableUNIXUserConfig$Type extends MessageType<StableUNIXUserConfig> {
    constructor() {
        super("types.StableUNIXUserConfig", [
            { no: 1, name: "enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "first_uid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "last_uid", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<StableUNIXUserConfig>): StableUNIXUserConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.enabled = false;
        message.firstUid = 0;
        message.lastUid = 0;
        if (value !== undefined)
            reflectionMergePartial<StableUNIXUserConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StableUNIXUserConfig): StableUNIXUserConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool enabled */ 1:
                    message.enabled = reader.bool();
                    break;
                case /* int32 first_uid */ 2:
                    message.firstUid = reader.int32();
                    break;
                case /* int32 last_uid */ 3:
                    message.lastUid = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StableUNIXUserConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool enabled = 1; */
        if (message.enabled !== false)
            writer.tag(1, WireType.Varint).bool(message.enabled);
        /* int32 first_uid = 2; */
        if (message.firstUid !== 0)
            writer.tag(2, WireType.Varint).int32(message.firstUid);
        /* int32 last_uid = 3; */
        if (message.lastUid !== 0)
            writer.tag(3, WireType.Varint).int32(message.lastUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.StableUNIXUserConfig
 */
export const StableUNIXUserConfig = new StableUNIXUserConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class U2F$Type extends MessageType<U2F> {
    constructor() {
        super("types.U2F", [
            { no: 1, name: "AppID", kind: "scalar", jsonName: "AppID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "app_id,omitempty" } },
            { no: 2, name: "Facets", kind: "scalar", jsonName: "Facets", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "facets,omitempty" } },
            { no: 3, name: "DeviceAttestationCAs", kind: "scalar", jsonName: "DeviceAttestationCAs", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "device_attestation_cas,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<U2F>): U2F {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.appID = "";
        message.facets = [];
        message.deviceAttestationCAs = [];
        if (value !== undefined)
            reflectionMergePartial<U2F>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: U2F): U2F {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string AppID = 1 [json_name = "AppID"];*/ 1:
                    message.appID = reader.string();
                    break;
                case /* repeated string Facets = 2 [json_name = "Facets"];*/ 2:
                    message.facets.push(reader.string());
                    break;
                case /* repeated string DeviceAttestationCAs = 3 [json_name = "DeviceAttestationCAs"];*/ 3:
                    message.deviceAttestationCAs.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: U2F, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string AppID = 1 [json_name = "AppID"]; */
        if (message.appID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.appID);
        /* repeated string Facets = 2 [json_name = "Facets"]; */
        for (let i = 0; i < message.facets.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.facets[i]);
        /* repeated string DeviceAttestationCAs = 3 [json_name = "DeviceAttestationCAs"]; */
        for (let i = 0; i < message.deviceAttestationCAs.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.deviceAttestationCAs[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.U2F
 */
export const U2F = new U2F$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Webauthn$Type extends MessageType<Webauthn> {
    constructor() {
        super("types.Webauthn", [
            { no: 1, name: "RPID", kind: "scalar", jsonName: "RPID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "rp_id,omitempty" } },
            { no: 2, name: "AttestationAllowedCAs", kind: "scalar", jsonName: "AttestationAllowedCAs", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "attestation_allowed_cas,omitempty" } },
            { no: 3, name: "AttestationDeniedCAs", kind: "scalar", jsonName: "AttestationDeniedCAs", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "attestation_denied_cas,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<Webauthn>): Webauthn {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rPID = "";
        message.attestationAllowedCAs = [];
        message.attestationDeniedCAs = [];
        if (value !== undefined)
            reflectionMergePartial<Webauthn>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Webauthn): Webauthn {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string RPID = 1 [json_name = "RPID"];*/ 1:
                    message.rPID = reader.string();
                    break;
                case /* repeated string AttestationAllowedCAs = 2 [json_name = "AttestationAllowedCAs"];*/ 2:
                    message.attestationAllowedCAs.push(reader.string());
                    break;
                case /* repeated string AttestationDeniedCAs = 3 [json_name = "AttestationDeniedCAs"];*/ 3:
                    message.attestationDeniedCAs.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Webauthn, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string RPID = 1 [json_name = "RPID"]; */
        if (message.rPID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.rPID);
        /* repeated string AttestationAllowedCAs = 2 [json_name = "AttestationAllowedCAs"]; */
        for (let i = 0; i < message.attestationAllowedCAs.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.attestationAllowedCAs[i]);
        /* repeated string AttestationDeniedCAs = 3 [json_name = "AttestationDeniedCAs"]; */
        for (let i = 0; i < message.attestationDeniedCAs.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.attestationDeniedCAs[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.Webauthn
 */
export const Webauthn = new Webauthn$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeviceTrust$Type extends MessageType<DeviceTrust> {
    constructor() {
        super("types.DeviceTrust", [
            { no: 1, name: "Mode", kind: "scalar", jsonName: "Mode", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "mode,omitempty" } },
            { no: 2, name: "AutoEnroll", kind: "scalar", jsonName: "AutoEnroll", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "auto_enroll,omitempty" } },
            { no: 3, name: "EKCertAllowedCAs", kind: "scalar", jsonName: "EKCertAllowedCAs", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "ekcert_allowed_cas,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<DeviceTrust>): DeviceTrust {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mode = "";
        message.autoEnroll = false;
        message.eKCertAllowedCAs = [];
        if (value !== undefined)
            reflectionMergePartial<DeviceTrust>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeviceTrust): DeviceTrust {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Mode = 1 [json_name = "Mode"];*/ 1:
                    message.mode = reader.string();
                    break;
                case /* bool AutoEnroll = 2 [json_name = "AutoEnroll"];*/ 2:
                    message.autoEnroll = reader.bool();
                    break;
                case /* repeated string EKCertAllowedCAs = 3 [json_name = "EKCertAllowedCAs"];*/ 3:
                    message.eKCertAllowedCAs.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeviceTrust, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Mode = 1 [json_name = "Mode"]; */
        if (message.mode !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.mode);
        /* bool AutoEnroll = 2 [json_name = "AutoEnroll"]; */
        if (message.autoEnroll !== false)
            writer.tag(2, WireType.Varint).bool(message.autoEnroll);
        /* repeated string EKCertAllowedCAs = 3 [json_name = "EKCertAllowedCAs"]; */
        for (let i = 0; i < message.eKCertAllowedCAs.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.eKCertAllowedCAs[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.DeviceTrust
 */
export const DeviceTrust = new DeviceTrust$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HardwareKey$Type extends MessageType<HardwareKey> {
    constructor() {
        super("types.HardwareKey", [
            { no: 1, name: "PIVSlot", kind: "scalar", jsonName: "PIVSlot", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "piv_slot,omitempty" } },
            { no: 2, name: "SerialNumberValidation", kind: "message", jsonName: "SerialNumberValidation", T: () => HardwareKeySerialNumberValidation, options: { "gogoproto.jsontag": "serial_number_validation,omitempty" } },
            { no: 3, name: "PinCacheTTL", kind: "scalar", jsonName: "PinCacheTTL", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "pin_cache_ttl,omitempty", "gogoproto.casttype": "Duration" } }
        ]);
    }
    create(value?: PartialMessage<HardwareKey>): HardwareKey {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pIVSlot = "";
        message.pinCacheTTL = 0n;
        if (value !== undefined)
            reflectionMergePartial<HardwareKey>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HardwareKey): HardwareKey {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string PIVSlot = 1 [json_name = "PIVSlot"];*/ 1:
                    message.pIVSlot = reader.string();
                    break;
                case /* types.HardwareKeySerialNumberValidation SerialNumberValidation = 2 [json_name = "SerialNumberValidation"];*/ 2:
                    message.serialNumberValidation = HardwareKeySerialNumberValidation.internalBinaryRead(reader, reader.uint32(), options, message.serialNumberValidation);
                    break;
                case /* int64 PinCacheTTL = 3 [json_name = "PinCacheTTL"];*/ 3:
                    message.pinCacheTTL = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HardwareKey, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string PIVSlot = 1 [json_name = "PIVSlot"]; */
        if (message.pIVSlot !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.pIVSlot);
        /* types.HardwareKeySerialNumberValidation SerialNumberValidation = 2 [json_name = "SerialNumberValidation"]; */
        if (message.serialNumberValidation)
            HardwareKeySerialNumberValidation.internalBinaryWrite(message.serialNumberValidation, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int64 PinCacheTTL = 3 [json_name = "PinCacheTTL"]; */
        if (message.pinCacheTTL !== 0n)
            writer.tag(3, WireType.Varint).int64(message.pinCacheTTL);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.HardwareKey
 */
export const HardwareKey = new HardwareKey$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HardwareKeySerialNumberValidation$Type extends MessageType<HardwareKeySerialNumberValidation> {
    constructor() {
        super("types.HardwareKeySerialNumberValidation", [
            { no: 1, name: "Enabled", kind: "scalar", jsonName: "Enabled", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "enabled,omitempty" } },
            { no: 2, name: "SerialNumberTraitName", kind: "scalar", jsonName: "SerialNumberTraitName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "serial_number_trait_name,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<HardwareKeySerialNumberValidation>): HardwareKeySerialNumberValidation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.enabled = false;
        message.serialNumberTraitName = "";
        if (value !== undefined)
            reflectionMergePartial<HardwareKeySerialNumberValidation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HardwareKeySerialNumberValidation): HardwareKeySerialNumberValidation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool Enabled = 1 [json_name = "Enabled"];*/ 1:
                    message.enabled = reader.bool();
                    break;
                case /* string SerialNumberTraitName = 2 [json_name = "SerialNumberTraitName"];*/ 2:
                    message.serialNumberTraitName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HardwareKeySerialNumberValidation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool Enabled = 1 [json_name = "Enabled"]; */
        if (message.enabled !== false)
            writer.tag(1, WireType.Varint).bool(message.enabled);
        /* string SerialNumberTraitName = 2 [json_name = "SerialNumberTraitName"]; */
        if (message.serialNumberTraitName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.serialNumberTraitName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.HardwareKeySerialNumberValidation
 */
export const HardwareKeySerialNumberValidation = new HardwareKeySerialNumberValidation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Namespace$Type extends MessageType<Namespace> {
    constructor() {
        super("types.Namespace", [
            { no: 1, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 2, name: "SubKind", kind: "scalar", jsonName: "SubKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub_kind,omitempty" } },
            { no: 3, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version" } },
            { no: 4, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "metadata" } },
            { no: 5, name: "Spec", kind: "message", jsonName: "Spec", T: () => NamespaceSpec, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ]);
    }
    create(value?: PartialMessage<Namespace>): Namespace {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.subKind = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<Namespace>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Namespace): Namespace {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Kind = 1 [json_name = "Kind"];*/ 1:
                    message.kind = reader.string();
                    break;
                case /* string SubKind = 2 [json_name = "SubKind"];*/ 2:
                    message.subKind = reader.string();
                    break;
                case /* string Version = 3 [json_name = "Version"];*/ 3:
                    message.version = reader.string();
                    break;
                case /* types.Metadata Metadata = 4 [json_name = "Metadata"];*/ 4:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* types.NamespaceSpec Spec = 5 [json_name = "Spec"];*/ 5:
                    message.spec = NamespaceSpec.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Namespace, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Kind = 1 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string SubKind = 2 [json_name = "SubKind"]; */
        if (message.subKind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subKind);
        /* string Version = 3 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* types.Metadata Metadata = 4 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.NamespaceSpec Spec = 5 [json_name = "Spec"]; */
        if (message.spec)
            NamespaceSpec.internalBinaryWrite(message.spec, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.Namespace
 */
export const Namespace = new Namespace$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NamespaceSpec$Type extends MessageType<NamespaceSpec> {
    constructor() {
        super("types.NamespaceSpec", []);
    }
    create(value?: PartialMessage<NamespaceSpec>): NamespaceSpec {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<NamespaceSpec>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NamespaceSpec): NamespaceSpec {
        return target ?? this.create();
    }
    internalBinaryWrite(message: NamespaceSpec, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.NamespaceSpec
 */
export const NamespaceSpec = new NamespaceSpec$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserTokenV3$Type extends MessageType<UserTokenV3> {
    constructor() {
        super("types.UserTokenV3", [
            { no: 1, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 2, name: "SubKind", kind: "scalar", jsonName: "SubKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub_kind,omitempty" } },
            { no: 3, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version" } },
            { no: 4, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "metadata" } },
            { no: 5, name: "Spec", kind: "message", jsonName: "Spec", T: () => UserTokenSpecV3, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ], { "gogoproto.goproto_stringer": false, "gogoproto.stringer": false });
    }
    create(value?: PartialMessage<UserTokenV3>): UserTokenV3 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.subKind = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<UserTokenV3>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserTokenV3): UserTokenV3 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Kind = 1 [json_name = "Kind"];*/ 1:
                    message.kind = reader.string();
                    break;
                case /* string SubKind = 2 [json_name = "SubKind"];*/ 2:
                    message.subKind = reader.string();
                    break;
                case /* string Version = 3 [json_name = "Version"];*/ 3:
                    message.version = reader.string();
                    break;
                case /* types.Metadata Metadata = 4 [json_name = "Metadata"];*/ 4:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* types.UserTokenSpecV3 Spec = 5 [json_name = "Spec"];*/ 5:
                    message.spec = UserTokenSpecV3.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserTokenV3, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Kind = 1 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string SubKind = 2 [json_name = "SubKind"]; */
        if (message.subKind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subKind);
        /* string Version = 3 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* types.Metadata Metadata = 4 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.UserTokenSpecV3 Spec = 5 [json_name = "Spec"]; */
        if (message.spec)
            UserTokenSpecV3.internalBinaryWrite(message.spec, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.UserTokenV3
 */
export const UserTokenV3 = new UserTokenV3$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserTokenSpecV3$Type extends MessageType<UserTokenSpecV3> {
    constructor() {
        super("types.UserTokenSpecV3", [
            { no: 1, name: "User", kind: "scalar", jsonName: "User", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "user" } },
            { no: 2, name: "URL", kind: "scalar", jsonName: "URL", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "url" } },
            { no: 3, name: "Usage", kind: "enum", jsonName: "Usage", T: () => ["types.UserTokenUsage", UserTokenUsage], options: { "gogoproto.jsontag": "usage,omitempty" } },
            { no: 4, name: "Created", kind: "message", jsonName: "Created", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "created,omitempty", "gogoproto.stdtime": true } }
        ]);
    }
    create(value?: PartialMessage<UserTokenSpecV3>): UserTokenSpecV3 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.user = "";
        message.uRL = "";
        message.usage = 0;
        if (value !== undefined)
            reflectionMergePartial<UserTokenSpecV3>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserTokenSpecV3): UserTokenSpecV3 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string User = 1 [json_name = "User"];*/ 1:
                    message.user = reader.string();
                    break;
                case /* string URL = 2 [json_name = "URL"];*/ 2:
                    message.uRL = reader.string();
                    break;
                case /* types.UserTokenUsage Usage = 3 [json_name = "Usage"];*/ 3:
                    message.usage = reader.int32();
                    break;
                case /* google.protobuf.Timestamp Created = 4 [json_name = "Created"];*/ 4:
                    message.created = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.created);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserTokenSpecV3, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string User = 1 [json_name = "User"]; */
        if (message.user !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.user);
        /* string URL = 2 [json_name = "URL"]; */
        if (message.uRL !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.uRL);
        /* types.UserTokenUsage Usage = 3 [json_name = "Usage"]; */
        if (message.usage !== 0)
            writer.tag(3, WireType.Varint).int32(message.usage);
        /* google.protobuf.Timestamp Created = 4 [json_name = "Created"]; */
        if (message.created)
            Timestamp.internalBinaryWrite(message.created, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.UserTokenSpecV3
 */
export const UserTokenSpecV3 = new UserTokenSpecV3$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserTokenSecretsV3$Type extends MessageType<UserTokenSecretsV3> {
    constructor() {
        super("types.UserTokenSecretsV3", [
            { no: 1, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 2, name: "SubKind", kind: "scalar", jsonName: "SubKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub_kind,omitempty" } },
            { no: 3, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version" } },
            { no: 4, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "metadata" } },
            { no: 5, name: "Spec", kind: "message", jsonName: "Spec", T: () => UserTokenSecretsSpecV3, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ], { "gogoproto.goproto_stringer": false, "gogoproto.stringer": false });
    }
    create(value?: PartialMessage<UserTokenSecretsV3>): UserTokenSecretsV3 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.subKind = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<UserTokenSecretsV3>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserTokenSecretsV3): UserTokenSecretsV3 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Kind = 1 [json_name = "Kind"];*/ 1:
                    message.kind = reader.string();
                    break;
                case /* string SubKind = 2 [json_name = "SubKind"];*/ 2:
                    message.subKind = reader.string();
                    break;
                case /* string Version = 3 [json_name = "Version"];*/ 3:
                    message.version = reader.string();
                    break;
                case /* types.Metadata Metadata = 4 [json_name = "Metadata"];*/ 4:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* types.UserTokenSecretsSpecV3 Spec = 5 [json_name = "Spec"];*/ 5:
                    message.spec = UserTokenSecretsSpecV3.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserTokenSecretsV3, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Kind = 1 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string SubKind = 2 [json_name = "SubKind"]; */
        if (message.subKind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subKind);
        /* string Version = 3 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* types.Metadata Metadata = 4 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.UserTokenSecretsSpecV3 Spec = 5 [json_name = "Spec"]; */
        if (message.spec)
            UserTokenSecretsSpecV3.internalBinaryWrite(message.spec, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.UserTokenSecretsV3
 */
export const UserTokenSecretsV3 = new UserTokenSecretsV3$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserTokenSecretsSpecV3$Type extends MessageType<UserTokenSecretsSpecV3> {
    constructor() {
        super("types.UserTokenSecretsSpecV3", [
            { no: 1, name: "OTPKey", kind: "scalar", jsonName: "OTPKey", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "opt_key" } },
            { no: 2, name: "QRCode", kind: "scalar", jsonName: "QRCode", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "qr_code,omitempty" } },
            { no: 3, name: "Created", kind: "message", jsonName: "Created", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "created,omitempty", "gogoproto.stdtime": true } }
        ]);
    }
    create(value?: PartialMessage<UserTokenSecretsSpecV3>): UserTokenSecretsSpecV3 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.oTPKey = "";
        message.qRCode = "";
        if (value !== undefined)
            reflectionMergePartial<UserTokenSecretsSpecV3>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserTokenSecretsSpecV3): UserTokenSecretsSpecV3 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string OTPKey = 1 [json_name = "OTPKey"];*/ 1:
                    message.oTPKey = reader.string();
                    break;
                case /* string QRCode = 2 [json_name = "QRCode"];*/ 2:
                    message.qRCode = reader.string();
                    break;
                case /* google.protobuf.Timestamp Created = 3 [json_name = "Created"];*/ 3:
                    message.created = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.created);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserTokenSecretsSpecV3, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string OTPKey = 1 [json_name = "OTPKey"]; */
        if (message.oTPKey !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.oTPKey);
        /* string QRCode = 2 [json_name = "QRCode"]; */
        if (message.qRCode !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.qRCode);
        /* google.protobuf.Timestamp Created = 3 [json_name = "Created"]; */
        if (message.created)
            Timestamp.internalBinaryWrite(message.created, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.UserTokenSecretsSpecV3
 */
export const UserTokenSecretsSpecV3 = new UserTokenSecretsSpecV3$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessRequestV3$Type extends MessageType<AccessRequestV3> {
    constructor() {
        super("types.AccessRequestV3", [
            { no: 1, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 2, name: "SubKind", kind: "scalar", jsonName: "SubKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub_kind,omitempty" } },
            { no: 3, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version" } },
            { no: 4, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "metadata" } },
            { no: 5, name: "Spec", kind: "message", jsonName: "Spec", T: () => AccessRequestSpecV3, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ], { "gogoproto.goproto_stringer": false, "gogoproto.stringer": false });
    }
    create(value?: PartialMessage<AccessRequestV3>): AccessRequestV3 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.subKind = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<AccessRequestV3>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessRequestV3): AccessRequestV3 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Kind = 1 [json_name = "Kind"];*/ 1:
                    message.kind = reader.string();
                    break;
                case /* string SubKind = 2 [json_name = "SubKind"];*/ 2:
                    message.subKind = reader.string();
                    break;
                case /* string Version = 3 [json_name = "Version"];*/ 3:
                    message.version = reader.string();
                    break;
                case /* types.Metadata Metadata = 4 [json_name = "Metadata"];*/ 4:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* types.AccessRequestSpecV3 Spec = 5 [json_name = "Spec"];*/ 5:
                    message.spec = AccessRequestSpecV3.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessRequestV3, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Kind = 1 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string SubKind = 2 [json_name = "SubKind"]; */
        if (message.subKind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subKind);
        /* string Version = 3 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* types.Metadata Metadata = 4 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.AccessRequestSpecV3 Spec = 5 [json_name = "Spec"]; */
        if (message.spec)
            AccessRequestSpecV3.internalBinaryWrite(message.spec, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AccessRequestV3
 */
export const AccessRequestV3 = new AccessRequestV3$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessReviewThreshold$Type extends MessageType<AccessReviewThreshold> {
    constructor() {
        super("types.AccessReviewThreshold", [
            { no: 1, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "name,omitempty" } },
            { no: 2, name: "Filter", kind: "scalar", jsonName: "Filter", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "filter,omitempty" } },
            { no: 3, name: "Approve", kind: "scalar", jsonName: "Approve", T: 13 /*ScalarType.UINT32*/, options: { "gogoproto.jsontag": "approve,omitempty" } },
            { no: 4, name: "Deny", kind: "scalar", jsonName: "Deny", T: 13 /*ScalarType.UINT32*/, options: { "gogoproto.jsontag": "deny,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<AccessReviewThreshold>): AccessReviewThreshold {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.filter = "";
        message.approve = 0;
        message.deny = 0;
        if (value !== undefined)
            reflectionMergePartial<AccessReviewThreshold>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessReviewThreshold): AccessReviewThreshold {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Name = 1 [json_name = "Name"];*/ 1:
                    message.name = reader.string();
                    break;
                case /* string Filter = 2 [json_name = "Filter"];*/ 2:
                    message.filter = reader.string();
                    break;
                case /* uint32 Approve = 3 [json_name = "Approve"];*/ 3:
                    message.approve = reader.uint32();
                    break;
                case /* uint32 Deny = 4 [json_name = "Deny"];*/ 4:
                    message.deny = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessReviewThreshold, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Name = 1 [json_name = "Name"]; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string Filter = 2 [json_name = "Filter"]; */
        if (message.filter !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.filter);
        /* uint32 Approve = 3 [json_name = "Approve"]; */
        if (message.approve !== 0)
            writer.tag(3, WireType.Varint).uint32(message.approve);
        /* uint32 Deny = 4 [json_name = "Deny"]; */
        if (message.deny !== 0)
            writer.tag(4, WireType.Varint).uint32(message.deny);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AccessReviewThreshold
 */
export const AccessReviewThreshold = new AccessReviewThreshold$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PromotedAccessList$Type extends MessageType<PromotedAccessList> {
    constructor() {
        super("types.PromotedAccessList", [
            { no: 1, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "name" } },
            { no: 2, name: "Title", kind: "scalar", jsonName: "Title", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "title" } }
        ]);
    }
    create(value?: PartialMessage<PromotedAccessList>): PromotedAccessList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.title = "";
        if (value !== undefined)
            reflectionMergePartial<PromotedAccessList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PromotedAccessList): PromotedAccessList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Name = 1 [json_name = "Name"];*/ 1:
                    message.name = reader.string();
                    break;
                case /* string Title = 2 [json_name = "Title"];*/ 2:
                    message.title = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PromotedAccessList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Name = 1 [json_name = "Name"]; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string Title = 2 [json_name = "Title"]; */
        if (message.title !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.title);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PromotedAccessList
 */
export const PromotedAccessList = new PromotedAccessList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessReview$Type extends MessageType<AccessReview> {
    constructor() {
        super("types.AccessReview", [
            { no: 1, name: "Author", kind: "scalar", jsonName: "Author", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "author" } },
            { no: 2, name: "Roles", kind: "scalar", jsonName: "Roles", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "roles,omitempty" } },
            { no: 3, name: "ProposedState", kind: "enum", jsonName: "ProposedState", T: () => ["types.RequestState", RequestState], options: { "gogoproto.jsontag": "proposed_state,omitempty" } },
            { no: 4, name: "Reason", kind: "scalar", jsonName: "Reason", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "reason,omitempty" } },
            { no: 5, name: "Created", kind: "message", jsonName: "Created", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "created,omitempty", "gogoproto.stdtime": true } },
            { no: 6, name: "Annotations", kind: "message", jsonName: "Annotations", T: () => LabelValues, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/gravitational/teleport/api/types/wrappers.Traits", "gogoproto.jsontag": "annotations,omitempty" } },
            { no: 7, name: "ThresholdIndexes", kind: "scalar", jsonName: "ThresholdIndexes", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/, options: { "gogoproto.jsontag": "i,omitempty" } },
            { no: 9, name: "accessList", kind: "message", T: () => PromotedAccessList, options: { "gogoproto.jsontag": "access_list,omitempty" } },
            { no: 10, name: "AssumeStartTime", kind: "message", jsonName: "AssumeStartTime", T: () => Timestamp, options: { "gogoproto.nullable": true, "gogoproto.jsontag": "assume_start_time,omitempty", "gogoproto.stdtime": true } }
        ]);
    }
    create(value?: PartialMessage<AccessReview>): AccessReview {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.author = "";
        message.roles = [];
        message.proposedState = 0;
        message.reason = "";
        message.thresholdIndexes = [];
        if (value !== undefined)
            reflectionMergePartial<AccessReview>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessReview): AccessReview {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Author = 1 [json_name = "Author"];*/ 1:
                    message.author = reader.string();
                    break;
                case /* repeated string Roles = 2 [json_name = "Roles"];*/ 2:
                    message.roles.push(reader.string());
                    break;
                case /* types.RequestState ProposedState = 3 [json_name = "ProposedState"];*/ 3:
                    message.proposedState = reader.int32();
                    break;
                case /* string Reason = 4 [json_name = "Reason"];*/ 4:
                    message.reason = reader.string();
                    break;
                case /* google.protobuf.Timestamp Created = 5 [json_name = "Created"];*/ 5:
                    message.created = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.created);
                    break;
                case /* wrappers.LabelValues Annotations = 6 [json_name = "Annotations"];*/ 6:
                    message.annotations = LabelValues.internalBinaryRead(reader, reader.uint32(), options, message.annotations);
                    break;
                case /* repeated uint32 ThresholdIndexes = 7 [json_name = "ThresholdIndexes"];*/ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.thresholdIndexes.push(reader.uint32());
                    else
                        message.thresholdIndexes.push(reader.uint32());
                    break;
                case /* types.PromotedAccessList accessList */ 9:
                    message.accessList = PromotedAccessList.internalBinaryRead(reader, reader.uint32(), options, message.accessList);
                    break;
                case /* google.protobuf.Timestamp AssumeStartTime = 10 [json_name = "AssumeStartTime"];*/ 10:
                    message.assumeStartTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.assumeStartTime);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessReview, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Author = 1 [json_name = "Author"]; */
        if (message.author !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.author);
        /* repeated string Roles = 2 [json_name = "Roles"]; */
        for (let i = 0; i < message.roles.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.roles[i]);
        /* types.RequestState ProposedState = 3 [json_name = "ProposedState"]; */
        if (message.proposedState !== 0)
            writer.tag(3, WireType.Varint).int32(message.proposedState);
        /* string Reason = 4 [json_name = "Reason"]; */
        if (message.reason !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.reason);
        /* google.protobuf.Timestamp Created = 5 [json_name = "Created"]; */
        if (message.created)
            Timestamp.internalBinaryWrite(message.created, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* wrappers.LabelValues Annotations = 6 [json_name = "Annotations"]; */
        if (message.annotations)
            LabelValues.internalBinaryWrite(message.annotations, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 ThresholdIndexes = 7 [json_name = "ThresholdIndexes"]; */
        if (message.thresholdIndexes.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.thresholdIndexes.length; i++)
                writer.uint32(message.thresholdIndexes[i]);
            writer.join();
        }
        /* types.PromotedAccessList accessList = 9; */
        if (message.accessList)
            PromotedAccessList.internalBinaryWrite(message.accessList, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp AssumeStartTime = 10 [json_name = "AssumeStartTime"]; */
        if (message.assumeStartTime)
            Timestamp.internalBinaryWrite(message.assumeStartTime, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AccessReview
 */
export const AccessReview = new AccessReview$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessReviewSubmission$Type extends MessageType<AccessReviewSubmission> {
    constructor() {
        super("types.AccessReviewSubmission", [
            { no: 1, name: "RequestID", kind: "scalar", jsonName: "RequestID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "id,omitempty" } },
            { no: 2, name: "Review", kind: "message", jsonName: "Review", T: () => AccessReview, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "review,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<AccessReviewSubmission>): AccessReviewSubmission {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.requestID = "";
        if (value !== undefined)
            reflectionMergePartial<AccessReviewSubmission>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessReviewSubmission): AccessReviewSubmission {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string RequestID = 1 [json_name = "RequestID"];*/ 1:
                    message.requestID = reader.string();
                    break;
                case /* types.AccessReview Review = 2 [json_name = "Review"];*/ 2:
                    message.review = AccessReview.internalBinaryRead(reader, reader.uint32(), options, message.review);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessReviewSubmission, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string RequestID = 1 [json_name = "RequestID"]; */
        if (message.requestID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.requestID);
        /* types.AccessReview Review = 2 [json_name = "Review"]; */
        if (message.review)
            AccessReview.internalBinaryWrite(message.review, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AccessReviewSubmission
 */
export const AccessReviewSubmission = new AccessReviewSubmission$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ThresholdIndexSet$Type extends MessageType<ThresholdIndexSet> {
    constructor() {
        super("types.ThresholdIndexSet", [
            { no: 1, name: "Indexes", kind: "scalar", jsonName: "Indexes", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/, options: { "gogoproto.jsontag": "i,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ThresholdIndexSet>): ThresholdIndexSet {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.indexes = [];
        if (value !== undefined)
            reflectionMergePartial<ThresholdIndexSet>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ThresholdIndexSet): ThresholdIndexSet {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 Indexes = 1 [json_name = "Indexes"];*/ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.indexes.push(reader.uint32());
                    else
                        message.indexes.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ThresholdIndexSet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 Indexes = 1 [json_name = "Indexes"]; */
        if (message.indexes.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.indexes.length; i++)
                writer.uint32(message.indexes[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ThresholdIndexSet
 */
export const ThresholdIndexSet = new ThresholdIndexSet$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ThresholdIndexSets$Type extends MessageType<ThresholdIndexSets> {
    constructor() {
        super("types.ThresholdIndexSets", [
            { no: 1, name: "Sets", kind: "message", jsonName: "Sets", repeat: 1 /*RepeatType.PACKED*/, T: () => ThresholdIndexSet, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "s,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ThresholdIndexSets>): ThresholdIndexSets {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sets = [];
        if (value !== undefined)
            reflectionMergePartial<ThresholdIndexSets>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ThresholdIndexSets): ThresholdIndexSets {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.ThresholdIndexSet Sets = 1 [json_name = "Sets"];*/ 1:
                    message.sets.push(ThresholdIndexSet.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ThresholdIndexSets, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.ThresholdIndexSet Sets = 1 [json_name = "Sets"]; */
        for (let i = 0; i < message.sets.length; i++)
            ThresholdIndexSet.internalBinaryWrite(message.sets[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ThresholdIndexSets
 */
export const ThresholdIndexSets = new ThresholdIndexSets$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessRequestSpecV3$Type extends MessageType<AccessRequestSpecV3> {
    constructor() {
        super("types.AccessRequestSpecV3", [
            { no: 1, name: "User", kind: "scalar", jsonName: "User", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "user" } },
            { no: 2, name: "Roles", kind: "scalar", jsonName: "Roles", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "roles" } },
            { no: 3, name: "State", kind: "enum", jsonName: "State", T: () => ["types.RequestState", RequestState], options: { "gogoproto.jsontag": "state,omitempty" } },
            { no: 4, name: "Created", kind: "message", jsonName: "Created", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "created,omitempty", "gogoproto.stdtime": true } },
            { no: 5, name: "Expires", kind: "message", jsonName: "Expires", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "expires,omitempty", "gogoproto.stdtime": true } },
            { no: 6, name: "RequestReason", kind: "scalar", jsonName: "RequestReason", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "request_reason,omitempty" } },
            { no: 7, name: "ResolveReason", kind: "scalar", jsonName: "ResolveReason", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "resolve_reason,omitempty" } },
            { no: 8, name: "ResolveAnnotations", kind: "message", jsonName: "ResolveAnnotations", T: () => LabelValues, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/gravitational/teleport/api/types/wrappers.Traits", "gogoproto.jsontag": "resolve_annotations,omitempty" } },
            { no: 9, name: "SystemAnnotations", kind: "message", jsonName: "SystemAnnotations", T: () => LabelValues, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/gravitational/teleport/api/types/wrappers.Traits", "gogoproto.jsontag": "system_annotations,omitempty" } },
            { no: 10, name: "Thresholds", kind: "message", jsonName: "Thresholds", repeat: 1 /*RepeatType.PACKED*/, T: () => AccessReviewThreshold, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "thresholds,omitempty" } },
            { no: 11, name: "RoleThresholdMapping", kind: "map", jsonName: "RoleThresholdMapping", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => ThresholdIndexSets }, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "rtm,omitempty" } },
            { no: 12, name: "Reviews", kind: "message", jsonName: "Reviews", repeat: 1 /*RepeatType.PACKED*/, T: () => AccessReview, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "reviews,omitempty" } },
            { no: 13, name: "SuggestedReviewers", kind: "scalar", jsonName: "SuggestedReviewers", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "suggested_reviewers,omitempty" } },
            { no: 14, name: "RequestedResourceIDs", kind: "message", jsonName: "RequestedResourceIDs", repeat: 1 /*RepeatType.PACKED*/, T: () => ResourceID, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "resource_ids,omitempty" } },
            { no: 15, name: "LoginHint", kind: "scalar", jsonName: "LoginHint", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "login_hint,omitempty" } },
            { no: 16, name: "DryRun", kind: "scalar", jsonName: "DryRun", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "dry_run,omitempty" } },
            { no: 17, name: "MaxDuration", kind: "message", jsonName: "MaxDuration", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "max_duration,omitempty", "gogoproto.stdtime": true } },
            { no: 18, name: "SessionTTL", kind: "message", jsonName: "SessionTTL", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "session_ttl,omitempty", "gogoproto.stdtime": true } },
            { no: 20, name: "accessList", kind: "message", T: () => PromotedAccessList, options: { "gogoproto.jsontag": "access_list,omitempty" } },
            { no: 21, name: "AssumeStartTime", kind: "message", jsonName: "AssumeStartTime", T: () => Timestamp, options: { "gogoproto.nullable": true, "gogoproto.jsontag": "assume_start_time,omitempty", "gogoproto.stdtime": true } },
            { no: 22, name: "ResourceExpiry", kind: "message", jsonName: "ResourceExpiry", T: () => Timestamp, options: { "gogoproto.nullable": true, "gogoproto.jsontag": "expiry,omitempty", "gogoproto.stdtime": true } }
        ]);
    }
    create(value?: PartialMessage<AccessRequestSpecV3>): AccessRequestSpecV3 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.user = "";
        message.roles = [];
        message.state = 0;
        message.requestReason = "";
        message.resolveReason = "";
        message.thresholds = [];
        message.roleThresholdMapping = {};
        message.reviews = [];
        message.suggestedReviewers = [];
        message.requestedResourceIDs = [];
        message.loginHint = "";
        message.dryRun = false;
        if (value !== undefined)
            reflectionMergePartial<AccessRequestSpecV3>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessRequestSpecV3): AccessRequestSpecV3 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string User = 1 [json_name = "User"];*/ 1:
                    message.user = reader.string();
                    break;
                case /* repeated string Roles = 2 [json_name = "Roles"];*/ 2:
                    message.roles.push(reader.string());
                    break;
                case /* types.RequestState State = 3 [json_name = "State"];*/ 3:
                    message.state = reader.int32();
                    break;
                case /* google.protobuf.Timestamp Created = 4 [json_name = "Created"];*/ 4:
                    message.created = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.created);
                    break;
                case /* google.protobuf.Timestamp Expires = 5 [json_name = "Expires"];*/ 5:
                    message.expires = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expires);
                    break;
                case /* string RequestReason = 6 [json_name = "RequestReason"];*/ 6:
                    message.requestReason = reader.string();
                    break;
                case /* string ResolveReason = 7 [json_name = "ResolveReason"];*/ 7:
                    message.resolveReason = reader.string();
                    break;
                case /* wrappers.LabelValues ResolveAnnotations = 8 [json_name = "ResolveAnnotations"];*/ 8:
                    message.resolveAnnotations = LabelValues.internalBinaryRead(reader, reader.uint32(), options, message.resolveAnnotations);
                    break;
                case /* wrappers.LabelValues SystemAnnotations = 9 [json_name = "SystemAnnotations"];*/ 9:
                    message.systemAnnotations = LabelValues.internalBinaryRead(reader, reader.uint32(), options, message.systemAnnotations);
                    break;
                case /* repeated types.AccessReviewThreshold Thresholds = 10 [json_name = "Thresholds"];*/ 10:
                    message.thresholds.push(AccessReviewThreshold.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* map<string, types.ThresholdIndexSets> RoleThresholdMapping = 11 [json_name = "RoleThresholdMapping"];*/ 11:
                    this.binaryReadMap11(message.roleThresholdMapping, reader, options);
                    break;
                case /* repeated types.AccessReview Reviews = 12 [json_name = "Reviews"];*/ 12:
                    message.reviews.push(AccessReview.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string SuggestedReviewers = 13 [json_name = "SuggestedReviewers"];*/ 13:
                    message.suggestedReviewers.push(reader.string());
                    break;
                case /* repeated types.ResourceID RequestedResourceIDs = 14 [json_name = "RequestedResourceIDs"];*/ 14:
                    message.requestedResourceIDs.push(ResourceID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string LoginHint = 15 [json_name = "LoginHint"];*/ 15:
                    message.loginHint = reader.string();
                    break;
                case /* bool DryRun = 16 [json_name = "DryRun"];*/ 16:
                    message.dryRun = reader.bool();
                    break;
                case /* google.protobuf.Timestamp MaxDuration = 17 [json_name = "MaxDuration"];*/ 17:
                    message.maxDuration = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.maxDuration);
                    break;
                case /* google.protobuf.Timestamp SessionTTL = 18 [json_name = "SessionTTL"];*/ 18:
                    message.sessionTTL = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.sessionTTL);
                    break;
                case /* types.PromotedAccessList accessList */ 20:
                    message.accessList = PromotedAccessList.internalBinaryRead(reader, reader.uint32(), options, message.accessList);
                    break;
                case /* google.protobuf.Timestamp AssumeStartTime = 21 [json_name = "AssumeStartTime"];*/ 21:
                    message.assumeStartTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.assumeStartTime);
                    break;
                case /* google.protobuf.Timestamp ResourceExpiry = 22 [json_name = "ResourceExpiry"];*/ 22:
                    message.resourceExpiry = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.resourceExpiry);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap11(map: AccessRequestSpecV3["roleThresholdMapping"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AccessRequestSpecV3["roleThresholdMapping"] | undefined, val: AccessRequestSpecV3["roleThresholdMapping"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = ThresholdIndexSets.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field types.AccessRequestSpecV3.RoleThresholdMapping");
            }
        }
        map[key ?? ""] = val ?? ThresholdIndexSets.create();
    }
    internalBinaryWrite(message: AccessRequestSpecV3, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string User = 1 [json_name = "User"]; */
        if (message.user !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.user);
        /* repeated string Roles = 2 [json_name = "Roles"]; */
        for (let i = 0; i < message.roles.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.roles[i]);
        /* types.RequestState State = 3 [json_name = "State"]; */
        if (message.state !== 0)
            writer.tag(3, WireType.Varint).int32(message.state);
        /* google.protobuf.Timestamp Created = 4 [json_name = "Created"]; */
        if (message.created)
            Timestamp.internalBinaryWrite(message.created, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp Expires = 5 [json_name = "Expires"]; */
        if (message.expires)
            Timestamp.internalBinaryWrite(message.expires, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string RequestReason = 6 [json_name = "RequestReason"]; */
        if (message.requestReason !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.requestReason);
        /* string ResolveReason = 7 [json_name = "ResolveReason"]; */
        if (message.resolveReason !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.resolveReason);
        /* wrappers.LabelValues ResolveAnnotations = 8 [json_name = "ResolveAnnotations"]; */
        if (message.resolveAnnotations)
            LabelValues.internalBinaryWrite(message.resolveAnnotations, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* wrappers.LabelValues SystemAnnotations = 9 [json_name = "SystemAnnotations"]; */
        if (message.systemAnnotations)
            LabelValues.internalBinaryWrite(message.systemAnnotations, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* repeated types.AccessReviewThreshold Thresholds = 10 [json_name = "Thresholds"]; */
        for (let i = 0; i < message.thresholds.length; i++)
            AccessReviewThreshold.internalBinaryWrite(message.thresholds[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* map<string, types.ThresholdIndexSets> RoleThresholdMapping = 11 [json_name = "RoleThresholdMapping"]; */
        for (let k of globalThis.Object.keys(message.roleThresholdMapping)) {
            writer.tag(11, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            ThresholdIndexSets.internalBinaryWrite(message.roleThresholdMapping[k], writer, options);
            writer.join().join();
        }
        /* repeated types.AccessReview Reviews = 12 [json_name = "Reviews"]; */
        for (let i = 0; i < message.reviews.length; i++)
            AccessReview.internalBinaryWrite(message.reviews[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* repeated string SuggestedReviewers = 13 [json_name = "SuggestedReviewers"]; */
        for (let i = 0; i < message.suggestedReviewers.length; i++)
            writer.tag(13, WireType.LengthDelimited).string(message.suggestedReviewers[i]);
        /* repeated types.ResourceID RequestedResourceIDs = 14 [json_name = "RequestedResourceIDs"]; */
        for (let i = 0; i < message.requestedResourceIDs.length; i++)
            ResourceID.internalBinaryWrite(message.requestedResourceIDs[i], writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* string LoginHint = 15 [json_name = "LoginHint"]; */
        if (message.loginHint !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.loginHint);
        /* bool DryRun = 16 [json_name = "DryRun"]; */
        if (message.dryRun !== false)
            writer.tag(16, WireType.Varint).bool(message.dryRun);
        /* google.protobuf.Timestamp MaxDuration = 17 [json_name = "MaxDuration"]; */
        if (message.maxDuration)
            Timestamp.internalBinaryWrite(message.maxDuration, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp SessionTTL = 18 [json_name = "SessionTTL"]; */
        if (message.sessionTTL)
            Timestamp.internalBinaryWrite(message.sessionTTL, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* types.PromotedAccessList accessList = 20; */
        if (message.accessList)
            PromotedAccessList.internalBinaryWrite(message.accessList, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp AssumeStartTime = 21 [json_name = "AssumeStartTime"]; */
        if (message.assumeStartTime)
            Timestamp.internalBinaryWrite(message.assumeStartTime, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp ResourceExpiry = 22 [json_name = "ResourceExpiry"]; */
        if (message.resourceExpiry)
            Timestamp.internalBinaryWrite(message.resourceExpiry, writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AccessRequestSpecV3
 */
export const AccessRequestSpecV3 = new AccessRequestSpecV3$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessRequestFilter$Type extends MessageType<AccessRequestFilter> {
    constructor() {
        super("types.AccessRequestFilter", [
            { no: 1, name: "ID", kind: "scalar", jsonName: "ID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "id,omitempty" } },
            { no: 2, name: "User", kind: "scalar", jsonName: "User", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "user,omitempty" } },
            { no: 3, name: "State", kind: "enum", jsonName: "State", T: () => ["types.RequestState", RequestState], options: { "gogoproto.jsontag": "state,omitempty" } },
            { no: 4, name: "SearchKeywords", kind: "scalar", jsonName: "SearchKeywords", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "search,omitempty" } },
            { no: 5, name: "Scope", kind: "enum", jsonName: "Scope", T: () => ["types.AccessRequestScope", AccessRequestScope], options: { "gogoproto.jsontag": "scope,omitempty" } },
            { no: 6, name: "Requester", kind: "scalar", jsonName: "Requester", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "requester,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<AccessRequestFilter>): AccessRequestFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.iD = "";
        message.user = "";
        message.state = 0;
        message.searchKeywords = [];
        message.scope = 0;
        message.requester = "";
        if (value !== undefined)
            reflectionMergePartial<AccessRequestFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessRequestFilter): AccessRequestFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ID = 1 [json_name = "ID"];*/ 1:
                    message.iD = reader.string();
                    break;
                case /* string User = 2 [json_name = "User"];*/ 2:
                    message.user = reader.string();
                    break;
                case /* types.RequestState State = 3 [json_name = "State"];*/ 3:
                    message.state = reader.int32();
                    break;
                case /* repeated string SearchKeywords = 4 [json_name = "SearchKeywords"];*/ 4:
                    message.searchKeywords.push(reader.string());
                    break;
                case /* types.AccessRequestScope Scope = 5 [json_name = "Scope"];*/ 5:
                    message.scope = reader.int32();
                    break;
                case /* string Requester = 6 [json_name = "Requester"];*/ 6:
                    message.requester = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessRequestFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ID = 1 [json_name = "ID"]; */
        if (message.iD !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.iD);
        /* string User = 2 [json_name = "User"]; */
        if (message.user !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.user);
        /* types.RequestState State = 3 [json_name = "State"]; */
        if (message.state !== 0)
            writer.tag(3, WireType.Varint).int32(message.state);
        /* repeated string SearchKeywords = 4 [json_name = "SearchKeywords"]; */
        for (let i = 0; i < message.searchKeywords.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.searchKeywords[i]);
        /* types.AccessRequestScope Scope = 5 [json_name = "Scope"]; */
        if (message.scope !== 0)
            writer.tag(5, WireType.Varint).int32(message.scope);
        /* string Requester = 6 [json_name = "Requester"]; */
        if (message.requester !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.requester);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AccessRequestFilter
 */
export const AccessRequestFilter = new AccessRequestFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessCapabilities$Type extends MessageType<AccessCapabilities> {
    constructor() {
        super("types.AccessCapabilities", [
            { no: 1, name: "RequestableRoles", kind: "scalar", jsonName: "RequestableRoles", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "requestable_roles,omitempty" } },
            { no: 2, name: "SuggestedReviewers", kind: "scalar", jsonName: "SuggestedReviewers", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "suggested_reviewers,omitempty" } },
            { no: 3, name: "ApplicableRolesForResources", kind: "scalar", jsonName: "ApplicableRolesForResources", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "applicable_roles,omitempty" } },
            { no: 4, name: "RequestPrompt", kind: "scalar", jsonName: "RequestPrompt", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "request_prompt,omitempty" } },
            { no: 5, name: "RequireReason", kind: "scalar", jsonName: "RequireReason", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "require_reason,omitempty" } },
            { no: 6, name: "AutoRequest", kind: "scalar", jsonName: "AutoRequest", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "auto_request,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<AccessCapabilities>): AccessCapabilities {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.requestableRoles = [];
        message.suggestedReviewers = [];
        message.applicableRolesForResources = [];
        message.requestPrompt = "";
        message.requireReason = false;
        message.autoRequest = false;
        if (value !== undefined)
            reflectionMergePartial<AccessCapabilities>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessCapabilities): AccessCapabilities {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string RequestableRoles = 1 [json_name = "RequestableRoles"];*/ 1:
                    message.requestableRoles.push(reader.string());
                    break;
                case /* repeated string SuggestedReviewers = 2 [json_name = "SuggestedReviewers"];*/ 2:
                    message.suggestedReviewers.push(reader.string());
                    break;
                case /* repeated string ApplicableRolesForResources = 3 [json_name = "ApplicableRolesForResources"];*/ 3:
                    message.applicableRolesForResources.push(reader.string());
                    break;
                case /* string RequestPrompt = 4 [json_name = "RequestPrompt"];*/ 4:
                    message.requestPrompt = reader.string();
                    break;
                case /* bool RequireReason = 5 [json_name = "RequireReason"];*/ 5:
                    message.requireReason = reader.bool();
                    break;
                case /* bool AutoRequest = 6 [json_name = "AutoRequest"];*/ 6:
                    message.autoRequest = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessCapabilities, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string RequestableRoles = 1 [json_name = "RequestableRoles"]; */
        for (let i = 0; i < message.requestableRoles.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.requestableRoles[i]);
        /* repeated string SuggestedReviewers = 2 [json_name = "SuggestedReviewers"]; */
        for (let i = 0; i < message.suggestedReviewers.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.suggestedReviewers[i]);
        /* repeated string ApplicableRolesForResources = 3 [json_name = "ApplicableRolesForResources"]; */
        for (let i = 0; i < message.applicableRolesForResources.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.applicableRolesForResources[i]);
        /* string RequestPrompt = 4 [json_name = "RequestPrompt"]; */
        if (message.requestPrompt !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.requestPrompt);
        /* bool RequireReason = 5 [json_name = "RequireReason"]; */
        if (message.requireReason !== false)
            writer.tag(5, WireType.Varint).bool(message.requireReason);
        /* bool AutoRequest = 6 [json_name = "AutoRequest"]; */
        if (message.autoRequest !== false)
            writer.tag(6, WireType.Varint).bool(message.autoRequest);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AccessCapabilities
 */
export const AccessCapabilities = new AccessCapabilities$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessCapabilitiesRequest$Type extends MessageType<AccessCapabilitiesRequest> {
    constructor() {
        super("types.AccessCapabilitiesRequest", [
            { no: 1, name: "User", kind: "scalar", jsonName: "User", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "user,omitempty" } },
            { no: 2, name: "RequestableRoles", kind: "scalar", jsonName: "RequestableRoles", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "requestable_roles,omitempty" } },
            { no: 3, name: "SuggestedReviewers", kind: "scalar", jsonName: "SuggestedReviewers", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "suggested_reviewers,omitempty" } },
            { no: 4, name: "ResourceIDs", kind: "message", jsonName: "ResourceIDs", repeat: 1 /*RepeatType.PACKED*/, T: () => ResourceID, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "resource_ids,omitempty" } },
            { no: 5, name: "Login", kind: "scalar", jsonName: "Login", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "login,omitempty" } },
            { no: 6, name: "FilterRequestableRolesByResource", kind: "scalar", jsonName: "FilterRequestableRolesByResource", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "filter_requestable_roles_by_resource,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<AccessCapabilitiesRequest>): AccessCapabilitiesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.user = "";
        message.requestableRoles = false;
        message.suggestedReviewers = false;
        message.resourceIDs = [];
        message.login = "";
        message.filterRequestableRolesByResource = false;
        if (value !== undefined)
            reflectionMergePartial<AccessCapabilitiesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessCapabilitiesRequest): AccessCapabilitiesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string User = 1 [json_name = "User"];*/ 1:
                    message.user = reader.string();
                    break;
                case /* bool RequestableRoles = 2 [json_name = "RequestableRoles"];*/ 2:
                    message.requestableRoles = reader.bool();
                    break;
                case /* bool SuggestedReviewers = 3 [json_name = "SuggestedReviewers"];*/ 3:
                    message.suggestedReviewers = reader.bool();
                    break;
                case /* repeated types.ResourceID ResourceIDs = 4 [json_name = "ResourceIDs"];*/ 4:
                    message.resourceIDs.push(ResourceID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string Login = 5 [json_name = "Login"];*/ 5:
                    message.login = reader.string();
                    break;
                case /* bool FilterRequestableRolesByResource = 6 [json_name = "FilterRequestableRolesByResource"];*/ 6:
                    message.filterRequestableRolesByResource = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessCapabilitiesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string User = 1 [json_name = "User"]; */
        if (message.user !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.user);
        /* bool RequestableRoles = 2 [json_name = "RequestableRoles"]; */
        if (message.requestableRoles !== false)
            writer.tag(2, WireType.Varint).bool(message.requestableRoles);
        /* bool SuggestedReviewers = 3 [json_name = "SuggestedReviewers"]; */
        if (message.suggestedReviewers !== false)
            writer.tag(3, WireType.Varint).bool(message.suggestedReviewers);
        /* repeated types.ResourceID ResourceIDs = 4 [json_name = "ResourceIDs"]; */
        for (let i = 0; i < message.resourceIDs.length; i++)
            ResourceID.internalBinaryWrite(message.resourceIDs[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string Login = 5 [json_name = "Login"]; */
        if (message.login !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.login);
        /* bool FilterRequestableRolesByResource = 6 [json_name = "FilterRequestableRolesByResource"]; */
        if (message.filterRequestableRolesByResource !== false)
            writer.tag(6, WireType.Varint).bool(message.filterRequestableRolesByResource);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AccessCapabilitiesRequest
 */
export const AccessCapabilitiesRequest = new AccessCapabilitiesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestKubernetesResource$Type extends MessageType<RequestKubernetesResource> {
    constructor() {
        super("types.RequestKubernetesResource", [
            { no: 1, name: "kind", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<RequestKubernetesResource>): RequestKubernetesResource {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        if (value !== undefined)
            reflectionMergePartial<RequestKubernetesResource>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestKubernetesResource): RequestKubernetesResource {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string kind */ 1:
                    message.kind = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestKubernetesResource, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string kind = 1; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.RequestKubernetesResource
 */
export const RequestKubernetesResource = new RequestKubernetesResource$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResourceID$Type extends MessageType<ResourceID> {
    constructor() {
        super("types.ResourceID", [
            { no: 1, name: "ClusterName", kind: "scalar", jsonName: "ClusterName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "cluster" } },
            { no: 2, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 3, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "name" } },
            { no: 4, name: "SubResourceName", kind: "scalar", jsonName: "SubResourceName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub_resource,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ResourceID>): ResourceID {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterName = "";
        message.kind = "";
        message.name = "";
        message.subResourceName = "";
        if (value !== undefined)
            reflectionMergePartial<ResourceID>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResourceID): ResourceID {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ClusterName = 1 [json_name = "ClusterName"];*/ 1:
                    message.clusterName = reader.string();
                    break;
                case /* string Kind = 2 [json_name = "Kind"];*/ 2:
                    message.kind = reader.string();
                    break;
                case /* string Name = 3 [json_name = "Name"];*/ 3:
                    message.name = reader.string();
                    break;
                case /* string SubResourceName = 4 [json_name = "SubResourceName"];*/ 4:
                    message.subResourceName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResourceID, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ClusterName = 1 [json_name = "ClusterName"]; */
        if (message.clusterName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterName);
        /* string Kind = 2 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.kind);
        /* string Name = 3 [json_name = "Name"]; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string SubResourceName = 4 [json_name = "SubResourceName"]; */
        if (message.subResourceName !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.subResourceName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ResourceID
 */
export const ResourceID = new ResourceID$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginDataV3$Type extends MessageType<PluginDataV3> {
    constructor() {
        super("types.PluginDataV3", [
            { no: 1, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 2, name: "SubKind", kind: "scalar", jsonName: "SubKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub_kind,omitempty" } },
            { no: 3, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version" } },
            { no: 4, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "metadata" } },
            { no: 5, name: "Spec", kind: "message", jsonName: "Spec", T: () => PluginDataSpecV3, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ], { "gogoproto.goproto_stringer": false, "gogoproto.stringer": false });
    }
    create(value?: PartialMessage<PluginDataV3>): PluginDataV3 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.subKind = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<PluginDataV3>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginDataV3): PluginDataV3 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Kind = 1 [json_name = "Kind"];*/ 1:
                    message.kind = reader.string();
                    break;
                case /* string SubKind = 2 [json_name = "SubKind"];*/ 2:
                    message.subKind = reader.string();
                    break;
                case /* string Version = 3 [json_name = "Version"];*/ 3:
                    message.version = reader.string();
                    break;
                case /* types.Metadata Metadata = 4 [json_name = "Metadata"];*/ 4:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* types.PluginDataSpecV3 Spec = 5 [json_name = "Spec"];*/ 5:
                    message.spec = PluginDataSpecV3.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginDataV3, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Kind = 1 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string SubKind = 2 [json_name = "SubKind"]; */
        if (message.subKind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subKind);
        /* string Version = 3 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* types.Metadata Metadata = 4 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.PluginDataSpecV3 Spec = 5 [json_name = "Spec"]; */
        if (message.spec)
            PluginDataSpecV3.internalBinaryWrite(message.spec, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginDataV3
 */
export const PluginDataV3 = new PluginDataV3$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginDataEntry$Type extends MessageType<PluginDataEntry> {
    constructor() {
        super("types.PluginDataEntry", [
            { no: 1, name: "Data", kind: "map", jsonName: "Data", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ }, options: { "gogoproto.jsontag": "data,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<PluginDataEntry>): PluginDataEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = {};
        if (value !== undefined)
            reflectionMergePartial<PluginDataEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginDataEntry): PluginDataEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, string> Data = 1 [json_name = "Data"];*/ 1:
                    this.binaryReadMap1(message.data, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: PluginDataEntry["data"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof PluginDataEntry["data"] | undefined, val: PluginDataEntry["data"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field types.PluginDataEntry.Data");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: PluginDataEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, string> Data = 1 [json_name = "Data"]; */
        for (let k of globalThis.Object.keys(message.data))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.data[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginDataEntry
 */
export const PluginDataEntry = new PluginDataEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginDataSpecV3$Type extends MessageType<PluginDataSpecV3> {
    constructor() {
        super("types.PluginDataSpecV3", [
            { no: 1, name: "Entries", kind: "map", jsonName: "Entries", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => PluginDataEntry }, options: { "gogoproto.jsontag": "entries" } }
        ]);
    }
    create(value?: PartialMessage<PluginDataSpecV3>): PluginDataSpecV3 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entries = {};
        if (value !== undefined)
            reflectionMergePartial<PluginDataSpecV3>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginDataSpecV3): PluginDataSpecV3 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, types.PluginDataEntry> Entries = 1 [json_name = "Entries"];*/ 1:
                    this.binaryReadMap1(message.entries, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: PluginDataSpecV3["entries"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof PluginDataSpecV3["entries"] | undefined, val: PluginDataSpecV3["entries"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = PluginDataEntry.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field types.PluginDataSpecV3.Entries");
            }
        }
        map[key ?? ""] = val ?? PluginDataEntry.create();
    }
    internalBinaryWrite(message: PluginDataSpecV3, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, types.PluginDataEntry> Entries = 1 [json_name = "Entries"]; */
        for (let k of globalThis.Object.keys(message.entries)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            PluginDataEntry.internalBinaryWrite(message.entries[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginDataSpecV3
 */
export const PluginDataSpecV3 = new PluginDataSpecV3$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginDataFilter$Type extends MessageType<PluginDataFilter> {
    constructor() {
        super("types.PluginDataFilter", [
            { no: 1, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind,omitempty" } },
            { no: 2, name: "Resource", kind: "scalar", jsonName: "Resource", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "resource,omitempty" } },
            { no: 3, name: "Plugin", kind: "scalar", jsonName: "Plugin", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "plugin,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<PluginDataFilter>): PluginDataFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.resource = "";
        message.plugin = "";
        if (value !== undefined)
            reflectionMergePartial<PluginDataFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginDataFilter): PluginDataFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Kind = 1 [json_name = "Kind"];*/ 1:
                    message.kind = reader.string();
                    break;
                case /* string Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = reader.string();
                    break;
                case /* string Plugin = 3 [json_name = "Plugin"];*/ 3:
                    message.plugin = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginDataFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Kind = 1 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string Resource = 2 [json_name = "Resource"]; */
        if (message.resource !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.resource);
        /* string Plugin = 3 [json_name = "Plugin"]; */
        if (message.plugin !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.plugin);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginDataFilter
 */
export const PluginDataFilter = new PluginDataFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginDataUpdateParams$Type extends MessageType<PluginDataUpdateParams> {
    constructor() {
        super("types.PluginDataUpdateParams", [
            { no: 1, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 2, name: "Resource", kind: "scalar", jsonName: "Resource", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "resource" } },
            { no: 3, name: "Plugin", kind: "scalar", jsonName: "Plugin", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "plugin" } },
            { no: 4, name: "Set", kind: "map", jsonName: "Set", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ }, options: { "gogoproto.jsontag": "set,omitempty" } },
            { no: 5, name: "Expect", kind: "map", jsonName: "Expect", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ }, options: { "gogoproto.jsontag": "expect,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<PluginDataUpdateParams>): PluginDataUpdateParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.resource = "";
        message.plugin = "";
        message.set = {};
        message.expect = {};
        if (value !== undefined)
            reflectionMergePartial<PluginDataUpdateParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginDataUpdateParams): PluginDataUpdateParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Kind = 1 [json_name = "Kind"];*/ 1:
                    message.kind = reader.string();
                    break;
                case /* string Resource = 2 [json_name = "Resource"];*/ 2:
                    message.resource = reader.string();
                    break;
                case /* string Plugin = 3 [json_name = "Plugin"];*/ 3:
                    message.plugin = reader.string();
                    break;
                case /* map<string, string> Set = 4 [json_name = "Set"];*/ 4:
                    this.binaryReadMap4(message.set, reader, options);
                    break;
                case /* map<string, string> Expect = 5 [json_name = "Expect"];*/ 5:
                    this.binaryReadMap5(message.expect, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap4(map: PluginDataUpdateParams["set"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof PluginDataUpdateParams["set"] | undefined, val: PluginDataUpdateParams["set"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field types.PluginDataUpdateParams.Set");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    private binaryReadMap5(map: PluginDataUpdateParams["expect"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof PluginDataUpdateParams["expect"] | undefined, val: PluginDataUpdateParams["expect"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field types.PluginDataUpdateParams.Expect");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: PluginDataUpdateParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Kind = 1 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string Resource = 2 [json_name = "Resource"]; */
        if (message.resource !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.resource);
        /* string Plugin = 3 [json_name = "Plugin"]; */
        if (message.plugin !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.plugin);
        /* map<string, string> Set = 4 [json_name = "Set"]; */
        for (let k of globalThis.Object.keys(message.set))
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.set[k]).join();
        /* map<string, string> Expect = 5 [json_name = "Expect"]; */
        for (let k of globalThis.Object.keys(message.expect))
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.expect[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginDataUpdateParams
 */
export const PluginDataUpdateParams = new PluginDataUpdateParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RoleFilter$Type extends MessageType<RoleFilter> {
    constructor() {
        super("types.RoleFilter", [
            { no: 1, name: "SearchKeywords", kind: "scalar", jsonName: "SearchKeywords", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "search_keywords,omitempty" } },
            { no: 2, name: "SkipSystemRoles", kind: "scalar", jsonName: "SkipSystemRoles", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "skip_system_roles,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<RoleFilter>): RoleFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.searchKeywords = [];
        message.skipSystemRoles = false;
        if (value !== undefined)
            reflectionMergePartial<RoleFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RoleFilter): RoleFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string SearchKeywords = 1 [json_name = "SearchKeywords"];*/ 1:
                    message.searchKeywords.push(reader.string());
                    break;
                case /* bool SkipSystemRoles = 2 [json_name = "SkipSystemRoles"];*/ 2:
                    message.skipSystemRoles = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RoleFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string SearchKeywords = 1 [json_name = "SearchKeywords"]; */
        for (let i = 0; i < message.searchKeywords.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.searchKeywords[i]);
        /* bool SkipSystemRoles = 2 [json_name = "SkipSystemRoles"]; */
        if (message.skipSystemRoles !== false)
            writer.tag(2, WireType.Varint).bool(message.skipSystemRoles);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.RoleFilter
 */
export const RoleFilter = new RoleFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RoleV6$Type extends MessageType<RoleV6> {
    constructor() {
        super("types.RoleV6", [
            { no: 1, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 2, name: "SubKind", kind: "scalar", jsonName: "SubKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub_kind,omitempty" } },
            { no: 3, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version" } },
            { no: 4, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "metadata" } },
            { no: 5, name: "Spec", kind: "message", jsonName: "Spec", T: () => RoleSpecV6, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ], { "gogoproto.goproto_stringer": false, "gogoproto.stringer": false });
    }
    create(value?: PartialMessage<RoleV6>): RoleV6 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.subKind = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<RoleV6>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RoleV6): RoleV6 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Kind = 1 [json_name = "Kind"];*/ 1:
                    message.kind = reader.string();
                    break;
                case /* string SubKind = 2 [json_name = "SubKind"];*/ 2:
                    message.subKind = reader.string();
                    break;
                case /* string Version = 3 [json_name = "Version"];*/ 3:
                    message.version = reader.string();
                    break;
                case /* types.Metadata Metadata = 4 [json_name = "Metadata"];*/ 4:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* types.RoleSpecV6 Spec = 5 [json_name = "Spec"];*/ 5:
                    message.spec = RoleSpecV6.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RoleV6, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Kind = 1 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string SubKind = 2 [json_name = "SubKind"]; */
        if (message.subKind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subKind);
        /* string Version = 3 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* types.Metadata Metadata = 4 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.RoleSpecV6 Spec = 5 [json_name = "Spec"]; */
        if (message.spec)
            RoleSpecV6.internalBinaryWrite(message.spec, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.RoleV6
 */
export const RoleV6 = new RoleV6$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RoleSpecV6$Type extends MessageType<RoleSpecV6> {
    constructor() {
        super("types.RoleSpecV6", [
            { no: 1, name: "Options", kind: "message", jsonName: "Options", T: () => RoleOptions, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "options,omitempty" } },
            { no: 2, name: "Allow", kind: "message", jsonName: "Allow", T: () => RoleConditions, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "allow,omitempty" } },
            { no: 3, name: "Deny", kind: "message", jsonName: "Deny", T: () => RoleConditions, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "deny,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<RoleSpecV6>): RoleSpecV6 {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RoleSpecV6>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RoleSpecV6): RoleSpecV6 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.RoleOptions Options = 1 [json_name = "Options"];*/ 1:
                    message.options = RoleOptions.internalBinaryRead(reader, reader.uint32(), options, message.options);
                    break;
                case /* types.RoleConditions Allow = 2 [json_name = "Allow"];*/ 2:
                    message.allow = RoleConditions.internalBinaryRead(reader, reader.uint32(), options, message.allow);
                    break;
                case /* types.RoleConditions Deny = 3 [json_name = "Deny"];*/ 3:
                    message.deny = RoleConditions.internalBinaryRead(reader, reader.uint32(), options, message.deny);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RoleSpecV6, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.RoleOptions Options = 1 [json_name = "Options"]; */
        if (message.options)
            RoleOptions.internalBinaryWrite(message.options, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* types.RoleConditions Allow = 2 [json_name = "Allow"]; */
        if (message.allow)
            RoleConditions.internalBinaryWrite(message.allow, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* types.RoleConditions Deny = 3 [json_name = "Deny"]; */
        if (message.deny)
            RoleConditions.internalBinaryWrite(message.deny, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.RoleSpecV6
 */
export const RoleSpecV6 = new RoleSpecV6$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SSHLocalPortForwarding$Type extends MessageType<SSHLocalPortForwarding> {
    constructor() {
        super("types.SSHLocalPortForwarding", [
            { no: 1, name: "Enabled", kind: "message", jsonName: "Enabled", T: () => BoolValue, options: { "gogoproto.nullable": true, "gogoproto.customtype": "BoolOption", "gogoproto.jsontag": "enabled,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<SSHLocalPortForwarding>): SSHLocalPortForwarding {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SSHLocalPortForwarding>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SSHLocalPortForwarding): SSHLocalPortForwarding {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.BoolValue Enabled = 1 [json_name = "Enabled"];*/ 1:
                    message.enabled = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.enabled);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SSHLocalPortForwarding, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.BoolValue Enabled = 1 [json_name = "Enabled"]; */
        if (message.enabled)
            BoolValue.internalBinaryWrite(message.enabled, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.SSHLocalPortForwarding
 */
export const SSHLocalPortForwarding = new SSHLocalPortForwarding$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SSHRemotePortForwarding$Type extends MessageType<SSHRemotePortForwarding> {
    constructor() {
        super("types.SSHRemotePortForwarding", [
            { no: 1, name: "Enabled", kind: "message", jsonName: "Enabled", T: () => BoolValue, options: { "gogoproto.nullable": true, "gogoproto.customtype": "BoolOption", "gogoproto.jsontag": "enabled,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<SSHRemotePortForwarding>): SSHRemotePortForwarding {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SSHRemotePortForwarding>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SSHRemotePortForwarding): SSHRemotePortForwarding {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.BoolValue Enabled = 1 [json_name = "Enabled"];*/ 1:
                    message.enabled = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.enabled);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SSHRemotePortForwarding, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.BoolValue Enabled = 1 [json_name = "Enabled"]; */
        if (message.enabled)
            BoolValue.internalBinaryWrite(message.enabled, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.SSHRemotePortForwarding
 */
export const SSHRemotePortForwarding = new SSHRemotePortForwarding$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SSHPortForwarding$Type extends MessageType<SSHPortForwarding> {
    constructor() {
        super("types.SSHPortForwarding", [
            { no: 1, name: "Local", kind: "message", jsonName: "Local", T: () => SSHLocalPortForwarding, options: { "gogoproto.nullable": true, "gogoproto.jsontag": "local,omitempty" } },
            { no: 2, name: "Remote", kind: "message", jsonName: "Remote", T: () => SSHRemotePortForwarding, options: { "gogoproto.nullable": true, "gogoproto.jsontag": "remote,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<SSHPortForwarding>): SSHPortForwarding {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SSHPortForwarding>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SSHPortForwarding): SSHPortForwarding {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.SSHLocalPortForwarding Local = 1 [json_name = "Local"];*/ 1:
                    message.local = SSHLocalPortForwarding.internalBinaryRead(reader, reader.uint32(), options, message.local);
                    break;
                case /* types.SSHRemotePortForwarding Remote = 2 [json_name = "Remote"];*/ 2:
                    message.remote = SSHRemotePortForwarding.internalBinaryRead(reader, reader.uint32(), options, message.remote);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SSHPortForwarding, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.SSHLocalPortForwarding Local = 1 [json_name = "Local"]; */
        if (message.local)
            SSHLocalPortForwarding.internalBinaryWrite(message.local, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* types.SSHRemotePortForwarding Remote = 2 [json_name = "Remote"]; */
        if (message.remote)
            SSHRemotePortForwarding.internalBinaryWrite(message.remote, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.SSHPortForwarding
 */
export const SSHPortForwarding = new SSHPortForwarding$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RoleOptions$Type extends MessageType<RoleOptions> {
    constructor() {
        super("types.RoleOptions", [
            { no: 1, name: "ForwardAgent", kind: "scalar", jsonName: "ForwardAgent", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "forward_agent", "gogoproto.casttype": "Bool" } },
            { no: 2, name: "MaxSessionTTL", kind: "scalar", jsonName: "MaxSessionTTL", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "max_session_ttl,omitempty", "gogoproto.casttype": "Duration" } },
            { no: 3, name: "PortForwarding", kind: "message", jsonName: "PortForwarding", T: () => BoolValue, options: { "gogoproto.nullable": true, "gogoproto.customtype": "BoolOption", "gogoproto.jsontag": "port_forwarding,omitempty" } },
            { no: 4, name: "CertificateFormat", kind: "scalar", jsonName: "CertificateFormat", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "cert_format" } },
            { no: 5, name: "ClientIdleTimeout", kind: "scalar", jsonName: "ClientIdleTimeout", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "client_idle_timeout,omitempty", "gogoproto.casttype": "Duration" } },
            { no: 6, name: "DisconnectExpiredCert", kind: "scalar", jsonName: "DisconnectExpiredCert", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.nullable": true, "gogoproto.jsontag": "disconnect_expired_cert,omitempty", "gogoproto.casttype": "Bool" } },
            { no: 7, name: "BPF", kind: "scalar", jsonName: "BPF", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "enhanced_recording,omitempty" } },
            { no: 8, name: "PermitX11Forwarding", kind: "scalar", jsonName: "PermitX11Forwarding", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.nullable": true, "gogoproto.jsontag": "permit_x11_forwarding,omitempty", "gogoproto.casttype": "Bool" } },
            { no: 9, name: "MaxConnections", kind: "scalar", jsonName: "MaxConnections", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "max_connections,omitempty" } },
            { no: 10, name: "MaxSessions", kind: "scalar", jsonName: "MaxSessions", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "max_sessions,omitempty" } },
            { no: 11, name: "RequestAccess", kind: "scalar", jsonName: "RequestAccess", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "request_access,omitempty", "gogoproto.casttype": "RequestStrategy" } },
            { no: 12, name: "RequestPrompt", kind: "scalar", jsonName: "RequestPrompt", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "request_prompt,omitempty" } },
            { no: 14, name: "Lock", kind: "scalar", jsonName: "Lock", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "lock,omitempty", "gogoproto.casttype": "github.com/gravitational/teleport/api/constants.LockingMode" } },
            { no: 15, name: "RecordSession", kind: "message", jsonName: "RecordSession", T: () => RecordSession, options: { "gogoproto.jsontag": "record_session" } },
            { no: 16, name: "DesktopClipboard", kind: "message", jsonName: "DesktopClipboard", T: () => BoolValue, options: { "gogoproto.nullable": true, "gogoproto.customtype": "BoolOption", "gogoproto.jsontag": "desktop_clipboard" } },
            { no: 17, name: "CertExtensions", kind: "message", jsonName: "CertExtensions", repeat: 1 /*RepeatType.PACKED*/, T: () => CertExtension, options: { "gogoproto.jsontag": "cert_extensions,omitempty" } },
            { no: 18, name: "MaxKubernetesConnections", kind: "scalar", jsonName: "MaxKubernetesConnections", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "max_kubernetes_connections,omitempty" } },
            { no: 19, name: "DesktopDirectorySharing", kind: "message", jsonName: "DesktopDirectorySharing", T: () => BoolValue, options: { "gogoproto.nullable": true, "gogoproto.customtype": "BoolOption", "gogoproto.jsontag": "desktop_directory_sharing" } },
            { no: 20, name: "CreateHostUser", kind: "message", jsonName: "CreateHostUser", T: () => BoolValue, options: { "gogoproto.nullable": true, "gogoproto.customtype": "BoolOption", "gogoproto.jsontag": "create_host_user,omitempty" } },
            { no: 21, name: "PinSourceIP", kind: "scalar", jsonName: "PinSourceIP", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "pin_source_ip", "gogoproto.casttype": "Bool" } },
            { no: 22, name: "SSHFileCopy", kind: "message", jsonName: "SSHFileCopy", T: () => BoolValue, options: { "gogoproto.nullable": true, "gogoproto.customtype": "BoolOption", "gogoproto.jsontag": "ssh_file_copy" } },
            { no: 23, name: "RequireMFAType", kind: "enum", jsonName: "RequireMFAType", T: () => ["types.RequireMFAType", RequireMFAType], options: { "gogoproto.jsontag": "require_session_mfa,omitempty" } },
            { no: 24, name: "DeviceTrustMode", kind: "scalar", jsonName: "DeviceTrustMode", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "device_trust_mode,omitempty" } },
            { no: 25, name: "IDP", kind: "message", jsonName: "IDP", T: () => IdPOptions, options: { "gogoproto.jsontag": "idp,omitempty" } },
            { no: 26, name: "CreateDesktopUser", kind: "message", jsonName: "CreateDesktopUser", T: () => BoolValue, options: { "gogoproto.nullable": true, "gogoproto.customtype": "BoolOption", "gogoproto.jsontag": "create_desktop_user" } },
            { no: 27, name: "CreateDatabaseUser", kind: "message", jsonName: "CreateDatabaseUser", T: () => BoolValue, options: { "gogoproto.nullable": true, "gogoproto.customtype": "BoolOption", "gogoproto.jsontag": "create_db_user" } },
            { no: 28, name: "CreateHostUserMode", kind: "enum", jsonName: "CreateHostUserMode", T: () => ["types.CreateHostUserMode", CreateHostUserMode], options: { "gogoproto.jsontag": "create_host_user_mode,omitempty" } },
            { no: 29, name: "CreateDatabaseUserMode", kind: "enum", jsonName: "CreateDatabaseUserMode", T: () => ["types.CreateDatabaseUserMode", CreateDatabaseUserMode], options: { "gogoproto.jsontag": "create_db_user_mode,omitempty" } },
            { no: 30, name: "MFAVerificationInterval", kind: "message", jsonName: "MFAVerificationInterval", T: () => Duration, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "mfa_verification_interval,omitempty", "gogoproto.stdduration": true } },
            { no: 31, name: "CreateHostUserDefaultShell", kind: "scalar", jsonName: "CreateHostUserDefaultShell", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "create_host_user_default_shell,omitempty" } },
            { no: 32, name: "SSHPortForwarding", kind: "message", jsonName: "SSHPortForwarding", T: () => SSHPortForwarding, options: { "gogoproto.nullable": true, "gogoproto.jsontag": "ssh_port_forwarding,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<RoleOptions>): RoleOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.forwardAgent = false;
        message.maxSessionTTL = 0n;
        message.certificateFormat = "";
        message.clientIdleTimeout = 0n;
        message.disconnectExpiredCert = false;
        message.bPF = [];
        message.permitX11Forwarding = false;
        message.maxConnections = 0n;
        message.maxSessions = 0n;
        message.requestAccess = "";
        message.requestPrompt = "";
        message.lock = "";
        message.certExtensions = [];
        message.maxKubernetesConnections = 0n;
        message.pinSourceIP = false;
        message.requireMFAType = 0;
        message.deviceTrustMode = "";
        message.createHostUserMode = 0;
        message.createDatabaseUserMode = 0;
        message.createHostUserDefaultShell = "";
        if (value !== undefined)
            reflectionMergePartial<RoleOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RoleOptions): RoleOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool ForwardAgent = 1 [json_name = "ForwardAgent"];*/ 1:
                    message.forwardAgent = reader.bool();
                    break;
                case /* int64 MaxSessionTTL = 2 [json_name = "MaxSessionTTL"];*/ 2:
                    message.maxSessionTTL = reader.int64().toBigInt();
                    break;
                case /* types.BoolValue PortForwarding = 3 [deprecated = true, json_name = "PortForwarding"];*/ 3:
                    message.portForwarding = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.portForwarding);
                    break;
                case /* string CertificateFormat = 4 [json_name = "CertificateFormat"];*/ 4:
                    message.certificateFormat = reader.string();
                    break;
                case /* int64 ClientIdleTimeout = 5 [json_name = "ClientIdleTimeout"];*/ 5:
                    message.clientIdleTimeout = reader.int64().toBigInt();
                    break;
                case /* bool DisconnectExpiredCert = 6 [json_name = "DisconnectExpiredCert"];*/ 6:
                    message.disconnectExpiredCert = reader.bool();
                    break;
                case /* repeated string BPF = 7 [json_name = "BPF"];*/ 7:
                    message.bPF.push(reader.string());
                    break;
                case /* bool PermitX11Forwarding = 8 [json_name = "PermitX11Forwarding"];*/ 8:
                    message.permitX11Forwarding = reader.bool();
                    break;
                case /* int64 MaxConnections = 9 [json_name = "MaxConnections"];*/ 9:
                    message.maxConnections = reader.int64().toBigInt();
                    break;
                case /* int64 MaxSessions = 10 [json_name = "MaxSessions"];*/ 10:
                    message.maxSessions = reader.int64().toBigInt();
                    break;
                case /* string RequestAccess = 11 [json_name = "RequestAccess"];*/ 11:
                    message.requestAccess = reader.string();
                    break;
                case /* string RequestPrompt = 12 [json_name = "RequestPrompt"];*/ 12:
                    message.requestPrompt = reader.string();
                    break;
                case /* string Lock = 14 [json_name = "Lock"];*/ 14:
                    message.lock = reader.string();
                    break;
                case /* types.RecordSession RecordSession = 15 [json_name = "RecordSession"];*/ 15:
                    message.recordSession = RecordSession.internalBinaryRead(reader, reader.uint32(), options, message.recordSession);
                    break;
                case /* types.BoolValue DesktopClipboard = 16 [json_name = "DesktopClipboard"];*/ 16:
                    message.desktopClipboard = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.desktopClipboard);
                    break;
                case /* repeated types.CertExtension CertExtensions = 17 [json_name = "CertExtensions"];*/ 17:
                    message.certExtensions.push(CertExtension.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int64 MaxKubernetesConnections = 18 [json_name = "MaxKubernetesConnections"];*/ 18:
                    message.maxKubernetesConnections = reader.int64().toBigInt();
                    break;
                case /* types.BoolValue DesktopDirectorySharing = 19 [json_name = "DesktopDirectorySharing"];*/ 19:
                    message.desktopDirectorySharing = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.desktopDirectorySharing);
                    break;
                case /* types.BoolValue CreateHostUser = 20 [json_name = "CreateHostUser"];*/ 20:
                    message.createHostUser = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.createHostUser);
                    break;
                case /* bool PinSourceIP = 21 [json_name = "PinSourceIP"];*/ 21:
                    message.pinSourceIP = reader.bool();
                    break;
                case /* types.BoolValue SSHFileCopy = 22 [json_name = "SSHFileCopy"];*/ 22:
                    message.sSHFileCopy = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.sSHFileCopy);
                    break;
                case /* types.RequireMFAType RequireMFAType = 23 [json_name = "RequireMFAType"];*/ 23:
                    message.requireMFAType = reader.int32();
                    break;
                case /* string DeviceTrustMode = 24 [json_name = "DeviceTrustMode"];*/ 24:
                    message.deviceTrustMode = reader.string();
                    break;
                case /* types.IdPOptions IDP = 25 [json_name = "IDP"];*/ 25:
                    message.iDP = IdPOptions.internalBinaryRead(reader, reader.uint32(), options, message.iDP);
                    break;
                case /* types.BoolValue CreateDesktopUser = 26 [json_name = "CreateDesktopUser"];*/ 26:
                    message.createDesktopUser = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.createDesktopUser);
                    break;
                case /* types.BoolValue CreateDatabaseUser = 27 [json_name = "CreateDatabaseUser"];*/ 27:
                    message.createDatabaseUser = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.createDatabaseUser);
                    break;
                case /* types.CreateHostUserMode CreateHostUserMode = 28 [json_name = "CreateHostUserMode"];*/ 28:
                    message.createHostUserMode = reader.int32();
                    break;
                case /* types.CreateDatabaseUserMode CreateDatabaseUserMode = 29 [json_name = "CreateDatabaseUserMode"];*/ 29:
                    message.createDatabaseUserMode = reader.int32();
                    break;
                case /* google.protobuf.Duration MFAVerificationInterval = 30 [json_name = "MFAVerificationInterval"];*/ 30:
                    message.mFAVerificationInterval = Duration.internalBinaryRead(reader, reader.uint32(), options, message.mFAVerificationInterval);
                    break;
                case /* string CreateHostUserDefaultShell = 31 [json_name = "CreateHostUserDefaultShell"];*/ 31:
                    message.createHostUserDefaultShell = reader.string();
                    break;
                case /* types.SSHPortForwarding SSHPortForwarding = 32 [json_name = "SSHPortForwarding"];*/ 32:
                    message.sSHPortForwarding = SSHPortForwarding.internalBinaryRead(reader, reader.uint32(), options, message.sSHPortForwarding);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RoleOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool ForwardAgent = 1 [json_name = "ForwardAgent"]; */
        if (message.forwardAgent !== false)
            writer.tag(1, WireType.Varint).bool(message.forwardAgent);
        /* int64 MaxSessionTTL = 2 [json_name = "MaxSessionTTL"]; */
        if (message.maxSessionTTL !== 0n)
            writer.tag(2, WireType.Varint).int64(message.maxSessionTTL);
        /* types.BoolValue PortForwarding = 3 [deprecated = true, json_name = "PortForwarding"]; */
        if (message.portForwarding)
            BoolValue.internalBinaryWrite(message.portForwarding, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string CertificateFormat = 4 [json_name = "CertificateFormat"]; */
        if (message.certificateFormat !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.certificateFormat);
        /* int64 ClientIdleTimeout = 5 [json_name = "ClientIdleTimeout"]; */
        if (message.clientIdleTimeout !== 0n)
            writer.tag(5, WireType.Varint).int64(message.clientIdleTimeout);
        /* bool DisconnectExpiredCert = 6 [json_name = "DisconnectExpiredCert"]; */
        if (message.disconnectExpiredCert !== false)
            writer.tag(6, WireType.Varint).bool(message.disconnectExpiredCert);
        /* repeated string BPF = 7 [json_name = "BPF"]; */
        for (let i = 0; i < message.bPF.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.bPF[i]);
        /* bool PermitX11Forwarding = 8 [json_name = "PermitX11Forwarding"]; */
        if (message.permitX11Forwarding !== false)
            writer.tag(8, WireType.Varint).bool(message.permitX11Forwarding);
        /* int64 MaxConnections = 9 [json_name = "MaxConnections"]; */
        if (message.maxConnections !== 0n)
            writer.tag(9, WireType.Varint).int64(message.maxConnections);
        /* int64 MaxSessions = 10 [json_name = "MaxSessions"]; */
        if (message.maxSessions !== 0n)
            writer.tag(10, WireType.Varint).int64(message.maxSessions);
        /* string RequestAccess = 11 [json_name = "RequestAccess"]; */
        if (message.requestAccess !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.requestAccess);
        /* string RequestPrompt = 12 [json_name = "RequestPrompt"]; */
        if (message.requestPrompt !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.requestPrompt);
        /* string Lock = 14 [json_name = "Lock"]; */
        if (message.lock !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.lock);
        /* types.RecordSession RecordSession = 15 [json_name = "RecordSession"]; */
        if (message.recordSession)
            RecordSession.internalBinaryWrite(message.recordSession, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* types.BoolValue DesktopClipboard = 16 [json_name = "DesktopClipboard"]; */
        if (message.desktopClipboard)
            BoolValue.internalBinaryWrite(message.desktopClipboard, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* repeated types.CertExtension CertExtensions = 17 [json_name = "CertExtensions"]; */
        for (let i = 0; i < message.certExtensions.length; i++)
            CertExtension.internalBinaryWrite(message.certExtensions[i], writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* int64 MaxKubernetesConnections = 18 [json_name = "MaxKubernetesConnections"]; */
        if (message.maxKubernetesConnections !== 0n)
            writer.tag(18, WireType.Varint).int64(message.maxKubernetesConnections);
        /* types.BoolValue DesktopDirectorySharing = 19 [json_name = "DesktopDirectorySharing"]; */
        if (message.desktopDirectorySharing)
            BoolValue.internalBinaryWrite(message.desktopDirectorySharing, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* types.BoolValue CreateHostUser = 20 [json_name = "CreateHostUser"]; */
        if (message.createHostUser)
            BoolValue.internalBinaryWrite(message.createHostUser, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* bool PinSourceIP = 21 [json_name = "PinSourceIP"]; */
        if (message.pinSourceIP !== false)
            writer.tag(21, WireType.Varint).bool(message.pinSourceIP);
        /* types.BoolValue SSHFileCopy = 22 [json_name = "SSHFileCopy"]; */
        if (message.sSHFileCopy)
            BoolValue.internalBinaryWrite(message.sSHFileCopy, writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        /* types.RequireMFAType RequireMFAType = 23 [json_name = "RequireMFAType"]; */
        if (message.requireMFAType !== 0)
            writer.tag(23, WireType.Varint).int32(message.requireMFAType);
        /* string DeviceTrustMode = 24 [json_name = "DeviceTrustMode"]; */
        if (message.deviceTrustMode !== "")
            writer.tag(24, WireType.LengthDelimited).string(message.deviceTrustMode);
        /* types.IdPOptions IDP = 25 [json_name = "IDP"]; */
        if (message.iDP)
            IdPOptions.internalBinaryWrite(message.iDP, writer.tag(25, WireType.LengthDelimited).fork(), options).join();
        /* types.BoolValue CreateDesktopUser = 26 [json_name = "CreateDesktopUser"]; */
        if (message.createDesktopUser)
            BoolValue.internalBinaryWrite(message.createDesktopUser, writer.tag(26, WireType.LengthDelimited).fork(), options).join();
        /* types.BoolValue CreateDatabaseUser = 27 [json_name = "CreateDatabaseUser"]; */
        if (message.createDatabaseUser)
            BoolValue.internalBinaryWrite(message.createDatabaseUser, writer.tag(27, WireType.LengthDelimited).fork(), options).join();
        /* types.CreateHostUserMode CreateHostUserMode = 28 [json_name = "CreateHostUserMode"]; */
        if (message.createHostUserMode !== 0)
            writer.tag(28, WireType.Varint).int32(message.createHostUserMode);
        /* types.CreateDatabaseUserMode CreateDatabaseUserMode = 29 [json_name = "CreateDatabaseUserMode"]; */
        if (message.createDatabaseUserMode !== 0)
            writer.tag(29, WireType.Varint).int32(message.createDatabaseUserMode);
        /* google.protobuf.Duration MFAVerificationInterval = 30 [json_name = "MFAVerificationInterval"]; */
        if (message.mFAVerificationInterval)
            Duration.internalBinaryWrite(message.mFAVerificationInterval, writer.tag(30, WireType.LengthDelimited).fork(), options).join();
        /* string CreateHostUserDefaultShell = 31 [json_name = "CreateHostUserDefaultShell"]; */
        if (message.createHostUserDefaultShell !== "")
            writer.tag(31, WireType.LengthDelimited).string(message.createHostUserDefaultShell);
        /* types.SSHPortForwarding SSHPortForwarding = 32 [json_name = "SSHPortForwarding"]; */
        if (message.sSHPortForwarding)
            SSHPortForwarding.internalBinaryWrite(message.sSHPortForwarding, writer.tag(32, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.RoleOptions
 */
export const RoleOptions = new RoleOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RecordSession$Type extends MessageType<RecordSession> {
    constructor() {
        super("types.RecordSession", [
            { no: 1, name: "Desktop", kind: "message", jsonName: "Desktop", T: () => BoolValue, options: { "gogoproto.nullable": true, "gogoproto.customtype": "BoolOption", "gogoproto.jsontag": "desktop" } },
            { no: 2, name: "Default", kind: "scalar", jsonName: "Default", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "default,omitempty", "gogoproto.casttype": "github.com/gravitational/teleport/api/constants.SessionRecordingMode" } },
            { no: 3, name: "SSH", kind: "scalar", jsonName: "SSH", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "ssh,omitempty", "gogoproto.casttype": "github.com/gravitational/teleport/api/constants.SessionRecordingMode" } }
        ]);
    }
    create(value?: PartialMessage<RecordSession>): RecordSession {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.default = "";
        message.sSH = "";
        if (value !== undefined)
            reflectionMergePartial<RecordSession>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RecordSession): RecordSession {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.BoolValue Desktop = 1 [json_name = "Desktop"];*/ 1:
                    message.desktop = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.desktop);
                    break;
                case /* string Default = 2 [json_name = "Default"];*/ 2:
                    message.default = reader.string();
                    break;
                case /* string SSH = 3 [json_name = "SSH"];*/ 3:
                    message.sSH = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RecordSession, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.BoolValue Desktop = 1 [json_name = "Desktop"]; */
        if (message.desktop)
            BoolValue.internalBinaryWrite(message.desktop, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string Default = 2 [json_name = "Default"]; */
        if (message.default !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.default);
        /* string SSH = 3 [json_name = "SSH"]; */
        if (message.sSH !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.sSH);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.RecordSession
 */
export const RecordSession = new RecordSession$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CertExtension$Type extends MessageType<CertExtension> {
    constructor() {
        super("types.CertExtension", [
            { no: 1, name: "Type", kind: "enum", jsonName: "Type", T: () => ["types.CertExtensionType", CertExtensionType], options: { "gogoproto.jsontag": "type" } },
            { no: 2, name: "Mode", kind: "enum", jsonName: "Mode", T: () => ["types.CertExtensionMode", CertExtensionMode], options: { "gogoproto.jsontag": "mode" } },
            { no: 3, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "name" } },
            { no: 4, name: "Value", kind: "scalar", jsonName: "Value", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "value" } }
        ]);
    }
    create(value?: PartialMessage<CertExtension>): CertExtension {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.mode = 0;
        message.name = "";
        message.value = "";
        if (value !== undefined)
            reflectionMergePartial<CertExtension>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CertExtension): CertExtension {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.CertExtensionType Type = 1 [json_name = "Type"];*/ 1:
                    message.type = reader.int32();
                    break;
                case /* types.CertExtensionMode Mode = 2 [json_name = "Mode"];*/ 2:
                    message.mode = reader.int32();
                    break;
                case /* string Name = 3 [json_name = "Name"];*/ 3:
                    message.name = reader.string();
                    break;
                case /* string Value = 4 [json_name = "Value"];*/ 4:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CertExtension, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.CertExtensionType Type = 1 [json_name = "Type"]; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* types.CertExtensionMode Mode = 2 [json_name = "Mode"]; */
        if (message.mode !== 0)
            writer.tag(2, WireType.Varint).int32(message.mode);
        /* string Name = 3 [json_name = "Name"]; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string Value = 4 [json_name = "Value"]; */
        if (message.value !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.CertExtension
 */
export const CertExtension = new CertExtension$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RoleConditions$Type extends MessageType<RoleConditions> {
    constructor() {
        super("types.RoleConditions", [
            { no: 1, name: "Logins", kind: "scalar", jsonName: "Logins", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "logins,omitempty" } },
            { no: 2, name: "Namespaces", kind: "scalar", jsonName: "Namespaces", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "-" } },
            { no: 3, name: "NodeLabels", kind: "message", jsonName: "NodeLabels", T: () => LabelValues, options: { "gogoproto.nullable": false, "gogoproto.customtype": "Labels", "gogoproto.jsontag": "node_labels,omitempty" } },
            { no: 4, name: "Rules", kind: "message", jsonName: "Rules", repeat: 1 /*RepeatType.PACKED*/, T: () => Rule, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "rules,omitempty" } },
            { no: 5, name: "KubeGroups", kind: "scalar", jsonName: "KubeGroups", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kubernetes_groups,omitempty" } },
            { no: 6, name: "Request", kind: "message", jsonName: "Request", T: () => AccessRequestConditions, options: { "gogoproto.jsontag": "request,omitempty" } },
            { no: 7, name: "KubeUsers", kind: "scalar", jsonName: "KubeUsers", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kubernetes_users,omitempty" } },
            { no: 8, name: "AppLabels", kind: "message", jsonName: "AppLabels", T: () => LabelValues, options: { "gogoproto.nullable": false, "gogoproto.customtype": "Labels", "gogoproto.jsontag": "app_labels,omitempty" } },
            { no: 9, name: "ClusterLabels", kind: "message", jsonName: "ClusterLabels", T: () => LabelValues, options: { "gogoproto.nullable": false, "gogoproto.customtype": "Labels", "gogoproto.jsontag": "cluster_labels,omitempty" } },
            { no: 10, name: "KubernetesLabels", kind: "message", jsonName: "KubernetesLabels", T: () => LabelValues, options: { "gogoproto.nullable": false, "gogoproto.customtype": "Labels", "gogoproto.jsontag": "kubernetes_labels,omitempty" } },
            { no: 11, name: "DatabaseLabels", kind: "message", jsonName: "DatabaseLabels", T: () => LabelValues, options: { "gogoproto.nullable": false, "gogoproto.customtype": "Labels", "gogoproto.jsontag": "db_labels,omitempty" } },
            { no: 12, name: "DatabaseNames", kind: "scalar", jsonName: "DatabaseNames", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "db_names,omitempty" } },
            { no: 13, name: "DatabaseUsers", kind: "scalar", jsonName: "DatabaseUsers", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "db_users,omitempty" } },
            { no: 14, name: "Impersonate", kind: "message", jsonName: "Impersonate", T: () => ImpersonateConditions, options: { "gogoproto.jsontag": "impersonate,omitempty" } },
            { no: 15, name: "ReviewRequests", kind: "message", jsonName: "ReviewRequests", T: () => AccessReviewConditions, options: { "gogoproto.jsontag": "review_requests,omitempty" } },
            { no: 16, name: "AWSRoleARNs", kind: "scalar", jsonName: "AWSRoleARNs", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "aws_role_arns,omitempty" } },
            { no: 17, name: "WindowsDesktopLogins", kind: "scalar", jsonName: "WindowsDesktopLogins", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "windows_desktop_logins,omitempty" } },
            { no: 18, name: "WindowsDesktopLabels", kind: "message", jsonName: "WindowsDesktopLabels", T: () => LabelValues, options: { "gogoproto.nullable": false, "gogoproto.customtype": "Labels", "gogoproto.jsontag": "windows_desktop_labels,omitempty" } },
            { no: 19, name: "RequireSessionJoin", kind: "message", jsonName: "RequireSessionJoin", repeat: 1 /*RepeatType.PACKED*/, T: () => SessionRequirePolicy, options: { "gogoproto.jsontag": "require_session_join,omitempty" } },
            { no: 20, name: "JoinSessions", kind: "message", jsonName: "JoinSessions", repeat: 1 /*RepeatType.PACKED*/, T: () => SessionJoinPolicy, options: { "gogoproto.jsontag": "join_sessions,omitempty" } },
            { no: 21, name: "HostGroups", kind: "scalar", jsonName: "HostGroups", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "host_groups,omitempty" } },
            { no: 22, name: "HostSudoers", kind: "scalar", jsonName: "HostSudoers", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "host_sudoers,omitempty" } },
            { no: 23, name: "AzureIdentities", kind: "scalar", jsonName: "AzureIdentities", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "azure_identities,omitempty" } },
            { no: 24, name: "KubernetesResources", kind: "message", jsonName: "KubernetesResources", repeat: 1 /*RepeatType.PACKED*/, T: () => KubernetesResource, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "kubernetes_resources,omitempty" } },
            { no: 25, name: "GCPServiceAccounts", kind: "scalar", jsonName: "GCPServiceAccounts", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "gcp_service_accounts,omitempty" } },
            { no: 26, name: "DatabaseServiceLabels", kind: "message", jsonName: "DatabaseServiceLabels", T: () => LabelValues, options: { "gogoproto.nullable": false, "gogoproto.customtype": "Labels", "gogoproto.jsontag": "db_service_labels,omitempty" } },
            { no: 27, name: "GroupLabels", kind: "message", jsonName: "GroupLabels", T: () => LabelValues, options: { "gogoproto.nullable": false, "gogoproto.customtype": "Labels", "gogoproto.jsontag": "group_labels,omitempty" } },
            { no: 28, name: "DesktopGroups", kind: "scalar", jsonName: "DesktopGroups", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "desktop_groups,omitempty" } },
            { no: 29, name: "DatabaseRoles", kind: "scalar", jsonName: "DatabaseRoles", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "db_roles,omitempty" } },
            { no: 30, name: "NodeLabelsExpression", kind: "scalar", jsonName: "NodeLabelsExpression", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "node_labels_expression,omitempty" } },
            { no: 31, name: "AppLabelsExpression", kind: "scalar", jsonName: "AppLabelsExpression", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "app_labels_expression,omitempty" } },
            { no: 32, name: "ClusterLabelsExpression", kind: "scalar", jsonName: "ClusterLabelsExpression", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "cluster_labels_expression,omitempty" } },
            { no: 33, name: "KubernetesLabelsExpression", kind: "scalar", jsonName: "KubernetesLabelsExpression", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kubernetes_labels_expression,omitempty" } },
            { no: 34, name: "DatabaseLabelsExpression", kind: "scalar", jsonName: "DatabaseLabelsExpression", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "db_labels_expression,omitempty" } },
            { no: 35, name: "DatabaseServiceLabelsExpression", kind: "scalar", jsonName: "DatabaseServiceLabelsExpression", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "db_service_labels_expression,omitempty" } },
            { no: 36, name: "WindowsDesktopLabelsExpression", kind: "scalar", jsonName: "WindowsDesktopLabelsExpression", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "windows_desktop_labels_expression,omitempty" } },
            { no: 37, name: "GroupLabelsExpression", kind: "scalar", jsonName: "GroupLabelsExpression", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "group_labels_expression,omitempty" } },
            { no: 38, name: "DatabasePermissions", kind: "message", jsonName: "DatabasePermissions", repeat: 1 /*RepeatType.PACKED*/, T: () => DatabasePermission, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "db_permissions,omitempty" } },
            { no: 39, name: "SPIFFE", kind: "message", jsonName: "SPIFFE", repeat: 1 /*RepeatType.PACKED*/, T: () => SPIFFERoleCondition, options: { "gogoproto.jsontag": "spiffe,omitempty" } },
            { no: 42, name: "AccountAssignments", kind: "message", jsonName: "AccountAssignments", repeat: 1 /*RepeatType.PACKED*/, T: () => IdentityCenterAccountAssignment, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "account_assignments,omitempty" } },
            { no: 43, name: "git_hub_permissions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GitHubPermission, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "github_permissions,omitempty" } },
            { no: 44, name: "WorkloadIdentityLabels", kind: "message", jsonName: "WorkloadIdentityLabels", T: () => LabelValues, options: { "gogoproto.nullable": false, "gogoproto.customtype": "Labels", "gogoproto.jsontag": "workload_identity_labels,omitempty" } },
            { no: 45, name: "WorkloadIdentityLabelsExpression", kind: "scalar", jsonName: "WorkloadIdentityLabelsExpression", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "workload_identity_labels_expression,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<RoleConditions>): RoleConditions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.logins = [];
        message.namespaces = [];
        message.rules = [];
        message.kubeGroups = [];
        message.kubeUsers = [];
        message.databaseNames = [];
        message.databaseUsers = [];
        message.aWSRoleARNs = [];
        message.windowsDesktopLogins = [];
        message.requireSessionJoin = [];
        message.joinSessions = [];
        message.hostGroups = [];
        message.hostSudoers = [];
        message.azureIdentities = [];
        message.kubernetesResources = [];
        message.gCPServiceAccounts = [];
        message.desktopGroups = [];
        message.databaseRoles = [];
        message.nodeLabelsExpression = "";
        message.appLabelsExpression = "";
        message.clusterLabelsExpression = "";
        message.kubernetesLabelsExpression = "";
        message.databaseLabelsExpression = "";
        message.databaseServiceLabelsExpression = "";
        message.windowsDesktopLabelsExpression = "";
        message.groupLabelsExpression = "";
        message.databasePermissions = [];
        message.sPIFFE = [];
        message.accountAssignments = [];
        message.gitHubPermissions = [];
        message.workloadIdentityLabelsExpression = "";
        if (value !== undefined)
            reflectionMergePartial<RoleConditions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RoleConditions): RoleConditions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string Logins = 1 [json_name = "Logins"];*/ 1:
                    message.logins.push(reader.string());
                    break;
                case /* repeated string Namespaces = 2 [json_name = "Namespaces"];*/ 2:
                    message.namespaces.push(reader.string());
                    break;
                case /* wrappers.LabelValues NodeLabels = 3 [json_name = "NodeLabels"];*/ 3:
                    message.nodeLabels = LabelValues.internalBinaryRead(reader, reader.uint32(), options, message.nodeLabels);
                    break;
                case /* repeated types.Rule Rules = 4 [json_name = "Rules"];*/ 4:
                    message.rules.push(Rule.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string KubeGroups = 5 [json_name = "KubeGroups"];*/ 5:
                    message.kubeGroups.push(reader.string());
                    break;
                case /* types.AccessRequestConditions Request = 6 [json_name = "Request"];*/ 6:
                    message.request = AccessRequestConditions.internalBinaryRead(reader, reader.uint32(), options, message.request);
                    break;
                case /* repeated string KubeUsers = 7 [json_name = "KubeUsers"];*/ 7:
                    message.kubeUsers.push(reader.string());
                    break;
                case /* wrappers.LabelValues AppLabels = 8 [json_name = "AppLabels"];*/ 8:
                    message.appLabels = LabelValues.internalBinaryRead(reader, reader.uint32(), options, message.appLabels);
                    break;
                case /* wrappers.LabelValues ClusterLabels = 9 [json_name = "ClusterLabels"];*/ 9:
                    message.clusterLabels = LabelValues.internalBinaryRead(reader, reader.uint32(), options, message.clusterLabels);
                    break;
                case /* wrappers.LabelValues KubernetesLabels = 10 [json_name = "KubernetesLabels"];*/ 10:
                    message.kubernetesLabels = LabelValues.internalBinaryRead(reader, reader.uint32(), options, message.kubernetesLabels);
                    break;
                case /* wrappers.LabelValues DatabaseLabels = 11 [json_name = "DatabaseLabels"];*/ 11:
                    message.databaseLabels = LabelValues.internalBinaryRead(reader, reader.uint32(), options, message.databaseLabels);
                    break;
                case /* repeated string DatabaseNames = 12 [json_name = "DatabaseNames"];*/ 12:
                    message.databaseNames.push(reader.string());
                    break;
                case /* repeated string DatabaseUsers = 13 [json_name = "DatabaseUsers"];*/ 13:
                    message.databaseUsers.push(reader.string());
                    break;
                case /* types.ImpersonateConditions Impersonate = 14 [json_name = "Impersonate"];*/ 14:
                    message.impersonate = ImpersonateConditions.internalBinaryRead(reader, reader.uint32(), options, message.impersonate);
                    break;
                case /* types.AccessReviewConditions ReviewRequests = 15 [json_name = "ReviewRequests"];*/ 15:
                    message.reviewRequests = AccessReviewConditions.internalBinaryRead(reader, reader.uint32(), options, message.reviewRequests);
                    break;
                case /* repeated string AWSRoleARNs = 16 [json_name = "AWSRoleARNs"];*/ 16:
                    message.aWSRoleARNs.push(reader.string());
                    break;
                case /* repeated string WindowsDesktopLogins = 17 [json_name = "WindowsDesktopLogins"];*/ 17:
                    message.windowsDesktopLogins.push(reader.string());
                    break;
                case /* wrappers.LabelValues WindowsDesktopLabels = 18 [json_name = "WindowsDesktopLabels"];*/ 18:
                    message.windowsDesktopLabels = LabelValues.internalBinaryRead(reader, reader.uint32(), options, message.windowsDesktopLabels);
                    break;
                case /* repeated types.SessionRequirePolicy RequireSessionJoin = 19 [json_name = "RequireSessionJoin"];*/ 19:
                    message.requireSessionJoin.push(SessionRequirePolicy.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated types.SessionJoinPolicy JoinSessions = 20 [json_name = "JoinSessions"];*/ 20:
                    message.joinSessions.push(SessionJoinPolicy.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string HostGroups = 21 [json_name = "HostGroups"];*/ 21:
                    message.hostGroups.push(reader.string());
                    break;
                case /* repeated string HostSudoers = 22 [json_name = "HostSudoers"];*/ 22:
                    message.hostSudoers.push(reader.string());
                    break;
                case /* repeated string AzureIdentities = 23 [json_name = "AzureIdentities"];*/ 23:
                    message.azureIdentities.push(reader.string());
                    break;
                case /* repeated types.KubernetesResource KubernetesResources = 24 [json_name = "KubernetesResources"];*/ 24:
                    message.kubernetesResources.push(KubernetesResource.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string GCPServiceAccounts = 25 [json_name = "GCPServiceAccounts"];*/ 25:
                    message.gCPServiceAccounts.push(reader.string());
                    break;
                case /* wrappers.LabelValues DatabaseServiceLabels = 26 [json_name = "DatabaseServiceLabels"];*/ 26:
                    message.databaseServiceLabels = LabelValues.internalBinaryRead(reader, reader.uint32(), options, message.databaseServiceLabels);
                    break;
                case /* wrappers.LabelValues GroupLabels = 27 [json_name = "GroupLabels"];*/ 27:
                    message.groupLabels = LabelValues.internalBinaryRead(reader, reader.uint32(), options, message.groupLabels);
                    break;
                case /* repeated string DesktopGroups = 28 [json_name = "DesktopGroups"];*/ 28:
                    message.desktopGroups.push(reader.string());
                    break;
                case /* repeated string DatabaseRoles = 29 [json_name = "DatabaseRoles"];*/ 29:
                    message.databaseRoles.push(reader.string());
                    break;
                case /* string NodeLabelsExpression = 30 [json_name = "NodeLabelsExpression"];*/ 30:
                    message.nodeLabelsExpression = reader.string();
                    break;
                case /* string AppLabelsExpression = 31 [json_name = "AppLabelsExpression"];*/ 31:
                    message.appLabelsExpression = reader.string();
                    break;
                case /* string ClusterLabelsExpression = 32 [json_name = "ClusterLabelsExpression"];*/ 32:
                    message.clusterLabelsExpression = reader.string();
                    break;
                case /* string KubernetesLabelsExpression = 33 [json_name = "KubernetesLabelsExpression"];*/ 33:
                    message.kubernetesLabelsExpression = reader.string();
                    break;
                case /* string DatabaseLabelsExpression = 34 [json_name = "DatabaseLabelsExpression"];*/ 34:
                    message.databaseLabelsExpression = reader.string();
                    break;
                case /* string DatabaseServiceLabelsExpression = 35 [json_name = "DatabaseServiceLabelsExpression"];*/ 35:
                    message.databaseServiceLabelsExpression = reader.string();
                    break;
                case /* string WindowsDesktopLabelsExpression = 36 [json_name = "WindowsDesktopLabelsExpression"];*/ 36:
                    message.windowsDesktopLabelsExpression = reader.string();
                    break;
                case /* string GroupLabelsExpression = 37 [json_name = "GroupLabelsExpression"];*/ 37:
                    message.groupLabelsExpression = reader.string();
                    break;
                case /* repeated types.DatabasePermission DatabasePermissions = 38 [json_name = "DatabasePermissions"];*/ 38:
                    message.databasePermissions.push(DatabasePermission.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated types.SPIFFERoleCondition SPIFFE = 39 [json_name = "SPIFFE"];*/ 39:
                    message.sPIFFE.push(SPIFFERoleCondition.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated types.IdentityCenterAccountAssignment AccountAssignments = 42 [json_name = "AccountAssignments"];*/ 42:
                    message.accountAssignments.push(IdentityCenterAccountAssignment.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated types.GitHubPermission git_hub_permissions */ 43:
                    message.gitHubPermissions.push(GitHubPermission.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* wrappers.LabelValues WorkloadIdentityLabels = 44 [json_name = "WorkloadIdentityLabels"];*/ 44:
                    message.workloadIdentityLabels = LabelValues.internalBinaryRead(reader, reader.uint32(), options, message.workloadIdentityLabels);
                    break;
                case /* string WorkloadIdentityLabelsExpression = 45 [json_name = "WorkloadIdentityLabelsExpression"];*/ 45:
                    message.workloadIdentityLabelsExpression = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RoleConditions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string Logins = 1 [json_name = "Logins"]; */
        for (let i = 0; i < message.logins.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.logins[i]);
        /* repeated string Namespaces = 2 [json_name = "Namespaces"]; */
        for (let i = 0; i < message.namespaces.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.namespaces[i]);
        /* wrappers.LabelValues NodeLabels = 3 [json_name = "NodeLabels"]; */
        if (message.nodeLabels)
            LabelValues.internalBinaryWrite(message.nodeLabels, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated types.Rule Rules = 4 [json_name = "Rules"]; */
        for (let i = 0; i < message.rules.length; i++)
            Rule.internalBinaryWrite(message.rules[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated string KubeGroups = 5 [json_name = "KubeGroups"]; */
        for (let i = 0; i < message.kubeGroups.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.kubeGroups[i]);
        /* types.AccessRequestConditions Request = 6 [json_name = "Request"]; */
        if (message.request)
            AccessRequestConditions.internalBinaryWrite(message.request, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated string KubeUsers = 7 [json_name = "KubeUsers"]; */
        for (let i = 0; i < message.kubeUsers.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.kubeUsers[i]);
        /* wrappers.LabelValues AppLabels = 8 [json_name = "AppLabels"]; */
        if (message.appLabels)
            LabelValues.internalBinaryWrite(message.appLabels, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* wrappers.LabelValues ClusterLabels = 9 [json_name = "ClusterLabels"]; */
        if (message.clusterLabels)
            LabelValues.internalBinaryWrite(message.clusterLabels, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* wrappers.LabelValues KubernetesLabels = 10 [json_name = "KubernetesLabels"]; */
        if (message.kubernetesLabels)
            LabelValues.internalBinaryWrite(message.kubernetesLabels, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* wrappers.LabelValues DatabaseLabels = 11 [json_name = "DatabaseLabels"]; */
        if (message.databaseLabels)
            LabelValues.internalBinaryWrite(message.databaseLabels, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* repeated string DatabaseNames = 12 [json_name = "DatabaseNames"]; */
        for (let i = 0; i < message.databaseNames.length; i++)
            writer.tag(12, WireType.LengthDelimited).string(message.databaseNames[i]);
        /* repeated string DatabaseUsers = 13 [json_name = "DatabaseUsers"]; */
        for (let i = 0; i < message.databaseUsers.length; i++)
            writer.tag(13, WireType.LengthDelimited).string(message.databaseUsers[i]);
        /* types.ImpersonateConditions Impersonate = 14 [json_name = "Impersonate"]; */
        if (message.impersonate)
            ImpersonateConditions.internalBinaryWrite(message.impersonate, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* types.AccessReviewConditions ReviewRequests = 15 [json_name = "ReviewRequests"]; */
        if (message.reviewRequests)
            AccessReviewConditions.internalBinaryWrite(message.reviewRequests, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* repeated string AWSRoleARNs = 16 [json_name = "AWSRoleARNs"]; */
        for (let i = 0; i < message.aWSRoleARNs.length; i++)
            writer.tag(16, WireType.LengthDelimited).string(message.aWSRoleARNs[i]);
        /* repeated string WindowsDesktopLogins = 17 [json_name = "WindowsDesktopLogins"]; */
        for (let i = 0; i < message.windowsDesktopLogins.length; i++)
            writer.tag(17, WireType.LengthDelimited).string(message.windowsDesktopLogins[i]);
        /* wrappers.LabelValues WindowsDesktopLabels = 18 [json_name = "WindowsDesktopLabels"]; */
        if (message.windowsDesktopLabels)
            LabelValues.internalBinaryWrite(message.windowsDesktopLabels, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* repeated types.SessionRequirePolicy RequireSessionJoin = 19 [json_name = "RequireSessionJoin"]; */
        for (let i = 0; i < message.requireSessionJoin.length; i++)
            SessionRequirePolicy.internalBinaryWrite(message.requireSessionJoin[i], writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* repeated types.SessionJoinPolicy JoinSessions = 20 [json_name = "JoinSessions"]; */
        for (let i = 0; i < message.joinSessions.length; i++)
            SessionJoinPolicy.internalBinaryWrite(message.joinSessions[i], writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* repeated string HostGroups = 21 [json_name = "HostGroups"]; */
        for (let i = 0; i < message.hostGroups.length; i++)
            writer.tag(21, WireType.LengthDelimited).string(message.hostGroups[i]);
        /* repeated string HostSudoers = 22 [json_name = "HostSudoers"]; */
        for (let i = 0; i < message.hostSudoers.length; i++)
            writer.tag(22, WireType.LengthDelimited).string(message.hostSudoers[i]);
        /* repeated string AzureIdentities = 23 [json_name = "AzureIdentities"]; */
        for (let i = 0; i < message.azureIdentities.length; i++)
            writer.tag(23, WireType.LengthDelimited).string(message.azureIdentities[i]);
        /* repeated types.KubernetesResource KubernetesResources = 24 [json_name = "KubernetesResources"]; */
        for (let i = 0; i < message.kubernetesResources.length; i++)
            KubernetesResource.internalBinaryWrite(message.kubernetesResources[i], writer.tag(24, WireType.LengthDelimited).fork(), options).join();
        /* repeated string GCPServiceAccounts = 25 [json_name = "GCPServiceAccounts"]; */
        for (let i = 0; i < message.gCPServiceAccounts.length; i++)
            writer.tag(25, WireType.LengthDelimited).string(message.gCPServiceAccounts[i]);
        /* wrappers.LabelValues DatabaseServiceLabels = 26 [json_name = "DatabaseServiceLabels"]; */
        if (message.databaseServiceLabels)
            LabelValues.internalBinaryWrite(message.databaseServiceLabels, writer.tag(26, WireType.LengthDelimited).fork(), options).join();
        /* wrappers.LabelValues GroupLabels = 27 [json_name = "GroupLabels"]; */
        if (message.groupLabels)
            LabelValues.internalBinaryWrite(message.groupLabels, writer.tag(27, WireType.LengthDelimited).fork(), options).join();
        /* repeated string DesktopGroups = 28 [json_name = "DesktopGroups"]; */
        for (let i = 0; i < message.desktopGroups.length; i++)
            writer.tag(28, WireType.LengthDelimited).string(message.desktopGroups[i]);
        /* repeated string DatabaseRoles = 29 [json_name = "DatabaseRoles"]; */
        for (let i = 0; i < message.databaseRoles.length; i++)
            writer.tag(29, WireType.LengthDelimited).string(message.databaseRoles[i]);
        /* string NodeLabelsExpression = 30 [json_name = "NodeLabelsExpression"]; */
        if (message.nodeLabelsExpression !== "")
            writer.tag(30, WireType.LengthDelimited).string(message.nodeLabelsExpression);
        /* string AppLabelsExpression = 31 [json_name = "AppLabelsExpression"]; */
        if (message.appLabelsExpression !== "")
            writer.tag(31, WireType.LengthDelimited).string(message.appLabelsExpression);
        /* string ClusterLabelsExpression = 32 [json_name = "ClusterLabelsExpression"]; */
        if (message.clusterLabelsExpression !== "")
            writer.tag(32, WireType.LengthDelimited).string(message.clusterLabelsExpression);
        /* string KubernetesLabelsExpression = 33 [json_name = "KubernetesLabelsExpression"]; */
        if (message.kubernetesLabelsExpression !== "")
            writer.tag(33, WireType.LengthDelimited).string(message.kubernetesLabelsExpression);
        /* string DatabaseLabelsExpression = 34 [json_name = "DatabaseLabelsExpression"]; */
        if (message.databaseLabelsExpression !== "")
            writer.tag(34, WireType.LengthDelimited).string(message.databaseLabelsExpression);
        /* string DatabaseServiceLabelsExpression = 35 [json_name = "DatabaseServiceLabelsExpression"]; */
        if (message.databaseServiceLabelsExpression !== "")
            writer.tag(35, WireType.LengthDelimited).string(message.databaseServiceLabelsExpression);
        /* string WindowsDesktopLabelsExpression = 36 [json_name = "WindowsDesktopLabelsExpression"]; */
        if (message.windowsDesktopLabelsExpression !== "")
            writer.tag(36, WireType.LengthDelimited).string(message.windowsDesktopLabelsExpression);
        /* string GroupLabelsExpression = 37 [json_name = "GroupLabelsExpression"]; */
        if (message.groupLabelsExpression !== "")
            writer.tag(37, WireType.LengthDelimited).string(message.groupLabelsExpression);
        /* repeated types.DatabasePermission DatabasePermissions = 38 [json_name = "DatabasePermissions"]; */
        for (let i = 0; i < message.databasePermissions.length; i++)
            DatabasePermission.internalBinaryWrite(message.databasePermissions[i], writer.tag(38, WireType.LengthDelimited).fork(), options).join();
        /* repeated types.SPIFFERoleCondition SPIFFE = 39 [json_name = "SPIFFE"]; */
        for (let i = 0; i < message.sPIFFE.length; i++)
            SPIFFERoleCondition.internalBinaryWrite(message.sPIFFE[i], writer.tag(39, WireType.LengthDelimited).fork(), options).join();
        /* repeated types.IdentityCenterAccountAssignment AccountAssignments = 42 [json_name = "AccountAssignments"]; */
        for (let i = 0; i < message.accountAssignments.length; i++)
            IdentityCenterAccountAssignment.internalBinaryWrite(message.accountAssignments[i], writer.tag(42, WireType.LengthDelimited).fork(), options).join();
        /* repeated types.GitHubPermission git_hub_permissions = 43; */
        for (let i = 0; i < message.gitHubPermissions.length; i++)
            GitHubPermission.internalBinaryWrite(message.gitHubPermissions[i], writer.tag(43, WireType.LengthDelimited).fork(), options).join();
        /* wrappers.LabelValues WorkloadIdentityLabels = 44 [json_name = "WorkloadIdentityLabels"]; */
        if (message.workloadIdentityLabels)
            LabelValues.internalBinaryWrite(message.workloadIdentityLabels, writer.tag(44, WireType.LengthDelimited).fork(), options).join();
        /* string WorkloadIdentityLabelsExpression = 45 [json_name = "WorkloadIdentityLabelsExpression"]; */
        if (message.workloadIdentityLabelsExpression !== "")
            writer.tag(45, WireType.LengthDelimited).string(message.workloadIdentityLabelsExpression);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.RoleConditions
 */
export const RoleConditions = new RoleConditions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IdentityCenterAccountAssignment$Type extends MessageType<IdentityCenterAccountAssignment> {
    constructor() {
        super("types.IdentityCenterAccountAssignment", [
            { no: 1, name: "PermissionSet", kind: "scalar", jsonName: "PermissionSet", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "permission_set,omitempty" } },
            { no: 2, name: "Account", kind: "scalar", jsonName: "Account", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "account,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<IdentityCenterAccountAssignment>): IdentityCenterAccountAssignment {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.permissionSet = "";
        message.account = "";
        if (value !== undefined)
            reflectionMergePartial<IdentityCenterAccountAssignment>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IdentityCenterAccountAssignment): IdentityCenterAccountAssignment {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string PermissionSet = 1 [json_name = "PermissionSet"];*/ 1:
                    message.permissionSet = reader.string();
                    break;
                case /* string Account = 2 [json_name = "Account"];*/ 2:
                    message.account = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IdentityCenterAccountAssignment, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string PermissionSet = 1 [json_name = "PermissionSet"]; */
        if (message.permissionSet !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.permissionSet);
        /* string Account = 2 [json_name = "Account"]; */
        if (message.account !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.account);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.IdentityCenterAccountAssignment
 */
export const IdentityCenterAccountAssignment = new IdentityCenterAccountAssignment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GitHubPermission$Type extends MessageType<GitHubPermission> {
    constructor() {
        super("types.GitHubPermission", [
            { no: 1, name: "organizations", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "orgs,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<GitHubPermission>): GitHubPermission {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.organizations = [];
        if (value !== undefined)
            reflectionMergePartial<GitHubPermission>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GitHubPermission): GitHubPermission {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string organizations */ 1:
                    message.organizations.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GitHubPermission, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string organizations = 1; */
        for (let i = 0; i < message.organizations.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.organizations[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.GitHubPermission
 */
export const GitHubPermission = new GitHubPermission$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SPIFFERoleCondition$Type extends MessageType<SPIFFERoleCondition> {
    constructor() {
        super("types.SPIFFERoleCondition", [
            { no: 1, name: "Path", kind: "scalar", jsonName: "Path", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "path,omitempty" } },
            { no: 2, name: "DNSSANs", kind: "scalar", jsonName: "DNSSANs", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "dns_sans,omitempty" } },
            { no: 3, name: "IPSANs", kind: "scalar", jsonName: "IPSANs", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "ip_sans,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<SPIFFERoleCondition>): SPIFFERoleCondition {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.path = "";
        message.dNSSANs = [];
        message.iPSANs = [];
        if (value !== undefined)
            reflectionMergePartial<SPIFFERoleCondition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SPIFFERoleCondition): SPIFFERoleCondition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Path = 1 [json_name = "Path"];*/ 1:
                    message.path = reader.string();
                    break;
                case /* repeated string DNSSANs = 2 [json_name = "DNSSANs"];*/ 2:
                    message.dNSSANs.push(reader.string());
                    break;
                case /* repeated string IPSANs = 3 [json_name = "IPSANs"];*/ 3:
                    message.iPSANs.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SPIFFERoleCondition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Path = 1 [json_name = "Path"]; */
        if (message.path !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.path);
        /* repeated string DNSSANs = 2 [json_name = "DNSSANs"]; */
        for (let i = 0; i < message.dNSSANs.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.dNSSANs[i]);
        /* repeated string IPSANs = 3 [json_name = "IPSANs"]; */
        for (let i = 0; i < message.iPSANs.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.iPSANs[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.SPIFFERoleCondition
 */
export const SPIFFERoleCondition = new SPIFFERoleCondition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DatabasePermission$Type extends MessageType<DatabasePermission> {
    constructor() {
        super("types.DatabasePermission", [
            { no: 1, name: "Permissions", kind: "scalar", jsonName: "Permissions", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "permissions" } },
            { no: 2, name: "Match", kind: "message", jsonName: "Match", T: () => LabelValues, options: { "gogoproto.nullable": false, "gogoproto.customtype": "Labels", "gogoproto.jsontag": "match" } }
        ]);
    }
    create(value?: PartialMessage<DatabasePermission>): DatabasePermission {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.permissions = [];
        if (value !== undefined)
            reflectionMergePartial<DatabasePermission>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DatabasePermission): DatabasePermission {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string Permissions = 1 [json_name = "Permissions"];*/ 1:
                    message.permissions.push(reader.string());
                    break;
                case /* wrappers.LabelValues Match = 2 [json_name = "Match"];*/ 2:
                    message.match = LabelValues.internalBinaryRead(reader, reader.uint32(), options, message.match);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DatabasePermission, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string Permissions = 1 [json_name = "Permissions"]; */
        for (let i = 0; i < message.permissions.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.permissions[i]);
        /* wrappers.LabelValues Match = 2 [json_name = "Match"]; */
        if (message.match)
            LabelValues.internalBinaryWrite(message.match, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.DatabasePermission
 */
export const DatabasePermission = new DatabasePermission$Type();
// @generated message type with reflection information, may provide speed optimized methods
class KubernetesResource$Type extends MessageType<KubernetesResource> {
    constructor() {
        super("types.KubernetesResource", [
            { no: 1, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind,omitempty" } },
            { no: 2, name: "Namespace", kind: "scalar", jsonName: "Namespace", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "namespace,omitempty" } },
            { no: 3, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "name,omitempty" } },
            { no: 4, name: "Verbs", kind: "scalar", jsonName: "Verbs", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "verbs,omitempty" } },
            { no: 5, name: "APIGroup", kind: "scalar", jsonName: "APIGroup", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "api_group,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<KubernetesResource>): KubernetesResource {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.namespace = "";
        message.name = "";
        message.verbs = [];
        message.aPIGroup = "";
        if (value !== undefined)
            reflectionMergePartial<KubernetesResource>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KubernetesResource): KubernetesResource {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Kind = 1 [json_name = "Kind"];*/ 1:
                    message.kind = reader.string();
                    break;
                case /* string Namespace = 2 [json_name = "Namespace"];*/ 2:
                    message.namespace = reader.string();
                    break;
                case /* string Name = 3 [json_name = "Name"];*/ 3:
                    message.name = reader.string();
                    break;
                case /* repeated string Verbs = 4 [json_name = "Verbs"];*/ 4:
                    message.verbs.push(reader.string());
                    break;
                case /* string APIGroup = 5 [json_name = "APIGroup"];*/ 5:
                    message.aPIGroup = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: KubernetesResource, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Kind = 1 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string Namespace = 2 [json_name = "Namespace"]; */
        if (message.namespace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.namespace);
        /* string Name = 3 [json_name = "Name"]; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* repeated string Verbs = 4 [json_name = "Verbs"]; */
        for (let i = 0; i < message.verbs.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.verbs[i]);
        /* string APIGroup = 5 [json_name = "APIGroup"]; */
        if (message.aPIGroup !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.aPIGroup);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.KubernetesResource
 */
export const KubernetesResource = new KubernetesResource$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SessionRequirePolicy$Type extends MessageType<SessionRequirePolicy> {
    constructor() {
        super("types.SessionRequirePolicy", [
            { no: 1, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "name" } },
            { no: 2, name: "Filter", kind: "scalar", jsonName: "Filter", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "filter" } },
            { no: 3, name: "Kinds", kind: "scalar", jsonName: "Kinds", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kinds" } },
            { no: 4, name: "Count", kind: "scalar", jsonName: "Count", T: 5 /*ScalarType.INT32*/, options: { "gogoproto.jsontag": "count" } },
            { no: 5, name: "Modes", kind: "scalar", jsonName: "Modes", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "modes" } },
            { no: 6, name: "OnLeave", kind: "scalar", jsonName: "OnLeave", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "on_leave" } }
        ]);
    }
    create(value?: PartialMessage<SessionRequirePolicy>): SessionRequirePolicy {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.filter = "";
        message.kinds = [];
        message.count = 0;
        message.modes = [];
        message.onLeave = "";
        if (value !== undefined)
            reflectionMergePartial<SessionRequirePolicy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SessionRequirePolicy): SessionRequirePolicy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Name = 1 [json_name = "Name"];*/ 1:
                    message.name = reader.string();
                    break;
                case /* string Filter = 2 [json_name = "Filter"];*/ 2:
                    message.filter = reader.string();
                    break;
                case /* repeated string Kinds = 3 [json_name = "Kinds"];*/ 3:
                    message.kinds.push(reader.string());
                    break;
                case /* int32 Count = 4 [json_name = "Count"];*/ 4:
                    message.count = reader.int32();
                    break;
                case /* repeated string Modes = 5 [json_name = "Modes"];*/ 5:
                    message.modes.push(reader.string());
                    break;
                case /* string OnLeave = 6 [json_name = "OnLeave"];*/ 6:
                    message.onLeave = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SessionRequirePolicy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Name = 1 [json_name = "Name"]; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string Filter = 2 [json_name = "Filter"]; */
        if (message.filter !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.filter);
        /* repeated string Kinds = 3 [json_name = "Kinds"]; */
        for (let i = 0; i < message.kinds.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.kinds[i]);
        /* int32 Count = 4 [json_name = "Count"]; */
        if (message.count !== 0)
            writer.tag(4, WireType.Varint).int32(message.count);
        /* repeated string Modes = 5 [json_name = "Modes"]; */
        for (let i = 0; i < message.modes.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.modes[i]);
        /* string OnLeave = 6 [json_name = "OnLeave"]; */
        if (message.onLeave !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.onLeave);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.SessionRequirePolicy
 */
export const SessionRequirePolicy = new SessionRequirePolicy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SessionJoinPolicy$Type extends MessageType<SessionJoinPolicy> {
    constructor() {
        super("types.SessionJoinPolicy", [
            { no: 1, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "name" } },
            { no: 2, name: "Roles", kind: "scalar", jsonName: "Roles", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "roles" } },
            { no: 3, name: "Kinds", kind: "scalar", jsonName: "Kinds", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kinds" } },
            { no: 4, name: "Modes", kind: "scalar", jsonName: "Modes", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "modes" } }
        ]);
    }
    create(value?: PartialMessage<SessionJoinPolicy>): SessionJoinPolicy {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.roles = [];
        message.kinds = [];
        message.modes = [];
        if (value !== undefined)
            reflectionMergePartial<SessionJoinPolicy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SessionJoinPolicy): SessionJoinPolicy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Name = 1 [json_name = "Name"];*/ 1:
                    message.name = reader.string();
                    break;
                case /* repeated string Roles = 2 [json_name = "Roles"];*/ 2:
                    message.roles.push(reader.string());
                    break;
                case /* repeated string Kinds = 3 [json_name = "Kinds"];*/ 3:
                    message.kinds.push(reader.string());
                    break;
                case /* repeated string Modes = 4 [json_name = "Modes"];*/ 4:
                    message.modes.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SessionJoinPolicy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Name = 1 [json_name = "Name"]; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* repeated string Roles = 2 [json_name = "Roles"]; */
        for (let i = 0; i < message.roles.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.roles[i]);
        /* repeated string Kinds = 3 [json_name = "Kinds"]; */
        for (let i = 0; i < message.kinds.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.kinds[i]);
        /* repeated string Modes = 4 [json_name = "Modes"]; */
        for (let i = 0; i < message.modes.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.modes[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.SessionJoinPolicy
 */
export const SessionJoinPolicy = new SessionJoinPolicy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessRequestConditions$Type extends MessageType<AccessRequestConditions> {
    constructor() {
        super("types.AccessRequestConditions", [
            { no: 1, name: "Roles", kind: "scalar", jsonName: "Roles", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "roles,omitempty" } },
            { no: 2, name: "ClaimsToRoles", kind: "message", jsonName: "ClaimsToRoles", repeat: 1 /*RepeatType.PACKED*/, T: () => ClaimMapping, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "claims_to_roles,omitempty" } },
            { no: 3, name: "Annotations", kind: "message", jsonName: "Annotations", T: () => LabelValues, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/gravitational/teleport/api/types/wrappers.Traits", "gogoproto.jsontag": "annotations,omitempty" } },
            { no: 4, name: "Thresholds", kind: "message", jsonName: "Thresholds", repeat: 1 /*RepeatType.PACKED*/, T: () => AccessReviewThreshold, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "thresholds,omitempty" } },
            { no: 5, name: "SuggestedReviewers", kind: "scalar", jsonName: "SuggestedReviewers", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "suggested_reviewers,omitempty" } },
            { no: 6, name: "SearchAsRoles", kind: "scalar", jsonName: "SearchAsRoles", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "search_as_roles,omitempty" } },
            { no: 7, name: "MaxDuration", kind: "scalar", jsonName: "MaxDuration", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "max_duration,omitempty", "gogoproto.casttype": "Duration" } },
            { no: 8, name: "kubernetes_resources", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RequestKubernetesResource, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "kubernetes_resources,omitempty" } },
            { no: 9, name: "Reason", kind: "message", jsonName: "Reason", T: () => AccessRequestConditionsReason, options: { "gogoproto.jsontag": "reason,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<AccessRequestConditions>): AccessRequestConditions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.roles = [];
        message.claimsToRoles = [];
        message.thresholds = [];
        message.suggestedReviewers = [];
        message.searchAsRoles = [];
        message.maxDuration = 0n;
        message.kubernetesResources = [];
        if (value !== undefined)
            reflectionMergePartial<AccessRequestConditions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessRequestConditions): AccessRequestConditions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string Roles = 1 [json_name = "Roles"];*/ 1:
                    message.roles.push(reader.string());
                    break;
                case /* repeated types.ClaimMapping ClaimsToRoles = 2 [json_name = "ClaimsToRoles"];*/ 2:
                    message.claimsToRoles.push(ClaimMapping.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* wrappers.LabelValues Annotations = 3 [json_name = "Annotations"];*/ 3:
                    message.annotations = LabelValues.internalBinaryRead(reader, reader.uint32(), options, message.annotations);
                    break;
                case /* repeated types.AccessReviewThreshold Thresholds = 4 [json_name = "Thresholds"];*/ 4:
                    message.thresholds.push(AccessReviewThreshold.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string SuggestedReviewers = 5 [json_name = "SuggestedReviewers"];*/ 5:
                    message.suggestedReviewers.push(reader.string());
                    break;
                case /* repeated string SearchAsRoles = 6 [json_name = "SearchAsRoles"];*/ 6:
                    message.searchAsRoles.push(reader.string());
                    break;
                case /* int64 MaxDuration = 7 [json_name = "MaxDuration"];*/ 7:
                    message.maxDuration = reader.int64().toBigInt();
                    break;
                case /* repeated types.RequestKubernetesResource kubernetes_resources */ 8:
                    message.kubernetesResources.push(RequestKubernetesResource.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* types.AccessRequestConditionsReason Reason = 9 [json_name = "Reason"];*/ 9:
                    message.reason = AccessRequestConditionsReason.internalBinaryRead(reader, reader.uint32(), options, message.reason);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessRequestConditions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string Roles = 1 [json_name = "Roles"]; */
        for (let i = 0; i < message.roles.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.roles[i]);
        /* repeated types.ClaimMapping ClaimsToRoles = 2 [json_name = "ClaimsToRoles"]; */
        for (let i = 0; i < message.claimsToRoles.length; i++)
            ClaimMapping.internalBinaryWrite(message.claimsToRoles[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* wrappers.LabelValues Annotations = 3 [json_name = "Annotations"]; */
        if (message.annotations)
            LabelValues.internalBinaryWrite(message.annotations, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated types.AccessReviewThreshold Thresholds = 4 [json_name = "Thresholds"]; */
        for (let i = 0; i < message.thresholds.length; i++)
            AccessReviewThreshold.internalBinaryWrite(message.thresholds[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated string SuggestedReviewers = 5 [json_name = "SuggestedReviewers"]; */
        for (let i = 0; i < message.suggestedReviewers.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.suggestedReviewers[i]);
        /* repeated string SearchAsRoles = 6 [json_name = "SearchAsRoles"]; */
        for (let i = 0; i < message.searchAsRoles.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.searchAsRoles[i]);
        /* int64 MaxDuration = 7 [json_name = "MaxDuration"]; */
        if (message.maxDuration !== 0n)
            writer.tag(7, WireType.Varint).int64(message.maxDuration);
        /* repeated types.RequestKubernetesResource kubernetes_resources = 8; */
        for (let i = 0; i < message.kubernetesResources.length; i++)
            RequestKubernetesResource.internalBinaryWrite(message.kubernetesResources[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* types.AccessRequestConditionsReason Reason = 9 [json_name = "Reason"]; */
        if (message.reason)
            AccessRequestConditionsReason.internalBinaryWrite(message.reason, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AccessRequestConditions
 */
export const AccessRequestConditions = new AccessRequestConditions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessRequestConditionsReason$Type extends MessageType<AccessRequestConditionsReason> {
    constructor() {
        super("types.AccessRequestConditionsReason", [
            { no: 1, name: "Mode", kind: "scalar", jsonName: "Mode", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "mode,omitempty", "gogoproto.casttype": "RequestReasonMode" } }
        ]);
    }
    create(value?: PartialMessage<AccessRequestConditionsReason>): AccessRequestConditionsReason {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mode = "";
        if (value !== undefined)
            reflectionMergePartial<AccessRequestConditionsReason>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessRequestConditionsReason): AccessRequestConditionsReason {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Mode = 1 [json_name = "Mode"];*/ 1:
                    message.mode = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessRequestConditionsReason, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Mode = 1 [json_name = "Mode"]; */
        if (message.mode !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.mode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AccessRequestConditionsReason
 */
export const AccessRequestConditionsReason = new AccessRequestConditionsReason$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessReviewConditions$Type extends MessageType<AccessReviewConditions> {
    constructor() {
        super("types.AccessReviewConditions", [
            { no: 1, name: "Roles", kind: "scalar", jsonName: "Roles", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "roles,omitempty" } },
            { no: 2, name: "ClaimsToRoles", kind: "message", jsonName: "ClaimsToRoles", repeat: 1 /*RepeatType.PACKED*/, T: () => ClaimMapping, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "claims_to_roles,omitempty" } },
            { no: 3, name: "Where", kind: "scalar", jsonName: "Where", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "where,omitempty" } },
            { no: 4, name: "PreviewAsRoles", kind: "scalar", jsonName: "PreviewAsRoles", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "preview_as_roles,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<AccessReviewConditions>): AccessReviewConditions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.roles = [];
        message.claimsToRoles = [];
        message.where = "";
        message.previewAsRoles = [];
        if (value !== undefined)
            reflectionMergePartial<AccessReviewConditions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessReviewConditions): AccessReviewConditions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string Roles = 1 [json_name = "Roles"];*/ 1:
                    message.roles.push(reader.string());
                    break;
                case /* repeated types.ClaimMapping ClaimsToRoles = 2 [json_name = "ClaimsToRoles"];*/ 2:
                    message.claimsToRoles.push(ClaimMapping.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string Where = 3 [json_name = "Where"];*/ 3:
                    message.where = reader.string();
                    break;
                case /* repeated string PreviewAsRoles = 4 [json_name = "PreviewAsRoles"];*/ 4:
                    message.previewAsRoles.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessReviewConditions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string Roles = 1 [json_name = "Roles"]; */
        for (let i = 0; i < message.roles.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.roles[i]);
        /* repeated types.ClaimMapping ClaimsToRoles = 2 [json_name = "ClaimsToRoles"]; */
        for (let i = 0; i < message.claimsToRoles.length; i++)
            ClaimMapping.internalBinaryWrite(message.claimsToRoles[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string Where = 3 [json_name = "Where"]; */
        if (message.where !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.where);
        /* repeated string PreviewAsRoles = 4 [json_name = "PreviewAsRoles"]; */
        for (let i = 0; i < message.previewAsRoles.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.previewAsRoles[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AccessReviewConditions
 */
export const AccessReviewConditions = new AccessReviewConditions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessRequestAllowedPromotion$Type extends MessageType<AccessRequestAllowedPromotion> {
    constructor() {
        super("types.AccessRequestAllowedPromotion", [
            { no: 1, name: "accessListName", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AccessRequestAllowedPromotion>): AccessRequestAllowedPromotion {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accessListName = "";
        if (value !== undefined)
            reflectionMergePartial<AccessRequestAllowedPromotion>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessRequestAllowedPromotion): AccessRequestAllowedPromotion {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string accessListName */ 1:
                    message.accessListName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessRequestAllowedPromotion, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string accessListName = 1; */
        if (message.accessListName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accessListName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AccessRequestAllowedPromotion
 */
export const AccessRequestAllowedPromotion = new AccessRequestAllowedPromotion$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessRequestAllowedPromotions$Type extends MessageType<AccessRequestAllowedPromotions> {
    constructor() {
        super("types.AccessRequestAllowedPromotions", [
            { no: 1, name: "promotions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AccessRequestAllowedPromotion }
        ]);
    }
    create(value?: PartialMessage<AccessRequestAllowedPromotions>): AccessRequestAllowedPromotions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.promotions = [];
        if (value !== undefined)
            reflectionMergePartial<AccessRequestAllowedPromotions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessRequestAllowedPromotions): AccessRequestAllowedPromotions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.AccessRequestAllowedPromotion promotions */ 1:
                    message.promotions.push(AccessRequestAllowedPromotion.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessRequestAllowedPromotions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.AccessRequestAllowedPromotion promotions = 1; */
        for (let i = 0; i < message.promotions.length; i++)
            AccessRequestAllowedPromotion.internalBinaryWrite(message.promotions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AccessRequestAllowedPromotions
 */
export const AccessRequestAllowedPromotions = new AccessRequestAllowedPromotions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClaimMapping$Type extends MessageType<ClaimMapping> {
    constructor() {
        super("types.ClaimMapping", [
            { no: 1, name: "Claim", kind: "scalar", jsonName: "Claim", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "claim" } },
            { no: 2, name: "Value", kind: "scalar", jsonName: "Value", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "value" } },
            { no: 3, name: "Roles", kind: "scalar", jsonName: "Roles", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "roles,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ClaimMapping>): ClaimMapping {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.claim = "";
        message.value = "";
        message.roles = [];
        if (value !== undefined)
            reflectionMergePartial<ClaimMapping>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClaimMapping): ClaimMapping {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Claim = 1 [json_name = "Claim"];*/ 1:
                    message.claim = reader.string();
                    break;
                case /* string Value = 2 [json_name = "Value"];*/ 2:
                    message.value = reader.string();
                    break;
                case /* repeated string Roles = 3 [json_name = "Roles"];*/ 3:
                    message.roles.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClaimMapping, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Claim = 1 [json_name = "Claim"]; */
        if (message.claim !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.claim);
        /* string Value = 2 [json_name = "Value"]; */
        if (message.value !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        /* repeated string Roles = 3 [json_name = "Roles"]; */
        for (let i = 0; i < message.roles.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.roles[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ClaimMapping
 */
export const ClaimMapping = new ClaimMapping$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TraitMapping$Type extends MessageType<TraitMapping> {
    constructor() {
        super("types.TraitMapping", [
            { no: 1, name: "Trait", kind: "scalar", jsonName: "Trait", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "trait" } },
            { no: 2, name: "Value", kind: "scalar", jsonName: "Value", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "value" } },
            { no: 3, name: "Roles", kind: "scalar", jsonName: "Roles", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "roles,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<TraitMapping>): TraitMapping {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.trait = "";
        message.value = "";
        message.roles = [];
        if (value !== undefined)
            reflectionMergePartial<TraitMapping>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TraitMapping): TraitMapping {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Trait = 1 [json_name = "Trait"];*/ 1:
                    message.trait = reader.string();
                    break;
                case /* string Value = 2 [json_name = "Value"];*/ 2:
                    message.value = reader.string();
                    break;
                case /* repeated string Roles = 3 [json_name = "Roles"];*/ 3:
                    message.roles.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TraitMapping, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Trait = 1 [json_name = "Trait"]; */
        if (message.trait !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.trait);
        /* string Value = 2 [json_name = "Value"]; */
        if (message.value !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        /* repeated string Roles = 3 [json_name = "Roles"]; */
        for (let i = 0; i < message.roles.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.roles[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.TraitMapping
 */
export const TraitMapping = new TraitMapping$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Rule$Type extends MessageType<Rule> {
    constructor() {
        super("types.Rule", [
            { no: 1, name: "Resources", kind: "scalar", jsonName: "Resources", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "resources,omitempty" } },
            { no: 2, name: "Verbs", kind: "scalar", jsonName: "Verbs", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "verbs,omitempty" } },
            { no: 3, name: "Where", kind: "scalar", jsonName: "Where", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "where,omitempty" } },
            { no: 4, name: "Actions", kind: "scalar", jsonName: "Actions", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "actions,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<Rule>): Rule {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.resources = [];
        message.verbs = [];
        message.where = "";
        message.actions = [];
        if (value !== undefined)
            reflectionMergePartial<Rule>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Rule): Rule {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string Resources = 1 [json_name = "Resources"];*/ 1:
                    message.resources.push(reader.string());
                    break;
                case /* repeated string Verbs = 2 [json_name = "Verbs"];*/ 2:
                    message.verbs.push(reader.string());
                    break;
                case /* string Where = 3 [json_name = "Where"];*/ 3:
                    message.where = reader.string();
                    break;
                case /* repeated string Actions = 4 [json_name = "Actions"];*/ 4:
                    message.actions.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Rule, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string Resources = 1 [json_name = "Resources"]; */
        for (let i = 0; i < message.resources.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.resources[i]);
        /* repeated string Verbs = 2 [json_name = "Verbs"]; */
        for (let i = 0; i < message.verbs.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.verbs[i]);
        /* string Where = 3 [json_name = "Where"]; */
        if (message.where !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.where);
        /* repeated string Actions = 4 [json_name = "Actions"]; */
        for (let i = 0; i < message.actions.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.actions[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.Rule
 */
export const Rule = new Rule$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImpersonateConditions$Type extends MessageType<ImpersonateConditions> {
    constructor() {
        super("types.ImpersonateConditions", [
            { no: 1, name: "Users", kind: "scalar", jsonName: "Users", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "users,omitempty" } },
            { no: 2, name: "Roles", kind: "scalar", jsonName: "Roles", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "roles,omitempty" } },
            { no: 3, name: "Where", kind: "scalar", jsonName: "Where", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "where,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ImpersonateConditions>): ImpersonateConditions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.users = [];
        message.roles = [];
        message.where = "";
        if (value !== undefined)
            reflectionMergePartial<ImpersonateConditions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImpersonateConditions): ImpersonateConditions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string Users = 1 [json_name = "Users"];*/ 1:
                    message.users.push(reader.string());
                    break;
                case /* repeated string Roles = 2 [json_name = "Roles"];*/ 2:
                    message.roles.push(reader.string());
                    break;
                case /* string Where = 3 [json_name = "Where"];*/ 3:
                    message.where = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ImpersonateConditions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string Users = 1 [json_name = "Users"]; */
        for (let i = 0; i < message.users.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.users[i]);
        /* repeated string Roles = 2 [json_name = "Roles"]; */
        for (let i = 0; i < message.roles.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.roles[i]);
        /* string Where = 3 [json_name = "Where"]; */
        if (message.where !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.where);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ImpersonateConditions
 */
export const ImpersonateConditions = new ImpersonateConditions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BoolValue$Type extends MessageType<BoolValue> {
    constructor() {
        super("types.BoolValue", [
            { no: 1, name: "Value", kind: "scalar", jsonName: "Value", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<BoolValue>): BoolValue {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = false;
        if (value !== undefined)
            reflectionMergePartial<BoolValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BoolValue): BoolValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool Value = 1 [json_name = "Value"];*/ 1:
                    message.value = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BoolValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool Value = 1 [json_name = "Value"]; */
        if (message.value !== false)
            writer.tag(1, WireType.Varint).bool(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.BoolValue
 */
export const BoolValue = new BoolValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserFilter$Type extends MessageType<UserFilter> {
    constructor() {
        super("types.UserFilter", [
            { no: 1, name: "SearchKeywords", kind: "scalar", jsonName: "SearchKeywords", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "search_keywords,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<UserFilter>): UserFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.searchKeywords = [];
        if (value !== undefined)
            reflectionMergePartial<UserFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserFilter): UserFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string SearchKeywords = 1 [json_name = "SearchKeywords"];*/ 1:
                    message.searchKeywords.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string SearchKeywords = 1 [json_name = "SearchKeywords"]; */
        for (let i = 0; i < message.searchKeywords.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.searchKeywords[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.UserFilter
 */
export const UserFilter = new UserFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserV2$Type extends MessageType<UserV2> {
    constructor() {
        super("types.UserV2", [
            { no: 1, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 2, name: "SubKind", kind: "scalar", jsonName: "SubKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub_kind,omitempty" } },
            { no: 3, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version" } },
            { no: 4, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "metadata" } },
            { no: 5, name: "Spec", kind: "message", jsonName: "Spec", T: () => UserSpecV2, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } },
            { no: 6, name: "Status", kind: "message", jsonName: "Status", T: () => UserStatusV2, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "status,omitempty" } }
        ], { "gogoproto.goproto_stringer": false, "gogoproto.stringer": false });
    }
    create(value?: PartialMessage<UserV2>): UserV2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.subKind = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<UserV2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserV2): UserV2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Kind = 1 [json_name = "Kind"];*/ 1:
                    message.kind = reader.string();
                    break;
                case /* string SubKind = 2 [json_name = "SubKind"];*/ 2:
                    message.subKind = reader.string();
                    break;
                case /* string Version = 3 [json_name = "Version"];*/ 3:
                    message.version = reader.string();
                    break;
                case /* types.Metadata Metadata = 4 [json_name = "Metadata"];*/ 4:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* types.UserSpecV2 Spec = 5 [json_name = "Spec"];*/ 5:
                    message.spec = UserSpecV2.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                case /* types.UserStatusV2 Status = 6 [json_name = "Status"];*/ 6:
                    message.status = UserStatusV2.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserV2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Kind = 1 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string SubKind = 2 [json_name = "SubKind"]; */
        if (message.subKind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subKind);
        /* string Version = 3 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* types.Metadata Metadata = 4 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.UserSpecV2 Spec = 5 [json_name = "Spec"]; */
        if (message.spec)
            UserSpecV2.internalBinaryWrite(message.spec, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* types.UserStatusV2 Status = 6 [json_name = "Status"]; */
        if (message.status)
            UserStatusV2.internalBinaryWrite(message.status, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.UserV2
 */
export const UserV2 = new UserV2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserStatusV2$Type extends MessageType<UserStatusV2> {
    constructor() {
        super("types.UserStatusV2", [
            { no: 1, name: "password_state", kind: "enum", T: () => ["types.PasswordState", PasswordState, "PASSWORD_STATE_"], options: { "gogoproto.jsontag": "password_state,omitempty" } },
            { no: 2, name: "mfa_weakest_device", kind: "enum", T: () => ["types.MFADeviceKind", MFADeviceKind], options: { "gogoproto.jsontag": "mfa_weakest_device,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<UserStatusV2>): UserStatusV2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.passwordState = 0;
        message.mfaWeakestDevice = 0;
        if (value !== undefined)
            reflectionMergePartial<UserStatusV2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserStatusV2): UserStatusV2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.PasswordState password_state */ 1:
                    message.passwordState = reader.int32();
                    break;
                case /* types.MFADeviceKind mfa_weakest_device */ 2:
                    message.mfaWeakestDevice = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserStatusV2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.PasswordState password_state = 1; */
        if (message.passwordState !== 0)
            writer.tag(1, WireType.Varint).int32(message.passwordState);
        /* types.MFADeviceKind mfa_weakest_device = 2; */
        if (message.mfaWeakestDevice !== 0)
            writer.tag(2, WireType.Varint).int32(message.mfaWeakestDevice);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.UserStatusV2
 */
export const UserStatusV2 = new UserStatusV2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserSpecV2$Type extends MessageType<UserSpecV2> {
    constructor() {
        super("types.UserSpecV2", [
            { no: 1, name: "OIDCIdentities", kind: "message", jsonName: "OIDCIdentities", repeat: 1 /*RepeatType.PACKED*/, T: () => ExternalIdentity, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "oidc_identities,omitempty" } },
            { no: 2, name: "SAMLIdentities", kind: "message", jsonName: "SAMLIdentities", repeat: 1 /*RepeatType.PACKED*/, T: () => ExternalIdentity, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "saml_identities,omitempty" } },
            { no: 3, name: "GithubIdentities", kind: "message", jsonName: "GithubIdentities", repeat: 1 /*RepeatType.PACKED*/, T: () => ExternalIdentity, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "github_identities,omitempty" } },
            { no: 4, name: "Roles", kind: "scalar", jsonName: "Roles", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "roles,omitempty" } },
            { no: 5, name: "Traits", kind: "message", jsonName: "Traits", T: () => LabelValues, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/gravitational/teleport/api/types/wrappers.Traits", "gogoproto.jsontag": "traits,omitempty" } },
            { no: 6, name: "Status", kind: "message", jsonName: "Status", T: () => LoginStatus, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "status,omitempty" } },
            { no: 7, name: "Expires", kind: "message", jsonName: "Expires", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "expires", "gogoproto.stdtime": true } },
            { no: 8, name: "CreatedBy", kind: "message", jsonName: "CreatedBy", T: () => CreatedBy, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "created_by,omitempty" } },
            { no: 9, name: "LocalAuth", kind: "message", jsonName: "LocalAuth", T: () => LocalAuthSecrets, options: { "gogoproto.jsontag": "local_auth,omitempty" } },
            { no: 10, name: "TrustedDeviceIDs", kind: "scalar", jsonName: "TrustedDeviceIDs", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "trusted_device_ids,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<UserSpecV2>): UserSpecV2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.oIDCIdentities = [];
        message.sAMLIdentities = [];
        message.githubIdentities = [];
        message.roles = [];
        message.trustedDeviceIDs = [];
        if (value !== undefined)
            reflectionMergePartial<UserSpecV2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserSpecV2): UserSpecV2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.ExternalIdentity OIDCIdentities = 1 [json_name = "OIDCIdentities"];*/ 1:
                    message.oIDCIdentities.push(ExternalIdentity.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated types.ExternalIdentity SAMLIdentities = 2 [json_name = "SAMLIdentities"];*/ 2:
                    message.sAMLIdentities.push(ExternalIdentity.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated types.ExternalIdentity GithubIdentities = 3 [json_name = "GithubIdentities"];*/ 3:
                    message.githubIdentities.push(ExternalIdentity.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string Roles = 4 [json_name = "Roles"];*/ 4:
                    message.roles.push(reader.string());
                    break;
                case /* wrappers.LabelValues Traits = 5 [json_name = "Traits"];*/ 5:
                    message.traits = LabelValues.internalBinaryRead(reader, reader.uint32(), options, message.traits);
                    break;
                case /* types.LoginStatus Status = 6 [json_name = "Status"];*/ 6:
                    message.status = LoginStatus.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* google.protobuf.Timestamp Expires = 7 [json_name = "Expires"];*/ 7:
                    message.expires = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expires);
                    break;
                case /* types.CreatedBy CreatedBy = 8 [json_name = "CreatedBy"];*/ 8:
                    message.createdBy = CreatedBy.internalBinaryRead(reader, reader.uint32(), options, message.createdBy);
                    break;
                case /* types.LocalAuthSecrets LocalAuth = 9 [json_name = "LocalAuth"];*/ 9:
                    message.localAuth = LocalAuthSecrets.internalBinaryRead(reader, reader.uint32(), options, message.localAuth);
                    break;
                case /* repeated string TrustedDeviceIDs = 10 [json_name = "TrustedDeviceIDs"];*/ 10:
                    message.trustedDeviceIDs.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserSpecV2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.ExternalIdentity OIDCIdentities = 1 [json_name = "OIDCIdentities"]; */
        for (let i = 0; i < message.oIDCIdentities.length; i++)
            ExternalIdentity.internalBinaryWrite(message.oIDCIdentities[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated types.ExternalIdentity SAMLIdentities = 2 [json_name = "SAMLIdentities"]; */
        for (let i = 0; i < message.sAMLIdentities.length; i++)
            ExternalIdentity.internalBinaryWrite(message.sAMLIdentities[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated types.ExternalIdentity GithubIdentities = 3 [json_name = "GithubIdentities"]; */
        for (let i = 0; i < message.githubIdentities.length; i++)
            ExternalIdentity.internalBinaryWrite(message.githubIdentities[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated string Roles = 4 [json_name = "Roles"]; */
        for (let i = 0; i < message.roles.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.roles[i]);
        /* wrappers.LabelValues Traits = 5 [json_name = "Traits"]; */
        if (message.traits)
            LabelValues.internalBinaryWrite(message.traits, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* types.LoginStatus Status = 6 [json_name = "Status"]; */
        if (message.status)
            LoginStatus.internalBinaryWrite(message.status, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp Expires = 7 [json_name = "Expires"]; */
        if (message.expires)
            Timestamp.internalBinaryWrite(message.expires, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* types.CreatedBy CreatedBy = 8 [json_name = "CreatedBy"]; */
        if (message.createdBy)
            CreatedBy.internalBinaryWrite(message.createdBy, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* types.LocalAuthSecrets LocalAuth = 9 [json_name = "LocalAuth"]; */
        if (message.localAuth)
            LocalAuthSecrets.internalBinaryWrite(message.localAuth, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* repeated string TrustedDeviceIDs = 10 [json_name = "TrustedDeviceIDs"]; */
        for (let i = 0; i < message.trustedDeviceIDs.length; i++)
            writer.tag(10, WireType.LengthDelimited).string(message.trustedDeviceIDs[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.UserSpecV2
 */
export const UserSpecV2 = new UserSpecV2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExternalIdentity$Type extends MessageType<ExternalIdentity> {
    constructor() {
        super("types.ExternalIdentity", [
            { no: 1, name: "ConnectorID", kind: "scalar", jsonName: "ConnectorID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "connector_id,omitempty" } },
            { no: 2, name: "Username", kind: "scalar", jsonName: "Username", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "username,omitempty" } },
            { no: 3, name: "SAMLSingleLogoutURL", kind: "scalar", jsonName: "SAMLSingleLogoutURL", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "samlSingleLogoutUrl,omitempty" } },
            { no: 4, name: "UserID", kind: "scalar", jsonName: "UserID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "user_id,omitempty" } }
        ], { "gogoproto.goproto_stringer": false, "gogoproto.stringer": false });
    }
    create(value?: PartialMessage<ExternalIdentity>): ExternalIdentity {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.connectorID = "";
        message.username = "";
        message.sAMLSingleLogoutURL = "";
        message.userID = "";
        if (value !== undefined)
            reflectionMergePartial<ExternalIdentity>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExternalIdentity): ExternalIdentity {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ConnectorID = 1 [json_name = "ConnectorID"];*/ 1:
                    message.connectorID = reader.string();
                    break;
                case /* string Username = 2 [json_name = "Username"];*/ 2:
                    message.username = reader.string();
                    break;
                case /* string SAMLSingleLogoutURL = 3 [json_name = "SAMLSingleLogoutURL"];*/ 3:
                    message.sAMLSingleLogoutURL = reader.string();
                    break;
                case /* string UserID = 4 [json_name = "UserID"];*/ 4:
                    message.userID = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExternalIdentity, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ConnectorID = 1 [json_name = "ConnectorID"]; */
        if (message.connectorID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.connectorID);
        /* string Username = 2 [json_name = "Username"]; */
        if (message.username !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.username);
        /* string SAMLSingleLogoutURL = 3 [json_name = "SAMLSingleLogoutURL"]; */
        if (message.sAMLSingleLogoutURL !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.sAMLSingleLogoutURL);
        /* string UserID = 4 [json_name = "UserID"]; */
        if (message.userID !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.userID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ExternalIdentity
 */
export const ExternalIdentity = new ExternalIdentity$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoginStatus$Type extends MessageType<LoginStatus> {
    constructor() {
        super("types.LoginStatus", [
            { no: 1, name: "IsLocked", kind: "scalar", jsonName: "IsLocked", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "is_locked" } },
            { no: 2, name: "LockedMessage", kind: "scalar", jsonName: "LockedMessage", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "locked_message,omitempty" } },
            { no: 3, name: "LockedTime", kind: "message", jsonName: "LockedTime", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "locked_time,omitempty", "gogoproto.stdtime": true } },
            { no: 4, name: "LockExpires", kind: "message", jsonName: "LockExpires", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "lock_expires,omitempty", "gogoproto.stdtime": true } }
        ]);
    }
    create(value?: PartialMessage<LoginStatus>): LoginStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isLocked = false;
        message.lockedMessage = "";
        if (value !== undefined)
            reflectionMergePartial<LoginStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoginStatus): LoginStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool IsLocked = 1 [json_name = "IsLocked"];*/ 1:
                    message.isLocked = reader.bool();
                    break;
                case /* string LockedMessage = 2 [json_name = "LockedMessage"];*/ 2:
                    message.lockedMessage = reader.string();
                    break;
                case /* google.protobuf.Timestamp LockedTime = 3 [json_name = "LockedTime"];*/ 3:
                    message.lockedTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lockedTime);
                    break;
                case /* google.protobuf.Timestamp LockExpires = 4 [json_name = "LockExpires"];*/ 4:
                    message.lockExpires = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lockExpires);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoginStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool IsLocked = 1 [json_name = "IsLocked"]; */
        if (message.isLocked !== false)
            writer.tag(1, WireType.Varint).bool(message.isLocked);
        /* string LockedMessage = 2 [json_name = "LockedMessage"]; */
        if (message.lockedMessage !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.lockedMessage);
        /* google.protobuf.Timestamp LockedTime = 3 [json_name = "LockedTime"]; */
        if (message.lockedTime)
            Timestamp.internalBinaryWrite(message.lockedTime, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp LockExpires = 4 [json_name = "LockExpires"]; */
        if (message.lockExpires)
            Timestamp.internalBinaryWrite(message.lockExpires, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.LoginStatus
 */
export const LoginStatus = new LoginStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreatedBy$Type extends MessageType<CreatedBy> {
    constructor() {
        super("types.CreatedBy", [
            { no: 1, name: "Connector", kind: "message", jsonName: "Connector", T: () => ConnectorRef, options: { "gogoproto.nullable": true, "gogoproto.jsontag": "connector,omitempty" } },
            { no: 2, name: "Time", kind: "message", jsonName: "Time", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "time", "gogoproto.stdtime": true } },
            { no: 3, name: "User", kind: "message", jsonName: "User", T: () => UserRef, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "user" } }
        ], { "gogoproto.goproto_stringer": false, "gogoproto.stringer": false });
    }
    create(value?: PartialMessage<CreatedBy>): CreatedBy {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CreatedBy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreatedBy): CreatedBy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.ConnectorRef Connector = 1 [json_name = "Connector"];*/ 1:
                    message.connector = ConnectorRef.internalBinaryRead(reader, reader.uint32(), options, message.connector);
                    break;
                case /* google.protobuf.Timestamp Time = 2 [json_name = "Time"];*/ 2:
                    message.time = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.time);
                    break;
                case /* types.UserRef User = 3 [json_name = "User"];*/ 3:
                    message.user = UserRef.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreatedBy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.ConnectorRef Connector = 1 [json_name = "Connector"]; */
        if (message.connector)
            ConnectorRef.internalBinaryWrite(message.connector, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp Time = 2 [json_name = "Time"]; */
        if (message.time)
            Timestamp.internalBinaryWrite(message.time, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* types.UserRef User = 3 [json_name = "User"]; */
        if (message.user)
            UserRef.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.CreatedBy
 */
export const CreatedBy = new CreatedBy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LocalAuthSecrets$Type extends MessageType<LocalAuthSecrets> {
    constructor() {
        super("types.LocalAuthSecrets", [
            { no: 1, name: "PasswordHash", kind: "scalar", jsonName: "PasswordHash", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.jsontag": "password_hash,omitempty" } },
            { no: 2, name: "TOTPKey", kind: "scalar", jsonName: "TOTPKey", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "totp_key,omitempty" } },
            { no: 5, name: "MFA", kind: "message", jsonName: "MFA", repeat: 1 /*RepeatType.PACKED*/, T: () => MFADevice, options: { "gogoproto.jsontag": "mfa,omitempty" } },
            { no: 6, name: "Webauthn", kind: "message", jsonName: "Webauthn", T: () => WebauthnLocalAuth, options: { "gogoproto.jsontag": "webauthn,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<LocalAuthSecrets>): LocalAuthSecrets {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.passwordHash = new Uint8Array(0);
        message.tOTPKey = "";
        message.mFA = [];
        if (value !== undefined)
            reflectionMergePartial<LocalAuthSecrets>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LocalAuthSecrets): LocalAuthSecrets {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes PasswordHash = 1 [json_name = "PasswordHash"];*/ 1:
                    message.passwordHash = reader.bytes();
                    break;
                case /* string TOTPKey = 2 [json_name = "TOTPKey"];*/ 2:
                    message.tOTPKey = reader.string();
                    break;
                case /* repeated types.MFADevice MFA = 5 [json_name = "MFA"];*/ 5:
                    message.mFA.push(MFADevice.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* types.WebauthnLocalAuth Webauthn = 6 [json_name = "Webauthn"];*/ 6:
                    message.webauthn = WebauthnLocalAuth.internalBinaryRead(reader, reader.uint32(), options, message.webauthn);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LocalAuthSecrets, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes PasswordHash = 1 [json_name = "PasswordHash"]; */
        if (message.passwordHash.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.passwordHash);
        /* string TOTPKey = 2 [json_name = "TOTPKey"]; */
        if (message.tOTPKey !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.tOTPKey);
        /* repeated types.MFADevice MFA = 5 [json_name = "MFA"]; */
        for (let i = 0; i < message.mFA.length; i++)
            MFADevice.internalBinaryWrite(message.mFA[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* types.WebauthnLocalAuth Webauthn = 6 [json_name = "Webauthn"]; */
        if (message.webauthn)
            WebauthnLocalAuth.internalBinaryWrite(message.webauthn, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.LocalAuthSecrets
 */
export const LocalAuthSecrets = new LocalAuthSecrets$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MFADevice$Type extends MessageType<MFADevice> {
    constructor() {
        super("types.MFADevice", [
            { no: 1, name: "kind", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "sub_kind", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "metadata", kind: "message", T: () => Metadata, options: { "gogoproto.nullable": false } },
            { no: 5, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "added_at", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.stdtime": true } },
            { no: 7, name: "last_used", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.stdtime": true } },
            { no: 8, name: "totp", kind: "message", oneof: "device", T: () => TOTPDevice },
            { no: 9, name: "u2f", kind: "message", jsonName: "u2f", oneof: "device", T: () => U2FDevice },
            { no: 10, name: "webauthn", kind: "message", oneof: "device", T: () => WebauthnDevice },
            { no: 11, name: "sso", kind: "message", oneof: "device", T: () => SSOMFADevice }
        ]);
    }
    create(value?: PartialMessage<MFADevice>): MFADevice {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.subKind = "";
        message.version = "";
        message.id = "";
        message.device = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<MFADevice>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MFADevice): MFADevice {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string kind */ 1:
                    message.kind = reader.string();
                    break;
                case /* string sub_kind */ 2:
                    message.subKind = reader.string();
                    break;
                case /* string version */ 3:
                    message.version = reader.string();
                    break;
                case /* types.Metadata metadata */ 4:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* string id */ 5:
                    message.id = reader.string();
                    break;
                case /* google.protobuf.Timestamp added_at */ 6:
                    message.addedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.addedAt);
                    break;
                case /* google.protobuf.Timestamp last_used */ 7:
                    message.lastUsed = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastUsed);
                    break;
                case /* types.TOTPDevice totp */ 8:
                    message.device = {
                        oneofKind: "totp",
                        totp: TOTPDevice.internalBinaryRead(reader, reader.uint32(), options, (message.device as any).totp)
                    };
                    break;
                case /* types.U2FDevice u2f = 9 [json_name = "u2f"];*/ 9:
                    message.device = {
                        oneofKind: "u2F",
                        u2F: U2FDevice.internalBinaryRead(reader, reader.uint32(), options, (message.device as any).u2F)
                    };
                    break;
                case /* types.WebauthnDevice webauthn */ 10:
                    message.device = {
                        oneofKind: "webauthn",
                        webauthn: WebauthnDevice.internalBinaryRead(reader, reader.uint32(), options, (message.device as any).webauthn)
                    };
                    break;
                case /* types.SSOMFADevice sso */ 11:
                    message.device = {
                        oneofKind: "sso",
                        sso: SSOMFADevice.internalBinaryRead(reader, reader.uint32(), options, (message.device as any).sso)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MFADevice, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string kind = 1; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string sub_kind = 2; */
        if (message.subKind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subKind);
        /* string version = 3; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* types.Metadata metadata = 4; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string id = 5; */
        if (message.id !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.id);
        /* google.protobuf.Timestamp added_at = 6; */
        if (message.addedAt)
            Timestamp.internalBinaryWrite(message.addedAt, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp last_used = 7; */
        if (message.lastUsed)
            Timestamp.internalBinaryWrite(message.lastUsed, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* types.TOTPDevice totp = 8; */
        if (message.device.oneofKind === "totp")
            TOTPDevice.internalBinaryWrite(message.device.totp, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* types.U2FDevice u2f = 9 [json_name = "u2f"]; */
        if (message.device.oneofKind === "u2F")
            U2FDevice.internalBinaryWrite(message.device.u2F, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* types.WebauthnDevice webauthn = 10; */
        if (message.device.oneofKind === "webauthn")
            WebauthnDevice.internalBinaryWrite(message.device.webauthn, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* types.SSOMFADevice sso = 11; */
        if (message.device.oneofKind === "sso")
            SSOMFADevice.internalBinaryWrite(message.device.sso, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.MFADevice
 */
export const MFADevice = new MFADevice$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TOTPDevice$Type extends MessageType<TOTPDevice> {
    constructor() {
        super("types.TOTPDevice", [
            { no: 1, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TOTPDevice>): TOTPDevice {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.key = "";
        if (value !== undefined)
            reflectionMergePartial<TOTPDevice>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TOTPDevice): TOTPDevice {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string key */ 1:
                    message.key = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TOTPDevice, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string key = 1; */
        if (message.key !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.key);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.TOTPDevice
 */
export const TOTPDevice = new TOTPDevice$Type();
// @generated message type with reflection information, may provide speed optimized methods
class U2FDevice$Type extends MessageType<U2FDevice> {
    constructor() {
        super("types.U2FDevice", [
            { no: 1, name: "key_handle", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "pub_key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "counter", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<U2FDevice>): U2FDevice {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyHandle = new Uint8Array(0);
        message.pubKey = new Uint8Array(0);
        message.counter = 0;
        if (value !== undefined)
            reflectionMergePartial<U2FDevice>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: U2FDevice): U2FDevice {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes key_handle */ 1:
                    message.keyHandle = reader.bytes();
                    break;
                case /* bytes pub_key */ 2:
                    message.pubKey = reader.bytes();
                    break;
                case /* uint32 counter */ 3:
                    message.counter = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: U2FDevice, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes key_handle = 1; */
        if (message.keyHandle.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.keyHandle);
        /* bytes pub_key = 2; */
        if (message.pubKey.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.pubKey);
        /* uint32 counter = 3; */
        if (message.counter !== 0)
            writer.tag(3, WireType.Varint).uint32(message.counter);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.U2FDevice
 */
export const U2FDevice = new U2FDevice$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WebauthnDevice$Type extends MessageType<WebauthnDevice> {
    constructor() {
        super("types.WebauthnDevice", [
            { no: 1, name: "credential_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "public_key_cbor", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "attestation_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "aaguid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "signature_counter", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "attestation_object", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "resident_key", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "credential_rp_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "credential_backup_eligible", kind: "message", T: () => BoolValue$ },
            { no: 10, name: "credential_backed_up", kind: "message", T: () => BoolValue$ }
        ]);
    }
    create(value?: PartialMessage<WebauthnDevice>): WebauthnDevice {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.credentialId = new Uint8Array(0);
        message.publicKeyCbor = new Uint8Array(0);
        message.attestationType = "";
        message.aaguid = new Uint8Array(0);
        message.signatureCounter = 0;
        message.attestationObject = new Uint8Array(0);
        message.residentKey = false;
        message.credentialRpId = "";
        if (value !== undefined)
            reflectionMergePartial<WebauthnDevice>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WebauthnDevice): WebauthnDevice {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes credential_id */ 1:
                    message.credentialId = reader.bytes();
                    break;
                case /* bytes public_key_cbor */ 2:
                    message.publicKeyCbor = reader.bytes();
                    break;
                case /* string attestation_type */ 3:
                    message.attestationType = reader.string();
                    break;
                case /* bytes aaguid */ 4:
                    message.aaguid = reader.bytes();
                    break;
                case /* uint32 signature_counter */ 5:
                    message.signatureCounter = reader.uint32();
                    break;
                case /* bytes attestation_object */ 6:
                    message.attestationObject = reader.bytes();
                    break;
                case /* bool resident_key */ 7:
                    message.residentKey = reader.bool();
                    break;
                case /* string credential_rp_id */ 8:
                    message.credentialRpId = reader.string();
                    break;
                case /* google.protobuf.BoolValue credential_backup_eligible */ 9:
                    message.credentialBackupEligible = BoolValue$.internalBinaryRead(reader, reader.uint32(), options, message.credentialBackupEligible);
                    break;
                case /* google.protobuf.BoolValue credential_backed_up */ 10:
                    message.credentialBackedUp = BoolValue$.internalBinaryRead(reader, reader.uint32(), options, message.credentialBackedUp);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WebauthnDevice, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes credential_id = 1; */
        if (message.credentialId.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.credentialId);
        /* bytes public_key_cbor = 2; */
        if (message.publicKeyCbor.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.publicKeyCbor);
        /* string attestation_type = 3; */
        if (message.attestationType !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.attestationType);
        /* bytes aaguid = 4; */
        if (message.aaguid.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.aaguid);
        /* uint32 signature_counter = 5; */
        if (message.signatureCounter !== 0)
            writer.tag(5, WireType.Varint).uint32(message.signatureCounter);
        /* bytes attestation_object = 6; */
        if (message.attestationObject.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.attestationObject);
        /* bool resident_key = 7; */
        if (message.residentKey !== false)
            writer.tag(7, WireType.Varint).bool(message.residentKey);
        /* string credential_rp_id = 8; */
        if (message.credentialRpId !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.credentialRpId);
        /* google.protobuf.BoolValue credential_backup_eligible = 9; */
        if (message.credentialBackupEligible)
            BoolValue$.internalBinaryWrite(message.credentialBackupEligible, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.BoolValue credential_backed_up = 10; */
        if (message.credentialBackedUp)
            BoolValue$.internalBinaryWrite(message.credentialBackedUp, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.WebauthnDevice
 */
export const WebauthnDevice = new WebauthnDevice$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SSOMFADevice$Type extends MessageType<SSOMFADevice> {
    constructor() {
        super("types.SSOMFADevice", [
            { no: 1, name: "connector_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "connector_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "display_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SSOMFADevice>): SSOMFADevice {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.connectorId = "";
        message.connectorType = "";
        message.displayName = "";
        if (value !== undefined)
            reflectionMergePartial<SSOMFADevice>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SSOMFADevice): SSOMFADevice {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string connector_id */ 1:
                    message.connectorId = reader.string();
                    break;
                case /* string connector_type */ 2:
                    message.connectorType = reader.string();
                    break;
                case /* string display_name */ 3:
                    message.displayName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SSOMFADevice, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string connector_id = 1; */
        if (message.connectorId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.connectorId);
        /* string connector_type = 2; */
        if (message.connectorType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.connectorType);
        /* string display_name = 3; */
        if (message.displayName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.displayName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.SSOMFADevice
 */
export const SSOMFADevice = new SSOMFADevice$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WebauthnLocalAuth$Type extends MessageType<WebauthnLocalAuth> {
    constructor() {
        super("types.WebauthnLocalAuth", [
            { no: 1, name: "UserID", kind: "scalar", jsonName: "UserID", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.jsontag": "user_id,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<WebauthnLocalAuth>): WebauthnLocalAuth {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userID = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<WebauthnLocalAuth>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WebauthnLocalAuth): WebauthnLocalAuth {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes UserID = 1 [json_name = "UserID"];*/ 1:
                    message.userID = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WebauthnLocalAuth, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes UserID = 1 [json_name = "UserID"]; */
        if (message.userID.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.userID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.WebauthnLocalAuth
 */
export const WebauthnLocalAuth = new WebauthnLocalAuth$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConnectorRef$Type extends MessageType<ConnectorRef> {
    constructor() {
        super("types.ConnectorRef", [
            { no: 1, name: "Type", kind: "scalar", jsonName: "Type", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "type" } },
            { no: 2, name: "ID", kind: "scalar", jsonName: "ID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "id" } },
            { no: 3, name: "Identity", kind: "scalar", jsonName: "Identity", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "identity" } }
        ]);
    }
    create(value?: PartialMessage<ConnectorRef>): ConnectorRef {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        message.iD = "";
        message.identity = "";
        if (value !== undefined)
            reflectionMergePartial<ConnectorRef>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConnectorRef): ConnectorRef {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Type = 1 [json_name = "Type"];*/ 1:
                    message.type = reader.string();
                    break;
                case /* string ID = 2 [json_name = "ID"];*/ 2:
                    message.iD = reader.string();
                    break;
                case /* string Identity = 3 [json_name = "Identity"];*/ 3:
                    message.identity = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConnectorRef, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Type = 1 [json_name = "Type"]; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* string ID = 2 [json_name = "ID"]; */
        if (message.iD !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.iD);
        /* string Identity = 3 [json_name = "Identity"]; */
        if (message.identity !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.identity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ConnectorRef
 */
export const ConnectorRef = new ConnectorRef$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserRef$Type extends MessageType<UserRef> {
    constructor() {
        super("types.UserRef", [
            { no: 1, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "name" } }
        ]);
    }
    create(value?: PartialMessage<UserRef>): UserRef {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<UserRef>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserRef): UserRef {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Name = 1 [json_name = "Name"];*/ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserRef, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Name = 1 [json_name = "Name"]; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.UserRef
 */
export const UserRef = new UserRef$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReverseTunnelV2$Type extends MessageType<ReverseTunnelV2> {
    constructor() {
        super("types.ReverseTunnelV2", [
            { no: 1, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 2, name: "SubKind", kind: "scalar", jsonName: "SubKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub_kind,omitempty" } },
            { no: 3, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version" } },
            { no: 4, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "metadata" } },
            { no: 5, name: "Spec", kind: "message", jsonName: "Spec", T: () => ReverseTunnelSpecV2, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ]);
    }
    create(value?: PartialMessage<ReverseTunnelV2>): ReverseTunnelV2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.subKind = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<ReverseTunnelV2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReverseTunnelV2): ReverseTunnelV2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Kind = 1 [json_name = "Kind"];*/ 1:
                    message.kind = reader.string();
                    break;
                case /* string SubKind = 2 [json_name = "SubKind"];*/ 2:
                    message.subKind = reader.string();
                    break;
                case /* string Version = 3 [json_name = "Version"];*/ 3:
                    message.version = reader.string();
                    break;
                case /* types.Metadata Metadata = 4 [json_name = "Metadata"];*/ 4:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* types.ReverseTunnelSpecV2 Spec = 5 [json_name = "Spec"];*/ 5:
                    message.spec = ReverseTunnelSpecV2.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReverseTunnelV2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Kind = 1 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string SubKind = 2 [json_name = "SubKind"]; */
        if (message.subKind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subKind);
        /* string Version = 3 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* types.Metadata Metadata = 4 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.ReverseTunnelSpecV2 Spec = 5 [json_name = "Spec"]; */
        if (message.spec)
            ReverseTunnelSpecV2.internalBinaryWrite(message.spec, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ReverseTunnelV2
 */
export const ReverseTunnelV2 = new ReverseTunnelV2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReverseTunnelSpecV2$Type extends MessageType<ReverseTunnelSpecV2> {
    constructor() {
        super("types.ReverseTunnelSpecV2", [
            { no: 1, name: "ClusterName", kind: "scalar", jsonName: "ClusterName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "cluster_name" } },
            { no: 2, name: "DialAddrs", kind: "scalar", jsonName: "DialAddrs", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "dial_addrs,omitempty" } },
            { no: 3, name: "Type", kind: "scalar", jsonName: "Type", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "type", "gogoproto.casttype": "TunnelType" } }
        ]);
    }
    create(value?: PartialMessage<ReverseTunnelSpecV2>): ReverseTunnelSpecV2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterName = "";
        message.dialAddrs = [];
        message.type = "";
        if (value !== undefined)
            reflectionMergePartial<ReverseTunnelSpecV2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReverseTunnelSpecV2): ReverseTunnelSpecV2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ClusterName = 1 [json_name = "ClusterName"];*/ 1:
                    message.clusterName = reader.string();
                    break;
                case /* repeated string DialAddrs = 2 [json_name = "DialAddrs"];*/ 2:
                    message.dialAddrs.push(reader.string());
                    break;
                case /* string Type = 3 [json_name = "Type"];*/ 3:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReverseTunnelSpecV2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ClusterName = 1 [json_name = "ClusterName"]; */
        if (message.clusterName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterName);
        /* repeated string DialAddrs = 2 [json_name = "DialAddrs"]; */
        for (let i = 0; i < message.dialAddrs.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.dialAddrs[i]);
        /* string Type = 3 [json_name = "Type"]; */
        if (message.type !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ReverseTunnelSpecV2
 */
export const ReverseTunnelSpecV2 = new ReverseTunnelSpecV2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TunnelConnectionV2$Type extends MessageType<TunnelConnectionV2> {
    constructor() {
        super("types.TunnelConnectionV2", [
            { no: 1, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 2, name: "SubKind", kind: "scalar", jsonName: "SubKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub_kind,omitempty" } },
            { no: 3, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version" } },
            { no: 4, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "metadata" } },
            { no: 5, name: "Spec", kind: "message", jsonName: "Spec", T: () => TunnelConnectionSpecV2, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ], { "gogoproto.goproto_stringer": false, "gogoproto.stringer": false });
    }
    create(value?: PartialMessage<TunnelConnectionV2>): TunnelConnectionV2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.subKind = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<TunnelConnectionV2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TunnelConnectionV2): TunnelConnectionV2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Kind = 1 [json_name = "Kind"];*/ 1:
                    message.kind = reader.string();
                    break;
                case /* string SubKind = 2 [json_name = "SubKind"];*/ 2:
                    message.subKind = reader.string();
                    break;
                case /* string Version = 3 [json_name = "Version"];*/ 3:
                    message.version = reader.string();
                    break;
                case /* types.Metadata Metadata = 4 [json_name = "Metadata"];*/ 4:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* types.TunnelConnectionSpecV2 Spec = 5 [json_name = "Spec"];*/ 5:
                    message.spec = TunnelConnectionSpecV2.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TunnelConnectionV2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Kind = 1 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string SubKind = 2 [json_name = "SubKind"]; */
        if (message.subKind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subKind);
        /* string Version = 3 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* types.Metadata Metadata = 4 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.TunnelConnectionSpecV2 Spec = 5 [json_name = "Spec"]; */
        if (message.spec)
            TunnelConnectionSpecV2.internalBinaryWrite(message.spec, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.TunnelConnectionV2
 */
export const TunnelConnectionV2 = new TunnelConnectionV2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TunnelConnectionSpecV2$Type extends MessageType<TunnelConnectionSpecV2> {
    constructor() {
        super("types.TunnelConnectionSpecV2", [
            { no: 1, name: "ClusterName", kind: "scalar", jsonName: "ClusterName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "cluster_name" } },
            { no: 2, name: "ProxyName", kind: "scalar", jsonName: "ProxyName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "proxy_name" } },
            { no: 3, name: "LastHeartbeat", kind: "message", jsonName: "LastHeartbeat", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "last_heartbeat,omitempty", "gogoproto.stdtime": true } },
            { no: 4, name: "Type", kind: "scalar", jsonName: "Type", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "type", "gogoproto.casttype": "TunnelType" } }
        ]);
    }
    create(value?: PartialMessage<TunnelConnectionSpecV2>): TunnelConnectionSpecV2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterName = "";
        message.proxyName = "";
        message.type = "";
        if (value !== undefined)
            reflectionMergePartial<TunnelConnectionSpecV2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TunnelConnectionSpecV2): TunnelConnectionSpecV2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ClusterName = 1 [json_name = "ClusterName"];*/ 1:
                    message.clusterName = reader.string();
                    break;
                case /* string ProxyName = 2 [json_name = "ProxyName"];*/ 2:
                    message.proxyName = reader.string();
                    break;
                case /* google.protobuf.Timestamp LastHeartbeat = 3 [json_name = "LastHeartbeat"];*/ 3:
                    message.lastHeartbeat = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastHeartbeat);
                    break;
                case /* string Type = 4 [json_name = "Type"];*/ 4:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TunnelConnectionSpecV2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ClusterName = 1 [json_name = "ClusterName"]; */
        if (message.clusterName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterName);
        /* string ProxyName = 2 [json_name = "ProxyName"]; */
        if (message.proxyName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.proxyName);
        /* google.protobuf.Timestamp LastHeartbeat = 3 [json_name = "LastHeartbeat"]; */
        if (message.lastHeartbeat)
            Timestamp.internalBinaryWrite(message.lastHeartbeat, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string Type = 4 [json_name = "Type"]; */
        if (message.type !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.TunnelConnectionSpecV2
 */
export const TunnelConnectionSpecV2 = new TunnelConnectionSpecV2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SemaphoreFilter$Type extends MessageType<SemaphoreFilter> {
    constructor() {
        super("types.SemaphoreFilter", [
            { no: 1, name: "SemaphoreKind", kind: "scalar", jsonName: "SemaphoreKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 2, name: "SemaphoreName", kind: "scalar", jsonName: "SemaphoreName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "name" } }
        ]);
    }
    create(value?: PartialMessage<SemaphoreFilter>): SemaphoreFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.semaphoreKind = "";
        message.semaphoreName = "";
        if (value !== undefined)
            reflectionMergePartial<SemaphoreFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SemaphoreFilter): SemaphoreFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string SemaphoreKind = 1 [json_name = "SemaphoreKind"];*/ 1:
                    message.semaphoreKind = reader.string();
                    break;
                case /* string SemaphoreName = 2 [json_name = "SemaphoreName"];*/ 2:
                    message.semaphoreName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SemaphoreFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string SemaphoreKind = 1 [json_name = "SemaphoreKind"]; */
        if (message.semaphoreKind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.semaphoreKind);
        /* string SemaphoreName = 2 [json_name = "SemaphoreName"]; */
        if (message.semaphoreName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.semaphoreName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.SemaphoreFilter
 */
export const SemaphoreFilter = new SemaphoreFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AcquireSemaphoreRequest$Type extends MessageType<AcquireSemaphoreRequest> {
    constructor() {
        super("types.AcquireSemaphoreRequest", [
            { no: 1, name: "SemaphoreKind", kind: "scalar", jsonName: "SemaphoreKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 2, name: "SemaphoreName", kind: "scalar", jsonName: "SemaphoreName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "name" } },
            { no: 3, name: "MaxLeases", kind: "scalar", jsonName: "MaxLeases", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "max_resources" } },
            { no: 4, name: "Expires", kind: "message", jsonName: "Expires", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "expires", "gogoproto.stdtime": true } },
            { no: 5, name: "Holder", kind: "scalar", jsonName: "Holder", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "holder" } }
        ]);
    }
    create(value?: PartialMessage<AcquireSemaphoreRequest>): AcquireSemaphoreRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.semaphoreKind = "";
        message.semaphoreName = "";
        message.maxLeases = 0n;
        message.holder = "";
        if (value !== undefined)
            reflectionMergePartial<AcquireSemaphoreRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AcquireSemaphoreRequest): AcquireSemaphoreRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string SemaphoreKind = 1 [json_name = "SemaphoreKind"];*/ 1:
                    message.semaphoreKind = reader.string();
                    break;
                case /* string SemaphoreName = 2 [json_name = "SemaphoreName"];*/ 2:
                    message.semaphoreName = reader.string();
                    break;
                case /* int64 MaxLeases = 3 [json_name = "MaxLeases"];*/ 3:
                    message.maxLeases = reader.int64().toBigInt();
                    break;
                case /* google.protobuf.Timestamp Expires = 4 [json_name = "Expires"];*/ 4:
                    message.expires = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expires);
                    break;
                case /* string Holder = 5 [json_name = "Holder"];*/ 5:
                    message.holder = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AcquireSemaphoreRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string SemaphoreKind = 1 [json_name = "SemaphoreKind"]; */
        if (message.semaphoreKind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.semaphoreKind);
        /* string SemaphoreName = 2 [json_name = "SemaphoreName"]; */
        if (message.semaphoreName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.semaphoreName);
        /* int64 MaxLeases = 3 [json_name = "MaxLeases"]; */
        if (message.maxLeases !== 0n)
            writer.tag(3, WireType.Varint).int64(message.maxLeases);
        /* google.protobuf.Timestamp Expires = 4 [json_name = "Expires"]; */
        if (message.expires)
            Timestamp.internalBinaryWrite(message.expires, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string Holder = 5 [json_name = "Holder"]; */
        if (message.holder !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.holder);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AcquireSemaphoreRequest
 */
export const AcquireSemaphoreRequest = new AcquireSemaphoreRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SemaphoreLease$Type extends MessageType<SemaphoreLease> {
    constructor() {
        super("types.SemaphoreLease", [
            { no: 1, name: "SemaphoreKind", kind: "scalar", jsonName: "SemaphoreKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 2, name: "SemaphoreName", kind: "scalar", jsonName: "SemaphoreName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "name" } },
            { no: 3, name: "LeaseID", kind: "scalar", jsonName: "LeaseID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "lease_id" } },
            { no: 5, name: "Expires", kind: "message", jsonName: "Expires", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "expires", "gogoproto.stdtime": true } }
        ]);
    }
    create(value?: PartialMessage<SemaphoreLease>): SemaphoreLease {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.semaphoreKind = "";
        message.semaphoreName = "";
        message.leaseID = "";
        if (value !== undefined)
            reflectionMergePartial<SemaphoreLease>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SemaphoreLease): SemaphoreLease {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string SemaphoreKind = 1 [json_name = "SemaphoreKind"];*/ 1:
                    message.semaphoreKind = reader.string();
                    break;
                case /* string SemaphoreName = 2 [json_name = "SemaphoreName"];*/ 2:
                    message.semaphoreName = reader.string();
                    break;
                case /* string LeaseID = 3 [json_name = "LeaseID"];*/ 3:
                    message.leaseID = reader.string();
                    break;
                case /* google.protobuf.Timestamp Expires = 5 [json_name = "Expires"];*/ 5:
                    message.expires = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expires);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SemaphoreLease, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string SemaphoreKind = 1 [json_name = "SemaphoreKind"]; */
        if (message.semaphoreKind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.semaphoreKind);
        /* string SemaphoreName = 2 [json_name = "SemaphoreName"]; */
        if (message.semaphoreName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.semaphoreName);
        /* string LeaseID = 3 [json_name = "LeaseID"]; */
        if (message.leaseID !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.leaseID);
        /* google.protobuf.Timestamp Expires = 5 [json_name = "Expires"]; */
        if (message.expires)
            Timestamp.internalBinaryWrite(message.expires, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.SemaphoreLease
 */
export const SemaphoreLease = new SemaphoreLease$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SemaphoreLeaseRef$Type extends MessageType<SemaphoreLeaseRef> {
    constructor() {
        super("types.SemaphoreLeaseRef", [
            { no: 1, name: "LeaseID", kind: "scalar", jsonName: "LeaseID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "lease_id" } },
            { no: 2, name: "Expires", kind: "message", jsonName: "Expires", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "expires", "gogoproto.stdtime": true } },
            { no: 3, name: "Holder", kind: "scalar", jsonName: "Holder", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "holder" } }
        ]);
    }
    create(value?: PartialMessage<SemaphoreLeaseRef>): SemaphoreLeaseRef {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.leaseID = "";
        message.holder = "";
        if (value !== undefined)
            reflectionMergePartial<SemaphoreLeaseRef>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SemaphoreLeaseRef): SemaphoreLeaseRef {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string LeaseID = 1 [json_name = "LeaseID"];*/ 1:
                    message.leaseID = reader.string();
                    break;
                case /* google.protobuf.Timestamp Expires = 2 [json_name = "Expires"];*/ 2:
                    message.expires = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expires);
                    break;
                case /* string Holder = 3 [json_name = "Holder"];*/ 3:
                    message.holder = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SemaphoreLeaseRef, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string LeaseID = 1 [json_name = "LeaseID"]; */
        if (message.leaseID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.leaseID);
        /* google.protobuf.Timestamp Expires = 2 [json_name = "Expires"]; */
        if (message.expires)
            Timestamp.internalBinaryWrite(message.expires, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string Holder = 3 [json_name = "Holder"]; */
        if (message.holder !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.holder);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.SemaphoreLeaseRef
 */
export const SemaphoreLeaseRef = new SemaphoreLeaseRef$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SemaphoreV3$Type extends MessageType<SemaphoreV3> {
    constructor() {
        super("types.SemaphoreV3", [
            { no: 1, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 2, name: "SubKind", kind: "scalar", jsonName: "SubKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub_kind,omitempty" } },
            { no: 3, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version" } },
            { no: 4, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "metadata" } },
            { no: 5, name: "Spec", kind: "message", jsonName: "Spec", T: () => SemaphoreSpecV3, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ], { "gogoproto.goproto_stringer": false, "gogoproto.stringer": false });
    }
    create(value?: PartialMessage<SemaphoreV3>): SemaphoreV3 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.subKind = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<SemaphoreV3>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SemaphoreV3): SemaphoreV3 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Kind = 1 [json_name = "Kind"];*/ 1:
                    message.kind = reader.string();
                    break;
                case /* string SubKind = 2 [json_name = "SubKind"];*/ 2:
                    message.subKind = reader.string();
                    break;
                case /* string Version = 3 [json_name = "Version"];*/ 3:
                    message.version = reader.string();
                    break;
                case /* types.Metadata Metadata = 4 [json_name = "Metadata"];*/ 4:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* types.SemaphoreSpecV3 Spec = 5 [json_name = "Spec"];*/ 5:
                    message.spec = SemaphoreSpecV3.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SemaphoreV3, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Kind = 1 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string SubKind = 2 [json_name = "SubKind"]; */
        if (message.subKind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subKind);
        /* string Version = 3 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* types.Metadata Metadata = 4 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.SemaphoreSpecV3 Spec = 5 [json_name = "Spec"]; */
        if (message.spec)
            SemaphoreSpecV3.internalBinaryWrite(message.spec, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.SemaphoreV3
 */
export const SemaphoreV3 = new SemaphoreV3$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SemaphoreSpecV3$Type extends MessageType<SemaphoreSpecV3> {
    constructor() {
        super("types.SemaphoreSpecV3", [
            { no: 1, name: "Leases", kind: "message", jsonName: "Leases", repeat: 1 /*RepeatType.PACKED*/, T: () => SemaphoreLeaseRef, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "leases" } }
        ]);
    }
    create(value?: PartialMessage<SemaphoreSpecV3>): SemaphoreSpecV3 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.leases = [];
        if (value !== undefined)
            reflectionMergePartial<SemaphoreSpecV3>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SemaphoreSpecV3): SemaphoreSpecV3 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.SemaphoreLeaseRef Leases = 1 [json_name = "Leases"];*/ 1:
                    message.leases.push(SemaphoreLeaseRef.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SemaphoreSpecV3, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.SemaphoreLeaseRef Leases = 1 [json_name = "Leases"]; */
        for (let i = 0; i < message.leases.length; i++)
            SemaphoreLeaseRef.internalBinaryWrite(message.leases[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.SemaphoreSpecV3
 */
export const SemaphoreSpecV3 = new SemaphoreSpecV3$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WebSessionV2$Type extends MessageType<WebSessionV2> {
    constructor() {
        super("types.WebSessionV2", [
            { no: 1, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 2, name: "SubKind", kind: "scalar", jsonName: "SubKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub_kind,omitempty" } },
            { no: 3, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version" } },
            { no: 4, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "metadata" } },
            { no: 5, name: "Spec", kind: "message", jsonName: "Spec", T: () => WebSessionSpecV2, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ], { "gogoproto.goproto_stringer": false, "gogoproto.stringer": false });
    }
    create(value?: PartialMessage<WebSessionV2>): WebSessionV2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.subKind = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<WebSessionV2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WebSessionV2): WebSessionV2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Kind = 1 [json_name = "Kind"];*/ 1:
                    message.kind = reader.string();
                    break;
                case /* string SubKind = 2 [json_name = "SubKind"];*/ 2:
                    message.subKind = reader.string();
                    break;
                case /* string Version = 3 [json_name = "Version"];*/ 3:
                    message.version = reader.string();
                    break;
                case /* types.Metadata Metadata = 4 [json_name = "Metadata"];*/ 4:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* types.WebSessionSpecV2 Spec = 5 [json_name = "Spec"];*/ 5:
                    message.spec = WebSessionSpecV2.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WebSessionV2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Kind = 1 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string SubKind = 2 [json_name = "SubKind"]; */
        if (message.subKind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subKind);
        /* string Version = 3 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* types.Metadata Metadata = 4 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.WebSessionSpecV2 Spec = 5 [json_name = "Spec"]; */
        if (message.spec)
            WebSessionSpecV2.internalBinaryWrite(message.spec, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.WebSessionV2
 */
export const WebSessionV2 = new WebSessionV2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WebSessionSpecV2$Type extends MessageType<WebSessionSpecV2> {
    constructor() {
        super("types.WebSessionSpecV2", [
            { no: 1, name: "User", kind: "scalar", jsonName: "User", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "user" } },
            { no: 2, name: "Pub", kind: "scalar", jsonName: "Pub", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.jsontag": "pub" } },
            { no: 3, name: "Priv", kind: "scalar", jsonName: "Priv", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.jsontag": "priv,omitempty" } },
            { no: 4, name: "TLSCert", kind: "scalar", jsonName: "TLSCert", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.jsontag": "tls_cert,omitempty" } },
            { no: 5, name: "BearerToken", kind: "scalar", jsonName: "BearerToken", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "bearer_token" } },
            { no: 6, name: "BearerTokenExpires", kind: "message", jsonName: "BearerTokenExpires", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "bearer_token_expires", "gogoproto.stdtime": true } },
            { no: 7, name: "Expires", kind: "message", jsonName: "Expires", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "expires", "gogoproto.stdtime": true } },
            { no: 8, name: "LoginTime", kind: "message", jsonName: "LoginTime", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "login_time", "gogoproto.stdtime": true } },
            { no: 9, name: "IdleTimeout", kind: "scalar", jsonName: "IdleTimeout", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "idle_timeout", "gogoproto.casttype": "Duration" } },
            { no: 10, name: "ConsumedAccessRequestID", kind: "scalar", jsonName: "ConsumedAccessRequestID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "consumed_access_request_id,omitempty" } },
            { no: 11, name: "SAMLSession", kind: "message", jsonName: "SAMLSession", T: () => SAMLSessionData, options: { "gogoproto.jsontag": "saml_session,omitempty" } },
            { no: 12, name: "DeviceWebToken", kind: "message", jsonName: "DeviceWebToken", T: () => DeviceWebToken, options: { "gogoproto.jsontag": "device_web_token,omitempty" } },
            { no: 13, name: "HasDeviceExtensions", kind: "scalar", jsonName: "HasDeviceExtensions", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "has_device_extensions,omitempty" } },
            { no: 14, name: "TrustedDeviceRequirement", kind: "enum", jsonName: "TrustedDeviceRequirement", T: () => ["types.TrustedDeviceRequirement", TrustedDeviceRequirement, "TRUSTED_DEVICE_REQUIREMENT_"], options: { "gogoproto.jsontag": "trusted_device_requirement,omitempty" } },
            { no: 15, name: "TLSPriv", kind: "scalar", jsonName: "TLSPriv", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.jsontag": "tls_priv,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<WebSessionSpecV2>): WebSessionSpecV2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.user = "";
        message.pub = new Uint8Array(0);
        message.priv = new Uint8Array(0);
        message.tLSCert = new Uint8Array(0);
        message.bearerToken = "";
        message.idleTimeout = 0n;
        message.consumedAccessRequestID = "";
        message.hasDeviceExtensions = false;
        message.trustedDeviceRequirement = 0;
        message.tLSPriv = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<WebSessionSpecV2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WebSessionSpecV2): WebSessionSpecV2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string User = 1 [json_name = "User"];*/ 1:
                    message.user = reader.string();
                    break;
                case /* bytes Pub = 2 [json_name = "Pub"];*/ 2:
                    message.pub = reader.bytes();
                    break;
                case /* bytes Priv = 3 [json_name = "Priv"];*/ 3:
                    message.priv = reader.bytes();
                    break;
                case /* bytes TLSCert = 4 [json_name = "TLSCert"];*/ 4:
                    message.tLSCert = reader.bytes();
                    break;
                case /* string BearerToken = 5 [json_name = "BearerToken"];*/ 5:
                    message.bearerToken = reader.string();
                    break;
                case /* google.protobuf.Timestamp BearerTokenExpires = 6 [json_name = "BearerTokenExpires"];*/ 6:
                    message.bearerTokenExpires = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.bearerTokenExpires);
                    break;
                case /* google.protobuf.Timestamp Expires = 7 [json_name = "Expires"];*/ 7:
                    message.expires = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expires);
                    break;
                case /* google.protobuf.Timestamp LoginTime = 8 [json_name = "LoginTime"];*/ 8:
                    message.loginTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.loginTime);
                    break;
                case /* int64 IdleTimeout = 9 [json_name = "IdleTimeout"];*/ 9:
                    message.idleTimeout = reader.int64().toBigInt();
                    break;
                case /* string ConsumedAccessRequestID = 10 [json_name = "ConsumedAccessRequestID"];*/ 10:
                    message.consumedAccessRequestID = reader.string();
                    break;
                case /* types.SAMLSessionData SAMLSession = 11 [json_name = "SAMLSession"];*/ 11:
                    message.sAMLSession = SAMLSessionData.internalBinaryRead(reader, reader.uint32(), options, message.sAMLSession);
                    break;
                case /* types.DeviceWebToken DeviceWebToken = 12 [json_name = "DeviceWebToken"];*/ 12:
                    message.deviceWebToken = DeviceWebToken.internalBinaryRead(reader, reader.uint32(), options, message.deviceWebToken);
                    break;
                case /* bool HasDeviceExtensions = 13 [json_name = "HasDeviceExtensions"];*/ 13:
                    message.hasDeviceExtensions = reader.bool();
                    break;
                case /* types.TrustedDeviceRequirement TrustedDeviceRequirement = 14 [json_name = "TrustedDeviceRequirement"];*/ 14:
                    message.trustedDeviceRequirement = reader.int32();
                    break;
                case /* bytes TLSPriv = 15 [json_name = "TLSPriv"];*/ 15:
                    message.tLSPriv = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WebSessionSpecV2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string User = 1 [json_name = "User"]; */
        if (message.user !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.user);
        /* bytes Pub = 2 [json_name = "Pub"]; */
        if (message.pub.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.pub);
        /* bytes Priv = 3 [json_name = "Priv"]; */
        if (message.priv.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.priv);
        /* bytes TLSCert = 4 [json_name = "TLSCert"]; */
        if (message.tLSCert.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.tLSCert);
        /* string BearerToken = 5 [json_name = "BearerToken"]; */
        if (message.bearerToken !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.bearerToken);
        /* google.protobuf.Timestamp BearerTokenExpires = 6 [json_name = "BearerTokenExpires"]; */
        if (message.bearerTokenExpires)
            Timestamp.internalBinaryWrite(message.bearerTokenExpires, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp Expires = 7 [json_name = "Expires"]; */
        if (message.expires)
            Timestamp.internalBinaryWrite(message.expires, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp LoginTime = 8 [json_name = "LoginTime"]; */
        if (message.loginTime)
            Timestamp.internalBinaryWrite(message.loginTime, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* int64 IdleTimeout = 9 [json_name = "IdleTimeout"]; */
        if (message.idleTimeout !== 0n)
            writer.tag(9, WireType.Varint).int64(message.idleTimeout);
        /* string ConsumedAccessRequestID = 10 [json_name = "ConsumedAccessRequestID"]; */
        if (message.consumedAccessRequestID !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.consumedAccessRequestID);
        /* types.SAMLSessionData SAMLSession = 11 [json_name = "SAMLSession"]; */
        if (message.sAMLSession)
            SAMLSessionData.internalBinaryWrite(message.sAMLSession, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* types.DeviceWebToken DeviceWebToken = 12 [json_name = "DeviceWebToken"]; */
        if (message.deviceWebToken)
            DeviceWebToken.internalBinaryWrite(message.deviceWebToken, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* bool HasDeviceExtensions = 13 [json_name = "HasDeviceExtensions"]; */
        if (message.hasDeviceExtensions !== false)
            writer.tag(13, WireType.Varint).bool(message.hasDeviceExtensions);
        /* types.TrustedDeviceRequirement TrustedDeviceRequirement = 14 [json_name = "TrustedDeviceRequirement"]; */
        if (message.trustedDeviceRequirement !== 0)
            writer.tag(14, WireType.Varint).int32(message.trustedDeviceRequirement);
        /* bytes TLSPriv = 15 [json_name = "TLSPriv"]; */
        if (message.tLSPriv.length)
            writer.tag(15, WireType.LengthDelimited).bytes(message.tLSPriv);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.WebSessionSpecV2
 */
export const WebSessionSpecV2 = new WebSessionSpecV2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeviceWebToken$Type extends MessageType<DeviceWebToken> {
    constructor() {
        super("types.DeviceWebToken", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeviceWebToken>): DeviceWebToken {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.token = "";
        if (value !== undefined)
            reflectionMergePartial<DeviceWebToken>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeviceWebToken): DeviceWebToken {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string token */ 2:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeviceWebToken, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string token = 2; */
        if (message.token !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.DeviceWebToken
 */
export const DeviceWebToken = new DeviceWebToken$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WebSessionFilter$Type extends MessageType<WebSessionFilter> {
    constructor() {
        super("types.WebSessionFilter", [
            { no: 1, name: "User", kind: "scalar", jsonName: "User", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "user" } }
        ]);
    }
    create(value?: PartialMessage<WebSessionFilter>): WebSessionFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.user = "";
        if (value !== undefined)
            reflectionMergePartial<WebSessionFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WebSessionFilter): WebSessionFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string User = 1 [json_name = "User"];*/ 1:
                    message.user = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WebSessionFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string User = 1 [json_name = "User"]; */
        if (message.user !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.user);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.WebSessionFilter
 */
export const WebSessionFilter = new WebSessionFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SAMLSessionData$Type extends MessageType<SAMLSessionData> {
    constructor() {
        super("types.SAMLSessionData", [
            { no: 1, name: "ID", kind: "scalar", jsonName: "ID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "id" } },
            { no: 2, name: "CreateTime", kind: "message", jsonName: "CreateTime", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "create_time", "gogoproto.stdtime": true } },
            { no: 3, name: "ExpireTime", kind: "message", jsonName: "ExpireTime", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "expire_time", "gogoproto.stdtime": true } },
            { no: 4, name: "Index", kind: "scalar", jsonName: "Index", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "index" } },
            { no: 5, name: "NameID", kind: "scalar", jsonName: "NameID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "name_id" } },
            { no: 6, name: "NameIDFormat", kind: "scalar", jsonName: "NameIDFormat", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "name_id_format" } },
            { no: 7, name: "SubjectID", kind: "scalar", jsonName: "SubjectID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "subject_id" } },
            { no: 8, name: "Groups", kind: "scalar", jsonName: "Groups", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "groups" } },
            { no: 9, name: "UserName", kind: "scalar", jsonName: "UserName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "user_name" } },
            { no: 10, name: "UserEmail", kind: "scalar", jsonName: "UserEmail", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "user_email" } },
            { no: 11, name: "UserCommonName", kind: "scalar", jsonName: "UserCommonName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "user_common_name" } },
            { no: 12, name: "UserSurname", kind: "scalar", jsonName: "UserSurname", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "user_surname" } },
            { no: 13, name: "UserGivenName", kind: "scalar", jsonName: "UserGivenName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "user_given_name" } },
            { no: 14, name: "UserScopedAffiliation", kind: "scalar", jsonName: "UserScopedAffiliation", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "user_scoped_affiliation" } },
            { no: 15, name: "CustomAttributes", kind: "message", jsonName: "CustomAttributes", repeat: 1 /*RepeatType.PACKED*/, T: () => SAMLAttribute, options: { "gogoproto.jsontag": "custom_attributes" } }
        ]);
    }
    create(value?: PartialMessage<SAMLSessionData>): SAMLSessionData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.iD = "";
        message.index = "";
        message.nameID = "";
        message.nameIDFormat = "";
        message.subjectID = "";
        message.groups = [];
        message.userName = "";
        message.userEmail = "";
        message.userCommonName = "";
        message.userSurname = "";
        message.userGivenName = "";
        message.userScopedAffiliation = "";
        message.customAttributes = [];
        if (value !== undefined)
            reflectionMergePartial<SAMLSessionData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SAMLSessionData): SAMLSessionData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ID = 1 [json_name = "ID"];*/ 1:
                    message.iD = reader.string();
                    break;
                case /* google.protobuf.Timestamp CreateTime = 2 [json_name = "CreateTime"];*/ 2:
                    message.createTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createTime);
                    break;
                case /* google.protobuf.Timestamp ExpireTime = 3 [json_name = "ExpireTime"];*/ 3:
                    message.expireTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expireTime);
                    break;
                case /* string Index = 4 [json_name = "Index"];*/ 4:
                    message.index = reader.string();
                    break;
                case /* string NameID = 5 [json_name = "NameID"];*/ 5:
                    message.nameID = reader.string();
                    break;
                case /* string NameIDFormat = 6 [json_name = "NameIDFormat"];*/ 6:
                    message.nameIDFormat = reader.string();
                    break;
                case /* string SubjectID = 7 [json_name = "SubjectID"];*/ 7:
                    message.subjectID = reader.string();
                    break;
                case /* repeated string Groups = 8 [json_name = "Groups"];*/ 8:
                    message.groups.push(reader.string());
                    break;
                case /* string UserName = 9 [json_name = "UserName"];*/ 9:
                    message.userName = reader.string();
                    break;
                case /* string UserEmail = 10 [json_name = "UserEmail"];*/ 10:
                    message.userEmail = reader.string();
                    break;
                case /* string UserCommonName = 11 [json_name = "UserCommonName"];*/ 11:
                    message.userCommonName = reader.string();
                    break;
                case /* string UserSurname = 12 [json_name = "UserSurname"];*/ 12:
                    message.userSurname = reader.string();
                    break;
                case /* string UserGivenName = 13 [json_name = "UserGivenName"];*/ 13:
                    message.userGivenName = reader.string();
                    break;
                case /* string UserScopedAffiliation = 14 [json_name = "UserScopedAffiliation"];*/ 14:
                    message.userScopedAffiliation = reader.string();
                    break;
                case /* repeated types.SAMLAttribute CustomAttributes = 15 [json_name = "CustomAttributes"];*/ 15:
                    message.customAttributes.push(SAMLAttribute.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SAMLSessionData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ID = 1 [json_name = "ID"]; */
        if (message.iD !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.iD);
        /* google.protobuf.Timestamp CreateTime = 2 [json_name = "CreateTime"]; */
        if (message.createTime)
            Timestamp.internalBinaryWrite(message.createTime, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp ExpireTime = 3 [json_name = "ExpireTime"]; */
        if (message.expireTime)
            Timestamp.internalBinaryWrite(message.expireTime, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string Index = 4 [json_name = "Index"]; */
        if (message.index !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.index);
        /* string NameID = 5 [json_name = "NameID"]; */
        if (message.nameID !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.nameID);
        /* string NameIDFormat = 6 [json_name = "NameIDFormat"]; */
        if (message.nameIDFormat !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.nameIDFormat);
        /* string SubjectID = 7 [json_name = "SubjectID"]; */
        if (message.subjectID !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.subjectID);
        /* repeated string Groups = 8 [json_name = "Groups"]; */
        for (let i = 0; i < message.groups.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.groups[i]);
        /* string UserName = 9 [json_name = "UserName"]; */
        if (message.userName !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.userName);
        /* string UserEmail = 10 [json_name = "UserEmail"]; */
        if (message.userEmail !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.userEmail);
        /* string UserCommonName = 11 [json_name = "UserCommonName"]; */
        if (message.userCommonName !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.userCommonName);
        /* string UserSurname = 12 [json_name = "UserSurname"]; */
        if (message.userSurname !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.userSurname);
        /* string UserGivenName = 13 [json_name = "UserGivenName"]; */
        if (message.userGivenName !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.userGivenName);
        /* string UserScopedAffiliation = 14 [json_name = "UserScopedAffiliation"]; */
        if (message.userScopedAffiliation !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.userScopedAffiliation);
        /* repeated types.SAMLAttribute CustomAttributes = 15 [json_name = "CustomAttributes"]; */
        for (let i = 0; i < message.customAttributes.length; i++)
            SAMLAttribute.internalBinaryWrite(message.customAttributes[i], writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.SAMLSessionData
 */
export const SAMLSessionData = new SAMLSessionData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SAMLAttribute$Type extends MessageType<SAMLAttribute> {
    constructor() {
        super("types.SAMLAttribute", [
            { no: 1, name: "FriendlyName", kind: "scalar", jsonName: "FriendlyName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "friendly_name" } },
            { no: 2, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "name" } },
            { no: 3, name: "NameFormat", kind: "scalar", jsonName: "NameFormat", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "name_format" } },
            { no: 4, name: "Values", kind: "message", jsonName: "Values", repeat: 1 /*RepeatType.PACKED*/, T: () => SAMLAttributeValue, options: { "gogoproto.jsontag": "values" } }
        ]);
    }
    create(value?: PartialMessage<SAMLAttribute>): SAMLAttribute {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.friendlyName = "";
        message.name = "";
        message.nameFormat = "";
        message.values = [];
        if (value !== undefined)
            reflectionMergePartial<SAMLAttribute>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SAMLAttribute): SAMLAttribute {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string FriendlyName = 1 [json_name = "FriendlyName"];*/ 1:
                    message.friendlyName = reader.string();
                    break;
                case /* string Name = 2 [json_name = "Name"];*/ 2:
                    message.name = reader.string();
                    break;
                case /* string NameFormat = 3 [json_name = "NameFormat"];*/ 3:
                    message.nameFormat = reader.string();
                    break;
                case /* repeated types.SAMLAttributeValue Values = 4 [json_name = "Values"];*/ 4:
                    message.values.push(SAMLAttributeValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SAMLAttribute, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string FriendlyName = 1 [json_name = "FriendlyName"]; */
        if (message.friendlyName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.friendlyName);
        /* string Name = 2 [json_name = "Name"]; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string NameFormat = 3 [json_name = "NameFormat"]; */
        if (message.nameFormat !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.nameFormat);
        /* repeated types.SAMLAttributeValue Values = 4 [json_name = "Values"]; */
        for (let i = 0; i < message.values.length; i++)
            SAMLAttributeValue.internalBinaryWrite(message.values[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.SAMLAttribute
 */
export const SAMLAttribute = new SAMLAttribute$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SAMLAttributeValue$Type extends MessageType<SAMLAttributeValue> {
    constructor() {
        super("types.SAMLAttributeValue", [
            { no: 1, name: "Type", kind: "scalar", jsonName: "Type", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "type" } },
            { no: 2, name: "Value", kind: "scalar", jsonName: "Value", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "value" } },
            { no: 3, name: "NameID", kind: "message", jsonName: "NameID", T: () => SAMLNameID, options: { "gogoproto.jsontag": "name_id,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<SAMLAttributeValue>): SAMLAttributeValue {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        message.value = "";
        if (value !== undefined)
            reflectionMergePartial<SAMLAttributeValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SAMLAttributeValue): SAMLAttributeValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Type = 1 [json_name = "Type"];*/ 1:
                    message.type = reader.string();
                    break;
                case /* string Value = 2 [json_name = "Value"];*/ 2:
                    message.value = reader.string();
                    break;
                case /* types.SAMLNameID NameID = 3 [json_name = "NameID"];*/ 3:
                    message.nameID = SAMLNameID.internalBinaryRead(reader, reader.uint32(), options, message.nameID);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SAMLAttributeValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Type = 1 [json_name = "Type"]; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* string Value = 2 [json_name = "Value"]; */
        if (message.value !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        /* types.SAMLNameID NameID = 3 [json_name = "NameID"]; */
        if (message.nameID)
            SAMLNameID.internalBinaryWrite(message.nameID, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.SAMLAttributeValue
 */
export const SAMLAttributeValue = new SAMLAttributeValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SAMLNameID$Type extends MessageType<SAMLNameID> {
    constructor() {
        super("types.SAMLNameID", [
            { no: 1, name: "NameQualifier", kind: "scalar", jsonName: "NameQualifier", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "name_qualifier" } },
            { no: 2, name: "SPNameQualifier", kind: "scalar", jsonName: "SPNameQualifier", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sp_name_qualifier" } },
            { no: 3, name: "Format", kind: "scalar", jsonName: "Format", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "format" } },
            { no: 4, name: "SPProvidedID", kind: "scalar", jsonName: "SPProvidedID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sp_provider_id" } },
            { no: 5, name: "Value", kind: "scalar", jsonName: "Value", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "value" } }
        ]);
    }
    create(value?: PartialMessage<SAMLNameID>): SAMLNameID {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.nameQualifier = "";
        message.sPNameQualifier = "";
        message.format = "";
        message.sPProvidedID = "";
        message.value = "";
        if (value !== undefined)
            reflectionMergePartial<SAMLNameID>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SAMLNameID): SAMLNameID {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string NameQualifier = 1 [json_name = "NameQualifier"];*/ 1:
                    message.nameQualifier = reader.string();
                    break;
                case /* string SPNameQualifier = 2 [json_name = "SPNameQualifier"];*/ 2:
                    message.sPNameQualifier = reader.string();
                    break;
                case /* string Format = 3 [json_name = "Format"];*/ 3:
                    message.format = reader.string();
                    break;
                case /* string SPProvidedID = 4 [json_name = "SPProvidedID"];*/ 4:
                    message.sPProvidedID = reader.string();
                    break;
                case /* string Value = 5 [json_name = "Value"];*/ 5:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SAMLNameID, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string NameQualifier = 1 [json_name = "NameQualifier"]; */
        if (message.nameQualifier !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.nameQualifier);
        /* string SPNameQualifier = 2 [json_name = "SPNameQualifier"]; */
        if (message.sPNameQualifier !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sPNameQualifier);
        /* string Format = 3 [json_name = "Format"]; */
        if (message.format !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.format);
        /* string SPProvidedID = 4 [json_name = "SPProvidedID"]; */
        if (message.sPProvidedID !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.sPProvidedID);
        /* string Value = 5 [json_name = "Value"]; */
        if (message.value !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.SAMLNameID
 */
export const SAMLNameID = new SAMLNameID$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoteClusterV3$Type extends MessageType<RemoteClusterV3> {
    constructor() {
        super("types.RemoteClusterV3", [
            { no: 1, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 2, name: "SubKind", kind: "scalar", jsonName: "SubKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub_kind,omitempty" } },
            { no: 3, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version" } },
            { no: 4, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "metadata" } },
            { no: 5, name: "Status", kind: "message", jsonName: "Status", T: () => RemoteClusterStatusV3, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "status" } }
        ], { "gogoproto.goproto_stringer": false, "gogoproto.stringer": false });
    }
    create(value?: PartialMessage<RemoteClusterV3>): RemoteClusterV3 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.subKind = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<RemoteClusterV3>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RemoteClusterV3): RemoteClusterV3 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Kind = 1 [json_name = "Kind"];*/ 1:
                    message.kind = reader.string();
                    break;
                case /* string SubKind = 2 [json_name = "SubKind"];*/ 2:
                    message.subKind = reader.string();
                    break;
                case /* string Version = 3 [json_name = "Version"];*/ 3:
                    message.version = reader.string();
                    break;
                case /* types.Metadata Metadata = 4 [json_name = "Metadata"];*/ 4:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* types.RemoteClusterStatusV3 Status = 5 [json_name = "Status"];*/ 5:
                    message.status = RemoteClusterStatusV3.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RemoteClusterV3, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Kind = 1 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string SubKind = 2 [json_name = "SubKind"]; */
        if (message.subKind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subKind);
        /* string Version = 3 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* types.Metadata Metadata = 4 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.RemoteClusterStatusV3 Status = 5 [json_name = "Status"]; */
        if (message.status)
            RemoteClusterStatusV3.internalBinaryWrite(message.status, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.RemoteClusterV3
 */
export const RemoteClusterV3 = new RemoteClusterV3$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoteClusterStatusV3$Type extends MessageType<RemoteClusterStatusV3> {
    constructor() {
        super("types.RemoteClusterStatusV3", [
            { no: 1, name: "Connection", kind: "scalar", jsonName: "Connection", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "connection" } },
            { no: 2, name: "LastHeartbeat", kind: "message", jsonName: "LastHeartbeat", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "last_heartbeat", "gogoproto.stdtime": true } }
        ]);
    }
    create(value?: PartialMessage<RemoteClusterStatusV3>): RemoteClusterStatusV3 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.connection = "";
        if (value !== undefined)
            reflectionMergePartial<RemoteClusterStatusV3>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RemoteClusterStatusV3): RemoteClusterStatusV3 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Connection = 1 [json_name = "Connection"];*/ 1:
                    message.connection = reader.string();
                    break;
                case /* google.protobuf.Timestamp LastHeartbeat = 2 [json_name = "LastHeartbeat"];*/ 2:
                    message.lastHeartbeat = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastHeartbeat);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RemoteClusterStatusV3, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Connection = 1 [json_name = "Connection"]; */
        if (message.connection !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.connection);
        /* google.protobuf.Timestamp LastHeartbeat = 2 [json_name = "LastHeartbeat"]; */
        if (message.lastHeartbeat)
            Timestamp.internalBinaryWrite(message.lastHeartbeat, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.RemoteClusterStatusV3
 */
export const RemoteClusterStatusV3 = new RemoteClusterStatusV3$Type();
// @generated message type with reflection information, may provide speed optimized methods
class KubernetesCluster$Type extends MessageType<KubernetesCluster> {
    constructor() {
        super("types.KubernetesCluster", [
            { no: 1, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "name" } },
            { no: 2, name: "StaticLabels", kind: "map", jsonName: "StaticLabels", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ }, options: { "gogoproto.jsontag": "static_labels,omitempty" } },
            { no: 3, name: "DynamicLabels", kind: "map", jsonName: "DynamicLabels", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => CommandLabelV2 }, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "dynamic_labels,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<KubernetesCluster>): KubernetesCluster {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.staticLabels = {};
        message.dynamicLabels = {};
        if (value !== undefined)
            reflectionMergePartial<KubernetesCluster>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KubernetesCluster): KubernetesCluster {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Name = 1 [json_name = "Name"];*/ 1:
                    message.name = reader.string();
                    break;
                case /* map<string, string> StaticLabels = 2 [json_name = "StaticLabels"];*/ 2:
                    this.binaryReadMap2(message.staticLabels, reader, options);
                    break;
                case /* map<string, types.CommandLabelV2> DynamicLabels = 3 [json_name = "DynamicLabels"];*/ 3:
                    this.binaryReadMap3(message.dynamicLabels, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: KubernetesCluster["staticLabels"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof KubernetesCluster["staticLabels"] | undefined, val: KubernetesCluster["staticLabels"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field types.KubernetesCluster.StaticLabels");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    private binaryReadMap3(map: KubernetesCluster["dynamicLabels"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof KubernetesCluster["dynamicLabels"] | undefined, val: KubernetesCluster["dynamicLabels"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = CommandLabelV2.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field types.KubernetesCluster.DynamicLabels");
            }
        }
        map[key ?? ""] = val ?? CommandLabelV2.create();
    }
    internalBinaryWrite(message: KubernetesCluster, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Name = 1 [json_name = "Name"]; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* map<string, string> StaticLabels = 2 [json_name = "StaticLabels"]; */
        for (let k of globalThis.Object.keys(message.staticLabels))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.staticLabels[k]).join();
        /* map<string, types.CommandLabelV2> DynamicLabels = 3 [json_name = "DynamicLabels"]; */
        for (let k of globalThis.Object.keys(message.dynamicLabels)) {
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            CommandLabelV2.internalBinaryWrite(message.dynamicLabels[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.KubernetesCluster
 */
export const KubernetesCluster = new KubernetesCluster$Type();
// @generated message type with reflection information, may provide speed optimized methods
class KubernetesClusterV3$Type extends MessageType<KubernetesClusterV3> {
    constructor() {
        super("types.KubernetesClusterV3", [
            { no: 1, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 2, name: "SubKind", kind: "scalar", jsonName: "SubKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub_kind,omitempty" } },
            { no: 3, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version" } },
            { no: 4, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "metadata" } },
            { no: 5, name: "Spec", kind: "message", jsonName: "Spec", T: () => KubernetesClusterSpecV3, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ], { "gogoproto.goproto_stringer": false, "gogoproto.stringer": false });
    }
    create(value?: PartialMessage<KubernetesClusterV3>): KubernetesClusterV3 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.subKind = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<KubernetesClusterV3>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KubernetesClusterV3): KubernetesClusterV3 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Kind = 1 [json_name = "Kind"];*/ 1:
                    message.kind = reader.string();
                    break;
                case /* string SubKind = 2 [json_name = "SubKind"];*/ 2:
                    message.subKind = reader.string();
                    break;
                case /* string Version = 3 [json_name = "Version"];*/ 3:
                    message.version = reader.string();
                    break;
                case /* types.Metadata Metadata = 4 [json_name = "Metadata"];*/ 4:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* types.KubernetesClusterSpecV3 Spec = 5 [json_name = "Spec"];*/ 5:
                    message.spec = KubernetesClusterSpecV3.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: KubernetesClusterV3, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Kind = 1 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string SubKind = 2 [json_name = "SubKind"]; */
        if (message.subKind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subKind);
        /* string Version = 3 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* types.Metadata Metadata = 4 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.KubernetesClusterSpecV3 Spec = 5 [json_name = "Spec"]; */
        if (message.spec)
            KubernetesClusterSpecV3.internalBinaryWrite(message.spec, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.KubernetesClusterV3
 */
export const KubernetesClusterV3 = new KubernetesClusterV3$Type();
// @generated message type with reflection information, may provide speed optimized methods
class KubernetesClusterSpecV3$Type extends MessageType<KubernetesClusterSpecV3> {
    constructor() {
        super("types.KubernetesClusterSpecV3", [
            { no: 1, name: "DynamicLabels", kind: "map", jsonName: "DynamicLabels", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => CommandLabelV2 }, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "dynamic_labels,omitempty" } },
            { no: 2, name: "Kubeconfig", kind: "scalar", jsonName: "Kubeconfig", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.jsontag": "kubeconfig,omitempty" } },
            { no: 3, name: "Azure", kind: "message", jsonName: "Azure", T: () => KubeAzure, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "azure,omitempty" } },
            { no: 4, name: "AWS", kind: "message", jsonName: "AWS", T: () => KubeAWS, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "aws,omitempty" } },
            { no: 5, name: "GCP", kind: "message", jsonName: "GCP", T: () => KubeGCP, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "gcp,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<KubernetesClusterSpecV3>): KubernetesClusterSpecV3 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.dynamicLabels = {};
        message.kubeconfig = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<KubernetesClusterSpecV3>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KubernetesClusterSpecV3): KubernetesClusterSpecV3 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, types.CommandLabelV2> DynamicLabels = 1 [json_name = "DynamicLabels"];*/ 1:
                    this.binaryReadMap1(message.dynamicLabels, reader, options);
                    break;
                case /* bytes Kubeconfig = 2 [json_name = "Kubeconfig"];*/ 2:
                    message.kubeconfig = reader.bytes();
                    break;
                case /* types.KubeAzure Azure = 3 [json_name = "Azure"];*/ 3:
                    message.azure = KubeAzure.internalBinaryRead(reader, reader.uint32(), options, message.azure);
                    break;
                case /* types.KubeAWS AWS = 4 [json_name = "AWS"];*/ 4:
                    message.aWS = KubeAWS.internalBinaryRead(reader, reader.uint32(), options, message.aWS);
                    break;
                case /* types.KubeGCP GCP = 5 [json_name = "GCP"];*/ 5:
                    message.gCP = KubeGCP.internalBinaryRead(reader, reader.uint32(), options, message.gCP);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: KubernetesClusterSpecV3["dynamicLabels"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof KubernetesClusterSpecV3["dynamicLabels"] | undefined, val: KubernetesClusterSpecV3["dynamicLabels"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = CommandLabelV2.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field types.KubernetesClusterSpecV3.DynamicLabels");
            }
        }
        map[key ?? ""] = val ?? CommandLabelV2.create();
    }
    internalBinaryWrite(message: KubernetesClusterSpecV3, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, types.CommandLabelV2> DynamicLabels = 1 [json_name = "DynamicLabels"]; */
        for (let k of globalThis.Object.keys(message.dynamicLabels)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            CommandLabelV2.internalBinaryWrite(message.dynamicLabels[k], writer, options);
            writer.join().join();
        }
        /* bytes Kubeconfig = 2 [json_name = "Kubeconfig"]; */
        if (message.kubeconfig.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.kubeconfig);
        /* types.KubeAzure Azure = 3 [json_name = "Azure"]; */
        if (message.azure)
            KubeAzure.internalBinaryWrite(message.azure, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* types.KubeAWS AWS = 4 [json_name = "AWS"]; */
        if (message.aWS)
            KubeAWS.internalBinaryWrite(message.aWS, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.KubeGCP GCP = 5 [json_name = "GCP"]; */
        if (message.gCP)
            KubeGCP.internalBinaryWrite(message.gCP, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.KubernetesClusterSpecV3
 */
export const KubernetesClusterSpecV3 = new KubernetesClusterSpecV3$Type();
// @generated message type with reflection information, may provide speed optimized methods
class KubeAzure$Type extends MessageType<KubeAzure> {
    constructor() {
        super("types.KubeAzure", [
            { no: 1, name: "ResourceName", kind: "scalar", jsonName: "ResourceName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "resource_name,omitempty" } },
            { no: 2, name: "ResourceGroup", kind: "scalar", jsonName: "ResourceGroup", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "resource_group,omitempty" } },
            { no: 3, name: "TenantID", kind: "scalar", jsonName: "TenantID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "tenant_id,omitempty" } },
            { no: 4, name: "SubscriptionID", kind: "scalar", jsonName: "SubscriptionID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "subscription_id,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<KubeAzure>): KubeAzure {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.resourceName = "";
        message.resourceGroup = "";
        message.tenantID = "";
        message.subscriptionID = "";
        if (value !== undefined)
            reflectionMergePartial<KubeAzure>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KubeAzure): KubeAzure {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ResourceName = 1 [json_name = "ResourceName"];*/ 1:
                    message.resourceName = reader.string();
                    break;
                case /* string ResourceGroup = 2 [json_name = "ResourceGroup"];*/ 2:
                    message.resourceGroup = reader.string();
                    break;
                case /* string TenantID = 3 [json_name = "TenantID"];*/ 3:
                    message.tenantID = reader.string();
                    break;
                case /* string SubscriptionID = 4 [json_name = "SubscriptionID"];*/ 4:
                    message.subscriptionID = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: KubeAzure, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ResourceName = 1 [json_name = "ResourceName"]; */
        if (message.resourceName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.resourceName);
        /* string ResourceGroup = 2 [json_name = "ResourceGroup"]; */
        if (message.resourceGroup !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.resourceGroup);
        /* string TenantID = 3 [json_name = "TenantID"]; */
        if (message.tenantID !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.tenantID);
        /* string SubscriptionID = 4 [json_name = "SubscriptionID"]; */
        if (message.subscriptionID !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.subscriptionID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.KubeAzure
 */
export const KubeAzure = new KubeAzure$Type();
// @generated message type with reflection information, may provide speed optimized methods
class KubeAWS$Type extends MessageType<KubeAWS> {
    constructor() {
        super("types.KubeAWS", [
            { no: 1, name: "Region", kind: "scalar", jsonName: "Region", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "region,omitempty" } },
            { no: 2, name: "AccountID", kind: "scalar", jsonName: "AccountID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "account_id,omitempty" } },
            { no: 3, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "name,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<KubeAWS>): KubeAWS {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.region = "";
        message.accountID = "";
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<KubeAWS>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KubeAWS): KubeAWS {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Region = 1 [json_name = "Region"];*/ 1:
                    message.region = reader.string();
                    break;
                case /* string AccountID = 2 [json_name = "AccountID"];*/ 2:
                    message.accountID = reader.string();
                    break;
                case /* string Name = 3 [json_name = "Name"];*/ 3:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: KubeAWS, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Region = 1 [json_name = "Region"]; */
        if (message.region !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.region);
        /* string AccountID = 2 [json_name = "AccountID"]; */
        if (message.accountID !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.accountID);
        /* string Name = 3 [json_name = "Name"]; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.KubeAWS
 */
export const KubeAWS = new KubeAWS$Type();
// @generated message type with reflection information, may provide speed optimized methods
class KubeGCP$Type extends MessageType<KubeGCP> {
    constructor() {
        super("types.KubeGCP", [
            { no: 1, name: "Location", kind: "scalar", jsonName: "Location", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "location,omitempty" } },
            { no: 2, name: "ProjectID", kind: "scalar", jsonName: "ProjectID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "project_id,omitempty" } },
            { no: 3, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "name,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<KubeGCP>): KubeGCP {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.location = "";
        message.projectID = "";
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<KubeGCP>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KubeGCP): KubeGCP {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Location = 1 [json_name = "Location"];*/ 1:
                    message.location = reader.string();
                    break;
                case /* string ProjectID = 2 [json_name = "ProjectID"];*/ 2:
                    message.projectID = reader.string();
                    break;
                case /* string Name = 3 [json_name = "Name"];*/ 3:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: KubeGCP, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Location = 1 [json_name = "Location"]; */
        if (message.location !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.location);
        /* string ProjectID = 2 [json_name = "ProjectID"]; */
        if (message.projectID !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.projectID);
        /* string Name = 3 [json_name = "Name"]; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.KubeGCP
 */
export const KubeGCP = new KubeGCP$Type();
// @generated message type with reflection information, may provide speed optimized methods
class KubernetesClusterV3List$Type extends MessageType<KubernetesClusterV3List> {
    constructor() {
        super("types.KubernetesClusterV3List", [
            { no: 1, name: "KubernetesClusters", kind: "message", jsonName: "KubernetesClusters", repeat: 1 /*RepeatType.PACKED*/, T: () => KubernetesClusterV3 }
        ]);
    }
    create(value?: PartialMessage<KubernetesClusterV3List>): KubernetesClusterV3List {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kubernetesClusters = [];
        if (value !== undefined)
            reflectionMergePartial<KubernetesClusterV3List>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KubernetesClusterV3List): KubernetesClusterV3List {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.KubernetesClusterV3 KubernetesClusters = 1 [json_name = "KubernetesClusters"];*/ 1:
                    message.kubernetesClusters.push(KubernetesClusterV3.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: KubernetesClusterV3List, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.KubernetesClusterV3 KubernetesClusters = 1 [json_name = "KubernetesClusters"]; */
        for (let i = 0; i < message.kubernetesClusters.length; i++)
            KubernetesClusterV3.internalBinaryWrite(message.kubernetesClusters[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.KubernetesClusterV3List
 */
export const KubernetesClusterV3List = new KubernetesClusterV3List$Type();
// @generated message type with reflection information, may provide speed optimized methods
class KubernetesServerV3$Type extends MessageType<KubernetesServerV3> {
    constructor() {
        super("types.KubernetesServerV3", [
            { no: 1, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 2, name: "SubKind", kind: "scalar", jsonName: "SubKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub_kind,omitempty" } },
            { no: 3, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version" } },
            { no: 4, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "metadata" } },
            { no: 5, name: "Spec", kind: "message", jsonName: "Spec", T: () => KubernetesServerSpecV3, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ], { "gogoproto.goproto_stringer": false, "gogoproto.stringer": false });
    }
    create(value?: PartialMessage<KubernetesServerV3>): KubernetesServerV3 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.subKind = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<KubernetesServerV3>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KubernetesServerV3): KubernetesServerV3 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Kind = 1 [json_name = "Kind"];*/ 1:
                    message.kind = reader.string();
                    break;
                case /* string SubKind = 2 [json_name = "SubKind"];*/ 2:
                    message.subKind = reader.string();
                    break;
                case /* string Version = 3 [json_name = "Version"];*/ 3:
                    message.version = reader.string();
                    break;
                case /* types.Metadata Metadata = 4 [json_name = "Metadata"];*/ 4:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* types.KubernetesServerSpecV3 Spec = 5 [json_name = "Spec"];*/ 5:
                    message.spec = KubernetesServerSpecV3.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: KubernetesServerV3, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Kind = 1 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string SubKind = 2 [json_name = "SubKind"]; */
        if (message.subKind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subKind);
        /* string Version = 3 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* types.Metadata Metadata = 4 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.KubernetesServerSpecV3 Spec = 5 [json_name = "Spec"]; */
        if (message.spec)
            KubernetesServerSpecV3.internalBinaryWrite(message.spec, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.KubernetesServerV3
 */
export const KubernetesServerV3 = new KubernetesServerV3$Type();
// @generated message type with reflection information, may provide speed optimized methods
class KubernetesServerSpecV3$Type extends MessageType<KubernetesServerSpecV3> {
    constructor() {
        super("types.KubernetesServerSpecV3", [
            { no: 1, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version" } },
            { no: 2, name: "Hostname", kind: "scalar", jsonName: "Hostname", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "hostname" } },
            { no: 3, name: "HostID", kind: "scalar", jsonName: "HostID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "host_id" } },
            { no: 4, name: "Rotation", kind: "message", jsonName: "Rotation", T: () => Rotation, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "rotation,omitempty" } },
            { no: 5, name: "Cluster", kind: "message", jsonName: "Cluster", T: () => KubernetesClusterV3, options: { "gogoproto.jsontag": "cluster" } },
            { no: 6, name: "ProxyIDs", kind: "scalar", jsonName: "ProxyIDs", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "proxy_ids,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<KubernetesServerSpecV3>): KubernetesServerSpecV3 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.version = "";
        message.hostname = "";
        message.hostID = "";
        message.proxyIDs = [];
        if (value !== undefined)
            reflectionMergePartial<KubernetesServerSpecV3>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KubernetesServerSpecV3): KubernetesServerSpecV3 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Version = 1 [json_name = "Version"];*/ 1:
                    message.version = reader.string();
                    break;
                case /* string Hostname = 2 [json_name = "Hostname"];*/ 2:
                    message.hostname = reader.string();
                    break;
                case /* string HostID = 3 [json_name = "HostID"];*/ 3:
                    message.hostID = reader.string();
                    break;
                case /* types.Rotation Rotation = 4 [json_name = "Rotation"];*/ 4:
                    message.rotation = Rotation.internalBinaryRead(reader, reader.uint32(), options, message.rotation);
                    break;
                case /* types.KubernetesClusterV3 Cluster = 5 [json_name = "Cluster"];*/ 5:
                    message.cluster = KubernetesClusterV3.internalBinaryRead(reader, reader.uint32(), options, message.cluster);
                    break;
                case /* repeated string ProxyIDs = 6 [json_name = "ProxyIDs"];*/ 6:
                    message.proxyIDs.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: KubernetesServerSpecV3, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Version = 1 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.version);
        /* string Hostname = 2 [json_name = "Hostname"]; */
        if (message.hostname !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.hostname);
        /* string HostID = 3 [json_name = "HostID"]; */
        if (message.hostID !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.hostID);
        /* types.Rotation Rotation = 4 [json_name = "Rotation"]; */
        if (message.rotation)
            Rotation.internalBinaryWrite(message.rotation, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.KubernetesClusterV3 Cluster = 5 [json_name = "Cluster"]; */
        if (message.cluster)
            KubernetesClusterV3.internalBinaryWrite(message.cluster, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated string ProxyIDs = 6 [json_name = "ProxyIDs"]; */
        for (let i = 0; i < message.proxyIDs.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.proxyIDs[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.KubernetesServerSpecV3
 */
export const KubernetesServerSpecV3 = new KubernetesServerSpecV3$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WebTokenV3$Type extends MessageType<WebTokenV3> {
    constructor() {
        super("types.WebTokenV3", [
            { no: 1, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 2, name: "SubKind", kind: "scalar", jsonName: "SubKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub_kind,omitempty" } },
            { no: 3, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version" } },
            { no: 4, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "metadata" } },
            { no: 5, name: "Spec", kind: "message", jsonName: "Spec", T: () => WebTokenSpecV3, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ], { "gogoproto.goproto_stringer": false, "gogoproto.stringer": false });
    }
    create(value?: PartialMessage<WebTokenV3>): WebTokenV3 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.subKind = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<WebTokenV3>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WebTokenV3): WebTokenV3 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Kind = 1 [json_name = "Kind"];*/ 1:
                    message.kind = reader.string();
                    break;
                case /* string SubKind = 2 [json_name = "SubKind"];*/ 2:
                    message.subKind = reader.string();
                    break;
                case /* string Version = 3 [json_name = "Version"];*/ 3:
                    message.version = reader.string();
                    break;
                case /* types.Metadata Metadata = 4 [json_name = "Metadata"];*/ 4:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* types.WebTokenSpecV3 Spec = 5 [json_name = "Spec"];*/ 5:
                    message.spec = WebTokenSpecV3.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WebTokenV3, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Kind = 1 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string SubKind = 2 [json_name = "SubKind"]; */
        if (message.subKind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subKind);
        /* string Version = 3 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* types.Metadata Metadata = 4 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.WebTokenSpecV3 Spec = 5 [json_name = "Spec"]; */
        if (message.spec)
            WebTokenSpecV3.internalBinaryWrite(message.spec, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.WebTokenV3
 */
export const WebTokenV3 = new WebTokenV3$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WebTokenSpecV3$Type extends MessageType<WebTokenSpecV3> {
    constructor() {
        super("types.WebTokenSpecV3", [
            { no: 1, name: "User", kind: "scalar", jsonName: "User", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "user" } },
            { no: 2, name: "Token", kind: "scalar", jsonName: "Token", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "token" } }
        ]);
    }
    create(value?: PartialMessage<WebTokenSpecV3>): WebTokenSpecV3 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.user = "";
        message.token = "";
        if (value !== undefined)
            reflectionMergePartial<WebTokenSpecV3>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WebTokenSpecV3): WebTokenSpecV3 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string User = 1 [json_name = "User"];*/ 1:
                    message.user = reader.string();
                    break;
                case /* string Token = 2 [json_name = "Token"];*/ 2:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WebTokenSpecV3, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string User = 1 [json_name = "User"]; */
        if (message.user !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.user);
        /* string Token = 2 [json_name = "Token"]; */
        if (message.token !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.WebTokenSpecV3
 */
export const WebTokenSpecV3 = new WebTokenSpecV3$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetWebSessionRequest$Type extends MessageType<GetWebSessionRequest> {
    constructor() {
        super("types.GetWebSessionRequest", [
            { no: 1, name: "User", kind: "scalar", jsonName: "User", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "user" } },
            { no: 2, name: "SessionID", kind: "scalar", jsonName: "SessionID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "session_id" } }
        ]);
    }
    create(value?: PartialMessage<GetWebSessionRequest>): GetWebSessionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.user = "";
        message.sessionID = "";
        if (value !== undefined)
            reflectionMergePartial<GetWebSessionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetWebSessionRequest): GetWebSessionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string User = 1 [json_name = "User"];*/ 1:
                    message.user = reader.string();
                    break;
                case /* string SessionID = 2 [json_name = "SessionID"];*/ 2:
                    message.sessionID = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetWebSessionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string User = 1 [json_name = "User"]; */
        if (message.user !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.user);
        /* string SessionID = 2 [json_name = "SessionID"]; */
        if (message.sessionID !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sessionID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.GetWebSessionRequest
 */
export const GetWebSessionRequest = new GetWebSessionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteWebSessionRequest$Type extends MessageType<DeleteWebSessionRequest> {
    constructor() {
        super("types.DeleteWebSessionRequest", [
            { no: 1, name: "User", kind: "scalar", jsonName: "User", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "user" } },
            { no: 2, name: "SessionID", kind: "scalar", jsonName: "SessionID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "session_id" } }
        ]);
    }
    create(value?: PartialMessage<DeleteWebSessionRequest>): DeleteWebSessionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.user = "";
        message.sessionID = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteWebSessionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteWebSessionRequest): DeleteWebSessionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string User = 1 [json_name = "User"];*/ 1:
                    message.user = reader.string();
                    break;
                case /* string SessionID = 2 [json_name = "SessionID"];*/ 2:
                    message.sessionID = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteWebSessionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string User = 1 [json_name = "User"]; */
        if (message.user !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.user);
        /* string SessionID = 2 [json_name = "SessionID"]; */
        if (message.sessionID !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sessionID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.DeleteWebSessionRequest
 */
export const DeleteWebSessionRequest = new DeleteWebSessionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetWebTokenRequest$Type extends MessageType<GetWebTokenRequest> {
    constructor() {
        super("types.GetWebTokenRequest", [
            { no: 1, name: "User", kind: "scalar", jsonName: "User", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "user" } },
            { no: 2, name: "Token", kind: "scalar", jsonName: "Token", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "token" } }
        ]);
    }
    create(value?: PartialMessage<GetWebTokenRequest>): GetWebTokenRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.user = "";
        message.token = "";
        if (value !== undefined)
            reflectionMergePartial<GetWebTokenRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetWebTokenRequest): GetWebTokenRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string User = 1 [json_name = "User"];*/ 1:
                    message.user = reader.string();
                    break;
                case /* string Token = 2 [json_name = "Token"];*/ 2:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetWebTokenRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string User = 1 [json_name = "User"]; */
        if (message.user !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.user);
        /* string Token = 2 [json_name = "Token"]; */
        if (message.token !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.GetWebTokenRequest
 */
export const GetWebTokenRequest = new GetWebTokenRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteWebTokenRequest$Type extends MessageType<DeleteWebTokenRequest> {
    constructor() {
        super("types.DeleteWebTokenRequest", [
            { no: 1, name: "User", kind: "scalar", jsonName: "User", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "user" } },
            { no: 2, name: "Token", kind: "scalar", jsonName: "Token", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "token" } }
        ]);
    }
    create(value?: PartialMessage<DeleteWebTokenRequest>): DeleteWebTokenRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.user = "";
        message.token = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteWebTokenRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteWebTokenRequest): DeleteWebTokenRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string User = 1 [json_name = "User"];*/ 1:
                    message.user = reader.string();
                    break;
                case /* string Token = 2 [json_name = "Token"];*/ 2:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteWebTokenRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string User = 1 [json_name = "User"]; */
        if (message.user !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.user);
        /* string Token = 2 [json_name = "Token"]; */
        if (message.token !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.DeleteWebTokenRequest
 */
export const DeleteWebTokenRequest = new DeleteWebTokenRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResourceRequest$Type extends MessageType<ResourceRequest> {
    constructor() {
        super("types.ResourceRequest", [
            { no: 1, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "name" } }
        ]);
    }
    create(value?: PartialMessage<ResourceRequest>): ResourceRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<ResourceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResourceRequest): ResourceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Name = 1 [json_name = "Name"];*/ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResourceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Name = 1 [json_name = "Name"]; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ResourceRequest
 */
export const ResourceRequest = new ResourceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResourceWithSecretsRequest$Type extends MessageType<ResourceWithSecretsRequest> {
    constructor() {
        super("types.ResourceWithSecretsRequest", [
            { no: 1, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "name" } },
            { no: 2, name: "WithSecrets", kind: "scalar", jsonName: "WithSecrets", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "with_secrets,omitempty" } },
            { no: 3, name: "SAMLValidationNoFollowURLs", kind: "scalar", jsonName: "SAMLValidationNoFollowURLs", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "saml_validation_no_follow_urls" } }
        ]);
    }
    create(value?: PartialMessage<ResourceWithSecretsRequest>): ResourceWithSecretsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.withSecrets = false;
        message.sAMLValidationNoFollowURLs = false;
        if (value !== undefined)
            reflectionMergePartial<ResourceWithSecretsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResourceWithSecretsRequest): ResourceWithSecretsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Name = 1 [json_name = "Name"];*/ 1:
                    message.name = reader.string();
                    break;
                case /* bool WithSecrets = 2 [json_name = "WithSecrets"];*/ 2:
                    message.withSecrets = reader.bool();
                    break;
                case /* bool SAMLValidationNoFollowURLs = 3 [json_name = "SAMLValidationNoFollowURLs"];*/ 3:
                    message.sAMLValidationNoFollowURLs = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResourceWithSecretsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Name = 1 [json_name = "Name"]; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* bool WithSecrets = 2 [json_name = "WithSecrets"]; */
        if (message.withSecrets !== false)
            writer.tag(2, WireType.Varint).bool(message.withSecrets);
        /* bool SAMLValidationNoFollowURLs = 3 [json_name = "SAMLValidationNoFollowURLs"]; */
        if (message.sAMLValidationNoFollowURLs !== false)
            writer.tag(3, WireType.Varint).bool(message.sAMLValidationNoFollowURLs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ResourceWithSecretsRequest
 */
export const ResourceWithSecretsRequest = new ResourceWithSecretsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResourcesWithSecretsRequest$Type extends MessageType<ResourcesWithSecretsRequest> {
    constructor() {
        super("types.ResourcesWithSecretsRequest", [
            { no: 1, name: "WithSecrets", kind: "scalar", jsonName: "WithSecrets", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "with_secrets,omitempty" } },
            { no: 2, name: "SAMLValidationNoFollowURLs", kind: "scalar", jsonName: "SAMLValidationNoFollowURLs", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "saml_validation_no_follow_urls" } }
        ]);
    }
    create(value?: PartialMessage<ResourcesWithSecretsRequest>): ResourcesWithSecretsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.withSecrets = false;
        message.sAMLValidationNoFollowURLs = false;
        if (value !== undefined)
            reflectionMergePartial<ResourcesWithSecretsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResourcesWithSecretsRequest): ResourcesWithSecretsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool WithSecrets = 1 [json_name = "WithSecrets"];*/ 1:
                    message.withSecrets = reader.bool();
                    break;
                case /* bool SAMLValidationNoFollowURLs = 2 [json_name = "SAMLValidationNoFollowURLs"];*/ 2:
                    message.sAMLValidationNoFollowURLs = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResourcesWithSecretsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool WithSecrets = 1 [json_name = "WithSecrets"]; */
        if (message.withSecrets !== false)
            writer.tag(1, WireType.Varint).bool(message.withSecrets);
        /* bool SAMLValidationNoFollowURLs = 2 [json_name = "SAMLValidationNoFollowURLs"]; */
        if (message.sAMLValidationNoFollowURLs !== false)
            writer.tag(2, WireType.Varint).bool(message.sAMLValidationNoFollowURLs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ResourcesWithSecretsRequest
 */
export const ResourcesWithSecretsRequest = new ResourcesWithSecretsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResourceInNamespaceRequest$Type extends MessageType<ResourceInNamespaceRequest> {
    constructor() {
        super("types.ResourceInNamespaceRequest", [
            { no: 1, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "Namespace", kind: "scalar", jsonName: "Namespace", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ResourceInNamespaceRequest>): ResourceInNamespaceRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.namespace = "";
        if (value !== undefined)
            reflectionMergePartial<ResourceInNamespaceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResourceInNamespaceRequest): ResourceInNamespaceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Name = 1 [json_name = "Name"];*/ 1:
                    message.name = reader.string();
                    break;
                case /* string Namespace = 2 [json_name = "Namespace"];*/ 2:
                    message.namespace = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResourceInNamespaceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Name = 1 [json_name = "Name"]; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string Namespace = 2 [json_name = "Namespace"]; */
        if (message.namespace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.namespace);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ResourceInNamespaceRequest
 */
export const ResourceInNamespaceRequest = new ResourceInNamespaceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResourcesInNamespaceRequest$Type extends MessageType<ResourcesInNamespaceRequest> {
    constructor() {
        super("types.ResourcesInNamespaceRequest", [
            { no: 1, name: "Namespace", kind: "scalar", jsonName: "Namespace", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ResourcesInNamespaceRequest>): ResourcesInNamespaceRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.namespace = "";
        if (value !== undefined)
            reflectionMergePartial<ResourcesInNamespaceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResourcesInNamespaceRequest): ResourcesInNamespaceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Namespace = 1 [json_name = "Namespace"];*/ 1:
                    message.namespace = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResourcesInNamespaceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Namespace = 1 [json_name = "Namespace"]; */
        if (message.namespace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.namespace);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ResourcesInNamespaceRequest
 */
export const ResourcesInNamespaceRequest = new ResourcesInNamespaceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OIDCConnectorV3$Type extends MessageType<OIDCConnectorV3> {
    constructor() {
        super("types.OIDCConnectorV3", [
            { no: 1, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 2, name: "SubKind", kind: "scalar", jsonName: "SubKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub_kind,omitempty" } },
            { no: 3, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version" } },
            { no: 4, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "metadata" } },
            { no: 5, name: "Spec", kind: "message", jsonName: "Spec", T: () => OIDCConnectorSpecV3, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ]);
    }
    create(value?: PartialMessage<OIDCConnectorV3>): OIDCConnectorV3 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.subKind = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<OIDCConnectorV3>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OIDCConnectorV3): OIDCConnectorV3 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Kind = 1 [json_name = "Kind"];*/ 1:
                    message.kind = reader.string();
                    break;
                case /* string SubKind = 2 [json_name = "SubKind"];*/ 2:
                    message.subKind = reader.string();
                    break;
                case /* string Version = 3 [json_name = "Version"];*/ 3:
                    message.version = reader.string();
                    break;
                case /* types.Metadata Metadata = 4 [json_name = "Metadata"];*/ 4:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* types.OIDCConnectorSpecV3 Spec = 5 [json_name = "Spec"];*/ 5:
                    message.spec = OIDCConnectorSpecV3.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OIDCConnectorV3, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Kind = 1 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string SubKind = 2 [json_name = "SubKind"]; */
        if (message.subKind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subKind);
        /* string Version = 3 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* types.Metadata Metadata = 4 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.OIDCConnectorSpecV3 Spec = 5 [json_name = "Spec"]; */
        if (message.spec)
            OIDCConnectorSpecV3.internalBinaryWrite(message.spec, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.OIDCConnectorV3
 */
export const OIDCConnectorV3 = new OIDCConnectorV3$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OIDCConnectorV3List$Type extends MessageType<OIDCConnectorV3List> {
    constructor() {
        super("types.OIDCConnectorV3List", [
            { no: 1, name: "OIDCConnectors", kind: "message", jsonName: "OIDCConnectors", repeat: 1 /*RepeatType.PACKED*/, T: () => OIDCConnectorV3 }
        ]);
    }
    create(value?: PartialMessage<OIDCConnectorV3List>): OIDCConnectorV3List {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.oIDCConnectors = [];
        if (value !== undefined)
            reflectionMergePartial<OIDCConnectorV3List>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OIDCConnectorV3List): OIDCConnectorV3List {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.OIDCConnectorV3 OIDCConnectors = 1 [json_name = "OIDCConnectors"];*/ 1:
                    message.oIDCConnectors.push(OIDCConnectorV3.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OIDCConnectorV3List, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.OIDCConnectorV3 OIDCConnectors = 1 [json_name = "OIDCConnectors"]; */
        for (let i = 0; i < message.oIDCConnectors.length; i++)
            OIDCConnectorV3.internalBinaryWrite(message.oIDCConnectors[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.OIDCConnectorV3List
 */
export const OIDCConnectorV3List = new OIDCConnectorV3List$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OIDCConnectorSpecV3$Type extends MessageType<OIDCConnectorSpecV3> {
    constructor() {
        super("types.OIDCConnectorSpecV3", [
            { no: 1, name: "IssuerURL", kind: "scalar", jsonName: "IssuerURL", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "issuer_url" } },
            { no: 2, name: "ClientID", kind: "scalar", jsonName: "ClientID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "client_id" } },
            { no: 3, name: "ClientSecret", kind: "scalar", jsonName: "ClientSecret", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "client_secret" } },
            { no: 5, name: "ACR", kind: "scalar", jsonName: "ACR", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "acr_values,omitempty" } },
            { no: 6, name: "Provider", kind: "scalar", jsonName: "Provider", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "provider,omitempty" } },
            { no: 7, name: "Display", kind: "scalar", jsonName: "Display", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "display,omitempty" } },
            { no: 8, name: "Scope", kind: "scalar", jsonName: "Scope", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "scope,omitempty" } },
            { no: 9, name: "Prompt", kind: "scalar", jsonName: "Prompt", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "prompt,omitempty" } },
            { no: 10, name: "ClaimsToRoles", kind: "message", jsonName: "ClaimsToRoles", repeat: 1 /*RepeatType.PACKED*/, T: () => ClaimMapping, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "claims_to_roles,omitempty" } },
            { no: 11, name: "GoogleServiceAccountURI", kind: "scalar", jsonName: "GoogleServiceAccountURI", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "google_service_account_uri,omitempty" } },
            { no: 12, name: "GoogleServiceAccount", kind: "scalar", jsonName: "GoogleServiceAccount", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "google_service_account,omitempty" } },
            { no: 13, name: "GoogleAdminEmail", kind: "scalar", jsonName: "GoogleAdminEmail", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "google_admin_email,omitempty" } },
            { no: 14, name: "RedirectURLs", kind: "message", jsonName: "RedirectURLs", T: () => StringValues, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/gravitational/teleport/api/types/wrappers.Strings", "gogoproto.jsontag": "redirect_url" } },
            { no: 15, name: "AllowUnverifiedEmail", kind: "scalar", jsonName: "AllowUnverifiedEmail", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "allow_unverified_email,omitempty" } },
            { no: 16, name: "UsernameClaim", kind: "scalar", jsonName: "UsernameClaim", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "username_claim,omitempty" } },
            { no: 17, name: "MaxAge", kind: "message", jsonName: "MaxAge", T: () => MaxAge, options: { "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 18, name: "ClientRedirectSettings", kind: "message", jsonName: "ClientRedirectSettings", T: () => SSOClientRedirectSettings, options: { "gogoproto.jsontag": "client_redirect_settings,omitempty" } },
            { no: 19, name: "MFASettings", kind: "message", jsonName: "MFASettings", T: () => OIDCConnectorMFASettings, options: { "gogoproto.jsontag": "mfa,omitempty" } },
            { no: 20, name: "PKCEMode", kind: "scalar", jsonName: "PKCEMode", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "pkce_mode,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<OIDCConnectorSpecV3>): OIDCConnectorSpecV3 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.issuerURL = "";
        message.clientID = "";
        message.clientSecret = "";
        message.aCR = "";
        message.provider = "";
        message.display = "";
        message.scope = [];
        message.prompt = "";
        message.claimsToRoles = [];
        message.googleServiceAccountURI = "";
        message.googleServiceAccount = "";
        message.googleAdminEmail = "";
        message.allowUnverifiedEmail = false;
        message.usernameClaim = "";
        message.pKCEMode = "";
        if (value !== undefined)
            reflectionMergePartial<OIDCConnectorSpecV3>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OIDCConnectorSpecV3): OIDCConnectorSpecV3 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string IssuerURL = 1 [json_name = "IssuerURL"];*/ 1:
                    message.issuerURL = reader.string();
                    break;
                case /* string ClientID = 2 [json_name = "ClientID"];*/ 2:
                    message.clientID = reader.string();
                    break;
                case /* string ClientSecret = 3 [json_name = "ClientSecret"];*/ 3:
                    message.clientSecret = reader.string();
                    break;
                case /* string ACR = 5 [json_name = "ACR"];*/ 5:
                    message.aCR = reader.string();
                    break;
                case /* string Provider = 6 [json_name = "Provider"];*/ 6:
                    message.provider = reader.string();
                    break;
                case /* string Display = 7 [json_name = "Display"];*/ 7:
                    message.display = reader.string();
                    break;
                case /* repeated string Scope = 8 [json_name = "Scope"];*/ 8:
                    message.scope.push(reader.string());
                    break;
                case /* string Prompt = 9 [json_name = "Prompt"];*/ 9:
                    message.prompt = reader.string();
                    break;
                case /* repeated types.ClaimMapping ClaimsToRoles = 10 [json_name = "ClaimsToRoles"];*/ 10:
                    message.claimsToRoles.push(ClaimMapping.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string GoogleServiceAccountURI = 11 [json_name = "GoogleServiceAccountURI"];*/ 11:
                    message.googleServiceAccountURI = reader.string();
                    break;
                case /* string GoogleServiceAccount = 12 [json_name = "GoogleServiceAccount"];*/ 12:
                    message.googleServiceAccount = reader.string();
                    break;
                case /* string GoogleAdminEmail = 13 [json_name = "GoogleAdminEmail"];*/ 13:
                    message.googleAdminEmail = reader.string();
                    break;
                case /* wrappers.StringValues RedirectURLs = 14 [json_name = "RedirectURLs"];*/ 14:
                    message.redirectURLs = StringValues.internalBinaryRead(reader, reader.uint32(), options, message.redirectURLs);
                    break;
                case /* bool AllowUnverifiedEmail = 15 [json_name = "AllowUnverifiedEmail"];*/ 15:
                    message.allowUnverifiedEmail = reader.bool();
                    break;
                case /* string UsernameClaim = 16 [json_name = "UsernameClaim"];*/ 16:
                    message.usernameClaim = reader.string();
                    break;
                case /* types.MaxAge MaxAge = 17 [json_name = "MaxAge"];*/ 17:
                    message.maxAge = MaxAge.internalBinaryRead(reader, reader.uint32(), options, message.maxAge);
                    break;
                case /* types.SSOClientRedirectSettings ClientRedirectSettings = 18 [json_name = "ClientRedirectSettings"];*/ 18:
                    message.clientRedirectSettings = SSOClientRedirectSettings.internalBinaryRead(reader, reader.uint32(), options, message.clientRedirectSettings);
                    break;
                case /* types.OIDCConnectorMFASettings MFASettings = 19 [json_name = "MFASettings"];*/ 19:
                    message.mFASettings = OIDCConnectorMFASettings.internalBinaryRead(reader, reader.uint32(), options, message.mFASettings);
                    break;
                case /* string PKCEMode = 20 [json_name = "PKCEMode"];*/ 20:
                    message.pKCEMode = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OIDCConnectorSpecV3, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string IssuerURL = 1 [json_name = "IssuerURL"]; */
        if (message.issuerURL !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.issuerURL);
        /* string ClientID = 2 [json_name = "ClientID"]; */
        if (message.clientID !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.clientID);
        /* string ClientSecret = 3 [json_name = "ClientSecret"]; */
        if (message.clientSecret !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.clientSecret);
        /* string ACR = 5 [json_name = "ACR"]; */
        if (message.aCR !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.aCR);
        /* string Provider = 6 [json_name = "Provider"]; */
        if (message.provider !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.provider);
        /* string Display = 7 [json_name = "Display"]; */
        if (message.display !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.display);
        /* repeated string Scope = 8 [json_name = "Scope"]; */
        for (let i = 0; i < message.scope.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.scope[i]);
        /* string Prompt = 9 [json_name = "Prompt"]; */
        if (message.prompt !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.prompt);
        /* repeated types.ClaimMapping ClaimsToRoles = 10 [json_name = "ClaimsToRoles"]; */
        for (let i = 0; i < message.claimsToRoles.length; i++)
            ClaimMapping.internalBinaryWrite(message.claimsToRoles[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* string GoogleServiceAccountURI = 11 [json_name = "GoogleServiceAccountURI"]; */
        if (message.googleServiceAccountURI !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.googleServiceAccountURI);
        /* string GoogleServiceAccount = 12 [json_name = "GoogleServiceAccount"]; */
        if (message.googleServiceAccount !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.googleServiceAccount);
        /* string GoogleAdminEmail = 13 [json_name = "GoogleAdminEmail"]; */
        if (message.googleAdminEmail !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.googleAdminEmail);
        /* wrappers.StringValues RedirectURLs = 14 [json_name = "RedirectURLs"]; */
        if (message.redirectURLs)
            StringValues.internalBinaryWrite(message.redirectURLs, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* bool AllowUnverifiedEmail = 15 [json_name = "AllowUnverifiedEmail"]; */
        if (message.allowUnverifiedEmail !== false)
            writer.tag(15, WireType.Varint).bool(message.allowUnverifiedEmail);
        /* string UsernameClaim = 16 [json_name = "UsernameClaim"]; */
        if (message.usernameClaim !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.usernameClaim);
        /* types.MaxAge MaxAge = 17 [json_name = "MaxAge"]; */
        if (message.maxAge)
            MaxAge.internalBinaryWrite(message.maxAge, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* types.SSOClientRedirectSettings ClientRedirectSettings = 18 [json_name = "ClientRedirectSettings"]; */
        if (message.clientRedirectSettings)
            SSOClientRedirectSettings.internalBinaryWrite(message.clientRedirectSettings, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* types.OIDCConnectorMFASettings MFASettings = 19 [json_name = "MFASettings"]; */
        if (message.mFASettings)
            OIDCConnectorMFASettings.internalBinaryWrite(message.mFASettings, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* string PKCEMode = 20 [json_name = "PKCEMode"]; */
        if (message.pKCEMode !== "")
            writer.tag(20, WireType.LengthDelimited).string(message.pKCEMode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.OIDCConnectorSpecV3
 */
export const OIDCConnectorSpecV3 = new OIDCConnectorSpecV3$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MaxAge$Type extends MessageType<MaxAge> {
    constructor() {
        super("types.MaxAge", [
            { no: 1, name: "Value", kind: "scalar", jsonName: "Value", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "max_age", "gogoproto.casttype": "Duration" } }
        ]);
    }
    create(value?: PartialMessage<MaxAge>): MaxAge {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = 0n;
        if (value !== undefined)
            reflectionMergePartial<MaxAge>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MaxAge): MaxAge {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 Value = 1 [json_name = "Value"];*/ 1:
                    message.value = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MaxAge, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 Value = 1 [json_name = "Value"]; */
        if (message.value !== 0n)
            writer.tag(1, WireType.Varint).int64(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.MaxAge
 */
export const MaxAge = new MaxAge$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SSOClientRedirectSettings$Type extends MessageType<SSOClientRedirectSettings> {
    constructor() {
        super("types.SSOClientRedirectSettings", [
            { no: 1, name: "allowed_https_hostnames", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "insecure_allowed_cidr_ranges", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SSOClientRedirectSettings>): SSOClientRedirectSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.allowedHttpsHostnames = [];
        message.insecureAllowedCidrRanges = [];
        if (value !== undefined)
            reflectionMergePartial<SSOClientRedirectSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SSOClientRedirectSettings): SSOClientRedirectSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string allowed_https_hostnames */ 1:
                    message.allowedHttpsHostnames.push(reader.string());
                    break;
                case /* repeated string insecure_allowed_cidr_ranges */ 2:
                    message.insecureAllowedCidrRanges.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SSOClientRedirectSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string allowed_https_hostnames = 1; */
        for (let i = 0; i < message.allowedHttpsHostnames.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.allowedHttpsHostnames[i]);
        /* repeated string insecure_allowed_cidr_ranges = 2; */
        for (let i = 0; i < message.insecureAllowedCidrRanges.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.insecureAllowedCidrRanges[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.SSOClientRedirectSettings
 */
export const SSOClientRedirectSettings = new SSOClientRedirectSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OIDCConnectorMFASettings$Type extends MessageType<OIDCConnectorMFASettings> {
    constructor() {
        super("types.OIDCConnectorMFASettings", [
            { no: 1, name: "enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "client_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "client_secret", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "acr_values", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "prompt", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "max_age", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.casttype": "Duration" } }
        ]);
    }
    create(value?: PartialMessage<OIDCConnectorMFASettings>): OIDCConnectorMFASettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.enabled = false;
        message.clientId = "";
        message.clientSecret = "";
        message.acrValues = "";
        message.prompt = "";
        message.maxAge = 0n;
        if (value !== undefined)
            reflectionMergePartial<OIDCConnectorMFASettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OIDCConnectorMFASettings): OIDCConnectorMFASettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool enabled */ 1:
                    message.enabled = reader.bool();
                    break;
                case /* string client_id */ 2:
                    message.clientId = reader.string();
                    break;
                case /* string client_secret */ 3:
                    message.clientSecret = reader.string();
                    break;
                case /* string acr_values */ 4:
                    message.acrValues = reader.string();
                    break;
                case /* string prompt */ 5:
                    message.prompt = reader.string();
                    break;
                case /* int64 max_age */ 6:
                    message.maxAge = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OIDCConnectorMFASettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool enabled = 1; */
        if (message.enabled !== false)
            writer.tag(1, WireType.Varint).bool(message.enabled);
        /* string client_id = 2; */
        if (message.clientId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.clientId);
        /* string client_secret = 3; */
        if (message.clientSecret !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.clientSecret);
        /* string acr_values = 4; */
        if (message.acrValues !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.acrValues);
        /* string prompt = 5; */
        if (message.prompt !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.prompt);
        /* int64 max_age = 6; */
        if (message.maxAge !== 0n)
            writer.tag(6, WireType.Varint).int64(message.maxAge);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.OIDCConnectorMFASettings
 */
export const OIDCConnectorMFASettings = new OIDCConnectorMFASettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OIDCAuthRequest$Type extends MessageType<OIDCAuthRequest> {
    constructor() {
        super("types.OIDCAuthRequest", [
            { no: 1, name: "ConnectorID", kind: "scalar", jsonName: "ConnectorID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "connector_id" } },
            { no: 2, name: "Type", kind: "scalar", jsonName: "Type", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "type" } },
            { no: 3, name: "CheckUser", kind: "scalar", jsonName: "CheckUser", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "check_user" } },
            { no: 4, name: "StateToken", kind: "scalar", jsonName: "StateToken", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "state_token" } },
            { no: 5, name: "CSRFToken", kind: "scalar", jsonName: "CSRFToken", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "csrf_token" } },
            { no: 6, name: "RedirectURL", kind: "scalar", jsonName: "RedirectURL", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "redirect_url" } },
            { no: 7, name: "PublicKey", kind: "scalar", jsonName: "PublicKey", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.jsontag": "public_key" } },
            { no: 8, name: "CertTTL", kind: "scalar", jsonName: "CertTTL", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "cert_ttl", "gogoproto.casttype": "time.Duration" } },
            { no: 9, name: "CreateWebSession", kind: "scalar", jsonName: "CreateWebSession", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "create_web_session" } },
            { no: 10, name: "ClientRedirectURL", kind: "scalar", jsonName: "ClientRedirectURL", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "client_redirect_url" } },
            { no: 11, name: "Compatibility", kind: "scalar", jsonName: "Compatibility", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "compatibility,omitempty" } },
            { no: 12, name: "RouteToCluster", kind: "scalar", jsonName: "RouteToCluster", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "route_to_cluster,omitempty" } },
            { no: 13, name: "KubernetesCluster", kind: "scalar", jsonName: "KubernetesCluster", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kubernetes_cluster,omitempty" } },
            { no: 14, name: "SSOTestFlow", kind: "scalar", jsonName: "SSOTestFlow", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "sso_test_flow" } },
            { no: 15, name: "ConnectorSpec", kind: "message", jsonName: "ConnectorSpec", T: () => OIDCConnectorSpecV3, options: { "gogoproto.jsontag": "connector_spec,omitempty" } },
            { no: 16, name: "ProxyAddress", kind: "scalar", jsonName: "ProxyAddress", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "proxy_address,omitempty" } },
            { no: 17, name: "attestation_statement", kind: "message", T: () => AttestationStatement, options: { "gogoproto.jsontag": "attestation_statement,omitempty" } },
            { no: 18, name: "ClientLoginIP", kind: "scalar", jsonName: "ClientLoginIP", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "client_login_ip,omitempty" } },
            { no: 19, name: "ClientUserAgent", kind: "scalar", jsonName: "ClientUserAgent", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "client_user_agent,omitempty" } },
            { no: 20, name: "ssh_public_key", kind: "scalar", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.jsontag": "ssh_pub_key,omitempty" } },
            { no: 21, name: "tls_public_key", kind: "scalar", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.jsontag": "tls_pub_key,omitempty" } },
            { no: 22, name: "ssh_attestation_statement", kind: "message", T: () => AttestationStatement, options: { "gogoproto.jsontag": "ssh_attestation_statement,omitempty" } },
            { no: 23, name: "tls_attestation_statement", kind: "message", T: () => AttestationStatement, options: { "gogoproto.jsontag": "tls_attestation_statement,omitempty" } },
            { no: 24, name: "pkce_verifier", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "pkce_verifier" } }
        ]);
    }
    create(value?: PartialMessage<OIDCAuthRequest>): OIDCAuthRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.connectorID = "";
        message.type = "";
        message.checkUser = false;
        message.stateToken = "";
        message.cSRFToken = "";
        message.redirectURL = "";
        message.publicKey = new Uint8Array(0);
        message.certTTL = 0n;
        message.createWebSession = false;
        message.clientRedirectURL = "";
        message.compatibility = "";
        message.routeToCluster = "";
        message.kubernetesCluster = "";
        message.sSOTestFlow = false;
        message.proxyAddress = "";
        message.clientLoginIP = "";
        message.clientUserAgent = "";
        message.sshPublicKey = new Uint8Array(0);
        message.tlsPublicKey = new Uint8Array(0);
        message.pkceVerifier = "";
        if (value !== undefined)
            reflectionMergePartial<OIDCAuthRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OIDCAuthRequest): OIDCAuthRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ConnectorID = 1 [json_name = "ConnectorID"];*/ 1:
                    message.connectorID = reader.string();
                    break;
                case /* string Type = 2 [json_name = "Type"];*/ 2:
                    message.type = reader.string();
                    break;
                case /* bool CheckUser = 3 [json_name = "CheckUser"];*/ 3:
                    message.checkUser = reader.bool();
                    break;
                case /* string StateToken = 4 [json_name = "StateToken"];*/ 4:
                    message.stateToken = reader.string();
                    break;
                case /* string CSRFToken = 5 [json_name = "CSRFToken"];*/ 5:
                    message.cSRFToken = reader.string();
                    break;
                case /* string RedirectURL = 6 [json_name = "RedirectURL"];*/ 6:
                    message.redirectURL = reader.string();
                    break;
                case /* bytes PublicKey = 7 [deprecated = true, json_name = "PublicKey"];*/ 7:
                    message.publicKey = reader.bytes();
                    break;
                case /* int64 CertTTL = 8 [json_name = "CertTTL"];*/ 8:
                    message.certTTL = reader.int64().toBigInt();
                    break;
                case /* bool CreateWebSession = 9 [json_name = "CreateWebSession"];*/ 9:
                    message.createWebSession = reader.bool();
                    break;
                case /* string ClientRedirectURL = 10 [json_name = "ClientRedirectURL"];*/ 10:
                    message.clientRedirectURL = reader.string();
                    break;
                case /* string Compatibility = 11 [json_name = "Compatibility"];*/ 11:
                    message.compatibility = reader.string();
                    break;
                case /* string RouteToCluster = 12 [json_name = "RouteToCluster"];*/ 12:
                    message.routeToCluster = reader.string();
                    break;
                case /* string KubernetesCluster = 13 [json_name = "KubernetesCluster"];*/ 13:
                    message.kubernetesCluster = reader.string();
                    break;
                case /* bool SSOTestFlow = 14 [json_name = "SSOTestFlow"];*/ 14:
                    message.sSOTestFlow = reader.bool();
                    break;
                case /* types.OIDCConnectorSpecV3 ConnectorSpec = 15 [json_name = "ConnectorSpec"];*/ 15:
                    message.connectorSpec = OIDCConnectorSpecV3.internalBinaryRead(reader, reader.uint32(), options, message.connectorSpec);
                    break;
                case /* string ProxyAddress = 16 [json_name = "ProxyAddress"];*/ 16:
                    message.proxyAddress = reader.string();
                    break;
                case /* teleport.attestation.v1.AttestationStatement attestation_statement = 17 [deprecated = true];*/ 17:
                    message.attestationStatement = AttestationStatement.internalBinaryRead(reader, reader.uint32(), options, message.attestationStatement);
                    break;
                case /* string ClientLoginIP = 18 [json_name = "ClientLoginIP"];*/ 18:
                    message.clientLoginIP = reader.string();
                    break;
                case /* string ClientUserAgent = 19 [json_name = "ClientUserAgent"];*/ 19:
                    message.clientUserAgent = reader.string();
                    break;
                case /* bytes ssh_public_key */ 20:
                    message.sshPublicKey = reader.bytes();
                    break;
                case /* bytes tls_public_key */ 21:
                    message.tlsPublicKey = reader.bytes();
                    break;
                case /* teleport.attestation.v1.AttestationStatement ssh_attestation_statement */ 22:
                    message.sshAttestationStatement = AttestationStatement.internalBinaryRead(reader, reader.uint32(), options, message.sshAttestationStatement);
                    break;
                case /* teleport.attestation.v1.AttestationStatement tls_attestation_statement */ 23:
                    message.tlsAttestationStatement = AttestationStatement.internalBinaryRead(reader, reader.uint32(), options, message.tlsAttestationStatement);
                    break;
                case /* string pkce_verifier */ 24:
                    message.pkceVerifier = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OIDCAuthRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ConnectorID = 1 [json_name = "ConnectorID"]; */
        if (message.connectorID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.connectorID);
        /* string Type = 2 [json_name = "Type"]; */
        if (message.type !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.type);
        /* bool CheckUser = 3 [json_name = "CheckUser"]; */
        if (message.checkUser !== false)
            writer.tag(3, WireType.Varint).bool(message.checkUser);
        /* string StateToken = 4 [json_name = "StateToken"]; */
        if (message.stateToken !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.stateToken);
        /* string CSRFToken = 5 [json_name = "CSRFToken"]; */
        if (message.cSRFToken !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.cSRFToken);
        /* string RedirectURL = 6 [json_name = "RedirectURL"]; */
        if (message.redirectURL !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.redirectURL);
        /* bytes PublicKey = 7 [deprecated = true, json_name = "PublicKey"]; */
        if (message.publicKey.length)
            writer.tag(7, WireType.LengthDelimited).bytes(message.publicKey);
        /* int64 CertTTL = 8 [json_name = "CertTTL"]; */
        if (message.certTTL !== 0n)
            writer.tag(8, WireType.Varint).int64(message.certTTL);
        /* bool CreateWebSession = 9 [json_name = "CreateWebSession"]; */
        if (message.createWebSession !== false)
            writer.tag(9, WireType.Varint).bool(message.createWebSession);
        /* string ClientRedirectURL = 10 [json_name = "ClientRedirectURL"]; */
        if (message.clientRedirectURL !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.clientRedirectURL);
        /* string Compatibility = 11 [json_name = "Compatibility"]; */
        if (message.compatibility !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.compatibility);
        /* string RouteToCluster = 12 [json_name = "RouteToCluster"]; */
        if (message.routeToCluster !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.routeToCluster);
        /* string KubernetesCluster = 13 [json_name = "KubernetesCluster"]; */
        if (message.kubernetesCluster !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.kubernetesCluster);
        /* bool SSOTestFlow = 14 [json_name = "SSOTestFlow"]; */
        if (message.sSOTestFlow !== false)
            writer.tag(14, WireType.Varint).bool(message.sSOTestFlow);
        /* types.OIDCConnectorSpecV3 ConnectorSpec = 15 [json_name = "ConnectorSpec"]; */
        if (message.connectorSpec)
            OIDCConnectorSpecV3.internalBinaryWrite(message.connectorSpec, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* string ProxyAddress = 16 [json_name = "ProxyAddress"]; */
        if (message.proxyAddress !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.proxyAddress);
        /* teleport.attestation.v1.AttestationStatement attestation_statement = 17 [deprecated = true]; */
        if (message.attestationStatement)
            AttestationStatement.internalBinaryWrite(message.attestationStatement, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* string ClientLoginIP = 18 [json_name = "ClientLoginIP"]; */
        if (message.clientLoginIP !== "")
            writer.tag(18, WireType.LengthDelimited).string(message.clientLoginIP);
        /* string ClientUserAgent = 19 [json_name = "ClientUserAgent"]; */
        if (message.clientUserAgent !== "")
            writer.tag(19, WireType.LengthDelimited).string(message.clientUserAgent);
        /* bytes ssh_public_key = 20; */
        if (message.sshPublicKey.length)
            writer.tag(20, WireType.LengthDelimited).bytes(message.sshPublicKey);
        /* bytes tls_public_key = 21; */
        if (message.tlsPublicKey.length)
            writer.tag(21, WireType.LengthDelimited).bytes(message.tlsPublicKey);
        /* teleport.attestation.v1.AttestationStatement ssh_attestation_statement = 22; */
        if (message.sshAttestationStatement)
            AttestationStatement.internalBinaryWrite(message.sshAttestationStatement, writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        /* teleport.attestation.v1.AttestationStatement tls_attestation_statement = 23; */
        if (message.tlsAttestationStatement)
            AttestationStatement.internalBinaryWrite(message.tlsAttestationStatement, writer.tag(23, WireType.LengthDelimited).fork(), options).join();
        /* string pkce_verifier = 24; */
        if (message.pkceVerifier !== "")
            writer.tag(24, WireType.LengthDelimited).string(message.pkceVerifier);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.OIDCAuthRequest
 */
export const OIDCAuthRequest = new OIDCAuthRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SAMLConnectorV2$Type extends MessageType<SAMLConnectorV2> {
    constructor() {
        super("types.SAMLConnectorV2", [
            { no: 1, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 2, name: "SubKind", kind: "scalar", jsonName: "SubKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub_kind,omitempty" } },
            { no: 3, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version" } },
            { no: 4, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "metadata" } },
            { no: 5, name: "Spec", kind: "message", jsonName: "Spec", T: () => SAMLConnectorSpecV2, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ]);
    }
    create(value?: PartialMessage<SAMLConnectorV2>): SAMLConnectorV2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.subKind = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<SAMLConnectorV2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SAMLConnectorV2): SAMLConnectorV2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Kind = 1 [json_name = "Kind"];*/ 1:
                    message.kind = reader.string();
                    break;
                case /* string SubKind = 2 [json_name = "SubKind"];*/ 2:
                    message.subKind = reader.string();
                    break;
                case /* string Version = 3 [json_name = "Version"];*/ 3:
                    message.version = reader.string();
                    break;
                case /* types.Metadata Metadata = 4 [json_name = "Metadata"];*/ 4:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* types.SAMLConnectorSpecV2 Spec = 5 [json_name = "Spec"];*/ 5:
                    message.spec = SAMLConnectorSpecV2.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SAMLConnectorV2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Kind = 1 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string SubKind = 2 [json_name = "SubKind"]; */
        if (message.subKind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subKind);
        /* string Version = 3 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* types.Metadata Metadata = 4 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.SAMLConnectorSpecV2 Spec = 5 [json_name = "Spec"]; */
        if (message.spec)
            SAMLConnectorSpecV2.internalBinaryWrite(message.spec, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.SAMLConnectorV2
 */
export const SAMLConnectorV2 = new SAMLConnectorV2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SAMLConnectorV2List$Type extends MessageType<SAMLConnectorV2List> {
    constructor() {
        super("types.SAMLConnectorV2List", [
            { no: 1, name: "SAMLConnectors", kind: "message", jsonName: "SAMLConnectors", repeat: 1 /*RepeatType.PACKED*/, T: () => SAMLConnectorV2 }
        ]);
    }
    create(value?: PartialMessage<SAMLConnectorV2List>): SAMLConnectorV2List {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sAMLConnectors = [];
        if (value !== undefined)
            reflectionMergePartial<SAMLConnectorV2List>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SAMLConnectorV2List): SAMLConnectorV2List {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.SAMLConnectorV2 SAMLConnectors = 1 [json_name = "SAMLConnectors"];*/ 1:
                    message.sAMLConnectors.push(SAMLConnectorV2.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SAMLConnectorV2List, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.SAMLConnectorV2 SAMLConnectors = 1 [json_name = "SAMLConnectors"]; */
        for (let i = 0; i < message.sAMLConnectors.length; i++)
            SAMLConnectorV2.internalBinaryWrite(message.sAMLConnectors[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.SAMLConnectorV2List
 */
export const SAMLConnectorV2List = new SAMLConnectorV2List$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SAMLConnectorSpecV2$Type extends MessageType<SAMLConnectorSpecV2> {
    constructor() {
        super("types.SAMLConnectorSpecV2", [
            { no: 1, name: "Issuer", kind: "scalar", jsonName: "Issuer", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "issuer" } },
            { no: 2, name: "SSO", kind: "scalar", jsonName: "SSO", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sso" } },
            { no: 3, name: "Cert", kind: "scalar", jsonName: "Cert", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "cert" } },
            { no: 4, name: "Display", kind: "scalar", jsonName: "Display", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "display" } },
            { no: 5, name: "AssertionConsumerService", kind: "scalar", jsonName: "AssertionConsumerService", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "acs" } },
            { no: 6, name: "Audience", kind: "scalar", jsonName: "Audience", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "audience" } },
            { no: 7, name: "ServiceProviderIssuer", kind: "scalar", jsonName: "ServiceProviderIssuer", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "service_provider_issuer" } },
            { no: 8, name: "EntityDescriptor", kind: "scalar", jsonName: "EntityDescriptor", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "entity_descriptor" } },
            { no: 9, name: "EntityDescriptorURL", kind: "scalar", jsonName: "EntityDescriptorURL", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "entity_descriptor_url" } },
            { no: 10, name: "AttributesToRoles", kind: "message", jsonName: "AttributesToRoles", repeat: 1 /*RepeatType.PACKED*/, T: () => AttributeMapping, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "attributes_to_roles" } },
            { no: 11, name: "SigningKeyPair", kind: "message", jsonName: "SigningKeyPair", T: () => AsymmetricKeyPair, options: { "gogoproto.nullable": true, "gogoproto.jsontag": "signing_key_pair,omitempty" } },
            { no: 12, name: "Provider", kind: "scalar", jsonName: "Provider", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "provider,omitempty" } },
            { no: 13, name: "EncryptionKeyPair", kind: "message", jsonName: "EncryptionKeyPair", T: () => AsymmetricKeyPair, options: { "gogoproto.nullable": true, "gogoproto.jsontag": "assertion_key_pair,omitempty" } },
            { no: 14, name: "AllowIDPInitiated", kind: "scalar", jsonName: "AllowIDPInitiated", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.nullable": true, "gogoproto.jsontag": "allow_idp_initiated,omitempty" } },
            { no: 15, name: "ClientRedirectSettings", kind: "message", jsonName: "ClientRedirectSettings", T: () => SSOClientRedirectSettings, options: { "gogoproto.jsontag": "client_redirect_settings,omitempty" } },
            { no: 16, name: "SingleLogoutURL", kind: "scalar", jsonName: "SingleLogoutURL", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "single_logout_url,omitempty" } },
            { no: 17, name: "MFASettings", kind: "message", jsonName: "MFASettings", T: () => SAMLConnectorMFASettings, options: { "gogoproto.jsontag": "mfa,omitempty" } },
            { no: 18, name: "ForceAuthn", kind: "enum", jsonName: "ForceAuthn", T: () => ["types.SAMLForceAuthn", SAMLForceAuthn], options: { "gogoproto.jsontag": "force_authn,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<SAMLConnectorSpecV2>): SAMLConnectorSpecV2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.issuer = "";
        message.sSO = "";
        message.cert = "";
        message.display = "";
        message.assertionConsumerService = "";
        message.audience = "";
        message.serviceProviderIssuer = "";
        message.entityDescriptor = "";
        message.entityDescriptorURL = "";
        message.attributesToRoles = [];
        message.provider = "";
        message.allowIDPInitiated = false;
        message.singleLogoutURL = "";
        message.forceAuthn = 0;
        if (value !== undefined)
            reflectionMergePartial<SAMLConnectorSpecV2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SAMLConnectorSpecV2): SAMLConnectorSpecV2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Issuer = 1 [json_name = "Issuer"];*/ 1:
                    message.issuer = reader.string();
                    break;
                case /* string SSO = 2 [json_name = "SSO"];*/ 2:
                    message.sSO = reader.string();
                    break;
                case /* string Cert = 3 [json_name = "Cert"];*/ 3:
                    message.cert = reader.string();
                    break;
                case /* string Display = 4 [json_name = "Display"];*/ 4:
                    message.display = reader.string();
                    break;
                case /* string AssertionConsumerService = 5 [json_name = "AssertionConsumerService"];*/ 5:
                    message.assertionConsumerService = reader.string();
                    break;
                case /* string Audience = 6 [json_name = "Audience"];*/ 6:
                    message.audience = reader.string();
                    break;
                case /* string ServiceProviderIssuer = 7 [json_name = "ServiceProviderIssuer"];*/ 7:
                    message.serviceProviderIssuer = reader.string();
                    break;
                case /* string EntityDescriptor = 8 [json_name = "EntityDescriptor"];*/ 8:
                    message.entityDescriptor = reader.string();
                    break;
                case /* string EntityDescriptorURL = 9 [json_name = "EntityDescriptorURL"];*/ 9:
                    message.entityDescriptorURL = reader.string();
                    break;
                case /* repeated types.AttributeMapping AttributesToRoles = 10 [json_name = "AttributesToRoles"];*/ 10:
                    message.attributesToRoles.push(AttributeMapping.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* types.AsymmetricKeyPair SigningKeyPair = 11 [json_name = "SigningKeyPair"];*/ 11:
                    message.signingKeyPair = AsymmetricKeyPair.internalBinaryRead(reader, reader.uint32(), options, message.signingKeyPair);
                    break;
                case /* string Provider = 12 [json_name = "Provider"];*/ 12:
                    message.provider = reader.string();
                    break;
                case /* types.AsymmetricKeyPair EncryptionKeyPair = 13 [json_name = "EncryptionKeyPair"];*/ 13:
                    message.encryptionKeyPair = AsymmetricKeyPair.internalBinaryRead(reader, reader.uint32(), options, message.encryptionKeyPair);
                    break;
                case /* bool AllowIDPInitiated = 14 [json_name = "AllowIDPInitiated"];*/ 14:
                    message.allowIDPInitiated = reader.bool();
                    break;
                case /* types.SSOClientRedirectSettings ClientRedirectSettings = 15 [json_name = "ClientRedirectSettings"];*/ 15:
                    message.clientRedirectSettings = SSOClientRedirectSettings.internalBinaryRead(reader, reader.uint32(), options, message.clientRedirectSettings);
                    break;
                case /* string SingleLogoutURL = 16 [json_name = "SingleLogoutURL"];*/ 16:
                    message.singleLogoutURL = reader.string();
                    break;
                case /* types.SAMLConnectorMFASettings MFASettings = 17 [json_name = "MFASettings"];*/ 17:
                    message.mFASettings = SAMLConnectorMFASettings.internalBinaryRead(reader, reader.uint32(), options, message.mFASettings);
                    break;
                case /* types.SAMLForceAuthn ForceAuthn = 18 [json_name = "ForceAuthn"];*/ 18:
                    message.forceAuthn = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SAMLConnectorSpecV2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Issuer = 1 [json_name = "Issuer"]; */
        if (message.issuer !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.issuer);
        /* string SSO = 2 [json_name = "SSO"]; */
        if (message.sSO !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sSO);
        /* string Cert = 3 [json_name = "Cert"]; */
        if (message.cert !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.cert);
        /* string Display = 4 [json_name = "Display"]; */
        if (message.display !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.display);
        /* string AssertionConsumerService = 5 [json_name = "AssertionConsumerService"]; */
        if (message.assertionConsumerService !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.assertionConsumerService);
        /* string Audience = 6 [json_name = "Audience"]; */
        if (message.audience !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.audience);
        /* string ServiceProviderIssuer = 7 [json_name = "ServiceProviderIssuer"]; */
        if (message.serviceProviderIssuer !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.serviceProviderIssuer);
        /* string EntityDescriptor = 8 [json_name = "EntityDescriptor"]; */
        if (message.entityDescriptor !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.entityDescriptor);
        /* string EntityDescriptorURL = 9 [json_name = "EntityDescriptorURL"]; */
        if (message.entityDescriptorURL !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.entityDescriptorURL);
        /* repeated types.AttributeMapping AttributesToRoles = 10 [json_name = "AttributesToRoles"]; */
        for (let i = 0; i < message.attributesToRoles.length; i++)
            AttributeMapping.internalBinaryWrite(message.attributesToRoles[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* types.AsymmetricKeyPair SigningKeyPair = 11 [json_name = "SigningKeyPair"]; */
        if (message.signingKeyPair)
            AsymmetricKeyPair.internalBinaryWrite(message.signingKeyPair, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* string Provider = 12 [json_name = "Provider"]; */
        if (message.provider !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.provider);
        /* types.AsymmetricKeyPair EncryptionKeyPair = 13 [json_name = "EncryptionKeyPair"]; */
        if (message.encryptionKeyPair)
            AsymmetricKeyPair.internalBinaryWrite(message.encryptionKeyPair, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* bool AllowIDPInitiated = 14 [json_name = "AllowIDPInitiated"]; */
        if (message.allowIDPInitiated !== false)
            writer.tag(14, WireType.Varint).bool(message.allowIDPInitiated);
        /* types.SSOClientRedirectSettings ClientRedirectSettings = 15 [json_name = "ClientRedirectSettings"]; */
        if (message.clientRedirectSettings)
            SSOClientRedirectSettings.internalBinaryWrite(message.clientRedirectSettings, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* string SingleLogoutURL = 16 [json_name = "SingleLogoutURL"]; */
        if (message.singleLogoutURL !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.singleLogoutURL);
        /* types.SAMLConnectorMFASettings MFASettings = 17 [json_name = "MFASettings"]; */
        if (message.mFASettings)
            SAMLConnectorMFASettings.internalBinaryWrite(message.mFASettings, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* types.SAMLForceAuthn ForceAuthn = 18 [json_name = "ForceAuthn"]; */
        if (message.forceAuthn !== 0)
            writer.tag(18, WireType.Varint).int32(message.forceAuthn);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.SAMLConnectorSpecV2
 */
export const SAMLConnectorSpecV2 = new SAMLConnectorSpecV2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SAMLConnectorMFASettings$Type extends MessageType<SAMLConnectorMFASettings> {
    constructor() {
        super("types.SAMLConnectorMFASettings", [
            { no: 1, name: "enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "entity_descriptor", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "entity_descriptor_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "force_authn", kind: "enum", T: () => ["types.SAMLForceAuthn", SAMLForceAuthn] },
            { no: 5, name: "issuer", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "sso", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "cert", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SAMLConnectorMFASettings>): SAMLConnectorMFASettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.enabled = false;
        message.entityDescriptor = "";
        message.entityDescriptorUrl = "";
        message.forceAuthn = 0;
        message.issuer = "";
        message.sso = "";
        message.cert = "";
        if (value !== undefined)
            reflectionMergePartial<SAMLConnectorMFASettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SAMLConnectorMFASettings): SAMLConnectorMFASettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool enabled */ 1:
                    message.enabled = reader.bool();
                    break;
                case /* string entity_descriptor */ 2:
                    message.entityDescriptor = reader.string();
                    break;
                case /* string entity_descriptor_url */ 3:
                    message.entityDescriptorUrl = reader.string();
                    break;
                case /* types.SAMLForceAuthn force_authn */ 4:
                    message.forceAuthn = reader.int32();
                    break;
                case /* string issuer */ 5:
                    message.issuer = reader.string();
                    break;
                case /* string sso */ 6:
                    message.sso = reader.string();
                    break;
                case /* string cert */ 7:
                    message.cert = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SAMLConnectorMFASettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool enabled = 1; */
        if (message.enabled !== false)
            writer.tag(1, WireType.Varint).bool(message.enabled);
        /* string entity_descriptor = 2; */
        if (message.entityDescriptor !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.entityDescriptor);
        /* string entity_descriptor_url = 3; */
        if (message.entityDescriptorUrl !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.entityDescriptorUrl);
        /* types.SAMLForceAuthn force_authn = 4; */
        if (message.forceAuthn !== 0)
            writer.tag(4, WireType.Varint).int32(message.forceAuthn);
        /* string issuer = 5; */
        if (message.issuer !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.issuer);
        /* string sso = 6; */
        if (message.sso !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.sso);
        /* string cert = 7; */
        if (message.cert !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.cert);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.SAMLConnectorMFASettings
 */
export const SAMLConnectorMFASettings = new SAMLConnectorMFASettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SAMLAuthRequest$Type extends MessageType<SAMLAuthRequest> {
    constructor() {
        super("types.SAMLAuthRequest", [
            { no: 1, name: "ID", kind: "scalar", jsonName: "ID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "id" } },
            { no: 2, name: "ConnectorID", kind: "scalar", jsonName: "ConnectorID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "connector_id" } },
            { no: 3, name: "Type", kind: "scalar", jsonName: "Type", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "type" } },
            { no: 4, name: "CheckUser", kind: "scalar", jsonName: "CheckUser", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "check_user" } },
            { no: 5, name: "RedirectURL", kind: "scalar", jsonName: "RedirectURL", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "redirect_url" } },
            { no: 6, name: "PublicKey", kind: "scalar", jsonName: "PublicKey", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.jsontag": "public_key" } },
            { no: 7, name: "CertTTL", kind: "scalar", jsonName: "CertTTL", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "cert_ttl", "gogoproto.casttype": "time.Duration" } },
            { no: 8, name: "CSRFToken", kind: "scalar", jsonName: "CSRFToken", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "csrf_token" } },
            { no: 9, name: "CreateWebSession", kind: "scalar", jsonName: "CreateWebSession", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "create_web_session" } },
            { no: 10, name: "ClientRedirectURL", kind: "scalar", jsonName: "ClientRedirectURL", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "client_redirect_url" } },
            { no: 11, name: "Compatibility", kind: "scalar", jsonName: "Compatibility", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "compatibility,omitempty" } },
            { no: 12, name: "RouteToCluster", kind: "scalar", jsonName: "RouteToCluster", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "route_to_cluster,omitempty" } },
            { no: 13, name: "KubernetesCluster", kind: "scalar", jsonName: "KubernetesCluster", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kubernetes_cluster,omitempty" } },
            { no: 14, name: "SSOTestFlow", kind: "scalar", jsonName: "SSOTestFlow", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "sso_test_flow" } },
            { no: 15, name: "ConnectorSpec", kind: "message", jsonName: "ConnectorSpec", T: () => SAMLConnectorSpecV2, options: { "gogoproto.jsontag": "connector_spec,omitempty" } },
            { no: 16, name: "attestation_statement", kind: "message", T: () => AttestationStatement, options: { "gogoproto.jsontag": "attestation_statement,omitempty" } },
            { no: 17, name: "ClientLoginIP", kind: "scalar", jsonName: "ClientLoginIP", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "client_login_ip,omitempty" } },
            { no: 18, name: "ClientUserAgent", kind: "scalar", jsonName: "ClientUserAgent", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "client_user_agent,omitempty" } },
            { no: 19, name: "ssh_public_key", kind: "scalar", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.jsontag": "ssh_pub_key,omitempty" } },
            { no: 20, name: "tls_public_key", kind: "scalar", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.jsontag": "tls_pub_key,omitempty" } },
            { no: 21, name: "ssh_attestation_statement", kind: "message", T: () => AttestationStatement, options: { "gogoproto.jsontag": "ssh_attestation_statement,omitempty" } },
            { no: 22, name: "tls_attestation_statement", kind: "message", T: () => AttestationStatement, options: { "gogoproto.jsontag": "tls_attestation_statement,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<SAMLAuthRequest>): SAMLAuthRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.iD = "";
        message.connectorID = "";
        message.type = "";
        message.checkUser = false;
        message.redirectURL = "";
        message.publicKey = new Uint8Array(0);
        message.certTTL = 0n;
        message.cSRFToken = "";
        message.createWebSession = false;
        message.clientRedirectURL = "";
        message.compatibility = "";
        message.routeToCluster = "";
        message.kubernetesCluster = "";
        message.sSOTestFlow = false;
        message.clientLoginIP = "";
        message.clientUserAgent = "";
        message.sshPublicKey = new Uint8Array(0);
        message.tlsPublicKey = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<SAMLAuthRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SAMLAuthRequest): SAMLAuthRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ID = 1 [json_name = "ID"];*/ 1:
                    message.iD = reader.string();
                    break;
                case /* string ConnectorID = 2 [json_name = "ConnectorID"];*/ 2:
                    message.connectorID = reader.string();
                    break;
                case /* string Type = 3 [json_name = "Type"];*/ 3:
                    message.type = reader.string();
                    break;
                case /* bool CheckUser = 4 [json_name = "CheckUser"];*/ 4:
                    message.checkUser = reader.bool();
                    break;
                case /* string RedirectURL = 5 [json_name = "RedirectURL"];*/ 5:
                    message.redirectURL = reader.string();
                    break;
                case /* bytes PublicKey = 6 [deprecated = true, json_name = "PublicKey"];*/ 6:
                    message.publicKey = reader.bytes();
                    break;
                case /* int64 CertTTL = 7 [json_name = "CertTTL"];*/ 7:
                    message.certTTL = reader.int64().toBigInt();
                    break;
                case /* string CSRFToken = 8 [json_name = "CSRFToken"];*/ 8:
                    message.cSRFToken = reader.string();
                    break;
                case /* bool CreateWebSession = 9 [json_name = "CreateWebSession"];*/ 9:
                    message.createWebSession = reader.bool();
                    break;
                case /* string ClientRedirectURL = 10 [json_name = "ClientRedirectURL"];*/ 10:
                    message.clientRedirectURL = reader.string();
                    break;
                case /* string Compatibility = 11 [json_name = "Compatibility"];*/ 11:
                    message.compatibility = reader.string();
                    break;
                case /* string RouteToCluster = 12 [json_name = "RouteToCluster"];*/ 12:
                    message.routeToCluster = reader.string();
                    break;
                case /* string KubernetesCluster = 13 [json_name = "KubernetesCluster"];*/ 13:
                    message.kubernetesCluster = reader.string();
                    break;
                case /* bool SSOTestFlow = 14 [json_name = "SSOTestFlow"];*/ 14:
                    message.sSOTestFlow = reader.bool();
                    break;
                case /* types.SAMLConnectorSpecV2 ConnectorSpec = 15 [json_name = "ConnectorSpec"];*/ 15:
                    message.connectorSpec = SAMLConnectorSpecV2.internalBinaryRead(reader, reader.uint32(), options, message.connectorSpec);
                    break;
                case /* teleport.attestation.v1.AttestationStatement attestation_statement */ 16:
                    message.attestationStatement = AttestationStatement.internalBinaryRead(reader, reader.uint32(), options, message.attestationStatement);
                    break;
                case /* string ClientLoginIP = 17 [json_name = "ClientLoginIP"];*/ 17:
                    message.clientLoginIP = reader.string();
                    break;
                case /* string ClientUserAgent = 18 [json_name = "ClientUserAgent"];*/ 18:
                    message.clientUserAgent = reader.string();
                    break;
                case /* bytes ssh_public_key */ 19:
                    message.sshPublicKey = reader.bytes();
                    break;
                case /* bytes tls_public_key */ 20:
                    message.tlsPublicKey = reader.bytes();
                    break;
                case /* teleport.attestation.v1.AttestationStatement ssh_attestation_statement */ 21:
                    message.sshAttestationStatement = AttestationStatement.internalBinaryRead(reader, reader.uint32(), options, message.sshAttestationStatement);
                    break;
                case /* teleport.attestation.v1.AttestationStatement tls_attestation_statement */ 22:
                    message.tlsAttestationStatement = AttestationStatement.internalBinaryRead(reader, reader.uint32(), options, message.tlsAttestationStatement);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SAMLAuthRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ID = 1 [json_name = "ID"]; */
        if (message.iD !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.iD);
        /* string ConnectorID = 2 [json_name = "ConnectorID"]; */
        if (message.connectorID !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.connectorID);
        /* string Type = 3 [json_name = "Type"]; */
        if (message.type !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.type);
        /* bool CheckUser = 4 [json_name = "CheckUser"]; */
        if (message.checkUser !== false)
            writer.tag(4, WireType.Varint).bool(message.checkUser);
        /* string RedirectURL = 5 [json_name = "RedirectURL"]; */
        if (message.redirectURL !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.redirectURL);
        /* bytes PublicKey = 6 [deprecated = true, json_name = "PublicKey"]; */
        if (message.publicKey.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.publicKey);
        /* int64 CertTTL = 7 [json_name = "CertTTL"]; */
        if (message.certTTL !== 0n)
            writer.tag(7, WireType.Varint).int64(message.certTTL);
        /* string CSRFToken = 8 [json_name = "CSRFToken"]; */
        if (message.cSRFToken !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.cSRFToken);
        /* bool CreateWebSession = 9 [json_name = "CreateWebSession"]; */
        if (message.createWebSession !== false)
            writer.tag(9, WireType.Varint).bool(message.createWebSession);
        /* string ClientRedirectURL = 10 [json_name = "ClientRedirectURL"]; */
        if (message.clientRedirectURL !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.clientRedirectURL);
        /* string Compatibility = 11 [json_name = "Compatibility"]; */
        if (message.compatibility !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.compatibility);
        /* string RouteToCluster = 12 [json_name = "RouteToCluster"]; */
        if (message.routeToCluster !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.routeToCluster);
        /* string KubernetesCluster = 13 [json_name = "KubernetesCluster"]; */
        if (message.kubernetesCluster !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.kubernetesCluster);
        /* bool SSOTestFlow = 14 [json_name = "SSOTestFlow"]; */
        if (message.sSOTestFlow !== false)
            writer.tag(14, WireType.Varint).bool(message.sSOTestFlow);
        /* types.SAMLConnectorSpecV2 ConnectorSpec = 15 [json_name = "ConnectorSpec"]; */
        if (message.connectorSpec)
            SAMLConnectorSpecV2.internalBinaryWrite(message.connectorSpec, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* teleport.attestation.v1.AttestationStatement attestation_statement = 16; */
        if (message.attestationStatement)
            AttestationStatement.internalBinaryWrite(message.attestationStatement, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* string ClientLoginIP = 17 [json_name = "ClientLoginIP"]; */
        if (message.clientLoginIP !== "")
            writer.tag(17, WireType.LengthDelimited).string(message.clientLoginIP);
        /* string ClientUserAgent = 18 [json_name = "ClientUserAgent"]; */
        if (message.clientUserAgent !== "")
            writer.tag(18, WireType.LengthDelimited).string(message.clientUserAgent);
        /* bytes ssh_public_key = 19; */
        if (message.sshPublicKey.length)
            writer.tag(19, WireType.LengthDelimited).bytes(message.sshPublicKey);
        /* bytes tls_public_key = 20; */
        if (message.tlsPublicKey.length)
            writer.tag(20, WireType.LengthDelimited).bytes(message.tlsPublicKey);
        /* teleport.attestation.v1.AttestationStatement ssh_attestation_statement = 21; */
        if (message.sshAttestationStatement)
            AttestationStatement.internalBinaryWrite(message.sshAttestationStatement, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        /* teleport.attestation.v1.AttestationStatement tls_attestation_statement = 22; */
        if (message.tlsAttestationStatement)
            AttestationStatement.internalBinaryWrite(message.tlsAttestationStatement, writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.SAMLAuthRequest
 */
export const SAMLAuthRequest = new SAMLAuthRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AttributeMapping$Type extends MessageType<AttributeMapping> {
    constructor() {
        super("types.AttributeMapping", [
            { no: 1, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "name" } },
            { no: 2, name: "Value", kind: "scalar", jsonName: "Value", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "value" } },
            { no: 3, name: "Roles", kind: "scalar", jsonName: "Roles", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "roles,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<AttributeMapping>): AttributeMapping {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.value = "";
        message.roles = [];
        if (value !== undefined)
            reflectionMergePartial<AttributeMapping>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AttributeMapping): AttributeMapping {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Name = 1 [json_name = "Name"];*/ 1:
                    message.name = reader.string();
                    break;
                case /* string Value = 2 [json_name = "Value"];*/ 2:
                    message.value = reader.string();
                    break;
                case /* repeated string Roles = 3 [json_name = "Roles"];*/ 3:
                    message.roles.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AttributeMapping, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Name = 1 [json_name = "Name"]; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string Value = 2 [json_name = "Value"]; */
        if (message.value !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        /* repeated string Roles = 3 [json_name = "Roles"]; */
        for (let i = 0; i < message.roles.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.roles[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AttributeMapping
 */
export const AttributeMapping = new AttributeMapping$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AsymmetricKeyPair$Type extends MessageType<AsymmetricKeyPair> {
    constructor() {
        super("types.AsymmetricKeyPair", [
            { no: 1, name: "PrivateKey", kind: "scalar", jsonName: "PrivateKey", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "private_key" } },
            { no: 2, name: "Cert", kind: "scalar", jsonName: "Cert", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "cert" } }
        ]);
    }
    create(value?: PartialMessage<AsymmetricKeyPair>): AsymmetricKeyPair {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.privateKey = "";
        message.cert = "";
        if (value !== undefined)
            reflectionMergePartial<AsymmetricKeyPair>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AsymmetricKeyPair): AsymmetricKeyPair {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string PrivateKey = 1 [json_name = "PrivateKey"];*/ 1:
                    message.privateKey = reader.string();
                    break;
                case /* string Cert = 2 [json_name = "Cert"];*/ 2:
                    message.cert = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AsymmetricKeyPair, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string PrivateKey = 1 [json_name = "PrivateKey"]; */
        if (message.privateKey !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.privateKey);
        /* string Cert = 2 [json_name = "Cert"]; */
        if (message.cert !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.cert);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AsymmetricKeyPair
 */
export const AsymmetricKeyPair = new AsymmetricKeyPair$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GithubConnectorV3$Type extends MessageType<GithubConnectorV3> {
    constructor() {
        super("types.GithubConnectorV3", [
            { no: 1, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 2, name: "SubKind", kind: "scalar", jsonName: "SubKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub_kind,omitempty" } },
            { no: 3, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version" } },
            { no: 4, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "metadata" } },
            { no: 5, name: "Spec", kind: "message", jsonName: "Spec", T: () => GithubConnectorSpecV3, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ]);
    }
    create(value?: PartialMessage<GithubConnectorV3>): GithubConnectorV3 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.subKind = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<GithubConnectorV3>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GithubConnectorV3): GithubConnectorV3 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Kind = 1 [json_name = "Kind"];*/ 1:
                    message.kind = reader.string();
                    break;
                case /* string SubKind = 2 [json_name = "SubKind"];*/ 2:
                    message.subKind = reader.string();
                    break;
                case /* string Version = 3 [json_name = "Version"];*/ 3:
                    message.version = reader.string();
                    break;
                case /* types.Metadata Metadata = 4 [json_name = "Metadata"];*/ 4:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* types.GithubConnectorSpecV3 Spec = 5 [json_name = "Spec"];*/ 5:
                    message.spec = GithubConnectorSpecV3.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GithubConnectorV3, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Kind = 1 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string SubKind = 2 [json_name = "SubKind"]; */
        if (message.subKind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subKind);
        /* string Version = 3 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* types.Metadata Metadata = 4 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.GithubConnectorSpecV3 Spec = 5 [json_name = "Spec"]; */
        if (message.spec)
            GithubConnectorSpecV3.internalBinaryWrite(message.spec, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.GithubConnectorV3
 */
export const GithubConnectorV3 = new GithubConnectorV3$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GithubConnectorV3List$Type extends MessageType<GithubConnectorV3List> {
    constructor() {
        super("types.GithubConnectorV3List", [
            { no: 1, name: "GithubConnectors", kind: "message", jsonName: "GithubConnectors", repeat: 1 /*RepeatType.PACKED*/, T: () => GithubConnectorV3 }
        ]);
    }
    create(value?: PartialMessage<GithubConnectorV3List>): GithubConnectorV3List {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.githubConnectors = [];
        if (value !== undefined)
            reflectionMergePartial<GithubConnectorV3List>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GithubConnectorV3List): GithubConnectorV3List {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.GithubConnectorV3 GithubConnectors = 1 [json_name = "GithubConnectors"];*/ 1:
                    message.githubConnectors.push(GithubConnectorV3.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GithubConnectorV3List, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.GithubConnectorV3 GithubConnectors = 1 [json_name = "GithubConnectors"]; */
        for (let i = 0; i < message.githubConnectors.length; i++)
            GithubConnectorV3.internalBinaryWrite(message.githubConnectors[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.GithubConnectorV3List
 */
export const GithubConnectorV3List = new GithubConnectorV3List$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GithubConnectorSpecV3$Type extends MessageType<GithubConnectorSpecV3> {
    constructor() {
        super("types.GithubConnectorSpecV3", [
            { no: 1, name: "ClientID", kind: "scalar", jsonName: "ClientID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "client_id" } },
            { no: 2, name: "ClientSecret", kind: "scalar", jsonName: "ClientSecret", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "client_secret" } },
            { no: 3, name: "RedirectURL", kind: "scalar", jsonName: "RedirectURL", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "redirect_url" } },
            { no: 4, name: "TeamsToLogins", kind: "message", jsonName: "TeamsToLogins", repeat: 1 /*RepeatType.PACKED*/, T: () => TeamMapping, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "teams_to_logins" } },
            { no: 5, name: "Display", kind: "scalar", jsonName: "Display", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "display" } },
            { no: 6, name: "TeamsToRoles", kind: "message", jsonName: "TeamsToRoles", repeat: 1 /*RepeatType.PACKED*/, T: () => TeamRolesMapping, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "teams_to_roles" } },
            { no: 7, name: "EndpointURL", kind: "scalar", jsonName: "EndpointURL", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "endpoint_url" } },
            { no: 8, name: "APIEndpointURL", kind: "scalar", jsonName: "APIEndpointURL", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "api_endpoint_url" } },
            { no: 9, name: "ClientRedirectSettings", kind: "message", jsonName: "ClientRedirectSettings", T: () => SSOClientRedirectSettings, options: { "gogoproto.jsontag": "client_redirect_settings,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<GithubConnectorSpecV3>): GithubConnectorSpecV3 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clientID = "";
        message.clientSecret = "";
        message.redirectURL = "";
        message.teamsToLogins = [];
        message.display = "";
        message.teamsToRoles = [];
        message.endpointURL = "";
        message.aPIEndpointURL = "";
        if (value !== undefined)
            reflectionMergePartial<GithubConnectorSpecV3>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GithubConnectorSpecV3): GithubConnectorSpecV3 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ClientID = 1 [json_name = "ClientID"];*/ 1:
                    message.clientID = reader.string();
                    break;
                case /* string ClientSecret = 2 [json_name = "ClientSecret"];*/ 2:
                    message.clientSecret = reader.string();
                    break;
                case /* string RedirectURL = 3 [json_name = "RedirectURL"];*/ 3:
                    message.redirectURL = reader.string();
                    break;
                case /* repeated types.TeamMapping TeamsToLogins = 4 [json_name = "TeamsToLogins"];*/ 4:
                    message.teamsToLogins.push(TeamMapping.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string Display = 5 [json_name = "Display"];*/ 5:
                    message.display = reader.string();
                    break;
                case /* repeated types.TeamRolesMapping TeamsToRoles = 6 [json_name = "TeamsToRoles"];*/ 6:
                    message.teamsToRoles.push(TeamRolesMapping.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string EndpointURL = 7 [json_name = "EndpointURL"];*/ 7:
                    message.endpointURL = reader.string();
                    break;
                case /* string APIEndpointURL = 8 [json_name = "APIEndpointURL"];*/ 8:
                    message.aPIEndpointURL = reader.string();
                    break;
                case /* types.SSOClientRedirectSettings ClientRedirectSettings = 9 [json_name = "ClientRedirectSettings"];*/ 9:
                    message.clientRedirectSettings = SSOClientRedirectSettings.internalBinaryRead(reader, reader.uint32(), options, message.clientRedirectSettings);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GithubConnectorSpecV3, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ClientID = 1 [json_name = "ClientID"]; */
        if (message.clientID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clientID);
        /* string ClientSecret = 2 [json_name = "ClientSecret"]; */
        if (message.clientSecret !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.clientSecret);
        /* string RedirectURL = 3 [json_name = "RedirectURL"]; */
        if (message.redirectURL !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.redirectURL);
        /* repeated types.TeamMapping TeamsToLogins = 4 [json_name = "TeamsToLogins"]; */
        for (let i = 0; i < message.teamsToLogins.length; i++)
            TeamMapping.internalBinaryWrite(message.teamsToLogins[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string Display = 5 [json_name = "Display"]; */
        if (message.display !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.display);
        /* repeated types.TeamRolesMapping TeamsToRoles = 6 [json_name = "TeamsToRoles"]; */
        for (let i = 0; i < message.teamsToRoles.length; i++)
            TeamRolesMapping.internalBinaryWrite(message.teamsToRoles[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* string EndpointURL = 7 [json_name = "EndpointURL"]; */
        if (message.endpointURL !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.endpointURL);
        /* string APIEndpointURL = 8 [json_name = "APIEndpointURL"]; */
        if (message.aPIEndpointURL !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.aPIEndpointURL);
        /* types.SSOClientRedirectSettings ClientRedirectSettings = 9 [json_name = "ClientRedirectSettings"]; */
        if (message.clientRedirectSettings)
            SSOClientRedirectSettings.internalBinaryWrite(message.clientRedirectSettings, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.GithubConnectorSpecV3
 */
export const GithubConnectorSpecV3 = new GithubConnectorSpecV3$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GithubAuthRequest$Type extends MessageType<GithubAuthRequest> {
    constructor() {
        super("types.GithubAuthRequest", [
            { no: 1, name: "ConnectorID", kind: "scalar", jsonName: "ConnectorID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "connector_id" } },
            { no: 2, name: "Type", kind: "scalar", jsonName: "Type", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "type" } },
            { no: 3, name: "StateToken", kind: "scalar", jsonName: "StateToken", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "state_token" } },
            { no: 4, name: "CSRFToken", kind: "scalar", jsonName: "CSRFToken", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "csrf_token" } },
            { no: 5, name: "PublicKey", kind: "scalar", jsonName: "PublicKey", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.jsontag": "public_key" } },
            { no: 6, name: "CertTTL", kind: "scalar", jsonName: "CertTTL", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "cert_ttl", "gogoproto.casttype": "time.Duration" } },
            { no: 7, name: "CreateWebSession", kind: "scalar", jsonName: "CreateWebSession", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "create_web_session" } },
            { no: 8, name: "RedirectURL", kind: "scalar", jsonName: "RedirectURL", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "redirect_url" } },
            { no: 9, name: "ClientRedirectURL", kind: "scalar", jsonName: "ClientRedirectURL", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "client_redirect_url" } },
            { no: 10, name: "Compatibility", kind: "scalar", jsonName: "Compatibility", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "compatibility,omitempty" } },
            { no: 11, name: "Expires", kind: "message", jsonName: "Expires", T: () => Timestamp, options: { "gogoproto.nullable": true, "gogoproto.jsontag": "expires,omitempty", "gogoproto.stdtime": true } },
            { no: 12, name: "RouteToCluster", kind: "scalar", jsonName: "RouteToCluster", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "route_to_cluster,omitempty" } },
            { no: 13, name: "KubernetesCluster", kind: "scalar", jsonName: "KubernetesCluster", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kubernetes_cluster,omitempty" } },
            { no: 14, name: "SSOTestFlow", kind: "scalar", jsonName: "SSOTestFlow", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "sso_test_flow" } },
            { no: 15, name: "ConnectorSpec", kind: "message", jsonName: "ConnectorSpec", T: () => GithubConnectorSpecV3, options: { "gogoproto.jsontag": "connector_spec,omitempty" } },
            { no: 16, name: "attestation_statement", kind: "message", T: () => AttestationStatement, options: { "gogoproto.jsontag": "attestation_statement,omitempty" } },
            { no: 17, name: "ClientLoginIP", kind: "scalar", jsonName: "ClientLoginIP", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "client_login_ip,omitempty" } },
            { no: 18, name: "ClientUserAgent", kind: "scalar", jsonName: "ClientUserAgent", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "client_user_agent,omitempty" } },
            { no: 19, name: "ssh_public_key", kind: "scalar", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.jsontag": "ssh_pub_key,omitempty" } },
            { no: 20, name: "tls_public_key", kind: "scalar", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.jsontag": "tls_pub_key,omitempty" } },
            { no: 21, name: "ssh_attestation_statement", kind: "message", T: () => AttestationStatement, options: { "gogoproto.jsontag": "ssh_attestation_statement,omitempty" } },
            { no: 22, name: "tls_attestation_statement", kind: "message", T: () => AttestationStatement, options: { "gogoproto.jsontag": "tls_attestation_statement,omitempty" } },
            { no: 23, name: "authenticated_user", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "authenticated_user,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<GithubAuthRequest>): GithubAuthRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.connectorID = "";
        message.type = "";
        message.stateToken = "";
        message.cSRFToken = "";
        message.publicKey = new Uint8Array(0);
        message.certTTL = 0n;
        message.createWebSession = false;
        message.redirectURL = "";
        message.clientRedirectURL = "";
        message.compatibility = "";
        message.routeToCluster = "";
        message.kubernetesCluster = "";
        message.sSOTestFlow = false;
        message.clientLoginIP = "";
        message.clientUserAgent = "";
        message.sshPublicKey = new Uint8Array(0);
        message.tlsPublicKey = new Uint8Array(0);
        message.authenticatedUser = "";
        if (value !== undefined)
            reflectionMergePartial<GithubAuthRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GithubAuthRequest): GithubAuthRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ConnectorID = 1 [json_name = "ConnectorID"];*/ 1:
                    message.connectorID = reader.string();
                    break;
                case /* string Type = 2 [json_name = "Type"];*/ 2:
                    message.type = reader.string();
                    break;
                case /* string StateToken = 3 [json_name = "StateToken"];*/ 3:
                    message.stateToken = reader.string();
                    break;
                case /* string CSRFToken = 4 [json_name = "CSRFToken"];*/ 4:
                    message.cSRFToken = reader.string();
                    break;
                case /* bytes PublicKey = 5 [deprecated = true, json_name = "PublicKey"];*/ 5:
                    message.publicKey = reader.bytes();
                    break;
                case /* int64 CertTTL = 6 [json_name = "CertTTL"];*/ 6:
                    message.certTTL = reader.int64().toBigInt();
                    break;
                case /* bool CreateWebSession = 7 [json_name = "CreateWebSession"];*/ 7:
                    message.createWebSession = reader.bool();
                    break;
                case /* string RedirectURL = 8 [json_name = "RedirectURL"];*/ 8:
                    message.redirectURL = reader.string();
                    break;
                case /* string ClientRedirectURL = 9 [json_name = "ClientRedirectURL"];*/ 9:
                    message.clientRedirectURL = reader.string();
                    break;
                case /* string Compatibility = 10 [json_name = "Compatibility"];*/ 10:
                    message.compatibility = reader.string();
                    break;
                case /* google.protobuf.Timestamp Expires = 11 [json_name = "Expires"];*/ 11:
                    message.expires = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expires);
                    break;
                case /* string RouteToCluster = 12 [json_name = "RouteToCluster"];*/ 12:
                    message.routeToCluster = reader.string();
                    break;
                case /* string KubernetesCluster = 13 [json_name = "KubernetesCluster"];*/ 13:
                    message.kubernetesCluster = reader.string();
                    break;
                case /* bool SSOTestFlow = 14 [json_name = "SSOTestFlow"];*/ 14:
                    message.sSOTestFlow = reader.bool();
                    break;
                case /* types.GithubConnectorSpecV3 ConnectorSpec = 15 [json_name = "ConnectorSpec"];*/ 15:
                    message.connectorSpec = GithubConnectorSpecV3.internalBinaryRead(reader, reader.uint32(), options, message.connectorSpec);
                    break;
                case /* teleport.attestation.v1.AttestationStatement attestation_statement = 16 [deprecated = true];*/ 16:
                    message.attestationStatement = AttestationStatement.internalBinaryRead(reader, reader.uint32(), options, message.attestationStatement);
                    break;
                case /* string ClientLoginIP = 17 [json_name = "ClientLoginIP"];*/ 17:
                    message.clientLoginIP = reader.string();
                    break;
                case /* string ClientUserAgent = 18 [json_name = "ClientUserAgent"];*/ 18:
                    message.clientUserAgent = reader.string();
                    break;
                case /* bytes ssh_public_key */ 19:
                    message.sshPublicKey = reader.bytes();
                    break;
                case /* bytes tls_public_key */ 20:
                    message.tlsPublicKey = reader.bytes();
                    break;
                case /* teleport.attestation.v1.AttestationStatement ssh_attestation_statement */ 21:
                    message.sshAttestationStatement = AttestationStatement.internalBinaryRead(reader, reader.uint32(), options, message.sshAttestationStatement);
                    break;
                case /* teleport.attestation.v1.AttestationStatement tls_attestation_statement */ 22:
                    message.tlsAttestationStatement = AttestationStatement.internalBinaryRead(reader, reader.uint32(), options, message.tlsAttestationStatement);
                    break;
                case /* string authenticated_user */ 23:
                    message.authenticatedUser = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GithubAuthRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ConnectorID = 1 [json_name = "ConnectorID"]; */
        if (message.connectorID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.connectorID);
        /* string Type = 2 [json_name = "Type"]; */
        if (message.type !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.type);
        /* string StateToken = 3 [json_name = "StateToken"]; */
        if (message.stateToken !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.stateToken);
        /* string CSRFToken = 4 [json_name = "CSRFToken"]; */
        if (message.cSRFToken !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.cSRFToken);
        /* bytes PublicKey = 5 [deprecated = true, json_name = "PublicKey"]; */
        if (message.publicKey.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.publicKey);
        /* int64 CertTTL = 6 [json_name = "CertTTL"]; */
        if (message.certTTL !== 0n)
            writer.tag(6, WireType.Varint).int64(message.certTTL);
        /* bool CreateWebSession = 7 [json_name = "CreateWebSession"]; */
        if (message.createWebSession !== false)
            writer.tag(7, WireType.Varint).bool(message.createWebSession);
        /* string RedirectURL = 8 [json_name = "RedirectURL"]; */
        if (message.redirectURL !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.redirectURL);
        /* string ClientRedirectURL = 9 [json_name = "ClientRedirectURL"]; */
        if (message.clientRedirectURL !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.clientRedirectURL);
        /* string Compatibility = 10 [json_name = "Compatibility"]; */
        if (message.compatibility !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.compatibility);
        /* google.protobuf.Timestamp Expires = 11 [json_name = "Expires"]; */
        if (message.expires)
            Timestamp.internalBinaryWrite(message.expires, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* string RouteToCluster = 12 [json_name = "RouteToCluster"]; */
        if (message.routeToCluster !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.routeToCluster);
        /* string KubernetesCluster = 13 [json_name = "KubernetesCluster"]; */
        if (message.kubernetesCluster !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.kubernetesCluster);
        /* bool SSOTestFlow = 14 [json_name = "SSOTestFlow"]; */
        if (message.sSOTestFlow !== false)
            writer.tag(14, WireType.Varint).bool(message.sSOTestFlow);
        /* types.GithubConnectorSpecV3 ConnectorSpec = 15 [json_name = "ConnectorSpec"]; */
        if (message.connectorSpec)
            GithubConnectorSpecV3.internalBinaryWrite(message.connectorSpec, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* teleport.attestation.v1.AttestationStatement attestation_statement = 16 [deprecated = true]; */
        if (message.attestationStatement)
            AttestationStatement.internalBinaryWrite(message.attestationStatement, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* string ClientLoginIP = 17 [json_name = "ClientLoginIP"]; */
        if (message.clientLoginIP !== "")
            writer.tag(17, WireType.LengthDelimited).string(message.clientLoginIP);
        /* string ClientUserAgent = 18 [json_name = "ClientUserAgent"]; */
        if (message.clientUserAgent !== "")
            writer.tag(18, WireType.LengthDelimited).string(message.clientUserAgent);
        /* bytes ssh_public_key = 19; */
        if (message.sshPublicKey.length)
            writer.tag(19, WireType.LengthDelimited).bytes(message.sshPublicKey);
        /* bytes tls_public_key = 20; */
        if (message.tlsPublicKey.length)
            writer.tag(20, WireType.LengthDelimited).bytes(message.tlsPublicKey);
        /* teleport.attestation.v1.AttestationStatement ssh_attestation_statement = 21; */
        if (message.sshAttestationStatement)
            AttestationStatement.internalBinaryWrite(message.sshAttestationStatement, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        /* teleport.attestation.v1.AttestationStatement tls_attestation_statement = 22; */
        if (message.tlsAttestationStatement)
            AttestationStatement.internalBinaryWrite(message.tlsAttestationStatement, writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        /* string authenticated_user = 23; */
        if (message.authenticatedUser !== "")
            writer.tag(23, WireType.LengthDelimited).string(message.authenticatedUser);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.GithubAuthRequest
 */
export const GithubAuthRequest = new GithubAuthRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SSOWarnings$Type extends MessageType<SSOWarnings> {
    constructor() {
        super("types.SSOWarnings", [
            { no: 1, name: "Message", kind: "scalar", jsonName: "Message", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "message,omitempty" } },
            { no: 2, name: "Warnings", kind: "scalar", jsonName: "Warnings", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "warnings,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<SSOWarnings>): SSOWarnings {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.message = "";
        message.warnings = [];
        if (value !== undefined)
            reflectionMergePartial<SSOWarnings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SSOWarnings): SSOWarnings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Message = 1 [json_name = "Message"];*/ 1:
                    message.message = reader.string();
                    break;
                case /* repeated string Warnings = 2 [json_name = "Warnings"];*/ 2:
                    message.warnings.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SSOWarnings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Message = 1 [json_name = "Message"]; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        /* repeated string Warnings = 2 [json_name = "Warnings"]; */
        for (let i = 0; i < message.warnings.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.warnings[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.SSOWarnings
 */
export const SSOWarnings = new SSOWarnings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateUserParams$Type extends MessageType<CreateUserParams> {
    constructor() {
        super("types.CreateUserParams", [
            { no: 1, name: "ConnectorName", kind: "scalar", jsonName: "ConnectorName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "connector_name,omitempty" } },
            { no: 2, name: "Username", kind: "scalar", jsonName: "Username", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "username,omitempty" } },
            { no: 3, name: "Logins", kind: "scalar", jsonName: "Logins", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "logins,omitempty" } },
            { no: 4, name: "KubeGroups", kind: "scalar", jsonName: "KubeGroups", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kube_groups,omitempty" } },
            { no: 5, name: "KubeUsers", kind: "scalar", jsonName: "KubeUsers", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kube_users,omitempty" } },
            { no: 6, name: "Roles", kind: "scalar", jsonName: "Roles", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "roles,omitempty" } },
            { no: 7, name: "Traits", kind: "message", jsonName: "Traits", T: () => LabelValues, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/gravitational/teleport/api/types/wrappers.Traits", "gogoproto.jsontag": "traits,omitempty" } },
            { no: 8, name: "SessionTTL", kind: "scalar", jsonName: "SessionTTL", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "session_ttl,omitempty", "gogoproto.casttype": "Duration" } }
        ]);
    }
    create(value?: PartialMessage<CreateUserParams>): CreateUserParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.connectorName = "";
        message.username = "";
        message.logins = [];
        message.kubeGroups = [];
        message.kubeUsers = [];
        message.roles = [];
        message.sessionTTL = 0n;
        if (value !== undefined)
            reflectionMergePartial<CreateUserParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateUserParams): CreateUserParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ConnectorName = 1 [json_name = "ConnectorName"];*/ 1:
                    message.connectorName = reader.string();
                    break;
                case /* string Username = 2 [json_name = "Username"];*/ 2:
                    message.username = reader.string();
                    break;
                case /* repeated string Logins = 3 [json_name = "Logins"];*/ 3:
                    message.logins.push(reader.string());
                    break;
                case /* repeated string KubeGroups = 4 [json_name = "KubeGroups"];*/ 4:
                    message.kubeGroups.push(reader.string());
                    break;
                case /* repeated string KubeUsers = 5 [json_name = "KubeUsers"];*/ 5:
                    message.kubeUsers.push(reader.string());
                    break;
                case /* repeated string Roles = 6 [json_name = "Roles"];*/ 6:
                    message.roles.push(reader.string());
                    break;
                case /* wrappers.LabelValues Traits = 7 [json_name = "Traits"];*/ 7:
                    message.traits = LabelValues.internalBinaryRead(reader, reader.uint32(), options, message.traits);
                    break;
                case /* int64 SessionTTL = 8 [json_name = "SessionTTL"];*/ 8:
                    message.sessionTTL = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateUserParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ConnectorName = 1 [json_name = "ConnectorName"]; */
        if (message.connectorName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.connectorName);
        /* string Username = 2 [json_name = "Username"]; */
        if (message.username !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.username);
        /* repeated string Logins = 3 [json_name = "Logins"]; */
        for (let i = 0; i < message.logins.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.logins[i]);
        /* repeated string KubeGroups = 4 [json_name = "KubeGroups"]; */
        for (let i = 0; i < message.kubeGroups.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.kubeGroups[i]);
        /* repeated string KubeUsers = 5 [json_name = "KubeUsers"]; */
        for (let i = 0; i < message.kubeUsers.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.kubeUsers[i]);
        /* repeated string Roles = 6 [json_name = "Roles"]; */
        for (let i = 0; i < message.roles.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.roles[i]);
        /* wrappers.LabelValues Traits = 7 [json_name = "Traits"]; */
        if (message.traits)
            LabelValues.internalBinaryWrite(message.traits, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* int64 SessionTTL = 8 [json_name = "SessionTTL"]; */
        if (message.sessionTTL !== 0n)
            writer.tag(8, WireType.Varint).int64(message.sessionTTL);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.CreateUserParams
 */
export const CreateUserParams = new CreateUserParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SSODiagnosticInfo$Type extends MessageType<SSODiagnosticInfo> {
    constructor() {
        super("types.SSODiagnosticInfo", [
            { no: 1, name: "TestFlow", kind: "scalar", jsonName: "TestFlow", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "test_flow" } },
            { no: 2, name: "Error", kind: "scalar", jsonName: "Error", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "error" } },
            { no: 3, name: "Success", kind: "scalar", jsonName: "Success", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "success" } },
            { no: 4, name: "CreateUserParams", kind: "message", jsonName: "CreateUserParams", T: () => CreateUserParams, options: { "gogoproto.jsontag": "create_user_params,omitempty" } },
            { no: 10, name: "SAMLAttributesToRoles", kind: "message", jsonName: "SAMLAttributesToRoles", repeat: 1 /*RepeatType.PACKED*/, T: () => AttributeMapping, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "saml_attributes_to_roles,omitempty" } },
            { no: 11, name: "SAMLAttributesToRolesWarnings", kind: "message", jsonName: "SAMLAttributesToRolesWarnings", T: () => SSOWarnings, options: { "gogoproto.jsontag": "saml_attributes_to_roles_warnings,omitempty" } },
            { no: 12, name: "SAMLAttributeStatements", kind: "message", jsonName: "SAMLAttributeStatements", T: () => LabelValues, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/gravitational/teleport/api/types/wrappers.Traits", "gogoproto.jsontag": "saml_attribute_statements,omitempty" } },
            { no: 13, name: "SAMLAssertionInfo", kind: "message", jsonName: "SAMLAssertionInfo", T: () => CustomType, options: { "gogoproto.customtype": "AssertionInfo", "gogoproto.jsontag": "saml_assertion_info,omitempty" } },
            { no: 14, name: "SAMLTraitsFromAssertions", kind: "message", jsonName: "SAMLTraitsFromAssertions", T: () => LabelValues, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/gravitational/teleport/api/types/wrappers.Traits", "gogoproto.jsontag": "saml_traits_from_assertions,omitempty" } },
            { no: 15, name: "SAMLConnectorTraitMapping", kind: "message", jsonName: "SAMLConnectorTraitMapping", repeat: 1 /*RepeatType.PACKED*/, T: () => TraitMapping, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "saml_connector_trait_mapping,omitempty" } },
            { no: 20, name: "OIDCClaimsToRoles", kind: "message", jsonName: "OIDCClaimsToRoles", repeat: 1 /*RepeatType.PACKED*/, T: () => ClaimMapping, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "oidc_claims_to_roles,omitempty" } },
            { no: 21, name: "OIDCClaimsToRolesWarnings", kind: "message", jsonName: "OIDCClaimsToRolesWarnings", T: () => SSOWarnings, options: { "gogoproto.jsontag": "oidc_claims_to_roles_warnings,omitempty" } },
            { no: 22, name: "OIDCClaims", kind: "message", jsonName: "OIDCClaims", T: () => CustomType, options: { "gogoproto.nullable": false, "gogoproto.customtype": "OIDCClaims", "gogoproto.jsontag": "oidc_claims,omitempty" } },
            { no: 23, name: "OIDCIdentity", kind: "message", jsonName: "OIDCIdentity", T: () => CustomType, options: { "gogoproto.customtype": "OIDCIdentity", "gogoproto.jsontag": "oidc_identity,omitempty" } },
            { no: 24, name: "OIDCTraitsFromClaims", kind: "message", jsonName: "OIDCTraitsFromClaims", T: () => LabelValues, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/gravitational/teleport/api/types/wrappers.Traits", "gogoproto.jsontag": "oidc_traits_from_claims,omitempty" } },
            { no: 25, name: "OIDCConnectorTraitMapping", kind: "message", jsonName: "OIDCConnectorTraitMapping", repeat: 1 /*RepeatType.PACKED*/, T: () => TraitMapping, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "oidc_connector_trait_mapping,omitempty" } },
            { no: 30, name: "GithubClaims", kind: "message", jsonName: "GithubClaims", T: () => GithubClaims, options: { "gogoproto.jsontag": "github_claims,omitempty" } },
            { no: 31, name: "GithubTeamsToLogins", kind: "message", jsonName: "GithubTeamsToLogins", repeat: 1 /*RepeatType.PACKED*/, T: () => TeamMapping, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "github_teams_to_logins,omitempty" } },
            { no: 32, name: "GithubTeamsToRoles", kind: "message", jsonName: "GithubTeamsToRoles", repeat: 1 /*RepeatType.PACKED*/, T: () => TeamRolesMapping, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "github_teams_to_roles,omitempty" } },
            { no: 33, name: "GithubTokenInfo", kind: "message", jsonName: "GithubTokenInfo", T: () => GithubTokenInfo, options: { "gogoproto.jsontag": "github_token_info,omitempty" } },
            { no: 34, name: "AppliedLoginRules", kind: "scalar", jsonName: "AppliedLoginRules", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "applied_login_rules,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<SSODiagnosticInfo>): SSODiagnosticInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.testFlow = false;
        message.error = "";
        message.success = false;
        message.sAMLAttributesToRoles = [];
        message.sAMLConnectorTraitMapping = [];
        message.oIDCClaimsToRoles = [];
        message.oIDCConnectorTraitMapping = [];
        message.githubTeamsToLogins = [];
        message.githubTeamsToRoles = [];
        message.appliedLoginRules = [];
        if (value !== undefined)
            reflectionMergePartial<SSODiagnosticInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SSODiagnosticInfo): SSODiagnosticInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool TestFlow = 1 [json_name = "TestFlow"];*/ 1:
                    message.testFlow = reader.bool();
                    break;
                case /* string Error = 2 [json_name = "Error"];*/ 2:
                    message.error = reader.string();
                    break;
                case /* bool Success = 3 [json_name = "Success"];*/ 3:
                    message.success = reader.bool();
                    break;
                case /* types.CreateUserParams CreateUserParams = 4 [json_name = "CreateUserParams"];*/ 4:
                    message.createUserParams = CreateUserParams.internalBinaryRead(reader, reader.uint32(), options, message.createUserParams);
                    break;
                case /* repeated types.AttributeMapping SAMLAttributesToRoles = 10 [json_name = "SAMLAttributesToRoles"];*/ 10:
                    message.sAMLAttributesToRoles.push(AttributeMapping.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* types.SSOWarnings SAMLAttributesToRolesWarnings = 11 [json_name = "SAMLAttributesToRolesWarnings"];*/ 11:
                    message.sAMLAttributesToRolesWarnings = SSOWarnings.internalBinaryRead(reader, reader.uint32(), options, message.sAMLAttributesToRolesWarnings);
                    break;
                case /* wrappers.LabelValues SAMLAttributeStatements = 12 [json_name = "SAMLAttributeStatements"];*/ 12:
                    message.sAMLAttributeStatements = LabelValues.internalBinaryRead(reader, reader.uint32(), options, message.sAMLAttributeStatements);
                    break;
                case /* wrappers.CustomType SAMLAssertionInfo = 13 [json_name = "SAMLAssertionInfo"];*/ 13:
                    message.sAMLAssertionInfo = CustomType.internalBinaryRead(reader, reader.uint32(), options, message.sAMLAssertionInfo);
                    break;
                case /* wrappers.LabelValues SAMLTraitsFromAssertions = 14 [json_name = "SAMLTraitsFromAssertions"];*/ 14:
                    message.sAMLTraitsFromAssertions = LabelValues.internalBinaryRead(reader, reader.uint32(), options, message.sAMLTraitsFromAssertions);
                    break;
                case /* repeated types.TraitMapping SAMLConnectorTraitMapping = 15 [json_name = "SAMLConnectorTraitMapping"];*/ 15:
                    message.sAMLConnectorTraitMapping.push(TraitMapping.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated types.ClaimMapping OIDCClaimsToRoles = 20 [json_name = "OIDCClaimsToRoles"];*/ 20:
                    message.oIDCClaimsToRoles.push(ClaimMapping.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* types.SSOWarnings OIDCClaimsToRolesWarnings = 21 [json_name = "OIDCClaimsToRolesWarnings"];*/ 21:
                    message.oIDCClaimsToRolesWarnings = SSOWarnings.internalBinaryRead(reader, reader.uint32(), options, message.oIDCClaimsToRolesWarnings);
                    break;
                case /* wrappers.CustomType OIDCClaims = 22 [json_name = "OIDCClaims"];*/ 22:
                    message.oIDCClaims = CustomType.internalBinaryRead(reader, reader.uint32(), options, message.oIDCClaims);
                    break;
                case /* wrappers.CustomType OIDCIdentity = 23 [json_name = "OIDCIdentity"];*/ 23:
                    message.oIDCIdentity = CustomType.internalBinaryRead(reader, reader.uint32(), options, message.oIDCIdentity);
                    break;
                case /* wrappers.LabelValues OIDCTraitsFromClaims = 24 [json_name = "OIDCTraitsFromClaims"];*/ 24:
                    message.oIDCTraitsFromClaims = LabelValues.internalBinaryRead(reader, reader.uint32(), options, message.oIDCTraitsFromClaims);
                    break;
                case /* repeated types.TraitMapping OIDCConnectorTraitMapping = 25 [json_name = "OIDCConnectorTraitMapping"];*/ 25:
                    message.oIDCConnectorTraitMapping.push(TraitMapping.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* types.GithubClaims GithubClaims = 30 [json_name = "GithubClaims"];*/ 30:
                    message.githubClaims = GithubClaims.internalBinaryRead(reader, reader.uint32(), options, message.githubClaims);
                    break;
                case /* repeated types.TeamMapping GithubTeamsToLogins = 31 [json_name = "GithubTeamsToLogins"];*/ 31:
                    message.githubTeamsToLogins.push(TeamMapping.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated types.TeamRolesMapping GithubTeamsToRoles = 32 [json_name = "GithubTeamsToRoles"];*/ 32:
                    message.githubTeamsToRoles.push(TeamRolesMapping.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* types.GithubTokenInfo GithubTokenInfo = 33 [json_name = "GithubTokenInfo"];*/ 33:
                    message.githubTokenInfo = GithubTokenInfo.internalBinaryRead(reader, reader.uint32(), options, message.githubTokenInfo);
                    break;
                case /* repeated string AppliedLoginRules = 34 [json_name = "AppliedLoginRules"];*/ 34:
                    message.appliedLoginRules.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SSODiagnosticInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool TestFlow = 1 [json_name = "TestFlow"]; */
        if (message.testFlow !== false)
            writer.tag(1, WireType.Varint).bool(message.testFlow);
        /* string Error = 2 [json_name = "Error"]; */
        if (message.error !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.error);
        /* bool Success = 3 [json_name = "Success"]; */
        if (message.success !== false)
            writer.tag(3, WireType.Varint).bool(message.success);
        /* types.CreateUserParams CreateUserParams = 4 [json_name = "CreateUserParams"]; */
        if (message.createUserParams)
            CreateUserParams.internalBinaryWrite(message.createUserParams, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated types.AttributeMapping SAMLAttributesToRoles = 10 [json_name = "SAMLAttributesToRoles"]; */
        for (let i = 0; i < message.sAMLAttributesToRoles.length; i++)
            AttributeMapping.internalBinaryWrite(message.sAMLAttributesToRoles[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* types.SSOWarnings SAMLAttributesToRolesWarnings = 11 [json_name = "SAMLAttributesToRolesWarnings"]; */
        if (message.sAMLAttributesToRolesWarnings)
            SSOWarnings.internalBinaryWrite(message.sAMLAttributesToRolesWarnings, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* wrappers.LabelValues SAMLAttributeStatements = 12 [json_name = "SAMLAttributeStatements"]; */
        if (message.sAMLAttributeStatements)
            LabelValues.internalBinaryWrite(message.sAMLAttributeStatements, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* wrappers.CustomType SAMLAssertionInfo = 13 [json_name = "SAMLAssertionInfo"]; */
        if (message.sAMLAssertionInfo)
            CustomType.internalBinaryWrite(message.sAMLAssertionInfo, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* wrappers.LabelValues SAMLTraitsFromAssertions = 14 [json_name = "SAMLTraitsFromAssertions"]; */
        if (message.sAMLTraitsFromAssertions)
            LabelValues.internalBinaryWrite(message.sAMLTraitsFromAssertions, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* repeated types.TraitMapping SAMLConnectorTraitMapping = 15 [json_name = "SAMLConnectorTraitMapping"]; */
        for (let i = 0; i < message.sAMLConnectorTraitMapping.length; i++)
            TraitMapping.internalBinaryWrite(message.sAMLConnectorTraitMapping[i], writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* repeated types.ClaimMapping OIDCClaimsToRoles = 20 [json_name = "OIDCClaimsToRoles"]; */
        for (let i = 0; i < message.oIDCClaimsToRoles.length; i++)
            ClaimMapping.internalBinaryWrite(message.oIDCClaimsToRoles[i], writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* types.SSOWarnings OIDCClaimsToRolesWarnings = 21 [json_name = "OIDCClaimsToRolesWarnings"]; */
        if (message.oIDCClaimsToRolesWarnings)
            SSOWarnings.internalBinaryWrite(message.oIDCClaimsToRolesWarnings, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        /* wrappers.CustomType OIDCClaims = 22 [json_name = "OIDCClaims"]; */
        if (message.oIDCClaims)
            CustomType.internalBinaryWrite(message.oIDCClaims, writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        /* wrappers.CustomType OIDCIdentity = 23 [json_name = "OIDCIdentity"]; */
        if (message.oIDCIdentity)
            CustomType.internalBinaryWrite(message.oIDCIdentity, writer.tag(23, WireType.LengthDelimited).fork(), options).join();
        /* wrappers.LabelValues OIDCTraitsFromClaims = 24 [json_name = "OIDCTraitsFromClaims"]; */
        if (message.oIDCTraitsFromClaims)
            LabelValues.internalBinaryWrite(message.oIDCTraitsFromClaims, writer.tag(24, WireType.LengthDelimited).fork(), options).join();
        /* repeated types.TraitMapping OIDCConnectorTraitMapping = 25 [json_name = "OIDCConnectorTraitMapping"]; */
        for (let i = 0; i < message.oIDCConnectorTraitMapping.length; i++)
            TraitMapping.internalBinaryWrite(message.oIDCConnectorTraitMapping[i], writer.tag(25, WireType.LengthDelimited).fork(), options).join();
        /* types.GithubClaims GithubClaims = 30 [json_name = "GithubClaims"]; */
        if (message.githubClaims)
            GithubClaims.internalBinaryWrite(message.githubClaims, writer.tag(30, WireType.LengthDelimited).fork(), options).join();
        /* repeated types.TeamMapping GithubTeamsToLogins = 31 [json_name = "GithubTeamsToLogins"]; */
        for (let i = 0; i < message.githubTeamsToLogins.length; i++)
            TeamMapping.internalBinaryWrite(message.githubTeamsToLogins[i], writer.tag(31, WireType.LengthDelimited).fork(), options).join();
        /* repeated types.TeamRolesMapping GithubTeamsToRoles = 32 [json_name = "GithubTeamsToRoles"]; */
        for (let i = 0; i < message.githubTeamsToRoles.length; i++)
            TeamRolesMapping.internalBinaryWrite(message.githubTeamsToRoles[i], writer.tag(32, WireType.LengthDelimited).fork(), options).join();
        /* types.GithubTokenInfo GithubTokenInfo = 33 [json_name = "GithubTokenInfo"]; */
        if (message.githubTokenInfo)
            GithubTokenInfo.internalBinaryWrite(message.githubTokenInfo, writer.tag(33, WireType.LengthDelimited).fork(), options).join();
        /* repeated string AppliedLoginRules = 34 [json_name = "AppliedLoginRules"]; */
        for (let i = 0; i < message.appliedLoginRules.length; i++)
            writer.tag(34, WireType.LengthDelimited).string(message.appliedLoginRules[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.SSODiagnosticInfo
 */
export const SSODiagnosticInfo = new SSODiagnosticInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GithubTokenInfo$Type extends MessageType<GithubTokenInfo> {
    constructor() {
        super("types.GithubTokenInfo", [
            { no: 1, name: "TokenType", kind: "scalar", jsonName: "TokenType", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "token_type" } },
            { no: 2, name: "Expires", kind: "scalar", jsonName: "Expires", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "expires" } },
            { no: 3, name: "Scope", kind: "scalar", jsonName: "Scope", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "scope" } }
        ]);
    }
    create(value?: PartialMessage<GithubTokenInfo>): GithubTokenInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tokenType = "";
        message.expires = 0n;
        message.scope = "";
        if (value !== undefined)
            reflectionMergePartial<GithubTokenInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GithubTokenInfo): GithubTokenInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string TokenType = 1 [json_name = "TokenType"];*/ 1:
                    message.tokenType = reader.string();
                    break;
                case /* int64 Expires = 2 [json_name = "Expires"];*/ 2:
                    message.expires = reader.int64().toBigInt();
                    break;
                case /* string Scope = 3 [json_name = "Scope"];*/ 3:
                    message.scope = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GithubTokenInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string TokenType = 1 [json_name = "TokenType"]; */
        if (message.tokenType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tokenType);
        /* int64 Expires = 2 [json_name = "Expires"]; */
        if (message.expires !== 0n)
            writer.tag(2, WireType.Varint).int64(message.expires);
        /* string Scope = 3 [json_name = "Scope"]; */
        if (message.scope !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.scope);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.GithubTokenInfo
 */
export const GithubTokenInfo = new GithubTokenInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GithubClaims$Type extends MessageType<GithubClaims> {
    constructor() {
        super("types.GithubClaims", [
            { no: 1, name: "Username", kind: "scalar", jsonName: "Username", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "username" } },
            { no: 2, name: "OrganizationToTeams", kind: "message", jsonName: "OrganizationToTeams", T: () => LabelValues, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/gravitational/teleport/api/types/wrappers.Traits", "gogoproto.jsontag": "organization_to_teams" } },
            { no: 3, name: "Teams", kind: "scalar", jsonName: "Teams", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "teams" } },
            { no: 4, name: "UserID", kind: "scalar", jsonName: "UserID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "user_id,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<GithubClaims>): GithubClaims {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.username = "";
        message.teams = [];
        message.userID = "";
        if (value !== undefined)
            reflectionMergePartial<GithubClaims>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GithubClaims): GithubClaims {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Username = 1 [json_name = "Username"];*/ 1:
                    message.username = reader.string();
                    break;
                case /* wrappers.LabelValues OrganizationToTeams = 2 [json_name = "OrganizationToTeams"];*/ 2:
                    message.organizationToTeams = LabelValues.internalBinaryRead(reader, reader.uint32(), options, message.organizationToTeams);
                    break;
                case /* repeated string Teams = 3 [json_name = "Teams"];*/ 3:
                    message.teams.push(reader.string());
                    break;
                case /* string UserID = 4 [json_name = "UserID"];*/ 4:
                    message.userID = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GithubClaims, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Username = 1 [json_name = "Username"]; */
        if (message.username !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.username);
        /* wrappers.LabelValues OrganizationToTeams = 2 [json_name = "OrganizationToTeams"]; */
        if (message.organizationToTeams)
            LabelValues.internalBinaryWrite(message.organizationToTeams, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated string Teams = 3 [json_name = "Teams"]; */
        for (let i = 0; i < message.teams.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.teams[i]);
        /* string UserID = 4 [json_name = "UserID"]; */
        if (message.userID !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.userID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.GithubClaims
 */
export const GithubClaims = new GithubClaims$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TeamMapping$Type extends MessageType<TeamMapping> {
    constructor() {
        super("types.TeamMapping", [
            { no: 1, name: "Organization", kind: "scalar", jsonName: "Organization", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "organization" } },
            { no: 2, name: "Team", kind: "scalar", jsonName: "Team", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "team" } },
            { no: 3, name: "Logins", kind: "scalar", jsonName: "Logins", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "logins,omitempty" } },
            { no: 4, name: "KubeGroups", kind: "scalar", jsonName: "KubeGroups", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kubernetes_groups,omitempty" } },
            { no: 5, name: "KubeUsers", kind: "scalar", jsonName: "KubeUsers", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kubernetes_users,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<TeamMapping>): TeamMapping {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.organization = "";
        message.team = "";
        message.logins = [];
        message.kubeGroups = [];
        message.kubeUsers = [];
        if (value !== undefined)
            reflectionMergePartial<TeamMapping>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TeamMapping): TeamMapping {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Organization = 1 [json_name = "Organization"];*/ 1:
                    message.organization = reader.string();
                    break;
                case /* string Team = 2 [json_name = "Team"];*/ 2:
                    message.team = reader.string();
                    break;
                case /* repeated string Logins = 3 [json_name = "Logins"];*/ 3:
                    message.logins.push(reader.string());
                    break;
                case /* repeated string KubeGroups = 4 [json_name = "KubeGroups"];*/ 4:
                    message.kubeGroups.push(reader.string());
                    break;
                case /* repeated string KubeUsers = 5 [json_name = "KubeUsers"];*/ 5:
                    message.kubeUsers.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TeamMapping, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Organization = 1 [json_name = "Organization"]; */
        if (message.organization !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.organization);
        /* string Team = 2 [json_name = "Team"]; */
        if (message.team !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.team);
        /* repeated string Logins = 3 [json_name = "Logins"]; */
        for (let i = 0; i < message.logins.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.logins[i]);
        /* repeated string KubeGroups = 4 [json_name = "KubeGroups"]; */
        for (let i = 0; i < message.kubeGroups.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.kubeGroups[i]);
        /* repeated string KubeUsers = 5 [json_name = "KubeUsers"]; */
        for (let i = 0; i < message.kubeUsers.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.kubeUsers[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.TeamMapping
 */
export const TeamMapping = new TeamMapping$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TeamRolesMapping$Type extends MessageType<TeamRolesMapping> {
    constructor() {
        super("types.TeamRolesMapping", [
            { no: 1, name: "Organization", kind: "scalar", jsonName: "Organization", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "organization" } },
            { no: 2, name: "Team", kind: "scalar", jsonName: "Team", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "team" } },
            { no: 3, name: "Roles", kind: "scalar", jsonName: "Roles", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "roles,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<TeamRolesMapping>): TeamRolesMapping {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.organization = "";
        message.team = "";
        message.roles = [];
        if (value !== undefined)
            reflectionMergePartial<TeamRolesMapping>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TeamRolesMapping): TeamRolesMapping {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Organization = 1 [json_name = "Organization"];*/ 1:
                    message.organization = reader.string();
                    break;
                case /* string Team = 2 [json_name = "Team"];*/ 2:
                    message.team = reader.string();
                    break;
                case /* repeated string Roles = 3 [json_name = "Roles"];*/ 3:
                    message.roles.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TeamRolesMapping, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Organization = 1 [json_name = "Organization"]; */
        if (message.organization !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.organization);
        /* string Team = 2 [json_name = "Team"]; */
        if (message.team !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.team);
        /* repeated string Roles = 3 [json_name = "Roles"]; */
        for (let i = 0; i < message.roles.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.roles[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.TeamRolesMapping
 */
export const TeamRolesMapping = new TeamRolesMapping$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrustedClusterV2$Type extends MessageType<TrustedClusterV2> {
    constructor() {
        super("types.TrustedClusterV2", [
            { no: 1, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 2, name: "SubKind", kind: "scalar", jsonName: "SubKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub_kind,omitempty" } },
            { no: 3, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version" } },
            { no: 4, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "metadata" } },
            { no: 5, name: "Spec", kind: "message", jsonName: "Spec", T: () => TrustedClusterSpecV2, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ], { "gogoproto.goproto_stringer": false });
    }
    create(value?: PartialMessage<TrustedClusterV2>): TrustedClusterV2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.subKind = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<TrustedClusterV2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrustedClusterV2): TrustedClusterV2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Kind = 1 [json_name = "Kind"];*/ 1:
                    message.kind = reader.string();
                    break;
                case /* string SubKind = 2 [json_name = "SubKind"];*/ 2:
                    message.subKind = reader.string();
                    break;
                case /* string Version = 3 [json_name = "Version"];*/ 3:
                    message.version = reader.string();
                    break;
                case /* types.Metadata Metadata = 4 [json_name = "Metadata"];*/ 4:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* types.TrustedClusterSpecV2 Spec = 5 [json_name = "Spec"];*/ 5:
                    message.spec = TrustedClusterSpecV2.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrustedClusterV2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Kind = 1 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string SubKind = 2 [json_name = "SubKind"]; */
        if (message.subKind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subKind);
        /* string Version = 3 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* types.Metadata Metadata = 4 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.TrustedClusterSpecV2 Spec = 5 [json_name = "Spec"]; */
        if (message.spec)
            TrustedClusterSpecV2.internalBinaryWrite(message.spec, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.TrustedClusterV2
 */
export const TrustedClusterV2 = new TrustedClusterV2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrustedClusterV2List$Type extends MessageType<TrustedClusterV2List> {
    constructor() {
        super("types.TrustedClusterV2List", [
            { no: 1, name: "TrustedClusters", kind: "message", jsonName: "TrustedClusters", repeat: 1 /*RepeatType.PACKED*/, T: () => TrustedClusterV2 }
        ]);
    }
    create(value?: PartialMessage<TrustedClusterV2List>): TrustedClusterV2List {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.trustedClusters = [];
        if (value !== undefined)
            reflectionMergePartial<TrustedClusterV2List>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrustedClusterV2List): TrustedClusterV2List {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.TrustedClusterV2 TrustedClusters = 1 [json_name = "TrustedClusters"];*/ 1:
                    message.trustedClusters.push(TrustedClusterV2.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrustedClusterV2List, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.TrustedClusterV2 TrustedClusters = 1 [json_name = "TrustedClusters"]; */
        for (let i = 0; i < message.trustedClusters.length; i++)
            TrustedClusterV2.internalBinaryWrite(message.trustedClusters[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.TrustedClusterV2List
 */
export const TrustedClusterV2List = new TrustedClusterV2List$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrustedClusterSpecV2$Type extends MessageType<TrustedClusterSpecV2> {
    constructor() {
        super("types.TrustedClusterSpecV2", [
            { no: 1, name: "Enabled", kind: "scalar", jsonName: "Enabled", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "enabled" } },
            { no: 2, name: "Roles", kind: "scalar", jsonName: "Roles", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "roles,omitempty" } },
            { no: 3, name: "Token", kind: "scalar", jsonName: "Token", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "token" } },
            { no: 4, name: "ProxyAddress", kind: "scalar", jsonName: "ProxyAddress", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "web_proxy_addr" } },
            { no: 5, name: "ReverseTunnelAddress", kind: "scalar", jsonName: "ReverseTunnelAddress", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "tunnel_addr" } },
            { no: 6, name: "RoleMap", kind: "message", jsonName: "RoleMap", repeat: 1 /*RepeatType.PACKED*/, T: () => RoleMapping, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "role_map,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<TrustedClusterSpecV2>): TrustedClusterSpecV2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.enabled = false;
        message.roles = [];
        message.token = "";
        message.proxyAddress = "";
        message.reverseTunnelAddress = "";
        message.roleMap = [];
        if (value !== undefined)
            reflectionMergePartial<TrustedClusterSpecV2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrustedClusterSpecV2): TrustedClusterSpecV2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool Enabled = 1 [json_name = "Enabled"];*/ 1:
                    message.enabled = reader.bool();
                    break;
                case /* repeated string Roles = 2 [json_name = "Roles"];*/ 2:
                    message.roles.push(reader.string());
                    break;
                case /* string Token = 3 [json_name = "Token"];*/ 3:
                    message.token = reader.string();
                    break;
                case /* string ProxyAddress = 4 [json_name = "ProxyAddress"];*/ 4:
                    message.proxyAddress = reader.string();
                    break;
                case /* string ReverseTunnelAddress = 5 [json_name = "ReverseTunnelAddress"];*/ 5:
                    message.reverseTunnelAddress = reader.string();
                    break;
                case /* repeated types.RoleMapping RoleMap = 6 [json_name = "RoleMap"];*/ 6:
                    message.roleMap.push(RoleMapping.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrustedClusterSpecV2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool Enabled = 1 [json_name = "Enabled"]; */
        if (message.enabled !== false)
            writer.tag(1, WireType.Varint).bool(message.enabled);
        /* repeated string Roles = 2 [json_name = "Roles"]; */
        for (let i = 0; i < message.roles.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.roles[i]);
        /* string Token = 3 [json_name = "Token"]; */
        if (message.token !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.token);
        /* string ProxyAddress = 4 [json_name = "ProxyAddress"]; */
        if (message.proxyAddress !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.proxyAddress);
        /* string ReverseTunnelAddress = 5 [json_name = "ReverseTunnelAddress"]; */
        if (message.reverseTunnelAddress !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.reverseTunnelAddress);
        /* repeated types.RoleMapping RoleMap = 6 [json_name = "RoleMap"]; */
        for (let i = 0; i < message.roleMap.length; i++)
            RoleMapping.internalBinaryWrite(message.roleMap[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.TrustedClusterSpecV2
 */
export const TrustedClusterSpecV2 = new TrustedClusterSpecV2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LockV2$Type extends MessageType<LockV2> {
    constructor() {
        super("types.LockV2", [
            { no: 1, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 2, name: "SubKind", kind: "scalar", jsonName: "SubKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub_kind,omitempty" } },
            { no: 3, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version" } },
            { no: 4, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "metadata" } },
            { no: 5, name: "Spec", kind: "message", jsonName: "Spec", T: () => LockSpecV2, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ]);
    }
    create(value?: PartialMessage<LockV2>): LockV2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.subKind = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<LockV2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LockV2): LockV2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Kind = 1 [json_name = "Kind"];*/ 1:
                    message.kind = reader.string();
                    break;
                case /* string SubKind = 2 [json_name = "SubKind"];*/ 2:
                    message.subKind = reader.string();
                    break;
                case /* string Version = 3 [json_name = "Version"];*/ 3:
                    message.version = reader.string();
                    break;
                case /* types.Metadata Metadata = 4 [json_name = "Metadata"];*/ 4:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* types.LockSpecV2 Spec = 5 [json_name = "Spec"];*/ 5:
                    message.spec = LockSpecV2.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LockV2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Kind = 1 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string SubKind = 2 [json_name = "SubKind"]; */
        if (message.subKind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subKind);
        /* string Version = 3 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* types.Metadata Metadata = 4 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.LockSpecV2 Spec = 5 [json_name = "Spec"]; */
        if (message.spec)
            LockSpecV2.internalBinaryWrite(message.spec, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.LockV2
 */
export const LockV2 = new LockV2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LockSpecV2$Type extends MessageType<LockSpecV2> {
    constructor() {
        super("types.LockSpecV2", [
            { no: 1, name: "Target", kind: "message", jsonName: "Target", T: () => LockTarget, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "target" } },
            { no: 2, name: "Message", kind: "scalar", jsonName: "Message", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "message,omitempty" } },
            { no: 3, name: "Expires", kind: "message", jsonName: "Expires", T: () => Timestamp, options: { "gogoproto.nullable": true, "gogoproto.jsontag": "expires,omitempty", "gogoproto.stdtime": true } },
            { no: 4, name: "CreatedAt", kind: "message", jsonName: "CreatedAt", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "created_at,omitempty", "gogoproto.stdtime": true } },
            { no: 5, name: "CreatedBy", kind: "scalar", jsonName: "CreatedBy", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "created_by,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<LockSpecV2>): LockSpecV2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.message = "";
        message.createdBy = "";
        if (value !== undefined)
            reflectionMergePartial<LockSpecV2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LockSpecV2): LockSpecV2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.LockTarget Target = 1 [json_name = "Target"];*/ 1:
                    message.target = LockTarget.internalBinaryRead(reader, reader.uint32(), options, message.target);
                    break;
                case /* string Message = 2 [json_name = "Message"];*/ 2:
                    message.message = reader.string();
                    break;
                case /* google.protobuf.Timestamp Expires = 3 [json_name = "Expires"];*/ 3:
                    message.expires = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expires);
                    break;
                case /* google.protobuf.Timestamp CreatedAt = 4 [json_name = "CreatedAt"];*/ 4:
                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                case /* string CreatedBy = 5 [json_name = "CreatedBy"];*/ 5:
                    message.createdBy = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LockSpecV2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.LockTarget Target = 1 [json_name = "Target"]; */
        if (message.target)
            LockTarget.internalBinaryWrite(message.target, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string Message = 2 [json_name = "Message"]; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        /* google.protobuf.Timestamp Expires = 3 [json_name = "Expires"]; */
        if (message.expires)
            Timestamp.internalBinaryWrite(message.expires, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp CreatedAt = 4 [json_name = "CreatedAt"]; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(message.createdAt, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string CreatedBy = 5 [json_name = "CreatedBy"]; */
        if (message.createdBy !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.createdBy);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.LockSpecV2
 */
export const LockSpecV2 = new LockSpecV2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LockTarget$Type extends MessageType<LockTarget> {
    constructor() {
        super("types.LockTarget", [
            { no: 1, name: "User", kind: "scalar", jsonName: "User", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "user,omitempty" } },
            { no: 2, name: "Role", kind: "scalar", jsonName: "Role", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "role,omitempty" } },
            { no: 3, name: "Login", kind: "scalar", jsonName: "Login", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "login,omitempty" } },
            { no: 5, name: "MFADevice", kind: "scalar", jsonName: "MFADevice", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "mfa_device,omitempty" } },
            { no: 6, name: "WindowsDesktop", kind: "scalar", jsonName: "WindowsDesktop", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "windows_desktop,omitempty" } },
            { no: 7, name: "AccessRequest", kind: "scalar", jsonName: "AccessRequest", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "access_request,omitempty" } },
            { no: 8, name: "Device", kind: "scalar", jsonName: "Device", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "device,omitempty" } },
            { no: 9, name: "ServerID", kind: "scalar", jsonName: "ServerID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "server_id,omitempty" } }
        ], { "gogoproto.goproto_stringer": false, "gogoproto.stringer": false });
    }
    create(value?: PartialMessage<LockTarget>): LockTarget {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.user = "";
        message.role = "";
        message.login = "";
        message.mFADevice = "";
        message.windowsDesktop = "";
        message.accessRequest = "";
        message.device = "";
        message.serverID = "";
        if (value !== undefined)
            reflectionMergePartial<LockTarget>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LockTarget): LockTarget {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string User = 1 [json_name = "User"];*/ 1:
                    message.user = reader.string();
                    break;
                case /* string Role = 2 [json_name = "Role"];*/ 2:
                    message.role = reader.string();
                    break;
                case /* string Login = 3 [json_name = "Login"];*/ 3:
                    message.login = reader.string();
                    break;
                case /* string MFADevice = 5 [json_name = "MFADevice"];*/ 5:
                    message.mFADevice = reader.string();
                    break;
                case /* string WindowsDesktop = 6 [json_name = "WindowsDesktop"];*/ 6:
                    message.windowsDesktop = reader.string();
                    break;
                case /* string AccessRequest = 7 [json_name = "AccessRequest"];*/ 7:
                    message.accessRequest = reader.string();
                    break;
                case /* string Device = 8 [json_name = "Device"];*/ 8:
                    message.device = reader.string();
                    break;
                case /* string ServerID = 9 [json_name = "ServerID"];*/ 9:
                    message.serverID = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LockTarget, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string User = 1 [json_name = "User"]; */
        if (message.user !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.user);
        /* string Role = 2 [json_name = "Role"]; */
        if (message.role !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.role);
        /* string Login = 3 [json_name = "Login"]; */
        if (message.login !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.login);
        /* string MFADevice = 5 [json_name = "MFADevice"]; */
        if (message.mFADevice !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.mFADevice);
        /* string WindowsDesktop = 6 [json_name = "WindowsDesktop"]; */
        if (message.windowsDesktop !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.windowsDesktop);
        /* string AccessRequest = 7 [json_name = "AccessRequest"]; */
        if (message.accessRequest !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.accessRequest);
        /* string Device = 8 [json_name = "Device"]; */
        if (message.device !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.device);
        /* string ServerID = 9 [json_name = "ServerID"]; */
        if (message.serverID !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.serverID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.LockTarget
 */
export const LockTarget = new LockTarget$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddressCondition$Type extends MessageType<AddressCondition> {
    constructor() {
        super("types.AddressCondition", [
            { no: 1, name: "CIDR", kind: "scalar", jsonName: "CIDR", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "cidr" } }
        ]);
    }
    create(value?: PartialMessage<AddressCondition>): AddressCondition {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cIDR = "";
        if (value !== undefined)
            reflectionMergePartial<AddressCondition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AddressCondition): AddressCondition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string CIDR = 1 [json_name = "CIDR"];*/ 1:
                    message.cIDR = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AddressCondition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string CIDR = 1 [json_name = "CIDR"]; */
        if (message.cIDR !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.cIDR);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AddressCondition
 */
export const AddressCondition = new AddressCondition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NetworkRestrictionsSpecV4$Type extends MessageType<NetworkRestrictionsSpecV4> {
    constructor() {
        super("types.NetworkRestrictionsSpecV4", [
            { no: 1, name: "Allow", kind: "message", jsonName: "Allow", repeat: 1 /*RepeatType.PACKED*/, T: () => AddressCondition, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "allow" } },
            { no: 2, name: "Deny", kind: "message", jsonName: "Deny", repeat: 1 /*RepeatType.PACKED*/, T: () => AddressCondition, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "deny" } }
        ]);
    }
    create(value?: PartialMessage<NetworkRestrictionsSpecV4>): NetworkRestrictionsSpecV4 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.allow = [];
        message.deny = [];
        if (value !== undefined)
            reflectionMergePartial<NetworkRestrictionsSpecV4>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NetworkRestrictionsSpecV4): NetworkRestrictionsSpecV4 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.AddressCondition Allow = 1 [json_name = "Allow"];*/ 1:
                    message.allow.push(AddressCondition.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated types.AddressCondition Deny = 2 [json_name = "Deny"];*/ 2:
                    message.deny.push(AddressCondition.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NetworkRestrictionsSpecV4, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.AddressCondition Allow = 1 [json_name = "Allow"]; */
        for (let i = 0; i < message.allow.length; i++)
            AddressCondition.internalBinaryWrite(message.allow[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated types.AddressCondition Deny = 2 [json_name = "Deny"]; */
        for (let i = 0; i < message.deny.length; i++)
            AddressCondition.internalBinaryWrite(message.deny[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.NetworkRestrictionsSpecV4
 */
export const NetworkRestrictionsSpecV4 = new NetworkRestrictionsSpecV4$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NetworkRestrictionsV4$Type extends MessageType<NetworkRestrictionsV4> {
    constructor() {
        super("types.NetworkRestrictionsV4", [
            { no: 1, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 2, name: "SubKind", kind: "scalar", jsonName: "SubKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub_kind,omitempty" } },
            { no: 3, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version" } },
            { no: 4, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "metadata" } },
            { no: 5, name: "Spec", kind: "message", jsonName: "Spec", T: () => NetworkRestrictionsSpecV4, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ]);
    }
    create(value?: PartialMessage<NetworkRestrictionsV4>): NetworkRestrictionsV4 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.subKind = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<NetworkRestrictionsV4>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NetworkRestrictionsV4): NetworkRestrictionsV4 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Kind = 1 [json_name = "Kind"];*/ 1:
                    message.kind = reader.string();
                    break;
                case /* string SubKind = 2 [json_name = "SubKind"];*/ 2:
                    message.subKind = reader.string();
                    break;
                case /* string Version = 3 [json_name = "Version"];*/ 3:
                    message.version = reader.string();
                    break;
                case /* types.Metadata Metadata = 4 [json_name = "Metadata"];*/ 4:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* types.NetworkRestrictionsSpecV4 Spec = 5 [json_name = "Spec"];*/ 5:
                    message.spec = NetworkRestrictionsSpecV4.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NetworkRestrictionsV4, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Kind = 1 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string SubKind = 2 [json_name = "SubKind"]; */
        if (message.subKind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subKind);
        /* string Version = 3 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* types.Metadata Metadata = 4 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.NetworkRestrictionsSpecV4 Spec = 5 [json_name = "Spec"]; */
        if (message.spec)
            NetworkRestrictionsSpecV4.internalBinaryWrite(message.spec, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.NetworkRestrictionsV4
 */
export const NetworkRestrictionsV4 = new NetworkRestrictionsV4$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WindowsDesktopServiceV3$Type extends MessageType<WindowsDesktopServiceV3> {
    constructor() {
        super("types.WindowsDesktopServiceV3", [
            { no: 1, name: "Header", kind: "message", jsonName: "Header", T: () => ResourceHeader, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Spec", kind: "message", jsonName: "Spec", T: () => WindowsDesktopServiceSpecV3, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ]);
    }
    create(value?: PartialMessage<WindowsDesktopServiceV3>): WindowsDesktopServiceV3 {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<WindowsDesktopServiceV3>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WindowsDesktopServiceV3): WindowsDesktopServiceV3 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.ResourceHeader Header = 1 [json_name = "Header"];*/ 1:
                    message.header = ResourceHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* types.WindowsDesktopServiceSpecV3 Spec = 2 [json_name = "Spec"];*/ 2:
                    message.spec = WindowsDesktopServiceSpecV3.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WindowsDesktopServiceV3, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.ResourceHeader Header = 1 [json_name = "Header"]; */
        if (message.header)
            ResourceHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* types.WindowsDesktopServiceSpecV3 Spec = 2 [json_name = "Spec"]; */
        if (message.spec)
            WindowsDesktopServiceSpecV3.internalBinaryWrite(message.spec, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.WindowsDesktopServiceV3
 */
export const WindowsDesktopServiceV3 = new WindowsDesktopServiceV3$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WindowsDesktopServiceSpecV3$Type extends MessageType<WindowsDesktopServiceSpecV3> {
    constructor() {
        super("types.WindowsDesktopServiceSpecV3", [
            { no: 1, name: "Addr", kind: "scalar", jsonName: "Addr", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "addr" } },
            { no: 2, name: "TeleportVersion", kind: "scalar", jsonName: "TeleportVersion", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "teleport_version" } },
            { no: 3, name: "Hostname", kind: "scalar", jsonName: "Hostname", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "hostname" } },
            { no: 4, name: "ProxyIDs", kind: "scalar", jsonName: "ProxyIDs", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "proxy_ids,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<WindowsDesktopServiceSpecV3>): WindowsDesktopServiceSpecV3 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.addr = "";
        message.teleportVersion = "";
        message.hostname = "";
        message.proxyIDs = [];
        if (value !== undefined)
            reflectionMergePartial<WindowsDesktopServiceSpecV3>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WindowsDesktopServiceSpecV3): WindowsDesktopServiceSpecV3 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Addr = 1 [json_name = "Addr"];*/ 1:
                    message.addr = reader.string();
                    break;
                case /* string TeleportVersion = 2 [json_name = "TeleportVersion"];*/ 2:
                    message.teleportVersion = reader.string();
                    break;
                case /* string Hostname = 3 [json_name = "Hostname"];*/ 3:
                    message.hostname = reader.string();
                    break;
                case /* repeated string ProxyIDs = 4 [json_name = "ProxyIDs"];*/ 4:
                    message.proxyIDs.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WindowsDesktopServiceSpecV3, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Addr = 1 [json_name = "Addr"]; */
        if (message.addr !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.addr);
        /* string TeleportVersion = 2 [json_name = "TeleportVersion"]; */
        if (message.teleportVersion !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.teleportVersion);
        /* string Hostname = 3 [json_name = "Hostname"]; */
        if (message.hostname !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.hostname);
        /* repeated string ProxyIDs = 4 [json_name = "ProxyIDs"]; */
        for (let i = 0; i < message.proxyIDs.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.proxyIDs[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.WindowsDesktopServiceSpecV3
 */
export const WindowsDesktopServiceSpecV3 = new WindowsDesktopServiceSpecV3$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WindowsDesktopFilter$Type extends MessageType<WindowsDesktopFilter> {
    constructor() {
        super("types.WindowsDesktopFilter", [
            { no: 1, name: "HostID", kind: "scalar", jsonName: "HostID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "host_id" } },
            { no: 2, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "name" } }
        ]);
    }
    create(value?: PartialMessage<WindowsDesktopFilter>): WindowsDesktopFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hostID = "";
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<WindowsDesktopFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WindowsDesktopFilter): WindowsDesktopFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string HostID = 1 [json_name = "HostID"];*/ 1:
                    message.hostID = reader.string();
                    break;
                case /* string Name = 2 [json_name = "Name"];*/ 2:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WindowsDesktopFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string HostID = 1 [json_name = "HostID"]; */
        if (message.hostID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.hostID);
        /* string Name = 2 [json_name = "Name"]; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.WindowsDesktopFilter
 */
export const WindowsDesktopFilter = new WindowsDesktopFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WindowsDesktopV3$Type extends MessageType<WindowsDesktopV3> {
    constructor() {
        super("types.WindowsDesktopV3", [
            { no: 1, name: "Header", kind: "message", jsonName: "Header", T: () => ResourceHeader, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Spec", kind: "message", jsonName: "Spec", T: () => WindowsDesktopSpecV3, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ]);
    }
    create(value?: PartialMessage<WindowsDesktopV3>): WindowsDesktopV3 {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<WindowsDesktopV3>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WindowsDesktopV3): WindowsDesktopV3 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.ResourceHeader Header = 1 [json_name = "Header"];*/ 1:
                    message.header = ResourceHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* types.WindowsDesktopSpecV3 Spec = 2 [json_name = "Spec"];*/ 2:
                    message.spec = WindowsDesktopSpecV3.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WindowsDesktopV3, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.ResourceHeader Header = 1 [json_name = "Header"]; */
        if (message.header)
            ResourceHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* types.WindowsDesktopSpecV3 Spec = 2 [json_name = "Spec"]; */
        if (message.spec)
            WindowsDesktopSpecV3.internalBinaryWrite(message.spec, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.WindowsDesktopV3
 */
export const WindowsDesktopV3 = new WindowsDesktopV3$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WindowsDesktopSpecV3$Type extends MessageType<WindowsDesktopSpecV3> {
    constructor() {
        super("types.WindowsDesktopSpecV3", [
            { no: 1, name: "Addr", kind: "scalar", jsonName: "Addr", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "addr" } },
            { no: 2, name: "Domain", kind: "scalar", jsonName: "Domain", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "domain" } },
            { no: 3, name: "HostID", kind: "scalar", jsonName: "HostID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "host_id" } },
            { no: 4, name: "NonAD", kind: "scalar", jsonName: "NonAD", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "non_ad" } },
            { no: 5, name: "ScreenSize", kind: "message", jsonName: "ScreenSize", T: () => Resolution, options: { "gogoproto.jsontag": "screen_size,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<WindowsDesktopSpecV3>): WindowsDesktopSpecV3 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.addr = "";
        message.domain = "";
        message.hostID = "";
        message.nonAD = false;
        if (value !== undefined)
            reflectionMergePartial<WindowsDesktopSpecV3>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WindowsDesktopSpecV3): WindowsDesktopSpecV3 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Addr = 1 [json_name = "Addr"];*/ 1:
                    message.addr = reader.string();
                    break;
                case /* string Domain = 2 [json_name = "Domain"];*/ 2:
                    message.domain = reader.string();
                    break;
                case /* string HostID = 3 [json_name = "HostID"];*/ 3:
                    message.hostID = reader.string();
                    break;
                case /* bool NonAD = 4 [json_name = "NonAD"];*/ 4:
                    message.nonAD = reader.bool();
                    break;
                case /* types.Resolution ScreenSize = 5 [json_name = "ScreenSize"];*/ 5:
                    message.screenSize = Resolution.internalBinaryRead(reader, reader.uint32(), options, message.screenSize);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WindowsDesktopSpecV3, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Addr = 1 [json_name = "Addr"]; */
        if (message.addr !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.addr);
        /* string Domain = 2 [json_name = "Domain"]; */
        if (message.domain !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.domain);
        /* string HostID = 3 [json_name = "HostID"]; */
        if (message.hostID !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.hostID);
        /* bool NonAD = 4 [json_name = "NonAD"]; */
        if (message.nonAD !== false)
            writer.tag(4, WireType.Varint).bool(message.nonAD);
        /* types.Resolution ScreenSize = 5 [json_name = "ScreenSize"]; */
        if (message.screenSize)
            Resolution.internalBinaryWrite(message.screenSize, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.WindowsDesktopSpecV3
 */
export const WindowsDesktopSpecV3 = new WindowsDesktopSpecV3$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DynamicWindowsDesktopV1$Type extends MessageType<DynamicWindowsDesktopV1> {
    constructor() {
        super("types.DynamicWindowsDesktopV1", [
            { no: 1, name: "Header", kind: "message", jsonName: "Header", T: () => ResourceHeader, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Spec", kind: "message", jsonName: "Spec", T: () => DynamicWindowsDesktopSpecV1, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ]);
    }
    create(value?: PartialMessage<DynamicWindowsDesktopV1>): DynamicWindowsDesktopV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DynamicWindowsDesktopV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DynamicWindowsDesktopV1): DynamicWindowsDesktopV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.ResourceHeader Header = 1 [json_name = "Header"];*/ 1:
                    message.header = ResourceHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* types.DynamicWindowsDesktopSpecV1 Spec = 2 [json_name = "Spec"];*/ 2:
                    message.spec = DynamicWindowsDesktopSpecV1.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DynamicWindowsDesktopV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.ResourceHeader Header = 1 [json_name = "Header"]; */
        if (message.header)
            ResourceHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* types.DynamicWindowsDesktopSpecV1 Spec = 2 [json_name = "Spec"]; */
        if (message.spec)
            DynamicWindowsDesktopSpecV1.internalBinaryWrite(message.spec, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.DynamicWindowsDesktopV1
 */
export const DynamicWindowsDesktopV1 = new DynamicWindowsDesktopV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DynamicWindowsDesktopSpecV1$Type extends MessageType<DynamicWindowsDesktopSpecV1> {
    constructor() {
        super("types.DynamicWindowsDesktopSpecV1", [
            { no: 1, name: "Addr", kind: "scalar", jsonName: "Addr", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "addr" } },
            { no: 2, name: "Domain", kind: "scalar", jsonName: "Domain", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "domain" } },
            { no: 4, name: "NonAD", kind: "scalar", jsonName: "NonAD", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "non_ad" } },
            { no: 5, name: "ScreenSize", kind: "message", jsonName: "ScreenSize", T: () => Resolution, options: { "gogoproto.jsontag": "screen_size,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<DynamicWindowsDesktopSpecV1>): DynamicWindowsDesktopSpecV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.addr = "";
        message.domain = "";
        message.nonAD = false;
        if (value !== undefined)
            reflectionMergePartial<DynamicWindowsDesktopSpecV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DynamicWindowsDesktopSpecV1): DynamicWindowsDesktopSpecV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Addr = 1 [json_name = "Addr"];*/ 1:
                    message.addr = reader.string();
                    break;
                case /* string Domain = 2 [json_name = "Domain"];*/ 2:
                    message.domain = reader.string();
                    break;
                case /* bool NonAD = 4 [json_name = "NonAD"];*/ 4:
                    message.nonAD = reader.bool();
                    break;
                case /* types.Resolution ScreenSize = 5 [json_name = "ScreenSize"];*/ 5:
                    message.screenSize = Resolution.internalBinaryRead(reader, reader.uint32(), options, message.screenSize);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DynamicWindowsDesktopSpecV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Addr = 1 [json_name = "Addr"]; */
        if (message.addr !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.addr);
        /* string Domain = 2 [json_name = "Domain"]; */
        if (message.domain !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.domain);
        /* bool NonAD = 4 [json_name = "NonAD"]; */
        if (message.nonAD !== false)
            writer.tag(4, WireType.Varint).bool(message.nonAD);
        /* types.Resolution ScreenSize = 5 [json_name = "ScreenSize"]; */
        if (message.screenSize)
            Resolution.internalBinaryWrite(message.screenSize, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.DynamicWindowsDesktopSpecV1
 */
export const DynamicWindowsDesktopSpecV1 = new DynamicWindowsDesktopSpecV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Resolution$Type extends MessageType<Resolution> {
    constructor() {
        super("types.Resolution", [
            { no: 1, name: "Width", kind: "scalar", jsonName: "Width", T: 13 /*ScalarType.UINT32*/, options: { "gogoproto.jsontag": "width,omitempty" } },
            { no: 2, name: "Height", kind: "scalar", jsonName: "Height", T: 13 /*ScalarType.UINT32*/, options: { "gogoproto.jsontag": "height,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<Resolution>): Resolution {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.width = 0;
        message.height = 0;
        if (value !== undefined)
            reflectionMergePartial<Resolution>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Resolution): Resolution {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 Width = 1 [json_name = "Width"];*/ 1:
                    message.width = reader.uint32();
                    break;
                case /* uint32 Height = 2 [json_name = "Height"];*/ 2:
                    message.height = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Resolution, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 Width = 1 [json_name = "Width"]; */
        if (message.width !== 0)
            writer.tag(1, WireType.Varint).uint32(message.width);
        /* uint32 Height = 2 [json_name = "Height"]; */
        if (message.height !== 0)
            writer.tag(2, WireType.Varint).uint32(message.height);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.Resolution
 */
export const Resolution = new Resolution$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterUsingTokenRequest$Type extends MessageType<RegisterUsingTokenRequest> {
    constructor() {
        super("types.RegisterUsingTokenRequest", [
            { no: 1, name: "HostID", kind: "scalar", jsonName: "HostID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "hostID" } },
            { no: 2, name: "NodeName", kind: "scalar", jsonName: "NodeName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "node_name" } },
            { no: 3, name: "Role", kind: "scalar", jsonName: "Role", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "role", "gogoproto.casttype": "SystemRole" } },
            { no: 4, name: "Token", kind: "scalar", jsonName: "Token", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "token" } },
            { no: 5, name: "AdditionalPrincipals", kind: "scalar", jsonName: "AdditionalPrincipals", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "additional_principals" } },
            { no: 6, name: "DNSNames", kind: "scalar", jsonName: "DNSNames", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "dns_names" } },
            { no: 7, name: "PublicTLSKey", kind: "scalar", jsonName: "PublicTLSKey", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.jsontag": "public_tls_key" } },
            { no: 8, name: "PublicSSHKey", kind: "scalar", jsonName: "PublicSSHKey", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.jsontag": "public_ssh_key" } },
            { no: 9, name: "RemoteAddr", kind: "scalar", jsonName: "RemoteAddr", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "remote_addr" } },
            { no: 10, name: "EC2IdentityDocument", kind: "scalar", jsonName: "EC2IdentityDocument", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.jsontag": "ec2_id" } },
            { no: 11, name: "IDToken", kind: "scalar", jsonName: "IDToken", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "id_token" } },
            { no: 12, name: "Expires", kind: "message", jsonName: "Expires", T: () => Timestamp, options: { "gogoproto.jsontag": "expires,omitempty", "gogoproto.stdtime": true } },
            { no: 13, name: "BotInstanceID", kind: "scalar", jsonName: "BotInstanceID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "bot_instance_id" } },
            { no: 14, name: "BotGeneration", kind: "scalar", jsonName: "BotGeneration", T: 5 /*ScalarType.INT32*/, options: { "gogoproto.jsontag": "bot_generation" } }
        ]);
    }
    create(value?: PartialMessage<RegisterUsingTokenRequest>): RegisterUsingTokenRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hostID = "";
        message.nodeName = "";
        message.role = "";
        message.token = "";
        message.additionalPrincipals = [];
        message.dNSNames = [];
        message.publicTLSKey = new Uint8Array(0);
        message.publicSSHKey = new Uint8Array(0);
        message.remoteAddr = "";
        message.eC2IdentityDocument = new Uint8Array(0);
        message.iDToken = "";
        message.botInstanceID = "";
        message.botGeneration = 0;
        if (value !== undefined)
            reflectionMergePartial<RegisterUsingTokenRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterUsingTokenRequest): RegisterUsingTokenRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string HostID = 1 [json_name = "HostID"];*/ 1:
                    message.hostID = reader.string();
                    break;
                case /* string NodeName = 2 [json_name = "NodeName"];*/ 2:
                    message.nodeName = reader.string();
                    break;
                case /* string Role = 3 [json_name = "Role"];*/ 3:
                    message.role = reader.string();
                    break;
                case /* string Token = 4 [json_name = "Token"];*/ 4:
                    message.token = reader.string();
                    break;
                case /* repeated string AdditionalPrincipals = 5 [json_name = "AdditionalPrincipals"];*/ 5:
                    message.additionalPrincipals.push(reader.string());
                    break;
                case /* repeated string DNSNames = 6 [json_name = "DNSNames"];*/ 6:
                    message.dNSNames.push(reader.string());
                    break;
                case /* bytes PublicTLSKey = 7 [json_name = "PublicTLSKey"];*/ 7:
                    message.publicTLSKey = reader.bytes();
                    break;
                case /* bytes PublicSSHKey = 8 [json_name = "PublicSSHKey"];*/ 8:
                    message.publicSSHKey = reader.bytes();
                    break;
                case /* string RemoteAddr = 9 [json_name = "RemoteAddr"];*/ 9:
                    message.remoteAddr = reader.string();
                    break;
                case /* bytes EC2IdentityDocument = 10 [json_name = "EC2IdentityDocument"];*/ 10:
                    message.eC2IdentityDocument = reader.bytes();
                    break;
                case /* string IDToken = 11 [json_name = "IDToken"];*/ 11:
                    message.iDToken = reader.string();
                    break;
                case /* google.protobuf.Timestamp Expires = 12 [json_name = "Expires"];*/ 12:
                    message.expires = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expires);
                    break;
                case /* string BotInstanceID = 13 [json_name = "BotInstanceID"];*/ 13:
                    message.botInstanceID = reader.string();
                    break;
                case /* int32 BotGeneration = 14 [json_name = "BotGeneration"];*/ 14:
                    message.botGeneration = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegisterUsingTokenRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string HostID = 1 [json_name = "HostID"]; */
        if (message.hostID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.hostID);
        /* string NodeName = 2 [json_name = "NodeName"]; */
        if (message.nodeName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.nodeName);
        /* string Role = 3 [json_name = "Role"]; */
        if (message.role !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.role);
        /* string Token = 4 [json_name = "Token"]; */
        if (message.token !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.token);
        /* repeated string AdditionalPrincipals = 5 [json_name = "AdditionalPrincipals"]; */
        for (let i = 0; i < message.additionalPrincipals.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.additionalPrincipals[i]);
        /* repeated string DNSNames = 6 [json_name = "DNSNames"]; */
        for (let i = 0; i < message.dNSNames.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.dNSNames[i]);
        /* bytes PublicTLSKey = 7 [json_name = "PublicTLSKey"]; */
        if (message.publicTLSKey.length)
            writer.tag(7, WireType.LengthDelimited).bytes(message.publicTLSKey);
        /* bytes PublicSSHKey = 8 [json_name = "PublicSSHKey"]; */
        if (message.publicSSHKey.length)
            writer.tag(8, WireType.LengthDelimited).bytes(message.publicSSHKey);
        /* string RemoteAddr = 9 [json_name = "RemoteAddr"]; */
        if (message.remoteAddr !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.remoteAddr);
        /* bytes EC2IdentityDocument = 10 [json_name = "EC2IdentityDocument"]; */
        if (message.eC2IdentityDocument.length)
            writer.tag(10, WireType.LengthDelimited).bytes(message.eC2IdentityDocument);
        /* string IDToken = 11 [json_name = "IDToken"]; */
        if (message.iDToken !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.iDToken);
        /* google.protobuf.Timestamp Expires = 12 [json_name = "Expires"]; */
        if (message.expires)
            Timestamp.internalBinaryWrite(message.expires, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* string BotInstanceID = 13 [json_name = "BotInstanceID"]; */
        if (message.botInstanceID !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.botInstanceID);
        /* int32 BotGeneration = 14 [json_name = "BotGeneration"]; */
        if (message.botGeneration !== 0)
            writer.tag(14, WireType.Varint).int32(message.botGeneration);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.RegisterUsingTokenRequest
 */
export const RegisterUsingTokenRequest = new RegisterUsingTokenRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RecoveryCodesV1$Type extends MessageType<RecoveryCodesV1> {
    constructor() {
        super("types.RecoveryCodesV1", [
            { no: 1, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 2, name: "SubKind", kind: "scalar", jsonName: "SubKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub_kind,omitempty" } },
            { no: 3, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version" } },
            { no: 4, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "metadata" } },
            { no: 5, name: "Spec", kind: "message", jsonName: "Spec", T: () => RecoveryCodesSpecV1, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ]);
    }
    create(value?: PartialMessage<RecoveryCodesV1>): RecoveryCodesV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.subKind = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<RecoveryCodesV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RecoveryCodesV1): RecoveryCodesV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Kind = 1 [json_name = "Kind"];*/ 1:
                    message.kind = reader.string();
                    break;
                case /* string SubKind = 2 [json_name = "SubKind"];*/ 2:
                    message.subKind = reader.string();
                    break;
                case /* string Version = 3 [json_name = "Version"];*/ 3:
                    message.version = reader.string();
                    break;
                case /* types.Metadata Metadata = 4 [json_name = "Metadata"];*/ 4:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* types.RecoveryCodesSpecV1 Spec = 5 [json_name = "Spec"];*/ 5:
                    message.spec = RecoveryCodesSpecV1.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RecoveryCodesV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Kind = 1 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string SubKind = 2 [json_name = "SubKind"]; */
        if (message.subKind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subKind);
        /* string Version = 3 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* types.Metadata Metadata = 4 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.RecoveryCodesSpecV1 Spec = 5 [json_name = "Spec"]; */
        if (message.spec)
            RecoveryCodesSpecV1.internalBinaryWrite(message.spec, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.RecoveryCodesV1
 */
export const RecoveryCodesV1 = new RecoveryCodesV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RecoveryCodesSpecV1$Type extends MessageType<RecoveryCodesSpecV1> {
    constructor() {
        super("types.RecoveryCodesSpecV1", [
            { no: 1, name: "Codes", kind: "message", jsonName: "Codes", repeat: 1 /*RepeatType.PACKED*/, T: () => RecoveryCode, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "codes" } },
            { no: 2, name: "Created", kind: "message", jsonName: "Created", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "created", "gogoproto.stdtime": true } }
        ]);
    }
    create(value?: PartialMessage<RecoveryCodesSpecV1>): RecoveryCodesSpecV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.codes = [];
        if (value !== undefined)
            reflectionMergePartial<RecoveryCodesSpecV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RecoveryCodesSpecV1): RecoveryCodesSpecV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.RecoveryCode Codes = 1 [json_name = "Codes"];*/ 1:
                    message.codes.push(RecoveryCode.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.Timestamp Created = 2 [json_name = "Created"];*/ 2:
                    message.created = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.created);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RecoveryCodesSpecV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.RecoveryCode Codes = 1 [json_name = "Codes"]; */
        for (let i = 0; i < message.codes.length; i++)
            RecoveryCode.internalBinaryWrite(message.codes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp Created = 2 [json_name = "Created"]; */
        if (message.created)
            Timestamp.internalBinaryWrite(message.created, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.RecoveryCodesSpecV1
 */
export const RecoveryCodesSpecV1 = new RecoveryCodesSpecV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RecoveryCode$Type extends MessageType<RecoveryCode> {
    constructor() {
        super("types.RecoveryCode", [
            { no: 1, name: "HashedCode", kind: "scalar", jsonName: "HashedCode", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.jsontag": "hashed_code" } },
            { no: 2, name: "IsUsed", kind: "scalar", jsonName: "IsUsed", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "is_used" } }
        ]);
    }
    create(value?: PartialMessage<RecoveryCode>): RecoveryCode {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hashedCode = new Uint8Array(0);
        message.isUsed = false;
        if (value !== undefined)
            reflectionMergePartial<RecoveryCode>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RecoveryCode): RecoveryCode {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes HashedCode = 1 [json_name = "HashedCode"];*/ 1:
                    message.hashedCode = reader.bytes();
                    break;
                case /* bool IsUsed = 2 [json_name = "IsUsed"];*/ 2:
                    message.isUsed = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RecoveryCode, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes HashedCode = 1 [json_name = "HashedCode"]; */
        if (message.hashedCode.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.hashedCode);
        /* bool IsUsed = 2 [json_name = "IsUsed"]; */
        if (message.isUsed !== false)
            writer.tag(2, WireType.Varint).bool(message.isUsed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.RecoveryCode
 */
export const RecoveryCode = new RecoveryCode$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NullableSessionState$Type extends MessageType<NullableSessionState> {
    constructor() {
        super("types.NullableSessionState", [
            { no: 1, name: "State", kind: "enum", jsonName: "State", T: () => ["types.SessionState", SessionState], options: { "gogoproto.nullable": true, "gogoproto.jsontag": "state,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<NullableSessionState>): NullableSessionState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.state = 0;
        if (value !== undefined)
            reflectionMergePartial<NullableSessionState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NullableSessionState): NullableSessionState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.SessionState State = 1 [json_name = "State"];*/ 1:
                    message.state = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NullableSessionState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.SessionState State = 1 [json_name = "State"]; */
        if (message.state !== 0)
            writer.tag(1, WireType.Varint).int32(message.state);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.NullableSessionState
 */
export const NullableSessionState = new NullableSessionState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SessionTrackerFilter$Type extends MessageType<SessionTrackerFilter> {
    constructor() {
        super("types.SessionTrackerFilter", [
            { no: 1, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind,omitempty" } },
            { no: 2, name: "State", kind: "message", jsonName: "State", T: () => NullableSessionState, options: { "gogoproto.nullable": true, "gogoproto.jsontag": "state,omitempty" } },
            { no: 3, name: "DesktopName", kind: "scalar", jsonName: "DesktopName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "desktop_name,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<SessionTrackerFilter>): SessionTrackerFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.desktopName = "";
        if (value !== undefined)
            reflectionMergePartial<SessionTrackerFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SessionTrackerFilter): SessionTrackerFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Kind = 1 [json_name = "Kind"];*/ 1:
                    message.kind = reader.string();
                    break;
                case /* types.NullableSessionState State = 2 [json_name = "State"];*/ 2:
                    message.state = NullableSessionState.internalBinaryRead(reader, reader.uint32(), options, message.state);
                    break;
                case /* string DesktopName = 3 [json_name = "DesktopName"];*/ 3:
                    message.desktopName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SessionTrackerFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Kind = 1 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* types.NullableSessionState State = 2 [json_name = "State"]; */
        if (message.state)
            NullableSessionState.internalBinaryWrite(message.state, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string DesktopName = 3 [json_name = "DesktopName"]; */
        if (message.desktopName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.desktopName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.SessionTrackerFilter
 */
export const SessionTrackerFilter = new SessionTrackerFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SessionTrackerV1$Type extends MessageType<SessionTrackerV1> {
    constructor() {
        super("types.SessionTrackerV1", [
            { no: 1, name: "Header", kind: "message", jsonName: "Header", T: () => ResourceHeader, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Spec", kind: "message", jsonName: "Spec", T: () => SessionTrackerSpecV1, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ]);
    }
    create(value?: PartialMessage<SessionTrackerV1>): SessionTrackerV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SessionTrackerV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SessionTrackerV1): SessionTrackerV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.ResourceHeader Header = 1 [json_name = "Header"];*/ 1:
                    message.header = ResourceHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* types.SessionTrackerSpecV1 Spec = 2 [json_name = "Spec"];*/ 2:
                    message.spec = SessionTrackerSpecV1.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SessionTrackerV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.ResourceHeader Header = 1 [json_name = "Header"]; */
        if (message.header)
            ResourceHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* types.SessionTrackerSpecV1 Spec = 2 [json_name = "Spec"]; */
        if (message.spec)
            SessionTrackerSpecV1.internalBinaryWrite(message.spec, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.SessionTrackerV1
 */
export const SessionTrackerV1 = new SessionTrackerV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SessionTrackerSpecV1$Type extends MessageType<SessionTrackerSpecV1> {
    constructor() {
        super("types.SessionTrackerSpecV1", [
            { no: 1, name: "SessionID", kind: "scalar", jsonName: "SessionID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "session_id,omitempty" } },
            { no: 2, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind,omitempty" } },
            { no: 3, name: "State", kind: "enum", jsonName: "State", T: () => ["types.SessionState", SessionState], options: { "gogoproto.jsontag": "state,omitempty" } },
            { no: 4, name: "Created", kind: "message", jsonName: "Created", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "created,omitempty", "gogoproto.stdtime": true } },
            { no: 5, name: "Expires", kind: "message", jsonName: "Expires", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "expires,omitempty", "gogoproto.stdtime": true } },
            { no: 6, name: "AttachedData", kind: "scalar", jsonName: "AttachedData", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "attached,omitempty" } },
            { no: 7, name: "Reason", kind: "scalar", jsonName: "Reason", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "reason,omitempty" } },
            { no: 8, name: "Invited", kind: "scalar", jsonName: "Invited", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "invited,omitempty" } },
            { no: 9, name: "Hostname", kind: "scalar", jsonName: "Hostname", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "target_hostname,omitempty" } },
            { no: 10, name: "Address", kind: "scalar", jsonName: "Address", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "target_address,omitempty" } },
            { no: 11, name: "ClusterName", kind: "scalar", jsonName: "ClusterName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "cluster_name,omitempty" } },
            { no: 12, name: "Login", kind: "scalar", jsonName: "Login", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "login,omitempty" } },
            { no: 13, name: "Participants", kind: "message", jsonName: "Participants", repeat: 1 /*RepeatType.PACKED*/, T: () => Participant, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "participants,omitempty" } },
            { no: 14, name: "KubernetesCluster", kind: "scalar", jsonName: "KubernetesCluster", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kubernetes_cluster,omitempty" } },
            { no: 15, name: "HostUser", kind: "scalar", jsonName: "HostUser", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "host_user,omitempty" } },
            { no: 16, name: "HostPolicies", kind: "message", jsonName: "HostPolicies", repeat: 1 /*RepeatType.PACKED*/, T: () => SessionTrackerPolicySet, options: { "gogoproto.jsontag": "host_roles,omitempty" } },
            { no: 17, name: "DatabaseName", kind: "scalar", jsonName: "DatabaseName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "database_name,omitempty" } },
            { no: 18, name: "AppName", kind: "scalar", jsonName: "AppName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "app_name,omitempty" } },
            { no: 19, name: "AppSessionID", kind: "scalar", jsonName: "AppSessionID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "app_session_id,omitempty" } },
            { no: 20, name: "DesktopName", kind: "scalar", jsonName: "DesktopName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "desktop_name,omitempty" } },
            { no: 21, name: "HostID", kind: "scalar", jsonName: "HostID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "host_id,omitempty" } },
            { no: 22, name: "TargetSubKind", kind: "scalar", jsonName: "TargetSubKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "target_sub_kind,omitempty" } },
            { no: 23, name: "InitialCommand", kind: "scalar", jsonName: "InitialCommand", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "initial_command,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<SessionTrackerSpecV1>): SessionTrackerSpecV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sessionID = "";
        message.kind = "";
        message.state = 0;
        message.attachedData = "";
        message.reason = "";
        message.invited = [];
        message.hostname = "";
        message.address = "";
        message.clusterName = "";
        message.login = "";
        message.participants = [];
        message.kubernetesCluster = "";
        message.hostUser = "";
        message.hostPolicies = [];
        message.databaseName = "";
        message.appName = "";
        message.appSessionID = "";
        message.desktopName = "";
        message.hostID = "";
        message.targetSubKind = "";
        message.initialCommand = [];
        if (value !== undefined)
            reflectionMergePartial<SessionTrackerSpecV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SessionTrackerSpecV1): SessionTrackerSpecV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string SessionID = 1 [json_name = "SessionID"];*/ 1:
                    message.sessionID = reader.string();
                    break;
                case /* string Kind = 2 [json_name = "Kind"];*/ 2:
                    message.kind = reader.string();
                    break;
                case /* types.SessionState State = 3 [json_name = "State"];*/ 3:
                    message.state = reader.int32();
                    break;
                case /* google.protobuf.Timestamp Created = 4 [json_name = "Created"];*/ 4:
                    message.created = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.created);
                    break;
                case /* google.protobuf.Timestamp Expires = 5 [json_name = "Expires"];*/ 5:
                    message.expires = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expires);
                    break;
                case /* string AttachedData = 6 [json_name = "AttachedData"];*/ 6:
                    message.attachedData = reader.string();
                    break;
                case /* string Reason = 7 [json_name = "Reason"];*/ 7:
                    message.reason = reader.string();
                    break;
                case /* repeated string Invited = 8 [json_name = "Invited"];*/ 8:
                    message.invited.push(reader.string());
                    break;
                case /* string Hostname = 9 [json_name = "Hostname"];*/ 9:
                    message.hostname = reader.string();
                    break;
                case /* string Address = 10 [json_name = "Address"];*/ 10:
                    message.address = reader.string();
                    break;
                case /* string ClusterName = 11 [json_name = "ClusterName"];*/ 11:
                    message.clusterName = reader.string();
                    break;
                case /* string Login = 12 [json_name = "Login"];*/ 12:
                    message.login = reader.string();
                    break;
                case /* repeated types.Participant Participants = 13 [json_name = "Participants"];*/ 13:
                    message.participants.push(Participant.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string KubernetesCluster = 14 [json_name = "KubernetesCluster"];*/ 14:
                    message.kubernetesCluster = reader.string();
                    break;
                case /* string HostUser = 15 [json_name = "HostUser"];*/ 15:
                    message.hostUser = reader.string();
                    break;
                case /* repeated types.SessionTrackerPolicySet HostPolicies = 16 [json_name = "HostPolicies"];*/ 16:
                    message.hostPolicies.push(SessionTrackerPolicySet.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string DatabaseName = 17 [json_name = "DatabaseName"];*/ 17:
                    message.databaseName = reader.string();
                    break;
                case /* string AppName = 18 [json_name = "AppName"];*/ 18:
                    message.appName = reader.string();
                    break;
                case /* string AppSessionID = 19 [json_name = "AppSessionID"];*/ 19:
                    message.appSessionID = reader.string();
                    break;
                case /* string DesktopName = 20 [json_name = "DesktopName"];*/ 20:
                    message.desktopName = reader.string();
                    break;
                case /* string HostID = 21 [json_name = "HostID"];*/ 21:
                    message.hostID = reader.string();
                    break;
                case /* string TargetSubKind = 22 [json_name = "TargetSubKind"];*/ 22:
                    message.targetSubKind = reader.string();
                    break;
                case /* repeated string InitialCommand = 23 [json_name = "InitialCommand"];*/ 23:
                    message.initialCommand.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SessionTrackerSpecV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string SessionID = 1 [json_name = "SessionID"]; */
        if (message.sessionID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sessionID);
        /* string Kind = 2 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.kind);
        /* types.SessionState State = 3 [json_name = "State"]; */
        if (message.state !== 0)
            writer.tag(3, WireType.Varint).int32(message.state);
        /* google.protobuf.Timestamp Created = 4 [json_name = "Created"]; */
        if (message.created)
            Timestamp.internalBinaryWrite(message.created, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp Expires = 5 [json_name = "Expires"]; */
        if (message.expires)
            Timestamp.internalBinaryWrite(message.expires, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string AttachedData = 6 [json_name = "AttachedData"]; */
        if (message.attachedData !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.attachedData);
        /* string Reason = 7 [json_name = "Reason"]; */
        if (message.reason !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.reason);
        /* repeated string Invited = 8 [json_name = "Invited"]; */
        for (let i = 0; i < message.invited.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.invited[i]);
        /* string Hostname = 9 [json_name = "Hostname"]; */
        if (message.hostname !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.hostname);
        /* string Address = 10 [json_name = "Address"]; */
        if (message.address !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.address);
        /* string ClusterName = 11 [json_name = "ClusterName"]; */
        if (message.clusterName !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.clusterName);
        /* string Login = 12 [json_name = "Login"]; */
        if (message.login !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.login);
        /* repeated types.Participant Participants = 13 [json_name = "Participants"]; */
        for (let i = 0; i < message.participants.length; i++)
            Participant.internalBinaryWrite(message.participants[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* string KubernetesCluster = 14 [json_name = "KubernetesCluster"]; */
        if (message.kubernetesCluster !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.kubernetesCluster);
        /* string HostUser = 15 [json_name = "HostUser"]; */
        if (message.hostUser !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.hostUser);
        /* repeated types.SessionTrackerPolicySet HostPolicies = 16 [json_name = "HostPolicies"]; */
        for (let i = 0; i < message.hostPolicies.length; i++)
            SessionTrackerPolicySet.internalBinaryWrite(message.hostPolicies[i], writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* string DatabaseName = 17 [json_name = "DatabaseName"]; */
        if (message.databaseName !== "")
            writer.tag(17, WireType.LengthDelimited).string(message.databaseName);
        /* string AppName = 18 [json_name = "AppName"]; */
        if (message.appName !== "")
            writer.tag(18, WireType.LengthDelimited).string(message.appName);
        /* string AppSessionID = 19 [json_name = "AppSessionID"]; */
        if (message.appSessionID !== "")
            writer.tag(19, WireType.LengthDelimited).string(message.appSessionID);
        /* string DesktopName = 20 [json_name = "DesktopName"]; */
        if (message.desktopName !== "")
            writer.tag(20, WireType.LengthDelimited).string(message.desktopName);
        /* string HostID = 21 [json_name = "HostID"]; */
        if (message.hostID !== "")
            writer.tag(21, WireType.LengthDelimited).string(message.hostID);
        /* string TargetSubKind = 22 [json_name = "TargetSubKind"]; */
        if (message.targetSubKind !== "")
            writer.tag(22, WireType.LengthDelimited).string(message.targetSubKind);
        /* repeated string InitialCommand = 23 [json_name = "InitialCommand"]; */
        for (let i = 0; i < message.initialCommand.length; i++)
            writer.tag(23, WireType.LengthDelimited).string(message.initialCommand[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.SessionTrackerSpecV1
 */
export const SessionTrackerSpecV1 = new SessionTrackerSpecV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SessionTrackerPolicySet$Type extends MessageType<SessionTrackerPolicySet> {
    constructor() {
        super("types.SessionTrackerPolicySet", [
            { no: 1, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "name,omitempty" } },
            { no: 2, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version,omitempty" } },
            { no: 3, name: "RequireSessionJoin", kind: "message", jsonName: "RequireSessionJoin", repeat: 1 /*RepeatType.PACKED*/, T: () => SessionRequirePolicy, options: { "gogoproto.jsontag": "require_session_join,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<SessionTrackerPolicySet>): SessionTrackerPolicySet {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.version = "";
        message.requireSessionJoin = [];
        if (value !== undefined)
            reflectionMergePartial<SessionTrackerPolicySet>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SessionTrackerPolicySet): SessionTrackerPolicySet {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Name = 1 [json_name = "Name"];*/ 1:
                    message.name = reader.string();
                    break;
                case /* string Version = 2 [json_name = "Version"];*/ 2:
                    message.version = reader.string();
                    break;
                case /* repeated types.SessionRequirePolicy RequireSessionJoin = 3 [json_name = "RequireSessionJoin"];*/ 3:
                    message.requireSessionJoin.push(SessionRequirePolicy.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SessionTrackerPolicySet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Name = 1 [json_name = "Name"]; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string Version = 2 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.version);
        /* repeated types.SessionRequirePolicy RequireSessionJoin = 3 [json_name = "RequireSessionJoin"]; */
        for (let i = 0; i < message.requireSessionJoin.length; i++)
            SessionRequirePolicy.internalBinaryWrite(message.requireSessionJoin[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.SessionTrackerPolicySet
 */
export const SessionTrackerPolicySet = new SessionTrackerPolicySet$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Participant$Type extends MessageType<Participant> {
    constructor() {
        super("types.Participant", [
            { no: 1, name: "ID", kind: "scalar", jsonName: "ID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "id,omitempty" } },
            { no: 2, name: "User", kind: "scalar", jsonName: "User", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "user,omitempty" } },
            { no: 3, name: "Mode", kind: "scalar", jsonName: "Mode", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "mode,omitempty" } },
            { no: 4, name: "LastActive", kind: "message", jsonName: "LastActive", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "last_active,omitempty", "gogoproto.stdtime": true } }
        ]);
    }
    create(value?: PartialMessage<Participant>): Participant {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.iD = "";
        message.user = "";
        message.mode = "";
        if (value !== undefined)
            reflectionMergePartial<Participant>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Participant): Participant {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ID = 1 [json_name = "ID"];*/ 1:
                    message.iD = reader.string();
                    break;
                case /* string User = 2 [json_name = "User"];*/ 2:
                    message.user = reader.string();
                    break;
                case /* string Mode = 3 [json_name = "Mode"];*/ 3:
                    message.mode = reader.string();
                    break;
                case /* google.protobuf.Timestamp LastActive = 4 [json_name = "LastActive"];*/ 4:
                    message.lastActive = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastActive);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Participant, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ID = 1 [json_name = "ID"]; */
        if (message.iD !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.iD);
        /* string User = 2 [json_name = "User"]; */
        if (message.user !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.user);
        /* string Mode = 3 [json_name = "Mode"]; */
        if (message.mode !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.mode);
        /* google.protobuf.Timestamp LastActive = 4 [json_name = "LastActive"]; */
        if (message.lastActive)
            Timestamp.internalBinaryWrite(message.lastActive, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.Participant
 */
export const Participant = new Participant$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UIConfigV1$Type extends MessageType<UIConfigV1> {
    constructor() {
        super("types.UIConfigV1", [
            { no: 1, name: "Header", kind: "message", jsonName: "Header", T: () => ResourceHeader, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Spec", kind: "message", jsonName: "Spec", T: () => UIConfigSpecV1, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ]);
    }
    create(value?: PartialMessage<UIConfigV1>): UIConfigV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UIConfigV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UIConfigV1): UIConfigV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.ResourceHeader Header = 1 [json_name = "Header"];*/ 1:
                    message.header = ResourceHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* types.UIConfigSpecV1 Spec = 5 [json_name = "Spec"];*/ 5:
                    message.spec = UIConfigSpecV1.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UIConfigV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.ResourceHeader Header = 1 [json_name = "Header"]; */
        if (message.header)
            ResourceHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* types.UIConfigSpecV1 Spec = 5 [json_name = "Spec"]; */
        if (message.spec)
            UIConfigSpecV1.internalBinaryWrite(message.spec, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.UIConfigV1
 */
export const UIConfigV1 = new UIConfigV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UIConfigSpecV1$Type extends MessageType<UIConfigSpecV1> {
    constructor() {
        super("types.UIConfigSpecV1", [
            { no: 1, name: "ScrollbackLines", kind: "scalar", jsonName: "ScrollbackLines", T: 5 /*ScalarType.INT32*/, options: { "gogoproto.jsontag": "scrollback_lines" } },
            { no: 2, name: "ShowResources", kind: "scalar", jsonName: "ShowResources", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "show_resources,omitempty", "gogoproto.casttype": "github.com/gravitational/teleport/api/constants.ShowResources" } }
        ]);
    }
    create(value?: PartialMessage<UIConfigSpecV1>): UIConfigSpecV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.scrollbackLines = 0;
        message.showResources = "";
        if (value !== undefined)
            reflectionMergePartial<UIConfigSpecV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UIConfigSpecV1): UIConfigSpecV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 ScrollbackLines = 1 [json_name = "ScrollbackLines"];*/ 1:
                    message.scrollbackLines = reader.int32();
                    break;
                case /* string ShowResources = 2 [json_name = "ShowResources"];*/ 2:
                    message.showResources = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UIConfigSpecV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 ScrollbackLines = 1 [json_name = "ScrollbackLines"]; */
        if (message.scrollbackLines !== 0)
            writer.tag(1, WireType.Varint).int32(message.scrollbackLines);
        /* string ShowResources = 2 [json_name = "ShowResources"]; */
        if (message.showResources !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.showResources);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.UIConfigSpecV1
 */
export const UIConfigSpecV1 = new UIConfigSpecV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InstallerV1$Type extends MessageType<InstallerV1> {
    constructor() {
        super("types.InstallerV1", [
            { no: 1, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 2, name: "SubKind", kind: "scalar", jsonName: "SubKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub_kind,omitempty" } },
            { no: 3, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version" } },
            { no: 4, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "metadata" } },
            { no: 5, name: "Spec", kind: "message", jsonName: "Spec", T: () => InstallerSpecV1, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ]);
    }
    create(value?: PartialMessage<InstallerV1>): InstallerV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.subKind = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<InstallerV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InstallerV1): InstallerV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Kind = 1 [json_name = "Kind"];*/ 1:
                    message.kind = reader.string();
                    break;
                case /* string SubKind = 2 [json_name = "SubKind"];*/ 2:
                    message.subKind = reader.string();
                    break;
                case /* string Version = 3 [json_name = "Version"];*/ 3:
                    message.version = reader.string();
                    break;
                case /* types.Metadata Metadata = 4 [json_name = "Metadata"];*/ 4:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* types.InstallerSpecV1 Spec = 5 [json_name = "Spec"];*/ 5:
                    message.spec = InstallerSpecV1.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InstallerV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Kind = 1 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string SubKind = 2 [json_name = "SubKind"]; */
        if (message.subKind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subKind);
        /* string Version = 3 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* types.Metadata Metadata = 4 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.InstallerSpecV1 Spec = 5 [json_name = "Spec"]; */
        if (message.spec)
            InstallerSpecV1.internalBinaryWrite(message.spec, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.InstallerV1
 */
export const InstallerV1 = new InstallerV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InstallerSpecV1$Type extends MessageType<InstallerSpecV1> {
    constructor() {
        super("types.InstallerSpecV1", [
            { no: 1, name: "Script", kind: "scalar", jsonName: "Script", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "script" } }
        ]);
    }
    create(value?: PartialMessage<InstallerSpecV1>): InstallerSpecV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.script = "";
        if (value !== undefined)
            reflectionMergePartial<InstallerSpecV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InstallerSpecV1): InstallerSpecV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Script = 1 [json_name = "Script"];*/ 1:
                    message.script = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InstallerSpecV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Script = 1 [json_name = "Script"]; */
        if (message.script !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.script);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.InstallerSpecV1
 */
export const InstallerSpecV1 = new InstallerSpecV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InstallerV1List$Type extends MessageType<InstallerV1List> {
    constructor() {
        super("types.InstallerV1List", [
            { no: 1, name: "installers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => InstallerV1 }
        ]);
    }
    create(value?: PartialMessage<InstallerV1List>): InstallerV1List {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.installers = [];
        if (value !== undefined)
            reflectionMergePartial<InstallerV1List>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InstallerV1List): InstallerV1List {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.InstallerV1 installers */ 1:
                    message.installers.push(InstallerV1.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InstallerV1List, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.InstallerV1 installers = 1; */
        for (let i = 0; i < message.installers.length; i++)
            InstallerV1.internalBinaryWrite(message.installers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.InstallerV1List
 */
export const InstallerV1List = new InstallerV1List$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SortBy$Type extends MessageType<SortBy> {
    constructor() {
        super("types.SortBy", [
            { no: 1, name: "IsDesc", kind: "scalar", jsonName: "IsDesc", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "is_desc" } },
            { no: 2, name: "Field", kind: "scalar", jsonName: "Field", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "field" } }
        ]);
    }
    create(value?: PartialMessage<SortBy>): SortBy {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isDesc = false;
        message.field = "";
        if (value !== undefined)
            reflectionMergePartial<SortBy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SortBy): SortBy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool IsDesc = 1 [json_name = "IsDesc"];*/ 1:
                    message.isDesc = reader.bool();
                    break;
                case /* string Field = 2 [json_name = "Field"];*/ 2:
                    message.field = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SortBy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool IsDesc = 1 [json_name = "IsDesc"]; */
        if (message.isDesc !== false)
            writer.tag(1, WireType.Varint).bool(message.isDesc);
        /* string Field = 2 [json_name = "Field"]; */
        if (message.field !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.field);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.SortBy
 */
export const SortBy = new SortBy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConnectionDiagnosticV1$Type extends MessageType<ConnectionDiagnosticV1> {
    constructor() {
        super("types.ConnectionDiagnosticV1", [
            { no: 1, name: "Header", kind: "message", jsonName: "Header", T: () => ResourceHeader, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 5, name: "Spec", kind: "message", jsonName: "Spec", T: () => ConnectionDiagnosticSpecV1, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ]);
    }
    create(value?: PartialMessage<ConnectionDiagnosticV1>): ConnectionDiagnosticV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ConnectionDiagnosticV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConnectionDiagnosticV1): ConnectionDiagnosticV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.ResourceHeader Header = 1 [json_name = "Header"];*/ 1:
                    message.header = ResourceHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* types.ConnectionDiagnosticSpecV1 Spec = 5 [json_name = "Spec"];*/ 5:
                    message.spec = ConnectionDiagnosticSpecV1.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConnectionDiagnosticV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.ResourceHeader Header = 1 [json_name = "Header"]; */
        if (message.header)
            ResourceHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* types.ConnectionDiagnosticSpecV1 Spec = 5 [json_name = "Spec"]; */
        if (message.spec)
            ConnectionDiagnosticSpecV1.internalBinaryWrite(message.spec, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ConnectionDiagnosticV1
 */
export const ConnectionDiagnosticV1 = new ConnectionDiagnosticV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConnectionDiagnosticSpecV1$Type extends MessageType<ConnectionDiagnosticSpecV1> {
    constructor() {
        super("types.ConnectionDiagnosticSpecV1", [
            { no: 1, name: "Success", kind: "scalar", jsonName: "Success", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "success" } },
            { no: 2, name: "Message", kind: "scalar", jsonName: "Message", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "message" } },
            { no: 3, name: "Traces", kind: "message", jsonName: "Traces", repeat: 1 /*RepeatType.PACKED*/, T: () => ConnectionDiagnosticTrace, options: { "gogoproto.jsontag": "traces" } }
        ]);
    }
    create(value?: PartialMessage<ConnectionDiagnosticSpecV1>): ConnectionDiagnosticSpecV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        message.message = "";
        message.traces = [];
        if (value !== undefined)
            reflectionMergePartial<ConnectionDiagnosticSpecV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConnectionDiagnosticSpecV1): ConnectionDiagnosticSpecV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool Success = 1 [json_name = "Success"];*/ 1:
                    message.success = reader.bool();
                    break;
                case /* string Message = 2 [json_name = "Message"];*/ 2:
                    message.message = reader.string();
                    break;
                case /* repeated types.ConnectionDiagnosticTrace Traces = 3 [json_name = "Traces"];*/ 3:
                    message.traces.push(ConnectionDiagnosticTrace.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConnectionDiagnosticSpecV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool Success = 1 [json_name = "Success"]; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* string Message = 2 [json_name = "Message"]; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        /* repeated types.ConnectionDiagnosticTrace Traces = 3 [json_name = "Traces"]; */
        for (let i = 0; i < message.traces.length; i++)
            ConnectionDiagnosticTrace.internalBinaryWrite(message.traces[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ConnectionDiagnosticSpecV1
 */
export const ConnectionDiagnosticSpecV1 = new ConnectionDiagnosticSpecV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConnectionDiagnosticTrace$Type extends MessageType<ConnectionDiagnosticTrace> {
    constructor() {
        super("types.ConnectionDiagnosticTrace", [
            { no: 1, name: "Type", kind: "enum", jsonName: "Type", T: () => ["types.ConnectionDiagnosticTrace.TraceType", ConnectionDiagnosticTrace_TraceType], options: { "gogoproto.jsontag": "type" } },
            { no: 2, name: "Status", kind: "enum", jsonName: "Status", T: () => ["types.ConnectionDiagnosticTrace.StatusType", ConnectionDiagnosticTrace_StatusType], options: { "gogoproto.jsontag": "status" } },
            { no: 3, name: "Details", kind: "scalar", jsonName: "Details", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "details" } },
            { no: 4, name: "Error", kind: "scalar", jsonName: "Error", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "error" } }
        ]);
    }
    create(value?: PartialMessage<ConnectionDiagnosticTrace>): ConnectionDiagnosticTrace {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.status = 0;
        message.details = "";
        message.error = "";
        if (value !== undefined)
            reflectionMergePartial<ConnectionDiagnosticTrace>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConnectionDiagnosticTrace): ConnectionDiagnosticTrace {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.ConnectionDiagnosticTrace.TraceType Type = 1 [json_name = "Type"];*/ 1:
                    message.type = reader.int32();
                    break;
                case /* types.ConnectionDiagnosticTrace.StatusType Status = 2 [json_name = "Status"];*/ 2:
                    message.status = reader.int32();
                    break;
                case /* string Details = 3 [json_name = "Details"];*/ 3:
                    message.details = reader.string();
                    break;
                case /* string Error = 4 [json_name = "Error"];*/ 4:
                    message.error = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConnectionDiagnosticTrace, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.ConnectionDiagnosticTrace.TraceType Type = 1 [json_name = "Type"]; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* types.ConnectionDiagnosticTrace.StatusType Status = 2 [json_name = "Status"]; */
        if (message.status !== 0)
            writer.tag(2, WireType.Varint).int32(message.status);
        /* string Details = 3 [json_name = "Details"]; */
        if (message.details !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.details);
        /* string Error = 4 [json_name = "Error"]; */
        if (message.error !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ConnectionDiagnosticTrace
 */
export const ConnectionDiagnosticTrace = new ConnectionDiagnosticTrace$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DatabaseServiceV1$Type extends MessageType<DatabaseServiceV1> {
    constructor() {
        super("types.DatabaseServiceV1", [
            { no: 1, name: "Header", kind: "message", jsonName: "Header", T: () => ResourceHeader, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Spec", kind: "message", jsonName: "Spec", T: () => DatabaseServiceSpecV1, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ]);
    }
    create(value?: PartialMessage<DatabaseServiceV1>): DatabaseServiceV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DatabaseServiceV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DatabaseServiceV1): DatabaseServiceV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.ResourceHeader Header = 1 [json_name = "Header"];*/ 1:
                    message.header = ResourceHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* types.DatabaseServiceSpecV1 Spec = 2 [json_name = "Spec"];*/ 2:
                    message.spec = DatabaseServiceSpecV1.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DatabaseServiceV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.ResourceHeader Header = 1 [json_name = "Header"]; */
        if (message.header)
            ResourceHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* types.DatabaseServiceSpecV1 Spec = 2 [json_name = "Spec"]; */
        if (message.spec)
            DatabaseServiceSpecV1.internalBinaryWrite(message.spec, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.DatabaseServiceV1
 */
export const DatabaseServiceV1 = new DatabaseServiceV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DatabaseServiceSpecV1$Type extends MessageType<DatabaseServiceSpecV1> {
    constructor() {
        super("types.DatabaseServiceSpecV1", [
            { no: 1, name: "ResourceMatchers", kind: "message", jsonName: "ResourceMatchers", repeat: 1 /*RepeatType.PACKED*/, T: () => DatabaseResourceMatcher, options: { "gogoproto.jsontag": "resources" } },
            { no: 2, name: "Hostname", kind: "scalar", jsonName: "Hostname", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "hostname" } }
        ]);
    }
    create(value?: PartialMessage<DatabaseServiceSpecV1>): DatabaseServiceSpecV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.resourceMatchers = [];
        message.hostname = "";
        if (value !== undefined)
            reflectionMergePartial<DatabaseServiceSpecV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DatabaseServiceSpecV1): DatabaseServiceSpecV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.DatabaseResourceMatcher ResourceMatchers = 1 [json_name = "ResourceMatchers"];*/ 1:
                    message.resourceMatchers.push(DatabaseResourceMatcher.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string Hostname = 2 [json_name = "Hostname"];*/ 2:
                    message.hostname = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DatabaseServiceSpecV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.DatabaseResourceMatcher ResourceMatchers = 1 [json_name = "ResourceMatchers"]; */
        for (let i = 0; i < message.resourceMatchers.length; i++)
            DatabaseResourceMatcher.internalBinaryWrite(message.resourceMatchers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string Hostname = 2 [json_name = "Hostname"]; */
        if (message.hostname !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.hostname);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.DatabaseServiceSpecV1
 */
export const DatabaseServiceSpecV1 = new DatabaseServiceSpecV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DatabaseResourceMatcher$Type extends MessageType<DatabaseResourceMatcher> {
    constructor() {
        super("types.DatabaseResourceMatcher", [
            { no: 1, name: "Labels", kind: "message", jsonName: "Labels", T: () => LabelValues, options: { "gogoproto.customtype": "Labels", "gogoproto.jsontag": "labels" } },
            { no: 2, name: "AWS", kind: "message", jsonName: "AWS", T: () => ResourceMatcherAWS, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "aws" } }
        ]);
    }
    create(value?: PartialMessage<DatabaseResourceMatcher>): DatabaseResourceMatcher {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DatabaseResourceMatcher>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DatabaseResourceMatcher): DatabaseResourceMatcher {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* wrappers.LabelValues Labels = 1 [json_name = "Labels"];*/ 1:
                    message.labels = LabelValues.internalBinaryRead(reader, reader.uint32(), options, message.labels);
                    break;
                case /* types.ResourceMatcherAWS AWS = 2 [json_name = "AWS"];*/ 2:
                    message.aWS = ResourceMatcherAWS.internalBinaryRead(reader, reader.uint32(), options, message.aWS);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DatabaseResourceMatcher, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* wrappers.LabelValues Labels = 1 [json_name = "Labels"]; */
        if (message.labels)
            LabelValues.internalBinaryWrite(message.labels, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* types.ResourceMatcherAWS AWS = 2 [json_name = "AWS"]; */
        if (message.aWS)
            ResourceMatcherAWS.internalBinaryWrite(message.aWS, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.DatabaseResourceMatcher
 */
export const DatabaseResourceMatcher = new DatabaseResourceMatcher$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResourceMatcherAWS$Type extends MessageType<ResourceMatcherAWS> {
    constructor() {
        super("types.ResourceMatcherAWS", [
            { no: 1, name: "AssumeRoleARN", kind: "scalar", jsonName: "AssumeRoleARN", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "assume_role_arn,omitempty" } },
            { no: 2, name: "ExternalID", kind: "scalar", jsonName: "ExternalID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "external_id,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ResourceMatcherAWS>): ResourceMatcherAWS {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.assumeRoleARN = "";
        message.externalID = "";
        if (value !== undefined)
            reflectionMergePartial<ResourceMatcherAWS>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResourceMatcherAWS): ResourceMatcherAWS {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string AssumeRoleARN = 1 [json_name = "AssumeRoleARN"];*/ 1:
                    message.assumeRoleARN = reader.string();
                    break;
                case /* string ExternalID = 2 [json_name = "ExternalID"];*/ 2:
                    message.externalID = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResourceMatcherAWS, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string AssumeRoleARN = 1 [json_name = "AssumeRoleARN"]; */
        if (message.assumeRoleARN !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.assumeRoleARN);
        /* string ExternalID = 2 [json_name = "ExternalID"]; */
        if (message.externalID !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.externalID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ResourceMatcherAWS
 */
export const ResourceMatcherAWS = new ResourceMatcherAWS$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClusterAlert$Type extends MessageType<ClusterAlert> {
    constructor() {
        super("types.ClusterAlert", [
            { no: 1, name: "Header", kind: "message", jsonName: "Header", T: () => ResourceHeader, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Spec", kind: "message", jsonName: "Spec", T: () => ClusterAlertSpec, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ]);
    }
    create(value?: PartialMessage<ClusterAlert>): ClusterAlert {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ClusterAlert>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClusterAlert): ClusterAlert {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.ResourceHeader Header = 1 [json_name = "Header"];*/ 1:
                    message.header = ResourceHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* types.ClusterAlertSpec Spec = 2 [json_name = "Spec"];*/ 2:
                    message.spec = ClusterAlertSpec.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClusterAlert, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.ResourceHeader Header = 1 [json_name = "Header"]; */
        if (message.header)
            ResourceHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* types.ClusterAlertSpec Spec = 2 [json_name = "Spec"]; */
        if (message.spec)
            ClusterAlertSpec.internalBinaryWrite(message.spec, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ClusterAlert
 */
export const ClusterAlert = new ClusterAlert$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClusterAlertSpec$Type extends MessageType<ClusterAlertSpec> {
    constructor() {
        super("types.ClusterAlertSpec", [
            { no: 1, name: "Severity", kind: "enum", jsonName: "Severity", T: () => ["types.AlertSeverity", AlertSeverity], options: { "gogoproto.jsontag": "severity" } },
            { no: 2, name: "Message", kind: "scalar", jsonName: "Message", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "message" } },
            { no: 3, name: "Created", kind: "message", jsonName: "Created", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "created,omitempty", "gogoproto.stdtime": true } }
        ]);
    }
    create(value?: PartialMessage<ClusterAlertSpec>): ClusterAlertSpec {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.severity = 0;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<ClusterAlertSpec>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClusterAlertSpec): ClusterAlertSpec {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.AlertSeverity Severity = 1 [json_name = "Severity"];*/ 1:
                    message.severity = reader.int32();
                    break;
                case /* string Message = 2 [json_name = "Message"];*/ 2:
                    message.message = reader.string();
                    break;
                case /* google.protobuf.Timestamp Created = 3 [json_name = "Created"];*/ 3:
                    message.created = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.created);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClusterAlertSpec, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.AlertSeverity Severity = 1 [json_name = "Severity"]; */
        if (message.severity !== 0)
            writer.tag(1, WireType.Varint).int32(message.severity);
        /* string Message = 2 [json_name = "Message"]; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        /* google.protobuf.Timestamp Created = 3 [json_name = "Created"]; */
        if (message.created)
            Timestamp.internalBinaryWrite(message.created, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ClusterAlertSpec
 */
export const ClusterAlertSpec = new ClusterAlertSpec$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetClusterAlertsRequest$Type extends MessageType<GetClusterAlertsRequest> {
    constructor() {
        super("types.GetClusterAlertsRequest", [
            { no: 1, name: "Severity", kind: "enum", jsonName: "Severity", T: () => ["types.AlertSeverity", AlertSeverity] },
            { no: 2, name: "AlertID", kind: "scalar", jsonName: "AlertID", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "Labels", kind: "map", jsonName: "Labels", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 4, name: "WithSuperseded", kind: "scalar", jsonName: "WithSuperseded", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "WithAcknowledged", kind: "scalar", jsonName: "WithAcknowledged", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "WithUntargeted", kind: "scalar", jsonName: "WithUntargeted", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GetClusterAlertsRequest>): GetClusterAlertsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.severity = 0;
        message.alertID = "";
        message.labels = {};
        message.withSuperseded = false;
        message.withAcknowledged = false;
        message.withUntargeted = false;
        if (value !== undefined)
            reflectionMergePartial<GetClusterAlertsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetClusterAlertsRequest): GetClusterAlertsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.AlertSeverity Severity = 1 [json_name = "Severity"];*/ 1:
                    message.severity = reader.int32();
                    break;
                case /* string AlertID = 2 [json_name = "AlertID"];*/ 2:
                    message.alertID = reader.string();
                    break;
                case /* map<string, string> Labels = 3 [json_name = "Labels"];*/ 3:
                    this.binaryReadMap3(message.labels, reader, options);
                    break;
                case /* bool WithSuperseded = 4 [json_name = "WithSuperseded"];*/ 4:
                    message.withSuperseded = reader.bool();
                    break;
                case /* bool WithAcknowledged = 5 [json_name = "WithAcknowledged"];*/ 5:
                    message.withAcknowledged = reader.bool();
                    break;
                case /* bool WithUntargeted = 6 [json_name = "WithUntargeted"];*/ 6:
                    message.withUntargeted = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: GetClusterAlertsRequest["labels"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GetClusterAlertsRequest["labels"] | undefined, val: GetClusterAlertsRequest["labels"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field types.GetClusterAlertsRequest.Labels");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: GetClusterAlertsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.AlertSeverity Severity = 1 [json_name = "Severity"]; */
        if (message.severity !== 0)
            writer.tag(1, WireType.Varint).int32(message.severity);
        /* string AlertID = 2 [json_name = "AlertID"]; */
        if (message.alertID !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.alertID);
        /* map<string, string> Labels = 3 [json_name = "Labels"]; */
        for (let k of globalThis.Object.keys(message.labels))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.labels[k]).join();
        /* bool WithSuperseded = 4 [json_name = "WithSuperseded"]; */
        if (message.withSuperseded !== false)
            writer.tag(4, WireType.Varint).bool(message.withSuperseded);
        /* bool WithAcknowledged = 5 [json_name = "WithAcknowledged"]; */
        if (message.withAcknowledged !== false)
            writer.tag(5, WireType.Varint).bool(message.withAcknowledged);
        /* bool WithUntargeted = 6 [json_name = "WithUntargeted"]; */
        if (message.withUntargeted !== false)
            writer.tag(6, WireType.Varint).bool(message.withUntargeted);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.GetClusterAlertsRequest
 */
export const GetClusterAlertsRequest = new GetClusterAlertsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AlertAcknowledgement$Type extends MessageType<AlertAcknowledgement> {
    constructor() {
        super("types.AlertAcknowledgement", [
            { no: 1, name: "AlertID", kind: "scalar", jsonName: "AlertID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "alert_id,omitempty" } },
            { no: 2, name: "Reason", kind: "scalar", jsonName: "Reason", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "reason,omitempty" } },
            { no: 4, name: "Expires", kind: "message", jsonName: "Expires", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "expires,omitempty", "gogoproto.stdtime": true } }
        ]);
    }
    create(value?: PartialMessage<AlertAcknowledgement>): AlertAcknowledgement {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.alertID = "";
        message.reason = "";
        if (value !== undefined)
            reflectionMergePartial<AlertAcknowledgement>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AlertAcknowledgement): AlertAcknowledgement {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string AlertID = 1 [json_name = "AlertID"];*/ 1:
                    message.alertID = reader.string();
                    break;
                case /* string Reason = 2 [json_name = "Reason"];*/ 2:
                    message.reason = reader.string();
                    break;
                case /* google.protobuf.Timestamp Expires = 4 [json_name = "Expires"];*/ 4:
                    message.expires = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expires);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AlertAcknowledgement, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string AlertID = 1 [json_name = "AlertID"]; */
        if (message.alertID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.alertID);
        /* string Reason = 2 [json_name = "Reason"]; */
        if (message.reason !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.reason);
        /* google.protobuf.Timestamp Expires = 4 [json_name = "Expires"]; */
        if (message.expires)
            Timestamp.internalBinaryWrite(message.expires, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AlertAcknowledgement
 */
export const AlertAcknowledgement = new AlertAcknowledgement$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Release$Type extends MessageType<Release> {
    constructor() {
        super("types.Release", [
            { no: 1, name: "NotesMD", kind: "scalar", jsonName: "NotesMD", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "notes_md" } },
            { no: 2, name: "Product", kind: "scalar", jsonName: "Product", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "product" } },
            { no: 3, name: "ReleaseID", kind: "scalar", jsonName: "ReleaseID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "release_id" } },
            { no: 4, name: "Status", kind: "scalar", jsonName: "Status", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "status" } },
            { no: 5, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version" } },
            { no: 6, name: "Assets", kind: "message", jsonName: "Assets", repeat: 1 /*RepeatType.PACKED*/, T: () => Asset, options: { "gogoproto.jsontag": "assets" } }
        ]);
    }
    create(value?: PartialMessage<Release>): Release {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.notesMD = "";
        message.product = "";
        message.releaseID = "";
        message.status = "";
        message.version = "";
        message.assets = [];
        if (value !== undefined)
            reflectionMergePartial<Release>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Release): Release {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string NotesMD = 1 [json_name = "NotesMD"];*/ 1:
                    message.notesMD = reader.string();
                    break;
                case /* string Product = 2 [json_name = "Product"];*/ 2:
                    message.product = reader.string();
                    break;
                case /* string ReleaseID = 3 [json_name = "ReleaseID"];*/ 3:
                    message.releaseID = reader.string();
                    break;
                case /* string Status = 4 [json_name = "Status"];*/ 4:
                    message.status = reader.string();
                    break;
                case /* string Version = 5 [json_name = "Version"];*/ 5:
                    message.version = reader.string();
                    break;
                case /* repeated types.Asset Assets = 6 [json_name = "Assets"];*/ 6:
                    message.assets.push(Asset.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Release, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string NotesMD = 1 [json_name = "NotesMD"]; */
        if (message.notesMD !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.notesMD);
        /* string Product = 2 [json_name = "Product"]; */
        if (message.product !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.product);
        /* string ReleaseID = 3 [json_name = "ReleaseID"]; */
        if (message.releaseID !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.releaseID);
        /* string Status = 4 [json_name = "Status"]; */
        if (message.status !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.status);
        /* string Version = 5 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.version);
        /* repeated types.Asset Assets = 6 [json_name = "Assets"]; */
        for (let i = 0; i < message.assets.length; i++)
            Asset.internalBinaryWrite(message.assets[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.Release
 */
export const Release = new Release$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Asset$Type extends MessageType<Asset> {
    constructor() {
        super("types.Asset", [
            { no: 1, name: "Arch", kind: "scalar", jsonName: "Arch", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "arch" } },
            { no: 2, name: "Description", kind: "scalar", jsonName: "Description", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "description" } },
            { no: 3, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "name" } },
            { no: 4, name: "OS", kind: "scalar", jsonName: "OS", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "os" } },
            { no: 5, name: "SHA256", kind: "scalar", jsonName: "SHA256", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sha256" } },
            { no: 6, name: "AssetSize", kind: "scalar", jsonName: "AssetSize", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "asset_size" } },
            { no: 7, name: "DisplaySize", kind: "scalar", jsonName: "DisplaySize", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "display_size" } },
            { no: 8, name: "ReleaseIDs", kind: "scalar", jsonName: "ReleaseIDs", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "release_ids" } },
            { no: 9, name: "PublicURL", kind: "scalar", jsonName: "PublicURL", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "public_url" } }
        ]);
    }
    create(value?: PartialMessage<Asset>): Asset {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.arch = "";
        message.description = "";
        message.name = "";
        message.oS = "";
        message.sHA256 = "";
        message.assetSize = 0n;
        message.displaySize = "";
        message.releaseIDs = [];
        message.publicURL = "";
        if (value !== undefined)
            reflectionMergePartial<Asset>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Asset): Asset {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Arch = 1 [json_name = "Arch"];*/ 1:
                    message.arch = reader.string();
                    break;
                case /* string Description = 2 [json_name = "Description"];*/ 2:
                    message.description = reader.string();
                    break;
                case /* string Name = 3 [json_name = "Name"];*/ 3:
                    message.name = reader.string();
                    break;
                case /* string OS = 4 [json_name = "OS"];*/ 4:
                    message.oS = reader.string();
                    break;
                case /* string SHA256 = 5 [json_name = "SHA256"];*/ 5:
                    message.sHA256 = reader.string();
                    break;
                case /* int64 AssetSize = 6 [json_name = "AssetSize"];*/ 6:
                    message.assetSize = reader.int64().toBigInt();
                    break;
                case /* string DisplaySize = 7 [json_name = "DisplaySize"];*/ 7:
                    message.displaySize = reader.string();
                    break;
                case /* repeated string ReleaseIDs = 8 [json_name = "ReleaseIDs"];*/ 8:
                    message.releaseIDs.push(reader.string());
                    break;
                case /* string PublicURL = 9 [json_name = "PublicURL"];*/ 9:
                    message.publicURL = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Asset, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Arch = 1 [json_name = "Arch"]; */
        if (message.arch !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.arch);
        /* string Description = 2 [json_name = "Description"]; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* string Name = 3 [json_name = "Name"]; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string OS = 4 [json_name = "OS"]; */
        if (message.oS !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.oS);
        /* string SHA256 = 5 [json_name = "SHA256"]; */
        if (message.sHA256 !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.sHA256);
        /* int64 AssetSize = 6 [json_name = "AssetSize"]; */
        if (message.assetSize !== 0n)
            writer.tag(6, WireType.Varint).int64(message.assetSize);
        /* string DisplaySize = 7 [json_name = "DisplaySize"]; */
        if (message.displaySize !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.displaySize);
        /* repeated string ReleaseIDs = 8 [json_name = "ReleaseIDs"]; */
        for (let i = 0; i < message.releaseIDs.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.releaseIDs[i]);
        /* string PublicURL = 9 [json_name = "PublicURL"]; */
        if (message.publicURL !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.publicURL);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.Asset
 */
export const Asset = new Asset$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginV1$Type extends MessageType<PluginV1> {
    constructor() {
        super("types.PluginV1", [
            { no: 1, name: "kind", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "sub_kind", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "metadata", kind: "message", T: () => Metadata, options: { "gogoproto.nullable": false } },
            { no: 5, name: "spec", kind: "message", T: () => PluginSpecV1, options: { "gogoproto.nullable": false } },
            { no: 6, name: "status", kind: "message", T: () => PluginStatusV1, options: { "gogoproto.nullable": false } },
            { no: 7, name: "credentials", kind: "message", T: () => PluginCredentialsV1 }
        ]);
    }
    create(value?: PartialMessage<PluginV1>): PluginV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.subKind = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<PluginV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginV1): PluginV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string kind */ 1:
                    message.kind = reader.string();
                    break;
                case /* string sub_kind */ 2:
                    message.subKind = reader.string();
                    break;
                case /* string version */ 3:
                    message.version = reader.string();
                    break;
                case /* types.Metadata metadata */ 4:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* types.PluginSpecV1 spec */ 5:
                    message.spec = PluginSpecV1.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                case /* types.PluginStatusV1 status */ 6:
                    message.status = PluginStatusV1.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* types.PluginCredentialsV1 credentials */ 7:
                    message.credentials = PluginCredentialsV1.internalBinaryRead(reader, reader.uint32(), options, message.credentials);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string kind = 1; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string sub_kind = 2; */
        if (message.subKind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subKind);
        /* string version = 3; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* types.Metadata metadata = 4; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.PluginSpecV1 spec = 5; */
        if (message.spec)
            PluginSpecV1.internalBinaryWrite(message.spec, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* types.PluginStatusV1 status = 6; */
        if (message.status)
            PluginStatusV1.internalBinaryWrite(message.status, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* types.PluginCredentialsV1 credentials = 7; */
        if (message.credentials)
            PluginCredentialsV1.internalBinaryWrite(message.credentials, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginV1
 */
export const PluginV1 = new PluginV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginSpecV1$Type extends MessageType<PluginSpecV1> {
    constructor() {
        super("types.PluginSpecV1", [
            { no: 1, name: "slack_access_plugin", kind: "message", oneof: "settings", T: () => PluginSlackAccessSettings },
            { no: 2, name: "opsgenie", kind: "message", oneof: "settings", T: () => PluginOpsgenieAccessSettings },
            { no: 3, name: "openai", kind: "message", oneof: "settings", T: () => PluginOpenAISettings },
            { no: 4, name: "okta", kind: "message", oneof: "settings", T: () => PluginOktaSettings },
            { no: 5, name: "jamf", kind: "message", oneof: "settings", T: () => PluginJamfSettings },
            { no: 6, name: "pager_duty", kind: "message", oneof: "settings", T: () => PluginPagerDutySettings },
            { no: 7, name: "mattermost", kind: "message", oneof: "settings", T: () => PluginMattermostSettings },
            { no: 8, name: "jira", kind: "message", oneof: "settings", T: () => PluginJiraSettings },
            { no: 9, name: "discord", kind: "message", oneof: "settings", T: () => PluginDiscordSettings },
            { no: 10, name: "serviceNow", kind: "message", oneof: "settings", T: () => PluginServiceNowSettings },
            { no: 12, name: "gitlab", kind: "message", oneof: "settings", T: () => PluginGitlabSettings },
            { no: 13, name: "entra_id", kind: "message", oneof: "settings", T: () => PluginEntraIDSettings },
            { no: 14, name: "scim", kind: "message", oneof: "settings", T: () => PluginSCIMSettings },
            { no: 15, name: "datadog", kind: "message", oneof: "settings", T: () => PluginDatadogAccessSettings },
            { no: 16, name: "aws_ic", kind: "message", oneof: "settings", T: () => PluginAWSICSettings },
            { no: 17, name: "email", kind: "message", oneof: "settings", T: () => PluginEmailSettings },
            { no: 18, name: "msteams", kind: "message", oneof: "settings", T: () => PluginMSTeamsSettings },
            { no: 19, name: "net_iq", kind: "message", oneof: "settings", T: () => PluginNetIQSettings },
            { no: 20, name: "github", kind: "message", oneof: "settings", T: () => PluginGithubSettings },
            { no: 11, name: "generation", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.equal": true });
    }
    create(value?: PartialMessage<PluginSpecV1>): PluginSpecV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.settings = { oneofKind: undefined };
        message.generation = "";
        if (value !== undefined)
            reflectionMergePartial<PluginSpecV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginSpecV1): PluginSpecV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.PluginSlackAccessSettings slack_access_plugin */ 1:
                    message.settings = {
                        oneofKind: "slackAccessPlugin",
                        slackAccessPlugin: PluginSlackAccessSettings.internalBinaryRead(reader, reader.uint32(), options, (message.settings as any).slackAccessPlugin)
                    };
                    break;
                case /* types.PluginOpsgenieAccessSettings opsgenie */ 2:
                    message.settings = {
                        oneofKind: "opsgenie",
                        opsgenie: PluginOpsgenieAccessSettings.internalBinaryRead(reader, reader.uint32(), options, (message.settings as any).opsgenie)
                    };
                    break;
                case /* types.PluginOpenAISettings openai */ 3:
                    message.settings = {
                        oneofKind: "openai",
                        openai: PluginOpenAISettings.internalBinaryRead(reader, reader.uint32(), options, (message.settings as any).openai)
                    };
                    break;
                case /* types.PluginOktaSettings okta */ 4:
                    message.settings = {
                        oneofKind: "okta",
                        okta: PluginOktaSettings.internalBinaryRead(reader, reader.uint32(), options, (message.settings as any).okta)
                    };
                    break;
                case /* types.PluginJamfSettings jamf */ 5:
                    message.settings = {
                        oneofKind: "jamf",
                        jamf: PluginJamfSettings.internalBinaryRead(reader, reader.uint32(), options, (message.settings as any).jamf)
                    };
                    break;
                case /* types.PluginPagerDutySettings pager_duty */ 6:
                    message.settings = {
                        oneofKind: "pagerDuty",
                        pagerDuty: PluginPagerDutySettings.internalBinaryRead(reader, reader.uint32(), options, (message.settings as any).pagerDuty)
                    };
                    break;
                case /* types.PluginMattermostSettings mattermost */ 7:
                    message.settings = {
                        oneofKind: "mattermost",
                        mattermost: PluginMattermostSettings.internalBinaryRead(reader, reader.uint32(), options, (message.settings as any).mattermost)
                    };
                    break;
                case /* types.PluginJiraSettings jira */ 8:
                    message.settings = {
                        oneofKind: "jira",
                        jira: PluginJiraSettings.internalBinaryRead(reader, reader.uint32(), options, (message.settings as any).jira)
                    };
                    break;
                case /* types.PluginDiscordSettings discord */ 9:
                    message.settings = {
                        oneofKind: "discord",
                        discord: PluginDiscordSettings.internalBinaryRead(reader, reader.uint32(), options, (message.settings as any).discord)
                    };
                    break;
                case /* types.PluginServiceNowSettings serviceNow */ 10:
                    message.settings = {
                        oneofKind: "serviceNow",
                        serviceNow: PluginServiceNowSettings.internalBinaryRead(reader, reader.uint32(), options, (message.settings as any).serviceNow)
                    };
                    break;
                case /* types.PluginGitlabSettings gitlab */ 12:
                    message.settings = {
                        oneofKind: "gitlab",
                        gitlab: PluginGitlabSettings.internalBinaryRead(reader, reader.uint32(), options, (message.settings as any).gitlab)
                    };
                    break;
                case /* types.PluginEntraIDSettings entra_id */ 13:
                    message.settings = {
                        oneofKind: "entraId",
                        entraId: PluginEntraIDSettings.internalBinaryRead(reader, reader.uint32(), options, (message.settings as any).entraId)
                    };
                    break;
                case /* types.PluginSCIMSettings scim */ 14:
                    message.settings = {
                        oneofKind: "scim",
                        scim: PluginSCIMSettings.internalBinaryRead(reader, reader.uint32(), options, (message.settings as any).scim)
                    };
                    break;
                case /* types.PluginDatadogAccessSettings datadog */ 15:
                    message.settings = {
                        oneofKind: "datadog",
                        datadog: PluginDatadogAccessSettings.internalBinaryRead(reader, reader.uint32(), options, (message.settings as any).datadog)
                    };
                    break;
                case /* types.PluginAWSICSettings aws_ic */ 16:
                    message.settings = {
                        oneofKind: "awsIc",
                        awsIc: PluginAWSICSettings.internalBinaryRead(reader, reader.uint32(), options, (message.settings as any).awsIc)
                    };
                    break;
                case /* types.PluginEmailSettings email */ 17:
                    message.settings = {
                        oneofKind: "email",
                        email: PluginEmailSettings.internalBinaryRead(reader, reader.uint32(), options, (message.settings as any).email)
                    };
                    break;
                case /* types.PluginMSTeamsSettings msteams */ 18:
                    message.settings = {
                        oneofKind: "msteams",
                        msteams: PluginMSTeamsSettings.internalBinaryRead(reader, reader.uint32(), options, (message.settings as any).msteams)
                    };
                    break;
                case /* types.PluginNetIQSettings net_iq */ 19:
                    message.settings = {
                        oneofKind: "netIq",
                        netIq: PluginNetIQSettings.internalBinaryRead(reader, reader.uint32(), options, (message.settings as any).netIq)
                    };
                    break;
                case /* types.PluginGithubSettings github */ 20:
                    message.settings = {
                        oneofKind: "github",
                        github: PluginGithubSettings.internalBinaryRead(reader, reader.uint32(), options, (message.settings as any).github)
                    };
                    break;
                case /* string generation */ 11:
                    message.generation = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginSpecV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.PluginSlackAccessSettings slack_access_plugin = 1; */
        if (message.settings.oneofKind === "slackAccessPlugin")
            PluginSlackAccessSettings.internalBinaryWrite(message.settings.slackAccessPlugin, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* types.PluginOpsgenieAccessSettings opsgenie = 2; */
        if (message.settings.oneofKind === "opsgenie")
            PluginOpsgenieAccessSettings.internalBinaryWrite(message.settings.opsgenie, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* types.PluginOpenAISettings openai = 3; */
        if (message.settings.oneofKind === "openai")
            PluginOpenAISettings.internalBinaryWrite(message.settings.openai, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* types.PluginOktaSettings okta = 4; */
        if (message.settings.oneofKind === "okta")
            PluginOktaSettings.internalBinaryWrite(message.settings.okta, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.PluginJamfSettings jamf = 5; */
        if (message.settings.oneofKind === "jamf")
            PluginJamfSettings.internalBinaryWrite(message.settings.jamf, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* types.PluginPagerDutySettings pager_duty = 6; */
        if (message.settings.oneofKind === "pagerDuty")
            PluginPagerDutySettings.internalBinaryWrite(message.settings.pagerDuty, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* types.PluginMattermostSettings mattermost = 7; */
        if (message.settings.oneofKind === "mattermost")
            PluginMattermostSettings.internalBinaryWrite(message.settings.mattermost, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* types.PluginJiraSettings jira = 8; */
        if (message.settings.oneofKind === "jira")
            PluginJiraSettings.internalBinaryWrite(message.settings.jira, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* types.PluginDiscordSettings discord = 9; */
        if (message.settings.oneofKind === "discord")
            PluginDiscordSettings.internalBinaryWrite(message.settings.discord, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* types.PluginServiceNowSettings serviceNow = 10; */
        if (message.settings.oneofKind === "serviceNow")
            PluginServiceNowSettings.internalBinaryWrite(message.settings.serviceNow, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* types.PluginGitlabSettings gitlab = 12; */
        if (message.settings.oneofKind === "gitlab")
            PluginGitlabSettings.internalBinaryWrite(message.settings.gitlab, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* types.PluginEntraIDSettings entra_id = 13; */
        if (message.settings.oneofKind === "entraId")
            PluginEntraIDSettings.internalBinaryWrite(message.settings.entraId, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* types.PluginSCIMSettings scim = 14; */
        if (message.settings.oneofKind === "scim")
            PluginSCIMSettings.internalBinaryWrite(message.settings.scim, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* types.PluginDatadogAccessSettings datadog = 15; */
        if (message.settings.oneofKind === "datadog")
            PluginDatadogAccessSettings.internalBinaryWrite(message.settings.datadog, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* types.PluginAWSICSettings aws_ic = 16; */
        if (message.settings.oneofKind === "awsIc")
            PluginAWSICSettings.internalBinaryWrite(message.settings.awsIc, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* types.PluginEmailSettings email = 17; */
        if (message.settings.oneofKind === "email")
            PluginEmailSettings.internalBinaryWrite(message.settings.email, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* types.PluginMSTeamsSettings msteams = 18; */
        if (message.settings.oneofKind === "msteams")
            PluginMSTeamsSettings.internalBinaryWrite(message.settings.msteams, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* types.PluginNetIQSettings net_iq = 19; */
        if (message.settings.oneofKind === "netIq")
            PluginNetIQSettings.internalBinaryWrite(message.settings.netIq, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* types.PluginGithubSettings github = 20; */
        if (message.settings.oneofKind === "github")
            PluginGithubSettings.internalBinaryWrite(message.settings.github, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* string generation = 11; */
        if (message.generation !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.generation);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginSpecV1
 */
export const PluginSpecV1 = new PluginSpecV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginGithubSettings$Type extends MessageType<PluginGithubSettings> {
    constructor() {
        super("types.PluginGithubSettings", [
            { no: 1, name: "api_endpoint", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "client_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "organization_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "start_date", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.stdtime": true } }
        ], { "gogoproto.equal": true });
    }
    create(value?: PartialMessage<PluginGithubSettings>): PluginGithubSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.apiEndpoint = "";
        message.clientId = "";
        message.organizationName = "";
        if (value !== undefined)
            reflectionMergePartial<PluginGithubSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginGithubSettings): PluginGithubSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string api_endpoint */ 1:
                    message.apiEndpoint = reader.string();
                    break;
                case /* string client_id */ 2:
                    message.clientId = reader.string();
                    break;
                case /* string organization_name */ 3:
                    message.organizationName = reader.string();
                    break;
                case /* google.protobuf.Timestamp start_date */ 4:
                    message.startDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.startDate);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginGithubSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string api_endpoint = 1; */
        if (message.apiEndpoint !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.apiEndpoint);
        /* string client_id = 2; */
        if (message.clientId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.clientId);
        /* string organization_name = 3; */
        if (message.organizationName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.organizationName);
        /* google.protobuf.Timestamp start_date = 4; */
        if (message.startDate)
            Timestamp.internalBinaryWrite(message.startDate, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginGithubSettings
 */
export const PluginGithubSettings = new PluginGithubSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginSlackAccessSettings$Type extends MessageType<PluginSlackAccessSettings> {
    constructor() {
        super("types.PluginSlackAccessSettings", [
            { no: 1, name: "fallback_channel", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.equal": true });
    }
    create(value?: PartialMessage<PluginSlackAccessSettings>): PluginSlackAccessSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fallbackChannel = "";
        if (value !== undefined)
            reflectionMergePartial<PluginSlackAccessSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginSlackAccessSettings): PluginSlackAccessSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string fallback_channel */ 1:
                    message.fallbackChannel = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginSlackAccessSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string fallback_channel = 1; */
        if (message.fallbackChannel !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.fallbackChannel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginSlackAccessSettings
 */
export const PluginSlackAccessSettings = new PluginSlackAccessSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginGitlabSettings$Type extends MessageType<PluginGitlabSettings> {
    constructor() {
        super("types.PluginGitlabSettings", [
            { no: 1, name: "api_endpoint", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.equal": true });
    }
    create(value?: PartialMessage<PluginGitlabSettings>): PluginGitlabSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.apiEndpoint = "";
        if (value !== undefined)
            reflectionMergePartial<PluginGitlabSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginGitlabSettings): PluginGitlabSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string api_endpoint */ 1:
                    message.apiEndpoint = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginGitlabSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string api_endpoint = 1; */
        if (message.apiEndpoint !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.apiEndpoint);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginGitlabSettings
 */
export const PluginGitlabSettings = new PluginGitlabSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginOpsgenieAccessSettings$Type extends MessageType<PluginOpsgenieAccessSettings> {
    constructor() {
        super("types.PluginOpsgenieAccessSettings", [
            { no: 2, name: "priority", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "alert_tags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "default_schedules", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "api_endpoint", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.equal": true });
    }
    create(value?: PartialMessage<PluginOpsgenieAccessSettings>): PluginOpsgenieAccessSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.priority = "";
        message.alertTags = [];
        message.defaultSchedules = [];
        message.apiEndpoint = "";
        if (value !== undefined)
            reflectionMergePartial<PluginOpsgenieAccessSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginOpsgenieAccessSettings): PluginOpsgenieAccessSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string priority */ 2:
                    message.priority = reader.string();
                    break;
                case /* repeated string alert_tags */ 3:
                    message.alertTags.push(reader.string());
                    break;
                case /* repeated string default_schedules */ 4:
                    message.defaultSchedules.push(reader.string());
                    break;
                case /* string api_endpoint */ 5:
                    message.apiEndpoint = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginOpsgenieAccessSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string priority = 2; */
        if (message.priority !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.priority);
        /* repeated string alert_tags = 3; */
        for (let i = 0; i < message.alertTags.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.alertTags[i]);
        /* repeated string default_schedules = 4; */
        for (let i = 0; i < message.defaultSchedules.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.defaultSchedules[i]);
        /* string api_endpoint = 5; */
        if (message.apiEndpoint !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.apiEndpoint);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginOpsgenieAccessSettings
 */
export const PluginOpsgenieAccessSettings = new PluginOpsgenieAccessSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginServiceNowSettings$Type extends MessageType<PluginServiceNowSettings> {
    constructor() {
        super("types.PluginServiceNowSettings", [
            { no: 1, name: "api_endpoint", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "api_endpoint,omitempty" } },
            { no: 2, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "username,omitempty" } },
            { no: 3, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "password,omitempty" } },
            { no: 4, name: "close_code", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "close_code,omitempty" } }
        ], { "gogoproto.equal": true });
    }
    create(value?: PartialMessage<PluginServiceNowSettings>): PluginServiceNowSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.apiEndpoint = "";
        message.username = "";
        message.password = "";
        message.closeCode = "";
        if (value !== undefined)
            reflectionMergePartial<PluginServiceNowSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginServiceNowSettings): PluginServiceNowSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string api_endpoint */ 1:
                    message.apiEndpoint = reader.string();
                    break;
                case /* string username */ 2:
                    message.username = reader.string();
                    break;
                case /* string password */ 3:
                    message.password = reader.string();
                    break;
                case /* string close_code */ 4:
                    message.closeCode = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginServiceNowSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string api_endpoint = 1; */
        if (message.apiEndpoint !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.apiEndpoint);
        /* string username = 2; */
        if (message.username !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.username);
        /* string password = 3; */
        if (message.password !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.password);
        /* string close_code = 4; */
        if (message.closeCode !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.closeCode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginServiceNowSettings
 */
export const PluginServiceNowSettings = new PluginServiceNowSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginPagerDutySettings$Type extends MessageType<PluginPagerDutySettings> {
    constructor() {
        super("types.PluginPagerDutySettings", [
            { no: 1, name: "user_email", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "api_endpoint", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.equal": true });
    }
    create(value?: PartialMessage<PluginPagerDutySettings>): PluginPagerDutySettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userEmail = "";
        message.apiEndpoint = "";
        if (value !== undefined)
            reflectionMergePartial<PluginPagerDutySettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginPagerDutySettings): PluginPagerDutySettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_email */ 1:
                    message.userEmail = reader.string();
                    break;
                case /* string api_endpoint */ 2:
                    message.apiEndpoint = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginPagerDutySettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_email = 1; */
        if (message.userEmail !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userEmail);
        /* string api_endpoint = 2; */
        if (message.apiEndpoint !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.apiEndpoint);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginPagerDutySettings
 */
export const PluginPagerDutySettings = new PluginPagerDutySettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginJiraSettings$Type extends MessageType<PluginJiraSettings> {
    constructor() {
        super("types.PluginJiraSettings", [
            { no: 1, name: "server_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "project_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "issue_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.equal": true });
    }
    create(value?: PartialMessage<PluginJiraSettings>): PluginJiraSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.serverUrl = "";
        message.projectKey = "";
        message.issueType = "";
        if (value !== undefined)
            reflectionMergePartial<PluginJiraSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginJiraSettings): PluginJiraSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string server_url */ 1:
                    message.serverUrl = reader.string();
                    break;
                case /* string project_key */ 2:
                    message.projectKey = reader.string();
                    break;
                case /* string issue_type */ 3:
                    message.issueType = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginJiraSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string server_url = 1; */
        if (message.serverUrl !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.serverUrl);
        /* string project_key = 2; */
        if (message.projectKey !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.projectKey);
        /* string issue_type = 3; */
        if (message.issueType !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.issueType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginJiraSettings
 */
export const PluginJiraSettings = new PluginJiraSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginOpenAISettings$Type extends MessageType<PluginOpenAISettings> {
    constructor() {
        super("types.PluginOpenAISettings", [], { "gogoproto.equal": true });
    }
    create(value?: PartialMessage<PluginOpenAISettings>): PluginOpenAISettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PluginOpenAISettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginOpenAISettings): PluginOpenAISettings {
        return target ?? this.create();
    }
    internalBinaryWrite(message: PluginOpenAISettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginOpenAISettings
 */
export const PluginOpenAISettings = new PluginOpenAISettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginMattermostSettings$Type extends MessageType<PluginMattermostSettings> {
    constructor() {
        super("types.PluginMattermostSettings", [
            { no: 1, name: "server_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "team", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "channel", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "report_to_email", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.equal": true });
    }
    create(value?: PartialMessage<PluginMattermostSettings>): PluginMattermostSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.serverUrl = "";
        message.team = "";
        message.channel = "";
        message.reportToEmail = "";
        if (value !== undefined)
            reflectionMergePartial<PluginMattermostSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginMattermostSettings): PluginMattermostSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string server_url */ 1:
                    message.serverUrl = reader.string();
                    break;
                case /* string team */ 2:
                    message.team = reader.string();
                    break;
                case /* string channel */ 3:
                    message.channel = reader.string();
                    break;
                case /* string report_to_email */ 4:
                    message.reportToEmail = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginMattermostSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string server_url = 1; */
        if (message.serverUrl !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.serverUrl);
        /* string team = 2; */
        if (message.team !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.team);
        /* string channel = 3; */
        if (message.channel !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.channel);
        /* string report_to_email = 4; */
        if (message.reportToEmail !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.reportToEmail);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginMattermostSettings
 */
export const PluginMattermostSettings = new PluginMattermostSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginJamfSettings$Type extends MessageType<PluginJamfSettings> {
    constructor() {
        super("types.PluginJamfSettings", [
            { no: 1, name: "jamf_spec", kind: "message", T: () => JamfSpecV1 }
        ], { "gogoproto.equal": true });
    }
    create(value?: PartialMessage<PluginJamfSettings>): PluginJamfSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PluginJamfSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginJamfSettings): PluginJamfSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.JamfSpecV1 jamf_spec */ 1:
                    message.jamfSpec = JamfSpecV1.internalBinaryRead(reader, reader.uint32(), options, message.jamfSpec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginJamfSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.JamfSpecV1 jamf_spec = 1; */
        if (message.jamfSpec)
            JamfSpecV1.internalBinaryWrite(message.jamfSpec, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginJamfSettings
 */
export const PluginJamfSettings = new PluginJamfSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginOktaSettings$Type extends MessageType<PluginOktaSettings> {
    constructor() {
        super("types.PluginOktaSettings", [
            { no: 1, name: "org_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "enable_user_sync", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "sso_connector_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "sync_settings", kind: "message", T: () => PluginOktaSyncSettings },
            { no: 5, name: "credentials_info", kind: "message", T: () => PluginOktaCredentialsInfo },
            { no: 6, name: "enable_system_log_export", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { "gogoproto.equal": true });
    }
    create(value?: PartialMessage<PluginOktaSettings>): PluginOktaSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orgUrl = "";
        message.enableUserSync = false;
        message.ssoConnectorId = "";
        message.enableSystemLogExport = false;
        if (value !== undefined)
            reflectionMergePartial<PluginOktaSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginOktaSettings): PluginOktaSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string org_url */ 1:
                    message.orgUrl = reader.string();
                    break;
                case /* bool enable_user_sync */ 2:
                    message.enableUserSync = reader.bool();
                    break;
                case /* string sso_connector_id */ 3:
                    message.ssoConnectorId = reader.string();
                    break;
                case /* types.PluginOktaSyncSettings sync_settings */ 4:
                    message.syncSettings = PluginOktaSyncSettings.internalBinaryRead(reader, reader.uint32(), options, message.syncSettings);
                    break;
                case /* types.PluginOktaCredentialsInfo credentials_info */ 5:
                    message.credentialsInfo = PluginOktaCredentialsInfo.internalBinaryRead(reader, reader.uint32(), options, message.credentialsInfo);
                    break;
                case /* bool enable_system_log_export */ 6:
                    message.enableSystemLogExport = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginOktaSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string org_url = 1; */
        if (message.orgUrl !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.orgUrl);
        /* bool enable_user_sync = 2; */
        if (message.enableUserSync !== false)
            writer.tag(2, WireType.Varint).bool(message.enableUserSync);
        /* string sso_connector_id = 3; */
        if (message.ssoConnectorId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.ssoConnectorId);
        /* types.PluginOktaSyncSettings sync_settings = 4; */
        if (message.syncSettings)
            PluginOktaSyncSettings.internalBinaryWrite(message.syncSettings, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.PluginOktaCredentialsInfo credentials_info = 5; */
        if (message.credentialsInfo)
            PluginOktaCredentialsInfo.internalBinaryWrite(message.credentialsInfo, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* bool enable_system_log_export = 6; */
        if (message.enableSystemLogExport !== false)
            writer.tag(6, WireType.Varint).bool(message.enableSystemLogExport);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginOktaSettings
 */
export const PluginOktaSettings = new PluginOktaSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginOktaCredentialsInfo$Type extends MessageType<PluginOktaCredentialsInfo> {
    constructor() {
        super("types.PluginOktaCredentialsInfo", [
            { no: 1, name: "has_ssm_token", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "has_oauth_credentials", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "has_scim_token", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { "gogoproto.equal": true });
    }
    create(value?: PartialMessage<PluginOktaCredentialsInfo>): PluginOktaCredentialsInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hasSsmToken = false;
        message.hasOauthCredentials = false;
        message.hasScimToken = false;
        if (value !== undefined)
            reflectionMergePartial<PluginOktaCredentialsInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginOktaCredentialsInfo): PluginOktaCredentialsInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool has_ssm_token */ 1:
                    message.hasSsmToken = reader.bool();
                    break;
                case /* bool has_oauth_credentials */ 2:
                    message.hasOauthCredentials = reader.bool();
                    break;
                case /* bool has_scim_token */ 3:
                    message.hasScimToken = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginOktaCredentialsInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool has_ssm_token = 1; */
        if (message.hasSsmToken !== false)
            writer.tag(1, WireType.Varint).bool(message.hasSsmToken);
        /* bool has_oauth_credentials = 2; */
        if (message.hasOauthCredentials !== false)
            writer.tag(2, WireType.Varint).bool(message.hasOauthCredentials);
        /* bool has_scim_token = 3; */
        if (message.hasScimToken !== false)
            writer.tag(3, WireType.Varint).bool(message.hasScimToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginOktaCredentialsInfo
 */
export const PluginOktaCredentialsInfo = new PluginOktaCredentialsInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginOktaSyncSettings$Type extends MessageType<PluginOktaSyncSettings> {
    constructor() {
        super("types.PluginOktaSyncSettings", [
            { no: 1, name: "sync_users", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "sso_connector_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "sync_access_lists", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "default_owners", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "app_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "group_filters", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "app_filters", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "app_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "disable_sync_app_groups", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "disable_bidirectional_sync", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "user_sync_source", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.equal": true });
    }
    create(value?: PartialMessage<PluginOktaSyncSettings>): PluginOktaSyncSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.syncUsers = false;
        message.ssoConnectorId = "";
        message.syncAccessLists = false;
        message.defaultOwners = [];
        message.appId = "";
        message.groupFilters = [];
        message.appFilters = [];
        message.appName = "";
        message.disableSyncAppGroups = false;
        message.disableBidirectionalSync = false;
        message.userSyncSource = "";
        if (value !== undefined)
            reflectionMergePartial<PluginOktaSyncSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginOktaSyncSettings): PluginOktaSyncSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool sync_users */ 1:
                    message.syncUsers = reader.bool();
                    break;
                case /* string sso_connector_id */ 2:
                    message.ssoConnectorId = reader.string();
                    break;
                case /* bool sync_access_lists */ 3:
                    message.syncAccessLists = reader.bool();
                    break;
                case /* repeated string default_owners */ 4:
                    message.defaultOwners.push(reader.string());
                    break;
                case /* string app_id */ 5:
                    message.appId = reader.string();
                    break;
                case /* repeated string group_filters */ 6:
                    message.groupFilters.push(reader.string());
                    break;
                case /* repeated string app_filters */ 7:
                    message.appFilters.push(reader.string());
                    break;
                case /* string app_name */ 8:
                    message.appName = reader.string();
                    break;
                case /* bool disable_sync_app_groups */ 9:
                    message.disableSyncAppGroups = reader.bool();
                    break;
                case /* bool disable_bidirectional_sync */ 10:
                    message.disableBidirectionalSync = reader.bool();
                    break;
                case /* string user_sync_source */ 11:
                    message.userSyncSource = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginOktaSyncSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool sync_users = 1; */
        if (message.syncUsers !== false)
            writer.tag(1, WireType.Varint).bool(message.syncUsers);
        /* string sso_connector_id = 2; */
        if (message.ssoConnectorId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.ssoConnectorId);
        /* bool sync_access_lists = 3; */
        if (message.syncAccessLists !== false)
            writer.tag(3, WireType.Varint).bool(message.syncAccessLists);
        /* repeated string default_owners = 4; */
        for (let i = 0; i < message.defaultOwners.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.defaultOwners[i]);
        /* string app_id = 5; */
        if (message.appId !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.appId);
        /* repeated string group_filters = 6; */
        for (let i = 0; i < message.groupFilters.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.groupFilters[i]);
        /* repeated string app_filters = 7; */
        for (let i = 0; i < message.appFilters.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.appFilters[i]);
        /* string app_name = 8; */
        if (message.appName !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.appName);
        /* bool disable_sync_app_groups = 9; */
        if (message.disableSyncAppGroups !== false)
            writer.tag(9, WireType.Varint).bool(message.disableSyncAppGroups);
        /* bool disable_bidirectional_sync = 10; */
        if (message.disableBidirectionalSync !== false)
            writer.tag(10, WireType.Varint).bool(message.disableBidirectionalSync);
        /* string user_sync_source = 11; */
        if (message.userSyncSource !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.userSyncSource);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginOktaSyncSettings
 */
export const PluginOktaSyncSettings = new PluginOktaSyncSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DiscordChannels$Type extends MessageType<DiscordChannels> {
    constructor() {
        super("types.DiscordChannels", [
            { no: 1, name: "channel_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.equal": true });
    }
    create(value?: PartialMessage<DiscordChannels>): DiscordChannels {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.channelIds = [];
        if (value !== undefined)
            reflectionMergePartial<DiscordChannels>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DiscordChannels): DiscordChannels {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string channel_ids */ 1:
                    message.channelIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DiscordChannels, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string channel_ids = 1; */
        for (let i = 0; i < message.channelIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.channelIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.DiscordChannels
 */
export const DiscordChannels = new DiscordChannels$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginDiscordSettings$Type extends MessageType<PluginDiscordSettings> {
    constructor() {
        super("types.PluginDiscordSettings", [
            { no: 1, name: "role_to_recipients", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => DiscordChannels } }
        ], { "gogoproto.equal": true });
    }
    create(value?: PartialMessage<PluginDiscordSettings>): PluginDiscordSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.roleToRecipients = {};
        if (value !== undefined)
            reflectionMergePartial<PluginDiscordSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginDiscordSettings): PluginDiscordSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, types.DiscordChannels> role_to_recipients */ 1:
                    this.binaryReadMap1(message.roleToRecipients, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: PluginDiscordSettings["roleToRecipients"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof PluginDiscordSettings["roleToRecipients"] | undefined, val: PluginDiscordSettings["roleToRecipients"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = DiscordChannels.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field types.PluginDiscordSettings.role_to_recipients");
            }
        }
        map[key ?? ""] = val ?? DiscordChannels.create();
    }
    internalBinaryWrite(message: PluginDiscordSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, types.DiscordChannels> role_to_recipients = 1; */
        for (let k of globalThis.Object.keys(message.roleToRecipients)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            DiscordChannels.internalBinaryWrite(message.roleToRecipients[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginDiscordSettings
 */
export const PluginDiscordSettings = new PluginDiscordSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginEntraIDSettings$Type extends MessageType<PluginEntraIDSettings> {
    constructor() {
        super("types.PluginEntraIDSettings", [
            { no: 1, name: "sync_settings", kind: "message", T: () => PluginEntraIDSyncSettings },
            { no: 2, name: "access_graph_settings", kind: "message", T: () => PluginEntraIDAccessGraphSettings }
        ], { "gogoproto.equal": true });
    }
    create(value?: PartialMessage<PluginEntraIDSettings>): PluginEntraIDSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PluginEntraIDSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginEntraIDSettings): PluginEntraIDSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.PluginEntraIDSyncSettings sync_settings */ 1:
                    message.syncSettings = PluginEntraIDSyncSettings.internalBinaryRead(reader, reader.uint32(), options, message.syncSettings);
                    break;
                case /* types.PluginEntraIDAccessGraphSettings access_graph_settings */ 2:
                    message.accessGraphSettings = PluginEntraIDAccessGraphSettings.internalBinaryRead(reader, reader.uint32(), options, message.accessGraphSettings);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginEntraIDSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.PluginEntraIDSyncSettings sync_settings = 1; */
        if (message.syncSettings)
            PluginEntraIDSyncSettings.internalBinaryWrite(message.syncSettings, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* types.PluginEntraIDAccessGraphSettings access_graph_settings = 2; */
        if (message.accessGraphSettings)
            PluginEntraIDAccessGraphSettings.internalBinaryWrite(message.accessGraphSettings, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginEntraIDSettings
 */
export const PluginEntraIDSettings = new PluginEntraIDSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginEntraIDSyncSettings$Type extends MessageType<PluginEntraIDSyncSettings> {
    constructor() {
        super("types.PluginEntraIDSyncSettings", [
            { no: 1, name: "default_owners", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "sso_connector_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "credentials_source", kind: "enum", T: () => ["types.EntraIDCredentialsSource", EntraIDCredentialsSource] },
            { no: 4, name: "tenant_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "entra_app_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.equal": true });
    }
    create(value?: PartialMessage<PluginEntraIDSyncSettings>): PluginEntraIDSyncSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.defaultOwners = [];
        message.ssoConnectorId = "";
        message.credentialsSource = 0;
        message.tenantId = "";
        message.entraAppId = "";
        if (value !== undefined)
            reflectionMergePartial<PluginEntraIDSyncSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginEntraIDSyncSettings): PluginEntraIDSyncSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string default_owners */ 1:
                    message.defaultOwners.push(reader.string());
                    break;
                case /* string sso_connector_id */ 2:
                    message.ssoConnectorId = reader.string();
                    break;
                case /* types.EntraIDCredentialsSource credentials_source */ 3:
                    message.credentialsSource = reader.int32();
                    break;
                case /* string tenant_id */ 4:
                    message.tenantId = reader.string();
                    break;
                case /* string entra_app_id */ 5:
                    message.entraAppId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginEntraIDSyncSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string default_owners = 1; */
        for (let i = 0; i < message.defaultOwners.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.defaultOwners[i]);
        /* string sso_connector_id = 2; */
        if (message.ssoConnectorId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.ssoConnectorId);
        /* types.EntraIDCredentialsSource credentials_source = 3; */
        if (message.credentialsSource !== 0)
            writer.tag(3, WireType.Varint).int32(message.credentialsSource);
        /* string tenant_id = 4; */
        if (message.tenantId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.tenantId);
        /* string entra_app_id = 5; */
        if (message.entraAppId !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.entraAppId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginEntraIDSyncSettings
 */
export const PluginEntraIDSyncSettings = new PluginEntraIDSyncSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginEntraIDAccessGraphSettings$Type extends MessageType<PluginEntraIDAccessGraphSettings> {
    constructor() {
        super("types.PluginEntraIDAccessGraphSettings", [
            { no: 1, name: "app_sso_settings_cache", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PluginEntraIDAppSSOSettings }
        ], { "gogoproto.equal": true });
    }
    create(value?: PartialMessage<PluginEntraIDAccessGraphSettings>): PluginEntraIDAccessGraphSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.appSsoSettingsCache = [];
        if (value !== undefined)
            reflectionMergePartial<PluginEntraIDAccessGraphSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginEntraIDAccessGraphSettings): PluginEntraIDAccessGraphSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.PluginEntraIDAppSSOSettings app_sso_settings_cache */ 1:
                    message.appSsoSettingsCache.push(PluginEntraIDAppSSOSettings.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginEntraIDAccessGraphSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.PluginEntraIDAppSSOSettings app_sso_settings_cache = 1; */
        for (let i = 0; i < message.appSsoSettingsCache.length; i++)
            PluginEntraIDAppSSOSettings.internalBinaryWrite(message.appSsoSettingsCache[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginEntraIDAccessGraphSettings
 */
export const PluginEntraIDAccessGraphSettings = new PluginEntraIDAccessGraphSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginEntraIDAppSSOSettings$Type extends MessageType<PluginEntraIDAppSSOSettings> {
    constructor() {
        super("types.PluginEntraIDAppSSOSettings", [
            { no: 1, name: "app_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "federated_sso_v2", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ], { "gogoproto.equal": true });
    }
    create(value?: PartialMessage<PluginEntraIDAppSSOSettings>): PluginEntraIDAppSSOSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.appId = "";
        message.federatedSsoV2 = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<PluginEntraIDAppSSOSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginEntraIDAppSSOSettings): PluginEntraIDAppSSOSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string app_id */ 1:
                    message.appId = reader.string();
                    break;
                case /* bytes federated_sso_v2 */ 2:
                    message.federatedSsoV2 = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginEntraIDAppSSOSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string app_id = 1; */
        if (message.appId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.appId);
        /* bytes federated_sso_v2 = 2; */
        if (message.federatedSsoV2.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.federatedSsoV2);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginEntraIDAppSSOSettings
 */
export const PluginEntraIDAppSSOSettings = new PluginEntraIDAppSSOSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginSCIMSettings$Type extends MessageType<PluginSCIMSettings> {
    constructor() {
        super("types.PluginSCIMSettings", [
            { no: 1, name: "saml_connector_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "default_role", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.equal": true });
    }
    create(value?: PartialMessage<PluginSCIMSettings>): PluginSCIMSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.samlConnectorName = "";
        message.defaultRole = "";
        if (value !== undefined)
            reflectionMergePartial<PluginSCIMSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginSCIMSettings): PluginSCIMSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string saml_connector_name */ 1:
                    message.samlConnectorName = reader.string();
                    break;
                case /* string default_role */ 2:
                    message.defaultRole = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginSCIMSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string saml_connector_name = 1; */
        if (message.samlConnectorName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.samlConnectorName);
        /* string default_role = 2; */
        if (message.defaultRole !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.defaultRole);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginSCIMSettings
 */
export const PluginSCIMSettings = new PluginSCIMSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginDatadogAccessSettings$Type extends MessageType<PluginDatadogAccessSettings> {
    constructor() {
        super("types.PluginDatadogAccessSettings", [
            { no: 1, name: "api_endpoint", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "fallback_recipient", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.equal": true });
    }
    create(value?: PartialMessage<PluginDatadogAccessSettings>): PluginDatadogAccessSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.apiEndpoint = "";
        message.fallbackRecipient = "";
        if (value !== undefined)
            reflectionMergePartial<PluginDatadogAccessSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginDatadogAccessSettings): PluginDatadogAccessSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string api_endpoint */ 1:
                    message.apiEndpoint = reader.string();
                    break;
                case /* string fallback_recipient */ 2:
                    message.fallbackRecipient = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginDatadogAccessSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string api_endpoint = 1; */
        if (message.apiEndpoint !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.apiEndpoint);
        /* string fallback_recipient = 2; */
        if (message.fallbackRecipient !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.fallbackRecipient);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginDatadogAccessSettings
 */
export const PluginDatadogAccessSettings = new PluginDatadogAccessSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginAWSICSettings$Type extends MessageType<PluginAWSICSettings> {
    constructor() {
        super("types.PluginAWSICSettings", [
            { no: 1, name: "integration_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "region", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "arn", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "provisioning_spec", kind: "message", T: () => AWSICProvisioningSpec },
            { no: 5, name: "access_list_default_owners", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "saml_idp_service_provider_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "credentials_source", kind: "enum", T: () => ["types.AWSICCredentialsSource", AWSICCredentialsSource] },
            { no: 8, name: "user_sync_filters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AWSICUserSyncFilter, options: { "gogoproto.jsontag": "user_sync_filters,omitempty" } },
            { no: 9, name: "aws_accounts_filters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AWSICResourceFilter },
            { no: 10, name: "group_sync_filters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AWSICResourceFilter, options: { "gogoproto.jsontag": "group_sync_filters,omitempty" } },
            { no: 11, name: "credentials", kind: "message", T: () => AWSICCredentials, options: { "gogoproto.jsontag": "credentials,omitempty" } }
        ], { "gogoproto.equal": true });
    }
    create(value?: PartialMessage<PluginAWSICSettings>): PluginAWSICSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.integrationName = "";
        message.region = "";
        message.arn = "";
        message.accessListDefaultOwners = [];
        message.samlIdpServiceProviderName = "";
        message.credentialsSource = 0;
        message.userSyncFilters = [];
        message.awsAccountsFilters = [];
        message.groupSyncFilters = [];
        if (value !== undefined)
            reflectionMergePartial<PluginAWSICSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginAWSICSettings): PluginAWSICSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string integration_name = 1 [deprecated = true];*/ 1:
                    message.integrationName = reader.string();
                    break;
                case /* string region */ 2:
                    message.region = reader.string();
                    break;
                case /* string arn */ 3:
                    message.arn = reader.string();
                    break;
                case /* types.AWSICProvisioningSpec provisioning_spec */ 4:
                    message.provisioningSpec = AWSICProvisioningSpec.internalBinaryRead(reader, reader.uint32(), options, message.provisioningSpec);
                    break;
                case /* repeated string access_list_default_owners */ 5:
                    message.accessListDefaultOwners.push(reader.string());
                    break;
                case /* string saml_idp_service_provider_name */ 6:
                    message.samlIdpServiceProviderName = reader.string();
                    break;
                case /* types.AWSICCredentialsSource credentials_source = 7 [deprecated = true];*/ 7:
                    message.credentialsSource = reader.int32();
                    break;
                case /* repeated types.AWSICUserSyncFilter user_sync_filters */ 8:
                    message.userSyncFilters.push(AWSICUserSyncFilter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated types.AWSICResourceFilter aws_accounts_filters */ 9:
                    message.awsAccountsFilters.push(AWSICResourceFilter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated types.AWSICResourceFilter group_sync_filters */ 10:
                    message.groupSyncFilters.push(AWSICResourceFilter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* types.AWSICCredentials credentials */ 11:
                    message.credentials = AWSICCredentials.internalBinaryRead(reader, reader.uint32(), options, message.credentials);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginAWSICSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string integration_name = 1 [deprecated = true]; */
        if (message.integrationName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.integrationName);
        /* string region = 2; */
        if (message.region !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.region);
        /* string arn = 3; */
        if (message.arn !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.arn);
        /* types.AWSICProvisioningSpec provisioning_spec = 4; */
        if (message.provisioningSpec)
            AWSICProvisioningSpec.internalBinaryWrite(message.provisioningSpec, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated string access_list_default_owners = 5; */
        for (let i = 0; i < message.accessListDefaultOwners.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.accessListDefaultOwners[i]);
        /* string saml_idp_service_provider_name = 6; */
        if (message.samlIdpServiceProviderName !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.samlIdpServiceProviderName);
        /* types.AWSICCredentialsSource credentials_source = 7 [deprecated = true]; */
        if (message.credentialsSource !== 0)
            writer.tag(7, WireType.Varint).int32(message.credentialsSource);
        /* repeated types.AWSICUserSyncFilter user_sync_filters = 8; */
        for (let i = 0; i < message.userSyncFilters.length; i++)
            AWSICUserSyncFilter.internalBinaryWrite(message.userSyncFilters[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* repeated types.AWSICResourceFilter aws_accounts_filters = 9; */
        for (let i = 0; i < message.awsAccountsFilters.length; i++)
            AWSICResourceFilter.internalBinaryWrite(message.awsAccountsFilters[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* repeated types.AWSICResourceFilter group_sync_filters = 10; */
        for (let i = 0; i < message.groupSyncFilters.length; i++)
            AWSICResourceFilter.internalBinaryWrite(message.groupSyncFilters[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* types.AWSICCredentials credentials = 11; */
        if (message.credentials)
            AWSICCredentials.internalBinaryWrite(message.credentials, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginAWSICSettings
 */
export const PluginAWSICSettings = new PluginAWSICSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AWSICCredentials$Type extends MessageType<AWSICCredentials> {
    constructor() {
        super("types.AWSICCredentials", [
            { no: 1, name: "system", kind: "message", oneof: "source", T: () => AWSICCredentialSourceSystem },
            { no: 2, name: "oidc", kind: "message", oneof: "source", T: () => AWSICCredentialSourceOIDC }
        ], { "gogoproto.equal": true });
    }
    create(value?: PartialMessage<AWSICCredentials>): AWSICCredentials {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.source = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<AWSICCredentials>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AWSICCredentials): AWSICCredentials {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.AWSICCredentialSourceSystem system */ 1:
                    message.source = {
                        oneofKind: "system",
                        system: AWSICCredentialSourceSystem.internalBinaryRead(reader, reader.uint32(), options, (message.source as any).system)
                    };
                    break;
                case /* types.AWSICCredentialSourceOIDC oidc */ 2:
                    message.source = {
                        oneofKind: "oidc",
                        oidc: AWSICCredentialSourceOIDC.internalBinaryRead(reader, reader.uint32(), options, (message.source as any).oidc)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AWSICCredentials, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.AWSICCredentialSourceSystem system = 1; */
        if (message.source.oneofKind === "system")
            AWSICCredentialSourceSystem.internalBinaryWrite(message.source.system, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* types.AWSICCredentialSourceOIDC oidc = 2; */
        if (message.source.oneofKind === "oidc")
            AWSICCredentialSourceOIDC.internalBinaryWrite(message.source.oidc, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AWSICCredentials
 */
export const AWSICCredentials = new AWSICCredentials$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AWSICCredentialSourceSystem$Type extends MessageType<AWSICCredentialSourceSystem> {
    constructor() {
        super("types.AWSICCredentialSourceSystem", [
            { no: 1, name: "assume_role_arn", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "assume_role_arn,omitempty" } }
        ], { "gogoproto.equal": true });
    }
    create(value?: PartialMessage<AWSICCredentialSourceSystem>): AWSICCredentialSourceSystem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.assumeRoleArn = "";
        if (value !== undefined)
            reflectionMergePartial<AWSICCredentialSourceSystem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AWSICCredentialSourceSystem): AWSICCredentialSourceSystem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string assume_role_arn */ 1:
                    message.assumeRoleArn = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AWSICCredentialSourceSystem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string assume_role_arn = 1; */
        if (message.assumeRoleArn !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.assumeRoleArn);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AWSICCredentialSourceSystem
 */
export const AWSICCredentialSourceSystem = new AWSICCredentialSourceSystem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AWSICCredentialSourceOIDC$Type extends MessageType<AWSICCredentialSourceOIDC> {
    constructor() {
        super("types.AWSICCredentialSourceOIDC", [
            { no: 1, name: "integration_name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "integration_name,omitempty" } }
        ], { "gogoproto.equal": true });
    }
    create(value?: PartialMessage<AWSICCredentialSourceOIDC>): AWSICCredentialSourceOIDC {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.integrationName = "";
        if (value !== undefined)
            reflectionMergePartial<AWSICCredentialSourceOIDC>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AWSICCredentialSourceOIDC): AWSICCredentialSourceOIDC {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string integration_name */ 1:
                    message.integrationName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AWSICCredentialSourceOIDC, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string integration_name = 1; */
        if (message.integrationName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.integrationName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AWSICCredentialSourceOIDC
 */
export const AWSICCredentialSourceOIDC = new AWSICCredentialSourceOIDC$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AWSICResourceFilter$Type extends MessageType<AWSICResourceFilter> {
    constructor() {
        super("types.AWSICResourceFilter", [
            { no: 1, name: "id", kind: "scalar", oneof: "include", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "id,omitempty" } },
            { no: 2, name: "name_regex", kind: "scalar", oneof: "include", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "name_regex,omitempty" } },
            { no: 3, name: "exclude_id", kind: "scalar", oneof: "exclude", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "id,omitempty" } },
            { no: 4, name: "exclude_name_regex", kind: "scalar", oneof: "exclude", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "name_regex,omitempty" } }
        ], { "gogoproto.equal": true });
    }
    create(value?: PartialMessage<AWSICResourceFilter>): AWSICResourceFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.include = { oneofKind: undefined };
        message.exclude = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<AWSICResourceFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AWSICResourceFilter): AWSICResourceFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.include = {
                        oneofKind: "id",
                        id: reader.string()
                    };
                    break;
                case /* string name_regex */ 2:
                    message.include = {
                        oneofKind: "nameRegex",
                        nameRegex: reader.string()
                    };
                    break;
                case /* string exclude_id */ 3:
                    message.exclude = {
                        oneofKind: "excludeId",
                        excludeId: reader.string()
                    };
                    break;
                case /* string exclude_name_regex */ 4:
                    message.exclude = {
                        oneofKind: "excludeNameRegex",
                        excludeNameRegex: reader.string()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AWSICResourceFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.include.oneofKind === "id")
            writer.tag(1, WireType.LengthDelimited).string(message.include.id);
        /* string name_regex = 2; */
        if (message.include.oneofKind === "nameRegex")
            writer.tag(2, WireType.LengthDelimited).string(message.include.nameRegex);
        /* string exclude_id = 3; */
        if (message.exclude.oneofKind === "excludeId")
            writer.tag(3, WireType.LengthDelimited).string(message.exclude.excludeId);
        /* string exclude_name_regex = 4; */
        if (message.exclude.oneofKind === "excludeNameRegex")
            writer.tag(4, WireType.LengthDelimited).string(message.exclude.excludeNameRegex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AWSICResourceFilter
 */
export const AWSICResourceFilter = new AWSICResourceFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AWSICUserSyncFilter$Type extends MessageType<AWSICUserSyncFilter> {
    constructor() {
        super("types.AWSICUserSyncFilter", [
            { no: 8, name: "labels", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ }, options: { "gogoproto.jsontag": "labels,omitempty" } }
        ], { "gogoproto.equal": true });
    }
    create(value?: PartialMessage<AWSICUserSyncFilter>): AWSICUserSyncFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.labels = {};
        if (value !== undefined)
            reflectionMergePartial<AWSICUserSyncFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AWSICUserSyncFilter): AWSICUserSyncFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, string> labels */ 8:
                    this.binaryReadMap8(message.labels, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap8(map: AWSICUserSyncFilter["labels"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AWSICUserSyncFilter["labels"] | undefined, val: AWSICUserSyncFilter["labels"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field types.AWSICUserSyncFilter.labels");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: AWSICUserSyncFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, string> labels = 8; */
        for (let k of globalThis.Object.keys(message.labels))
            writer.tag(8, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.labels[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AWSICUserSyncFilter
 */
export const AWSICUserSyncFilter = new AWSICUserSyncFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AWSICProvisioningSpec$Type extends MessageType<AWSICProvisioningSpec> {
    constructor() {
        super("types.AWSICProvisioningSpec", [
            { no: 1, name: "base_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "bearer_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.equal": true });
    }
    create(value?: PartialMessage<AWSICProvisioningSpec>): AWSICProvisioningSpec {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.baseUrl = "";
        message.bearerToken = "";
        if (value !== undefined)
            reflectionMergePartial<AWSICProvisioningSpec>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AWSICProvisioningSpec): AWSICProvisioningSpec {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string base_url */ 1:
                    message.baseUrl = reader.string();
                    break;
                case /* string bearer_token */ 2:
                    message.bearerToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AWSICProvisioningSpec, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string base_url = 1; */
        if (message.baseUrl !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.baseUrl);
        /* string bearer_token = 2; */
        if (message.bearerToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.bearerToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AWSICProvisioningSpec
 */
export const AWSICProvisioningSpec = new AWSICProvisioningSpec$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginAWSICStatusV1$Type extends MessageType<PluginAWSICStatusV1> {
    constructor() {
        super("types.PluginAWSICStatusV1", [
            { no: 1, name: "group_import_status", kind: "message", T: () => AWSICGroupImportStatus }
        ]);
    }
    create(value?: PartialMessage<PluginAWSICStatusV1>): PluginAWSICStatusV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PluginAWSICStatusV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginAWSICStatusV1): PluginAWSICStatusV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.AWSICGroupImportStatus group_import_status */ 1:
                    message.groupImportStatus = AWSICGroupImportStatus.internalBinaryRead(reader, reader.uint32(), options, message.groupImportStatus);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginAWSICStatusV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.AWSICGroupImportStatus group_import_status = 1; */
        if (message.groupImportStatus)
            AWSICGroupImportStatus.internalBinaryWrite(message.groupImportStatus, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginAWSICStatusV1
 */
export const PluginAWSICStatusV1 = new PluginAWSICStatusV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AWSICGroupImportStatus$Type extends MessageType<AWSICGroupImportStatus> {
    constructor() {
        super("types.AWSICGroupImportStatus", [
            { no: 1, name: "status_code", kind: "enum", T: () => ["types.AWSICGroupImportStatusCode", AWSICGroupImportStatusCode] },
            { no: 2, name: "error_message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AWSICGroupImportStatus>): AWSICGroupImportStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statusCode = 0;
        message.errorMessage = "";
        if (value !== undefined)
            reflectionMergePartial<AWSICGroupImportStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AWSICGroupImportStatus): AWSICGroupImportStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.AWSICGroupImportStatusCode status_code */ 1:
                    message.statusCode = reader.int32();
                    break;
                case /* string error_message */ 2:
                    message.errorMessage = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AWSICGroupImportStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.AWSICGroupImportStatusCode status_code = 1; */
        if (message.statusCode !== 0)
            writer.tag(1, WireType.Varint).int32(message.statusCode);
        /* string error_message = 2; */
        if (message.errorMessage !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.errorMessage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AWSICGroupImportStatus
 */
export const AWSICGroupImportStatus = new AWSICGroupImportStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginEmailSettings$Type extends MessageType<PluginEmailSettings> {
    constructor() {
        super("types.PluginEmailSettings", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "fallback_recipient", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "mailgun_spec", kind: "message", oneof: "spec", T: () => MailgunSpec },
            { no: 4, name: "smtp_spec", kind: "message", oneof: "spec", T: () => SMTPSpec }
        ], { "gogoproto.equal": true });
    }
    create(value?: PartialMessage<PluginEmailSettings>): PluginEmailSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.fallbackRecipient = "";
        message.spec = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<PluginEmailSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginEmailSettings): PluginEmailSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string fallback_recipient */ 2:
                    message.fallbackRecipient = reader.string();
                    break;
                case /* types.MailgunSpec mailgun_spec */ 3:
                    message.spec = {
                        oneofKind: "mailgunSpec",
                        mailgunSpec: MailgunSpec.internalBinaryRead(reader, reader.uint32(), options, (message.spec as any).mailgunSpec)
                    };
                    break;
                case /* types.SMTPSpec smtp_spec */ 4:
                    message.spec = {
                        oneofKind: "smtpSpec",
                        smtpSpec: SMTPSpec.internalBinaryRead(reader, reader.uint32(), options, (message.spec as any).smtpSpec)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginEmailSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string fallback_recipient = 2; */
        if (message.fallbackRecipient !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.fallbackRecipient);
        /* types.MailgunSpec mailgun_spec = 3; */
        if (message.spec.oneofKind === "mailgunSpec")
            MailgunSpec.internalBinaryWrite(message.spec.mailgunSpec, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* types.SMTPSpec smtp_spec = 4; */
        if (message.spec.oneofKind === "smtpSpec")
            SMTPSpec.internalBinaryWrite(message.spec.smtpSpec, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginEmailSettings
 */
export const PluginEmailSettings = new PluginEmailSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MailgunSpec$Type extends MessageType<MailgunSpec> {
    constructor() {
        super("types.MailgunSpec", [
            { no: 1, name: "domain", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.equal": true });
    }
    create(value?: PartialMessage<MailgunSpec>): MailgunSpec {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.domain = "";
        if (value !== undefined)
            reflectionMergePartial<MailgunSpec>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MailgunSpec): MailgunSpec {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string domain */ 1:
                    message.domain = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MailgunSpec, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string domain = 1; */
        if (message.domain !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.domain);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.MailgunSpec
 */
export const MailgunSpec = new MailgunSpec$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SMTPSpec$Type extends MessageType<SMTPSpec> {
    constructor() {
        super("types.SMTPSpec", [
            { no: 1, name: "host", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "port", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "start_tls_policy", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.equal": true });
    }
    create(value?: PartialMessage<SMTPSpec>): SMTPSpec {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.host = "";
        message.port = 0;
        message.startTlsPolicy = "";
        if (value !== undefined)
            reflectionMergePartial<SMTPSpec>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SMTPSpec): SMTPSpec {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string host */ 1:
                    message.host = reader.string();
                    break;
                case /* int32 port */ 2:
                    message.port = reader.int32();
                    break;
                case /* string start_tls_policy */ 3:
                    message.startTlsPolicy = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SMTPSpec, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string host = 1; */
        if (message.host !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.host);
        /* int32 port = 2; */
        if (message.port !== 0)
            writer.tag(2, WireType.Varint).int32(message.port);
        /* string start_tls_policy = 3; */
        if (message.startTlsPolicy !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.startTlsPolicy);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.SMTPSpec
 */
export const SMTPSpec = new SMTPSpec$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginMSTeamsSettings$Type extends MessageType<PluginMSTeamsSettings> {
    constructor() {
        super("types.PluginMSTeamsSettings", [
            { no: 1, name: "app_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "tenant_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "teams_app_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "region", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "default_recipient", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.equal": true });
    }
    create(value?: PartialMessage<PluginMSTeamsSettings>): PluginMSTeamsSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.appId = "";
        message.tenantId = "";
        message.teamsAppId = "";
        message.region = "";
        message.defaultRecipient = "";
        if (value !== undefined)
            reflectionMergePartial<PluginMSTeamsSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginMSTeamsSettings): PluginMSTeamsSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string app_id */ 1:
                    message.appId = reader.string();
                    break;
                case /* string tenant_id */ 2:
                    message.tenantId = reader.string();
                    break;
                case /* string teams_app_id */ 3:
                    message.teamsAppId = reader.string();
                    break;
                case /* string region */ 4:
                    message.region = reader.string();
                    break;
                case /* string default_recipient */ 5:
                    message.defaultRecipient = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginMSTeamsSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string app_id = 1; */
        if (message.appId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.appId);
        /* string tenant_id = 2; */
        if (message.tenantId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.tenantId);
        /* string teams_app_id = 3; */
        if (message.teamsAppId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.teamsAppId);
        /* string region = 4; */
        if (message.region !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.region);
        /* string default_recipient = 5; */
        if (message.defaultRecipient !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.defaultRecipient);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginMSTeamsSettings
 */
export const PluginMSTeamsSettings = new PluginMSTeamsSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginNetIQSettings$Type extends MessageType<PluginNetIQSettings> {
    constructor() {
        super("types.PluginNetIQSettings", [
            { no: 1, name: "oauth_issuer_endpoint", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "api_endpoint", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "insecure_skip_verify", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { "gogoproto.equal": true });
    }
    create(value?: PartialMessage<PluginNetIQSettings>): PluginNetIQSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.oauthIssuerEndpoint = "";
        message.apiEndpoint = "";
        message.insecureSkipVerify = false;
        if (value !== undefined)
            reflectionMergePartial<PluginNetIQSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginNetIQSettings): PluginNetIQSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string oauth_issuer_endpoint */ 1:
                    message.oauthIssuerEndpoint = reader.string();
                    break;
                case /* string api_endpoint */ 2:
                    message.apiEndpoint = reader.string();
                    break;
                case /* bool insecure_skip_verify */ 3:
                    message.insecureSkipVerify = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginNetIQSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string oauth_issuer_endpoint = 1; */
        if (message.oauthIssuerEndpoint !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.oauthIssuerEndpoint);
        /* string api_endpoint = 2; */
        if (message.apiEndpoint !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.apiEndpoint);
        /* bool insecure_skip_verify = 3; */
        if (message.insecureSkipVerify !== false)
            writer.tag(3, WireType.Varint).bool(message.insecureSkipVerify);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginNetIQSettings
 */
export const PluginNetIQSettings = new PluginNetIQSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginBootstrapCredentialsV1$Type extends MessageType<PluginBootstrapCredentialsV1> {
    constructor() {
        super("types.PluginBootstrapCredentialsV1", [
            { no: 1, name: "oauth2_authorization_code", kind: "message", oneof: "credentials", T: () => PluginOAuth2AuthorizationCodeCredentials },
            { no: 2, name: "bearer_token", kind: "message", oneof: "credentials", T: () => PluginBearerTokenCredentials },
            { no: 3, name: "id_secret", kind: "message", oneof: "credentials", T: () => PluginIdSecretCredential }
        ]);
    }
    create(value?: PartialMessage<PluginBootstrapCredentialsV1>): PluginBootstrapCredentialsV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.credentials = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<PluginBootstrapCredentialsV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginBootstrapCredentialsV1): PluginBootstrapCredentialsV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.PluginOAuth2AuthorizationCodeCredentials oauth2_authorization_code */ 1:
                    message.credentials = {
                        oneofKind: "oauth2AuthorizationCode",
                        oauth2AuthorizationCode: PluginOAuth2AuthorizationCodeCredentials.internalBinaryRead(reader, reader.uint32(), options, (message.credentials as any).oauth2AuthorizationCode)
                    };
                    break;
                case /* types.PluginBearerTokenCredentials bearer_token */ 2:
                    message.credentials = {
                        oneofKind: "bearerToken",
                        bearerToken: PluginBearerTokenCredentials.internalBinaryRead(reader, reader.uint32(), options, (message.credentials as any).bearerToken)
                    };
                    break;
                case /* types.PluginIdSecretCredential id_secret */ 3:
                    message.credentials = {
                        oneofKind: "idSecret",
                        idSecret: PluginIdSecretCredential.internalBinaryRead(reader, reader.uint32(), options, (message.credentials as any).idSecret)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginBootstrapCredentialsV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.PluginOAuth2AuthorizationCodeCredentials oauth2_authorization_code = 1; */
        if (message.credentials.oneofKind === "oauth2AuthorizationCode")
            PluginOAuth2AuthorizationCodeCredentials.internalBinaryWrite(message.credentials.oauth2AuthorizationCode, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* types.PluginBearerTokenCredentials bearer_token = 2; */
        if (message.credentials.oneofKind === "bearerToken")
            PluginBearerTokenCredentials.internalBinaryWrite(message.credentials.bearerToken, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* types.PluginIdSecretCredential id_secret = 3; */
        if (message.credentials.oneofKind === "idSecret")
            PluginIdSecretCredential.internalBinaryWrite(message.credentials.idSecret, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginBootstrapCredentialsV1
 */
export const PluginBootstrapCredentialsV1 = new PluginBootstrapCredentialsV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginIdSecretCredential$Type extends MessageType<PluginIdSecretCredential> {
    constructor() {
        super("types.PluginIdSecretCredential", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "secret", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PluginIdSecretCredential>): PluginIdSecretCredential {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.secret = "";
        if (value !== undefined)
            reflectionMergePartial<PluginIdSecretCredential>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginIdSecretCredential): PluginIdSecretCredential {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string secret */ 2:
                    message.secret = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginIdSecretCredential, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string secret = 2; */
        if (message.secret !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.secret);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginIdSecretCredential
 */
export const PluginIdSecretCredential = new PluginIdSecretCredential$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginOAuth2AuthorizationCodeCredentials$Type extends MessageType<PluginOAuth2AuthorizationCodeCredentials> {
    constructor() {
        super("types.PluginOAuth2AuthorizationCodeCredentials", [
            { no: 1, name: "authorization_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "redirect_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PluginOAuth2AuthorizationCodeCredentials>): PluginOAuth2AuthorizationCodeCredentials {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.authorizationCode = "";
        message.redirectUri = "";
        if (value !== undefined)
            reflectionMergePartial<PluginOAuth2AuthorizationCodeCredentials>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginOAuth2AuthorizationCodeCredentials): PluginOAuth2AuthorizationCodeCredentials {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string authorization_code */ 1:
                    message.authorizationCode = reader.string();
                    break;
                case /* string redirect_uri */ 2:
                    message.redirectUri = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginOAuth2AuthorizationCodeCredentials, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string authorization_code = 1; */
        if (message.authorizationCode !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.authorizationCode);
        /* string redirect_uri = 2; */
        if (message.redirectUri !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.redirectUri);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginOAuth2AuthorizationCodeCredentials
 */
export const PluginOAuth2AuthorizationCodeCredentials = new PluginOAuth2AuthorizationCodeCredentials$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginStatusV1$Type extends MessageType<PluginStatusV1> {
    constructor() {
        super("types.PluginStatusV1", [
            { no: 1, name: "code", kind: "enum", T: () => ["types.PluginStatusCode", PluginStatusCode] },
            { no: 2, name: "error_message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "last_sync_time", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.stdtime": true } },
            { no: 4, name: "gitlab", kind: "message", oneof: "details", T: () => PluginGitlabStatusV1 },
            { no: 5, name: "entra_id", kind: "message", oneof: "details", T: () => PluginEntraIDStatusV1 },
            { no: 7, name: "okta", kind: "message", oneof: "details", T: () => PluginOktaStatusV1 },
            { no: 8, name: "aws_ic", kind: "message", oneof: "details", T: () => PluginAWSICStatusV1 },
            { no: 9, name: "net_iq", kind: "message", oneof: "details", T: () => PluginNetIQStatusV1 },
            { no: 6, name: "last_raw_error", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PluginStatusV1>): PluginStatusV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.code = 0;
        message.errorMessage = "";
        message.details = { oneofKind: undefined };
        message.lastRawError = "";
        if (value !== undefined)
            reflectionMergePartial<PluginStatusV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginStatusV1): PluginStatusV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.PluginStatusCode code */ 1:
                    message.code = reader.int32();
                    break;
                case /* string error_message */ 2:
                    message.errorMessage = reader.string();
                    break;
                case /* google.protobuf.Timestamp last_sync_time */ 3:
                    message.lastSyncTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastSyncTime);
                    break;
                case /* types.PluginGitlabStatusV1 gitlab */ 4:
                    message.details = {
                        oneofKind: "gitlab",
                        gitlab: PluginGitlabStatusV1.internalBinaryRead(reader, reader.uint32(), options, (message.details as any).gitlab)
                    };
                    break;
                case /* types.PluginEntraIDStatusV1 entra_id */ 5:
                    message.details = {
                        oneofKind: "entraId",
                        entraId: PluginEntraIDStatusV1.internalBinaryRead(reader, reader.uint32(), options, (message.details as any).entraId)
                    };
                    break;
                case /* types.PluginOktaStatusV1 okta */ 7:
                    message.details = {
                        oneofKind: "okta",
                        okta: PluginOktaStatusV1.internalBinaryRead(reader, reader.uint32(), options, (message.details as any).okta)
                    };
                    break;
                case /* types.PluginAWSICStatusV1 aws_ic */ 8:
                    message.details = {
                        oneofKind: "awsIc",
                        awsIc: PluginAWSICStatusV1.internalBinaryRead(reader, reader.uint32(), options, (message.details as any).awsIc)
                    };
                    break;
                case /* types.PluginNetIQStatusV1 net_iq */ 9:
                    message.details = {
                        oneofKind: "netIq",
                        netIq: PluginNetIQStatusV1.internalBinaryRead(reader, reader.uint32(), options, (message.details as any).netIq)
                    };
                    break;
                case /* string last_raw_error */ 6:
                    message.lastRawError = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginStatusV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.PluginStatusCode code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).int32(message.code);
        /* string error_message = 2; */
        if (message.errorMessage !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.errorMessage);
        /* google.protobuf.Timestamp last_sync_time = 3; */
        if (message.lastSyncTime)
            Timestamp.internalBinaryWrite(message.lastSyncTime, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* types.PluginGitlabStatusV1 gitlab = 4; */
        if (message.details.oneofKind === "gitlab")
            PluginGitlabStatusV1.internalBinaryWrite(message.details.gitlab, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.PluginEntraIDStatusV1 entra_id = 5; */
        if (message.details.oneofKind === "entraId")
            PluginEntraIDStatusV1.internalBinaryWrite(message.details.entraId, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* types.PluginOktaStatusV1 okta = 7; */
        if (message.details.oneofKind === "okta")
            PluginOktaStatusV1.internalBinaryWrite(message.details.okta, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* types.PluginAWSICStatusV1 aws_ic = 8; */
        if (message.details.oneofKind === "awsIc")
            PluginAWSICStatusV1.internalBinaryWrite(message.details.awsIc, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* types.PluginNetIQStatusV1 net_iq = 9; */
        if (message.details.oneofKind === "netIq")
            PluginNetIQStatusV1.internalBinaryWrite(message.details.netIq, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* string last_raw_error = 6; */
        if (message.lastRawError !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.lastRawError);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginStatusV1
 */
export const PluginStatusV1 = new PluginStatusV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginNetIQStatusV1$Type extends MessageType<PluginNetIQStatusV1> {
    constructor() {
        super("types.PluginNetIQStatusV1", [
            { no: 1, name: "imported_users", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "imported_groups", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "imported_roles", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "imported_resources", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<PluginNetIQStatusV1>): PluginNetIQStatusV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.importedUsers = 0;
        message.importedGroups = 0;
        message.importedRoles = 0;
        message.importedResources = 0;
        if (value !== undefined)
            reflectionMergePartial<PluginNetIQStatusV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginNetIQStatusV1): PluginNetIQStatusV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 imported_users */ 1:
                    message.importedUsers = reader.uint32();
                    break;
                case /* uint32 imported_groups */ 2:
                    message.importedGroups = reader.uint32();
                    break;
                case /* uint32 imported_roles */ 3:
                    message.importedRoles = reader.uint32();
                    break;
                case /* uint32 imported_resources */ 4:
                    message.importedResources = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginNetIQStatusV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 imported_users = 1; */
        if (message.importedUsers !== 0)
            writer.tag(1, WireType.Varint).uint32(message.importedUsers);
        /* uint32 imported_groups = 2; */
        if (message.importedGroups !== 0)
            writer.tag(2, WireType.Varint).uint32(message.importedGroups);
        /* uint32 imported_roles = 3; */
        if (message.importedRoles !== 0)
            writer.tag(3, WireType.Varint).uint32(message.importedRoles);
        /* uint32 imported_resources = 4; */
        if (message.importedResources !== 0)
            writer.tag(4, WireType.Varint).uint32(message.importedResources);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginNetIQStatusV1
 */
export const PluginNetIQStatusV1 = new PluginNetIQStatusV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginGitlabStatusV1$Type extends MessageType<PluginGitlabStatusV1> {
    constructor() {
        super("types.PluginGitlabStatusV1", [
            { no: 1, name: "imported_users", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "imported_groups", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "imported_projects", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<PluginGitlabStatusV1>): PluginGitlabStatusV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.importedUsers = 0;
        message.importedGroups = 0;
        message.importedProjects = 0;
        if (value !== undefined)
            reflectionMergePartial<PluginGitlabStatusV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginGitlabStatusV1): PluginGitlabStatusV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 imported_users */ 1:
                    message.importedUsers = reader.uint32();
                    break;
                case /* uint32 imported_groups */ 2:
                    message.importedGroups = reader.uint32();
                    break;
                case /* uint32 imported_projects */ 3:
                    message.importedProjects = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginGitlabStatusV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 imported_users = 1; */
        if (message.importedUsers !== 0)
            writer.tag(1, WireType.Varint).uint32(message.importedUsers);
        /* uint32 imported_groups = 2; */
        if (message.importedGroups !== 0)
            writer.tag(2, WireType.Varint).uint32(message.importedGroups);
        /* uint32 imported_projects = 3; */
        if (message.importedProjects !== 0)
            writer.tag(3, WireType.Varint).uint32(message.importedProjects);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginGitlabStatusV1
 */
export const PluginGitlabStatusV1 = new PluginGitlabStatusV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginEntraIDStatusV1$Type extends MessageType<PluginEntraIDStatusV1> {
    constructor() {
        super("types.PluginEntraIDStatusV1", [
            { no: 1, name: "imported_users", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "imported_groups", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<PluginEntraIDStatusV1>): PluginEntraIDStatusV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.importedUsers = 0;
        message.importedGroups = 0;
        if (value !== undefined)
            reflectionMergePartial<PluginEntraIDStatusV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginEntraIDStatusV1): PluginEntraIDStatusV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 imported_users */ 1:
                    message.importedUsers = reader.uint32();
                    break;
                case /* uint32 imported_groups */ 2:
                    message.importedGroups = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginEntraIDStatusV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 imported_users = 1; */
        if (message.importedUsers !== 0)
            writer.tag(1, WireType.Varint).uint32(message.importedUsers);
        /* uint32 imported_groups = 2; */
        if (message.importedGroups !== 0)
            writer.tag(2, WireType.Varint).uint32(message.importedGroups);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginEntraIDStatusV1
 */
export const PluginEntraIDStatusV1 = new PluginEntraIDStatusV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginOktaStatusV1$Type extends MessageType<PluginOktaStatusV1> {
    constructor() {
        super("types.PluginOktaStatusV1", [
            { no: 1, name: "sso_details", kind: "message", T: () => PluginOktaStatusDetailsSSO },
            { no: 2, name: "app_group_sync_details", kind: "message", T: () => PluginOktaStatusDetailsAppGroupSync },
            { no: 3, name: "users_sync_details", kind: "message", T: () => PluginOktaStatusDetailsUsersSync },
            { no: 4, name: "scim_details", kind: "message", T: () => PluginOktaStatusDetailsSCIM },
            { no: 5, name: "access_lists_sync_details", kind: "message", T: () => PluginOktaStatusDetailsAccessListsSync }
        ]);
    }
    create(value?: PartialMessage<PluginOktaStatusV1>): PluginOktaStatusV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PluginOktaStatusV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginOktaStatusV1): PluginOktaStatusV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.PluginOktaStatusDetailsSSO sso_details */ 1:
                    message.ssoDetails = PluginOktaStatusDetailsSSO.internalBinaryRead(reader, reader.uint32(), options, message.ssoDetails);
                    break;
                case /* types.PluginOktaStatusDetailsAppGroupSync app_group_sync_details */ 2:
                    message.appGroupSyncDetails = PluginOktaStatusDetailsAppGroupSync.internalBinaryRead(reader, reader.uint32(), options, message.appGroupSyncDetails);
                    break;
                case /* types.PluginOktaStatusDetailsUsersSync users_sync_details */ 3:
                    message.usersSyncDetails = PluginOktaStatusDetailsUsersSync.internalBinaryRead(reader, reader.uint32(), options, message.usersSyncDetails);
                    break;
                case /* types.PluginOktaStatusDetailsSCIM scim_details */ 4:
                    message.scimDetails = PluginOktaStatusDetailsSCIM.internalBinaryRead(reader, reader.uint32(), options, message.scimDetails);
                    break;
                case /* types.PluginOktaStatusDetailsAccessListsSync access_lists_sync_details */ 5:
                    message.accessListsSyncDetails = PluginOktaStatusDetailsAccessListsSync.internalBinaryRead(reader, reader.uint32(), options, message.accessListsSyncDetails);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginOktaStatusV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.PluginOktaStatusDetailsSSO sso_details = 1; */
        if (message.ssoDetails)
            PluginOktaStatusDetailsSSO.internalBinaryWrite(message.ssoDetails, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* types.PluginOktaStatusDetailsAppGroupSync app_group_sync_details = 2; */
        if (message.appGroupSyncDetails)
            PluginOktaStatusDetailsAppGroupSync.internalBinaryWrite(message.appGroupSyncDetails, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* types.PluginOktaStatusDetailsUsersSync users_sync_details = 3; */
        if (message.usersSyncDetails)
            PluginOktaStatusDetailsUsersSync.internalBinaryWrite(message.usersSyncDetails, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* types.PluginOktaStatusDetailsSCIM scim_details = 4; */
        if (message.scimDetails)
            PluginOktaStatusDetailsSCIM.internalBinaryWrite(message.scimDetails, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.PluginOktaStatusDetailsAccessListsSync access_lists_sync_details = 5; */
        if (message.accessListsSyncDetails)
            PluginOktaStatusDetailsAccessListsSync.internalBinaryWrite(message.accessListsSyncDetails, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginOktaStatusV1
 */
export const PluginOktaStatusV1 = new PluginOktaStatusV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginOktaStatusDetailsSSO$Type extends MessageType<PluginOktaStatusDetailsSSO> {
    constructor() {
        super("types.PluginOktaStatusDetailsSSO", [
            { no: 1, name: "enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "app_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "app_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "okta_group_everyone_mapped_roles", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PluginOktaStatusDetailsSSO>): PluginOktaStatusDetailsSSO {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.enabled = false;
        message.appId = "";
        message.appName = "";
        message.oktaGroupEveryoneMappedRoles = [];
        if (value !== undefined)
            reflectionMergePartial<PluginOktaStatusDetailsSSO>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginOktaStatusDetailsSSO): PluginOktaStatusDetailsSSO {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool enabled */ 1:
                    message.enabled = reader.bool();
                    break;
                case /* string app_id */ 2:
                    message.appId = reader.string();
                    break;
                case /* string app_name */ 3:
                    message.appName = reader.string();
                    break;
                case /* repeated string okta_group_everyone_mapped_roles */ 4:
                    message.oktaGroupEveryoneMappedRoles.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginOktaStatusDetailsSSO, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool enabled = 1; */
        if (message.enabled !== false)
            writer.tag(1, WireType.Varint).bool(message.enabled);
        /* string app_id = 2; */
        if (message.appId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.appId);
        /* string app_name = 3; */
        if (message.appName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.appName);
        /* repeated string okta_group_everyone_mapped_roles = 4; */
        for (let i = 0; i < message.oktaGroupEveryoneMappedRoles.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.oktaGroupEveryoneMappedRoles[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginOktaStatusDetailsSSO
 */
export const PluginOktaStatusDetailsSSO = new PluginOktaStatusDetailsSSO$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginOktaStatusDetailsAppGroupSync$Type extends MessageType<PluginOktaStatusDetailsAppGroupSync> {
    constructor() {
        super("types.PluginOktaStatusDetailsAppGroupSync", [
            { no: 1, name: "enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "status_code", kind: "enum", T: () => ["types.OktaPluginSyncStatusCode", OktaPluginSyncStatusCode, "OKTA_PLUGIN_SYNC_STATUS_CODE_"] },
            { no: 3, name: "last_successful", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": true, "gogoproto.jsontag": "last_successful", "gogoproto.stdtime": true } },
            { no: 4, name: "last_failed", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": true, "gogoproto.jsontag": "last_failed", "gogoproto.stdtime": true } },
            { no: 5, name: "num_apps_synced", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "num_groups_synced", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PluginOktaStatusDetailsAppGroupSync>): PluginOktaStatusDetailsAppGroupSync {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.enabled = false;
        message.statusCode = 0;
        message.numAppsSynced = 0;
        message.numGroupsSynced = 0;
        message.error = "";
        if (value !== undefined)
            reflectionMergePartial<PluginOktaStatusDetailsAppGroupSync>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginOktaStatusDetailsAppGroupSync): PluginOktaStatusDetailsAppGroupSync {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool enabled */ 1:
                    message.enabled = reader.bool();
                    break;
                case /* types.OktaPluginSyncStatusCode status_code */ 2:
                    message.statusCode = reader.int32();
                    break;
                case /* google.protobuf.Timestamp last_successful */ 3:
                    message.lastSuccessful = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastSuccessful);
                    break;
                case /* google.protobuf.Timestamp last_failed */ 4:
                    message.lastFailed = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastFailed);
                    break;
                case /* int32 num_apps_synced */ 5:
                    message.numAppsSynced = reader.int32();
                    break;
                case /* int32 num_groups_synced */ 6:
                    message.numGroupsSynced = reader.int32();
                    break;
                case /* string error */ 7:
                    message.error = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginOktaStatusDetailsAppGroupSync, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool enabled = 1; */
        if (message.enabled !== false)
            writer.tag(1, WireType.Varint).bool(message.enabled);
        /* types.OktaPluginSyncStatusCode status_code = 2; */
        if (message.statusCode !== 0)
            writer.tag(2, WireType.Varint).int32(message.statusCode);
        /* google.protobuf.Timestamp last_successful = 3; */
        if (message.lastSuccessful)
            Timestamp.internalBinaryWrite(message.lastSuccessful, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp last_failed = 4; */
        if (message.lastFailed)
            Timestamp.internalBinaryWrite(message.lastFailed, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* int32 num_apps_synced = 5; */
        if (message.numAppsSynced !== 0)
            writer.tag(5, WireType.Varint).int32(message.numAppsSynced);
        /* int32 num_groups_synced = 6; */
        if (message.numGroupsSynced !== 0)
            writer.tag(6, WireType.Varint).int32(message.numGroupsSynced);
        /* string error = 7; */
        if (message.error !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginOktaStatusDetailsAppGroupSync
 */
export const PluginOktaStatusDetailsAppGroupSync = new PluginOktaStatusDetailsAppGroupSync$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginOktaStatusDetailsUsersSync$Type extends MessageType<PluginOktaStatusDetailsUsersSync> {
    constructor() {
        super("types.PluginOktaStatusDetailsUsersSync", [
            { no: 1, name: "enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "status_code", kind: "enum", T: () => ["types.OktaPluginSyncStatusCode", OktaPluginSyncStatusCode, "OKTA_PLUGIN_SYNC_STATUS_CODE_"] },
            { no: 3, name: "last_successful", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": true, "gogoproto.jsontag": "last_successful", "gogoproto.stdtime": true } },
            { no: 4, name: "last_failed", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": true, "gogoproto.jsontag": "last_failed", "gogoproto.stdtime": true } },
            { no: 5, name: "num_users_synced", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PluginOktaStatusDetailsUsersSync>): PluginOktaStatusDetailsUsersSync {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.enabled = false;
        message.statusCode = 0;
        message.numUsersSynced = 0;
        message.error = "";
        if (value !== undefined)
            reflectionMergePartial<PluginOktaStatusDetailsUsersSync>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginOktaStatusDetailsUsersSync): PluginOktaStatusDetailsUsersSync {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool enabled */ 1:
                    message.enabled = reader.bool();
                    break;
                case /* types.OktaPluginSyncStatusCode status_code */ 2:
                    message.statusCode = reader.int32();
                    break;
                case /* google.protobuf.Timestamp last_successful */ 3:
                    message.lastSuccessful = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastSuccessful);
                    break;
                case /* google.protobuf.Timestamp last_failed */ 4:
                    message.lastFailed = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastFailed);
                    break;
                case /* int32 num_users_synced */ 5:
                    message.numUsersSynced = reader.int32();
                    break;
                case /* string error */ 6:
                    message.error = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginOktaStatusDetailsUsersSync, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool enabled = 1; */
        if (message.enabled !== false)
            writer.tag(1, WireType.Varint).bool(message.enabled);
        /* types.OktaPluginSyncStatusCode status_code = 2; */
        if (message.statusCode !== 0)
            writer.tag(2, WireType.Varint).int32(message.statusCode);
        /* google.protobuf.Timestamp last_successful = 3; */
        if (message.lastSuccessful)
            Timestamp.internalBinaryWrite(message.lastSuccessful, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp last_failed = 4; */
        if (message.lastFailed)
            Timestamp.internalBinaryWrite(message.lastFailed, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* int32 num_users_synced = 5; */
        if (message.numUsersSynced !== 0)
            writer.tag(5, WireType.Varint).int32(message.numUsersSynced);
        /* string error = 6; */
        if (message.error !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginOktaStatusDetailsUsersSync
 */
export const PluginOktaStatusDetailsUsersSync = new PluginOktaStatusDetailsUsersSync$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginOktaStatusDetailsSCIM$Type extends MessageType<PluginOktaStatusDetailsSCIM> {
    constructor() {
        super("types.PluginOktaStatusDetailsSCIM", [
            { no: 1, name: "enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<PluginOktaStatusDetailsSCIM>): PluginOktaStatusDetailsSCIM {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.enabled = false;
        if (value !== undefined)
            reflectionMergePartial<PluginOktaStatusDetailsSCIM>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginOktaStatusDetailsSCIM): PluginOktaStatusDetailsSCIM {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool enabled */ 1:
                    message.enabled = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginOktaStatusDetailsSCIM, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool enabled = 1; */
        if (message.enabled !== false)
            writer.tag(1, WireType.Varint).bool(message.enabled);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginOktaStatusDetailsSCIM
 */
export const PluginOktaStatusDetailsSCIM = new PluginOktaStatusDetailsSCIM$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginOktaStatusDetailsAccessListsSync$Type extends MessageType<PluginOktaStatusDetailsAccessListsSync> {
    constructor() {
        super("types.PluginOktaStatusDetailsAccessListsSync", [
            { no: 1, name: "enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "status_code", kind: "enum", T: () => ["types.OktaPluginSyncStatusCode", OktaPluginSyncStatusCode, "OKTA_PLUGIN_SYNC_STATUS_CODE_"] },
            { no: 3, name: "last_successful", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": true, "gogoproto.jsontag": "last_successful", "gogoproto.stdtime": true } },
            { no: 4, name: "last_failed", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": true, "gogoproto.jsontag": "last_failed", "gogoproto.stdtime": true } },
            { no: 5, name: "app_filters", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "num_apps_synced", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "group_filters", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "num_groups_synced", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PluginOktaStatusDetailsAccessListsSync>): PluginOktaStatusDetailsAccessListsSync {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.enabled = false;
        message.statusCode = 0;
        message.appFilters = [];
        message.numAppsSynced = 0;
        message.groupFilters = [];
        message.numGroupsSynced = 0;
        message.error = "";
        if (value !== undefined)
            reflectionMergePartial<PluginOktaStatusDetailsAccessListsSync>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginOktaStatusDetailsAccessListsSync): PluginOktaStatusDetailsAccessListsSync {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool enabled */ 1:
                    message.enabled = reader.bool();
                    break;
                case /* types.OktaPluginSyncStatusCode status_code */ 2:
                    message.statusCode = reader.int32();
                    break;
                case /* google.protobuf.Timestamp last_successful */ 3:
                    message.lastSuccessful = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastSuccessful);
                    break;
                case /* google.protobuf.Timestamp last_failed */ 4:
                    message.lastFailed = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastFailed);
                    break;
                case /* repeated string app_filters */ 5:
                    message.appFilters.push(reader.string());
                    break;
                case /* int32 num_apps_synced */ 6:
                    message.numAppsSynced = reader.int32();
                    break;
                case /* repeated string group_filters */ 7:
                    message.groupFilters.push(reader.string());
                    break;
                case /* int32 num_groups_synced */ 8:
                    message.numGroupsSynced = reader.int32();
                    break;
                case /* string error */ 9:
                    message.error = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginOktaStatusDetailsAccessListsSync, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool enabled = 1; */
        if (message.enabled !== false)
            writer.tag(1, WireType.Varint).bool(message.enabled);
        /* types.OktaPluginSyncStatusCode status_code = 2; */
        if (message.statusCode !== 0)
            writer.tag(2, WireType.Varint).int32(message.statusCode);
        /* google.protobuf.Timestamp last_successful = 3; */
        if (message.lastSuccessful)
            Timestamp.internalBinaryWrite(message.lastSuccessful, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp last_failed = 4; */
        if (message.lastFailed)
            Timestamp.internalBinaryWrite(message.lastFailed, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated string app_filters = 5; */
        for (let i = 0; i < message.appFilters.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.appFilters[i]);
        /* int32 num_apps_synced = 6; */
        if (message.numAppsSynced !== 0)
            writer.tag(6, WireType.Varint).int32(message.numAppsSynced);
        /* repeated string group_filters = 7; */
        for (let i = 0; i < message.groupFilters.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.groupFilters[i]);
        /* int32 num_groups_synced = 8; */
        if (message.numGroupsSynced !== 0)
            writer.tag(8, WireType.Varint).int32(message.numGroupsSynced);
        /* string error = 9; */
        if (message.error !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginOktaStatusDetailsAccessListsSync
 */
export const PluginOktaStatusDetailsAccessListsSync = new PluginOktaStatusDetailsAccessListsSync$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginCredentialsV1$Type extends MessageType<PluginCredentialsV1> {
    constructor() {
        super("types.PluginCredentialsV1", [
            { no: 1, name: "oauth2_access_token", kind: "message", oneof: "credentials", T: () => PluginOAuth2AccessTokenCredentials },
            { no: 2, name: "bearer_token", kind: "message", oneof: "credentials", T: () => PluginBearerTokenCredentials },
            { no: 3, name: "id_secret", kind: "message", oneof: "credentials", T: () => PluginIdSecretCredential },
            { no: 4, name: "static_credentials_ref", kind: "message", oneof: "credentials", T: () => PluginStaticCredentialsRef }
        ]);
    }
    create(value?: PartialMessage<PluginCredentialsV1>): PluginCredentialsV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.credentials = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<PluginCredentialsV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginCredentialsV1): PluginCredentialsV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.PluginOAuth2AccessTokenCredentials oauth2_access_token */ 1:
                    message.credentials = {
                        oneofKind: "oauth2AccessToken",
                        oauth2AccessToken: PluginOAuth2AccessTokenCredentials.internalBinaryRead(reader, reader.uint32(), options, (message.credentials as any).oauth2AccessToken)
                    };
                    break;
                case /* types.PluginBearerTokenCredentials bearer_token */ 2:
                    message.credentials = {
                        oneofKind: "bearerToken",
                        bearerToken: PluginBearerTokenCredentials.internalBinaryRead(reader, reader.uint32(), options, (message.credentials as any).bearerToken)
                    };
                    break;
                case /* types.PluginIdSecretCredential id_secret */ 3:
                    message.credentials = {
                        oneofKind: "idSecret",
                        idSecret: PluginIdSecretCredential.internalBinaryRead(reader, reader.uint32(), options, (message.credentials as any).idSecret)
                    };
                    break;
                case /* types.PluginStaticCredentialsRef static_credentials_ref */ 4:
                    message.credentials = {
                        oneofKind: "staticCredentialsRef",
                        staticCredentialsRef: PluginStaticCredentialsRef.internalBinaryRead(reader, reader.uint32(), options, (message.credentials as any).staticCredentialsRef)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginCredentialsV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.PluginOAuth2AccessTokenCredentials oauth2_access_token = 1; */
        if (message.credentials.oneofKind === "oauth2AccessToken")
            PluginOAuth2AccessTokenCredentials.internalBinaryWrite(message.credentials.oauth2AccessToken, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* types.PluginBearerTokenCredentials bearer_token = 2; */
        if (message.credentials.oneofKind === "bearerToken")
            PluginBearerTokenCredentials.internalBinaryWrite(message.credentials.bearerToken, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* types.PluginIdSecretCredential id_secret = 3; */
        if (message.credentials.oneofKind === "idSecret")
            PluginIdSecretCredential.internalBinaryWrite(message.credentials.idSecret, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* types.PluginStaticCredentialsRef static_credentials_ref = 4; */
        if (message.credentials.oneofKind === "staticCredentialsRef")
            PluginStaticCredentialsRef.internalBinaryWrite(message.credentials.staticCredentialsRef, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginCredentialsV1
 */
export const PluginCredentialsV1 = new PluginCredentialsV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginOAuth2AccessTokenCredentials$Type extends MessageType<PluginOAuth2AccessTokenCredentials> {
    constructor() {
        super("types.PluginOAuth2AccessTokenCredentials", [
            { no: 1, name: "access_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "refresh_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "expires", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.stdtime": true } }
        ]);
    }
    create(value?: PartialMessage<PluginOAuth2AccessTokenCredentials>): PluginOAuth2AccessTokenCredentials {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accessToken = "";
        message.refreshToken = "";
        if (value !== undefined)
            reflectionMergePartial<PluginOAuth2AccessTokenCredentials>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginOAuth2AccessTokenCredentials): PluginOAuth2AccessTokenCredentials {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string access_token */ 1:
                    message.accessToken = reader.string();
                    break;
                case /* string refresh_token */ 2:
                    message.refreshToken = reader.string();
                    break;
                case /* google.protobuf.Timestamp expires */ 3:
                    message.expires = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expires);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginOAuth2AccessTokenCredentials, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string access_token = 1; */
        if (message.accessToken !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accessToken);
        /* string refresh_token = 2; */
        if (message.refreshToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.refreshToken);
        /* google.protobuf.Timestamp expires = 3; */
        if (message.expires)
            Timestamp.internalBinaryWrite(message.expires, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginOAuth2AccessTokenCredentials
 */
export const PluginOAuth2AccessTokenCredentials = new PluginOAuth2AccessTokenCredentials$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginBearerTokenCredentials$Type extends MessageType<PluginBearerTokenCredentials> {
    constructor() {
        super("types.PluginBearerTokenCredentials", [
            { no: 1, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PluginBearerTokenCredentials>): PluginBearerTokenCredentials {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.token = "";
        if (value !== undefined)
            reflectionMergePartial<PluginBearerTokenCredentials>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginBearerTokenCredentials): PluginBearerTokenCredentials {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string token */ 1:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginBearerTokenCredentials, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string token = 1; */
        if (message.token !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginBearerTokenCredentials
 */
export const PluginBearerTokenCredentials = new PluginBearerTokenCredentials$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginStaticCredentialsRef$Type extends MessageType<PluginStaticCredentialsRef> {
    constructor() {
        super("types.PluginStaticCredentialsRef", [
            { no: 1, name: "Labels", kind: "map", jsonName: "Labels", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ }, options: { "gogoproto.jsontag": "labels,omitempty" } }
        ], { "gogoproto.equal": true });
    }
    create(value?: PartialMessage<PluginStaticCredentialsRef>): PluginStaticCredentialsRef {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.labels = {};
        if (value !== undefined)
            reflectionMergePartial<PluginStaticCredentialsRef>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginStaticCredentialsRef): PluginStaticCredentialsRef {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, string> Labels = 1 [json_name = "Labels"];*/ 1:
                    this.binaryReadMap1(message.labels, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: PluginStaticCredentialsRef["labels"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof PluginStaticCredentialsRef["labels"] | undefined, val: PluginStaticCredentialsRef["labels"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field types.PluginStaticCredentialsRef.Labels");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: PluginStaticCredentialsRef, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, string> Labels = 1 [json_name = "Labels"]; */
        for (let k of globalThis.Object.keys(message.labels))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.labels[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginStaticCredentialsRef
 */
export const PluginStaticCredentialsRef = new PluginStaticCredentialsRef$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginListV1$Type extends MessageType<PluginListV1> {
    constructor() {
        super("types.PluginListV1", [
            { no: 1, name: "plugins", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PluginV1 }
        ]);
    }
    create(value?: PartialMessage<PluginListV1>): PluginListV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.plugins = [];
        if (value !== undefined)
            reflectionMergePartial<PluginListV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginListV1): PluginListV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.PluginV1 plugins */ 1:
                    message.plugins.push(PluginV1.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginListV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.PluginV1 plugins = 1; */
        for (let i = 0; i < message.plugins.length; i++)
            PluginV1.internalBinaryWrite(message.plugins[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginListV1
 */
export const PluginListV1 = new PluginListV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginStaticCredentialsV1$Type extends MessageType<PluginStaticCredentialsV1> {
    constructor() {
        super("types.PluginStaticCredentialsV1", [
            { no: 1, name: "Header", kind: "message", jsonName: "Header", T: () => ResourceHeader, options: { "gogoproto.nullable": false, "gogoproto.embed": true } },
            { no: 2, name: "Spec", kind: "message", jsonName: "Spec", T: () => PluginStaticCredentialsSpecV1 }
        ], { "gogoproto.goproto_stringer": false, "gogoproto.stringer": false });
    }
    create(value?: PartialMessage<PluginStaticCredentialsV1>): PluginStaticCredentialsV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PluginStaticCredentialsV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginStaticCredentialsV1): PluginStaticCredentialsV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.ResourceHeader Header = 1 [json_name = "Header"];*/ 1:
                    message.header = ResourceHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* types.PluginStaticCredentialsSpecV1 Spec = 2 [json_name = "Spec"];*/ 2:
                    message.spec = PluginStaticCredentialsSpecV1.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginStaticCredentialsV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.ResourceHeader Header = 1 [json_name = "Header"]; */
        if (message.header)
            ResourceHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* types.PluginStaticCredentialsSpecV1 Spec = 2 [json_name = "Spec"]; */
        if (message.spec)
            PluginStaticCredentialsSpecV1.internalBinaryWrite(message.spec, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginStaticCredentialsV1
 */
export const PluginStaticCredentialsV1 = new PluginStaticCredentialsV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginStaticCredentialsSpecV1$Type extends MessageType<PluginStaticCredentialsSpecV1> {
    constructor() {
        super("types.PluginStaticCredentialsSpecV1", [
            { no: 1, name: "APIToken", kind: "scalar", jsonName: "APIToken", oneof: "credentials", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "BasicAuth", kind: "message", jsonName: "BasicAuth", oneof: "credentials", T: () => PluginStaticCredentialsBasicAuth },
            { no: 3, name: "OAuthClientSecret", kind: "message", jsonName: "OAuthClientSecret", oneof: "credentials", T: () => PluginStaticCredentialsOAuthClientSecret },
            { no: 4, name: "SSHCertAuthorities", kind: "message", jsonName: "SSHCertAuthorities", oneof: "credentials", T: () => PluginStaticCredentialsSSHCertAuthorities },
            { no: 5, name: "private_key", kind: "scalar", oneof: "credentials", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<PluginStaticCredentialsSpecV1>): PluginStaticCredentialsSpecV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.credentials = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<PluginStaticCredentialsSpecV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginStaticCredentialsSpecV1): PluginStaticCredentialsSpecV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string APIToken = 1 [json_name = "APIToken"];*/ 1:
                    message.credentials = {
                        oneofKind: "aPIToken",
                        aPIToken: reader.string()
                    };
                    break;
                case /* types.PluginStaticCredentialsBasicAuth BasicAuth = 2 [json_name = "BasicAuth"];*/ 2:
                    message.credentials = {
                        oneofKind: "basicAuth",
                        basicAuth: PluginStaticCredentialsBasicAuth.internalBinaryRead(reader, reader.uint32(), options, (message.credentials as any).basicAuth)
                    };
                    break;
                case /* types.PluginStaticCredentialsOAuthClientSecret OAuthClientSecret = 3 [json_name = "OAuthClientSecret"];*/ 3:
                    message.credentials = {
                        oneofKind: "oAuthClientSecret",
                        oAuthClientSecret: PluginStaticCredentialsOAuthClientSecret.internalBinaryRead(reader, reader.uint32(), options, (message.credentials as any).oAuthClientSecret)
                    };
                    break;
                case /* types.PluginStaticCredentialsSSHCertAuthorities SSHCertAuthorities = 4 [json_name = "SSHCertAuthorities"];*/ 4:
                    message.credentials = {
                        oneofKind: "sSHCertAuthorities",
                        sSHCertAuthorities: PluginStaticCredentialsSSHCertAuthorities.internalBinaryRead(reader, reader.uint32(), options, (message.credentials as any).sSHCertAuthorities)
                    };
                    break;
                case /* bytes private_key */ 5:
                    message.credentials = {
                        oneofKind: "privateKey",
                        privateKey: reader.bytes()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginStaticCredentialsSpecV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string APIToken = 1 [json_name = "APIToken"]; */
        if (message.credentials.oneofKind === "aPIToken")
            writer.tag(1, WireType.LengthDelimited).string(message.credentials.aPIToken);
        /* types.PluginStaticCredentialsBasicAuth BasicAuth = 2 [json_name = "BasicAuth"]; */
        if (message.credentials.oneofKind === "basicAuth")
            PluginStaticCredentialsBasicAuth.internalBinaryWrite(message.credentials.basicAuth, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* types.PluginStaticCredentialsOAuthClientSecret OAuthClientSecret = 3 [json_name = "OAuthClientSecret"]; */
        if (message.credentials.oneofKind === "oAuthClientSecret")
            PluginStaticCredentialsOAuthClientSecret.internalBinaryWrite(message.credentials.oAuthClientSecret, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* types.PluginStaticCredentialsSSHCertAuthorities SSHCertAuthorities = 4 [json_name = "SSHCertAuthorities"]; */
        if (message.credentials.oneofKind === "sSHCertAuthorities")
            PluginStaticCredentialsSSHCertAuthorities.internalBinaryWrite(message.credentials.sSHCertAuthorities, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bytes private_key = 5; */
        if (message.credentials.oneofKind === "privateKey")
            writer.tag(5, WireType.LengthDelimited).bytes(message.credentials.privateKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginStaticCredentialsSpecV1
 */
export const PluginStaticCredentialsSpecV1 = new PluginStaticCredentialsSpecV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginStaticCredentialsBasicAuth$Type extends MessageType<PluginStaticCredentialsBasicAuth> {
    constructor() {
        super("types.PluginStaticCredentialsBasicAuth", [
            { no: 1, name: "Username", kind: "scalar", jsonName: "Username", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "username" } },
            { no: 2, name: "Password", kind: "scalar", jsonName: "Password", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "password" } }
        ]);
    }
    create(value?: PartialMessage<PluginStaticCredentialsBasicAuth>): PluginStaticCredentialsBasicAuth {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.username = "";
        message.password = "";
        if (value !== undefined)
            reflectionMergePartial<PluginStaticCredentialsBasicAuth>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginStaticCredentialsBasicAuth): PluginStaticCredentialsBasicAuth {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Username = 1 [json_name = "Username"];*/ 1:
                    message.username = reader.string();
                    break;
                case /* string Password = 2 [json_name = "Password"];*/ 2:
                    message.password = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginStaticCredentialsBasicAuth, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Username = 1 [json_name = "Username"]; */
        if (message.username !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.username);
        /* string Password = 2 [json_name = "Password"]; */
        if (message.password !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.password);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginStaticCredentialsBasicAuth
 */
export const PluginStaticCredentialsBasicAuth = new PluginStaticCredentialsBasicAuth$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginStaticCredentialsOAuthClientSecret$Type extends MessageType<PluginStaticCredentialsOAuthClientSecret> {
    constructor() {
        super("types.PluginStaticCredentialsOAuthClientSecret", [
            { no: 1, name: "ClientId", kind: "scalar", jsonName: "ClientId", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "client_id" } },
            { no: 2, name: "ClientSecret", kind: "scalar", jsonName: "ClientSecret", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "client_secret" } }
        ]);
    }
    create(value?: PartialMessage<PluginStaticCredentialsOAuthClientSecret>): PluginStaticCredentialsOAuthClientSecret {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clientId = "";
        message.clientSecret = "";
        if (value !== undefined)
            reflectionMergePartial<PluginStaticCredentialsOAuthClientSecret>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginStaticCredentialsOAuthClientSecret): PluginStaticCredentialsOAuthClientSecret {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ClientId = 1 [json_name = "ClientId"];*/ 1:
                    message.clientId = reader.string();
                    break;
                case /* string ClientSecret = 2 [json_name = "ClientSecret"];*/ 2:
                    message.clientSecret = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginStaticCredentialsOAuthClientSecret, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ClientId = 1 [json_name = "ClientId"]; */
        if (message.clientId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clientId);
        /* string ClientSecret = 2 [json_name = "ClientSecret"]; */
        if (message.clientSecret !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.clientSecret);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginStaticCredentialsOAuthClientSecret
 */
export const PluginStaticCredentialsOAuthClientSecret = new PluginStaticCredentialsOAuthClientSecret$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginStaticCredentialsSSHCertAuthorities$Type extends MessageType<PluginStaticCredentialsSSHCertAuthorities> {
    constructor() {
        super("types.PluginStaticCredentialsSSHCertAuthorities", [
            { no: 1, name: "cert_authorities", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SSHKeyPair }
        ]);
    }
    create(value?: PartialMessage<PluginStaticCredentialsSSHCertAuthorities>): PluginStaticCredentialsSSHCertAuthorities {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.certAuthorities = [];
        if (value !== undefined)
            reflectionMergePartial<PluginStaticCredentialsSSHCertAuthorities>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginStaticCredentialsSSHCertAuthorities): PluginStaticCredentialsSSHCertAuthorities {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.SSHKeyPair cert_authorities */ 1:
                    message.certAuthorities.push(SSHKeyPair.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginStaticCredentialsSSHCertAuthorities, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.SSHKeyPair cert_authorities = 1; */
        for (let i = 0; i < message.certAuthorities.length; i++)
            SSHKeyPair.internalBinaryWrite(message.certAuthorities[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PluginStaticCredentialsSSHCertAuthorities
 */
export const PluginStaticCredentialsSSHCertAuthorities = new PluginStaticCredentialsSSHCertAuthorities$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SAMLIdPServiceProviderV1$Type extends MessageType<SAMLIdPServiceProviderV1> {
    constructor() {
        super("types.SAMLIdPServiceProviderV1", [
            { no: 1, name: "Header", kind: "message", jsonName: "Header", T: () => ResourceHeader, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Spec", kind: "message", jsonName: "Spec", T: () => SAMLIdPServiceProviderSpecV1, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ], { "gogoproto.goproto_stringer": false, "gogoproto.stringer": false });
    }
    create(value?: PartialMessage<SAMLIdPServiceProviderV1>): SAMLIdPServiceProviderV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SAMLIdPServiceProviderV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SAMLIdPServiceProviderV1): SAMLIdPServiceProviderV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.ResourceHeader Header = 1 [json_name = "Header"];*/ 1:
                    message.header = ResourceHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* types.SAMLIdPServiceProviderSpecV1 Spec = 2 [json_name = "Spec"];*/ 2:
                    message.spec = SAMLIdPServiceProviderSpecV1.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SAMLIdPServiceProviderV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.ResourceHeader Header = 1 [json_name = "Header"]; */
        if (message.header)
            ResourceHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* types.SAMLIdPServiceProviderSpecV1 Spec = 2 [json_name = "Spec"]; */
        if (message.spec)
            SAMLIdPServiceProviderSpecV1.internalBinaryWrite(message.spec, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.SAMLIdPServiceProviderV1
 */
export const SAMLIdPServiceProviderV1 = new SAMLIdPServiceProviderV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SAMLIdPServiceProviderSpecV1$Type extends MessageType<SAMLIdPServiceProviderSpecV1> {
    constructor() {
        super("types.SAMLIdPServiceProviderSpecV1", [
            { no: 1, name: "EntityDescriptor", kind: "scalar", jsonName: "EntityDescriptor", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "entity_descriptor" } },
            { no: 2, name: "EntityID", kind: "scalar", jsonName: "EntityID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "entity_id" } },
            { no: 3, name: "ACSURL", kind: "scalar", jsonName: "ACSURL", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "acs_url" } },
            { no: 4, name: "AttributeMapping", kind: "message", jsonName: "AttributeMapping", repeat: 1 /*RepeatType.PACKED*/, T: () => SAMLAttributeMapping, options: { "gogoproto.jsontag": "attribute_mapping" } },
            { no: 5, name: "Preset", kind: "scalar", jsonName: "Preset", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "preset" } },
            { no: 6, name: "RelayState", kind: "scalar", jsonName: "RelayState", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "relay_state" } },
            { no: 7, name: "LaunchURLs", kind: "scalar", jsonName: "LaunchURLs", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "launch_urls" } }
        ]);
    }
    create(value?: PartialMessage<SAMLIdPServiceProviderSpecV1>): SAMLIdPServiceProviderSpecV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entityDescriptor = "";
        message.entityID = "";
        message.aCSURL = "";
        message.attributeMapping = [];
        message.preset = "";
        message.relayState = "";
        message.launchURLs = [];
        if (value !== undefined)
            reflectionMergePartial<SAMLIdPServiceProviderSpecV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SAMLIdPServiceProviderSpecV1): SAMLIdPServiceProviderSpecV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string EntityDescriptor = 1 [json_name = "EntityDescriptor"];*/ 1:
                    message.entityDescriptor = reader.string();
                    break;
                case /* string EntityID = 2 [json_name = "EntityID"];*/ 2:
                    message.entityID = reader.string();
                    break;
                case /* string ACSURL = 3 [json_name = "ACSURL"];*/ 3:
                    message.aCSURL = reader.string();
                    break;
                case /* repeated types.SAMLAttributeMapping AttributeMapping = 4 [json_name = "AttributeMapping"];*/ 4:
                    message.attributeMapping.push(SAMLAttributeMapping.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string Preset = 5 [json_name = "Preset"];*/ 5:
                    message.preset = reader.string();
                    break;
                case /* string RelayState = 6 [json_name = "RelayState"];*/ 6:
                    message.relayState = reader.string();
                    break;
                case /* repeated string LaunchURLs = 7 [json_name = "LaunchURLs"];*/ 7:
                    message.launchURLs.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SAMLIdPServiceProviderSpecV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string EntityDescriptor = 1 [json_name = "EntityDescriptor"]; */
        if (message.entityDescriptor !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.entityDescriptor);
        /* string EntityID = 2 [json_name = "EntityID"]; */
        if (message.entityID !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.entityID);
        /* string ACSURL = 3 [json_name = "ACSURL"]; */
        if (message.aCSURL !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.aCSURL);
        /* repeated types.SAMLAttributeMapping AttributeMapping = 4 [json_name = "AttributeMapping"]; */
        for (let i = 0; i < message.attributeMapping.length; i++)
            SAMLAttributeMapping.internalBinaryWrite(message.attributeMapping[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string Preset = 5 [json_name = "Preset"]; */
        if (message.preset !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.preset);
        /* string RelayState = 6 [json_name = "RelayState"]; */
        if (message.relayState !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.relayState);
        /* repeated string LaunchURLs = 7 [json_name = "LaunchURLs"]; */
        for (let i = 0; i < message.launchURLs.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.launchURLs[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.SAMLIdPServiceProviderSpecV1
 */
export const SAMLIdPServiceProviderSpecV1 = new SAMLIdPServiceProviderSpecV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SAMLAttributeMapping$Type extends MessageType<SAMLAttributeMapping> {
    constructor() {
        super("types.SAMLAttributeMapping", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "name" } },
            { no: 2, name: "name_format", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "name_format" } },
            { no: 3, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "value" } }
        ]);
    }
    create(value?: PartialMessage<SAMLAttributeMapping>): SAMLAttributeMapping {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.nameFormat = "";
        message.value = "";
        if (value !== undefined)
            reflectionMergePartial<SAMLAttributeMapping>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SAMLAttributeMapping): SAMLAttributeMapping {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string name_format */ 2:
                    message.nameFormat = reader.string();
                    break;
                case /* string value */ 3:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SAMLAttributeMapping, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string name_format = 2; */
        if (message.nameFormat !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.nameFormat);
        /* string value = 3; */
        if (message.value !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.SAMLAttributeMapping
 */
export const SAMLAttributeMapping = new SAMLAttributeMapping$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IdPOptions$Type extends MessageType<IdPOptions> {
    constructor() {
        super("types.IdPOptions", [
            { no: 1, name: "SAML", kind: "message", jsonName: "SAML", T: () => IdPSAMLOptions, options: { "gogoproto.jsontag": "saml" } }
        ]);
    }
    create(value?: PartialMessage<IdPOptions>): IdPOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<IdPOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IdPOptions): IdPOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.IdPSAMLOptions SAML = 1 [json_name = "SAML"];*/ 1:
                    message.sAML = IdPSAMLOptions.internalBinaryRead(reader, reader.uint32(), options, message.sAML);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IdPOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.IdPSAMLOptions SAML = 1 [json_name = "SAML"]; */
        if (message.sAML)
            IdPSAMLOptions.internalBinaryWrite(message.sAML, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.IdPOptions
 */
export const IdPOptions = new IdPOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IdPSAMLOptions$Type extends MessageType<IdPSAMLOptions> {
    constructor() {
        super("types.IdPSAMLOptions", [
            { no: 1, name: "Enabled", kind: "message", jsonName: "Enabled", T: () => BoolValue, options: { "gogoproto.customtype": "BoolOption", "gogoproto.jsontag": "enabled" } }
        ]);
    }
    create(value?: PartialMessage<IdPSAMLOptions>): IdPSAMLOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<IdPSAMLOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IdPSAMLOptions): IdPSAMLOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.BoolValue Enabled = 1 [json_name = "Enabled"];*/ 1:
                    message.enabled = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.enabled);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IdPSAMLOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.BoolValue Enabled = 1 [json_name = "Enabled"]; */
        if (message.enabled)
            BoolValue.internalBinaryWrite(message.enabled, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.IdPSAMLOptions
 */
export const IdPSAMLOptions = new IdPSAMLOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class KubernetesResourceV1$Type extends MessageType<KubernetesResourceV1> {
    constructor() {
        super("types.KubernetesResourceV1", [
            { no: 1, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 2, name: "SubKind", kind: "scalar", jsonName: "SubKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub_kind,omitempty" } },
            { no: 3, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version" } },
            { no: 4, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "metadata" } },
            { no: 5, name: "Spec", kind: "message", jsonName: "Spec", T: () => KubernetesResourceSpecV1, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ]);
    }
    create(value?: PartialMessage<KubernetesResourceV1>): KubernetesResourceV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.subKind = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<KubernetesResourceV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KubernetesResourceV1): KubernetesResourceV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Kind = 1 [json_name = "Kind"];*/ 1:
                    message.kind = reader.string();
                    break;
                case /* string SubKind = 2 [json_name = "SubKind"];*/ 2:
                    message.subKind = reader.string();
                    break;
                case /* string Version = 3 [json_name = "Version"];*/ 3:
                    message.version = reader.string();
                    break;
                case /* types.Metadata Metadata = 4 [json_name = "Metadata"];*/ 4:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* types.KubernetesResourceSpecV1 Spec = 5 [json_name = "Spec"];*/ 5:
                    message.spec = KubernetesResourceSpecV1.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: KubernetesResourceV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Kind = 1 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string SubKind = 2 [json_name = "SubKind"]; */
        if (message.subKind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subKind);
        /* string Version = 3 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* types.Metadata Metadata = 4 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.KubernetesResourceSpecV1 Spec = 5 [json_name = "Spec"]; */
        if (message.spec)
            KubernetesResourceSpecV1.internalBinaryWrite(message.spec, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.KubernetesResourceV1
 */
export const KubernetesResourceV1 = new KubernetesResourceV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class KubernetesResourceSpecV1$Type extends MessageType<KubernetesResourceSpecV1> {
    constructor() {
        super("types.KubernetesResourceSpecV1", [
            { no: 1, name: "Namespace", kind: "scalar", jsonName: "Namespace", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "namespace" } }
        ]);
    }
    create(value?: PartialMessage<KubernetesResourceSpecV1>): KubernetesResourceSpecV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.namespace = "";
        if (value !== undefined)
            reflectionMergePartial<KubernetesResourceSpecV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KubernetesResourceSpecV1): KubernetesResourceSpecV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Namespace = 1 [json_name = "Namespace"];*/ 1:
                    message.namespace = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: KubernetesResourceSpecV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Namespace = 1 [json_name = "Namespace"]; */
        if (message.namespace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.namespace);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.KubernetesResourceSpecV1
 */
export const KubernetesResourceSpecV1 = new KubernetesResourceSpecV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClusterMaintenanceConfigV1$Type extends MessageType<ClusterMaintenanceConfigV1> {
    constructor() {
        super("types.ClusterMaintenanceConfigV1", [
            { no: 1, name: "Header", kind: "message", jsonName: "Header", T: () => ResourceHeader, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Spec", kind: "message", jsonName: "Spec", T: () => ClusterMaintenanceConfigSpecV1, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } },
            { no: 3, name: "Nonce", kind: "scalar", jsonName: "Nonce", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "nonce,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ClusterMaintenanceConfigV1>): ClusterMaintenanceConfigV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.nonce = 0n;
        if (value !== undefined)
            reflectionMergePartial<ClusterMaintenanceConfigV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClusterMaintenanceConfigV1): ClusterMaintenanceConfigV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.ResourceHeader Header = 1 [json_name = "Header"];*/ 1:
                    message.header = ResourceHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* types.ClusterMaintenanceConfigSpecV1 Spec = 2 [json_name = "Spec"];*/ 2:
                    message.spec = ClusterMaintenanceConfigSpecV1.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                case /* uint64 Nonce = 3 [json_name = "Nonce"];*/ 3:
                    message.nonce = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClusterMaintenanceConfigV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.ResourceHeader Header = 1 [json_name = "Header"]; */
        if (message.header)
            ResourceHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* types.ClusterMaintenanceConfigSpecV1 Spec = 2 [json_name = "Spec"]; */
        if (message.spec)
            ClusterMaintenanceConfigSpecV1.internalBinaryWrite(message.spec, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* uint64 Nonce = 3 [json_name = "Nonce"]; */
        if (message.nonce !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.nonce);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ClusterMaintenanceConfigV1
 */
export const ClusterMaintenanceConfigV1 = new ClusterMaintenanceConfigV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClusterMaintenanceConfigSpecV1$Type extends MessageType<ClusterMaintenanceConfigSpecV1> {
    constructor() {
        super("types.ClusterMaintenanceConfigSpecV1", [
            { no: 1, name: "AgentUpgrades", kind: "message", jsonName: "AgentUpgrades", T: () => AgentUpgradeWindow, options: { "gogoproto.jsontag": "agent_upgrades,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ClusterMaintenanceConfigSpecV1>): ClusterMaintenanceConfigSpecV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ClusterMaintenanceConfigSpecV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClusterMaintenanceConfigSpecV1): ClusterMaintenanceConfigSpecV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.AgentUpgradeWindow AgentUpgrades = 1 [json_name = "AgentUpgrades"];*/ 1:
                    message.agentUpgrades = AgentUpgradeWindow.internalBinaryRead(reader, reader.uint32(), options, message.agentUpgrades);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClusterMaintenanceConfigSpecV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.AgentUpgradeWindow AgentUpgrades = 1 [json_name = "AgentUpgrades"]; */
        if (message.agentUpgrades)
            AgentUpgradeWindow.internalBinaryWrite(message.agentUpgrades, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ClusterMaintenanceConfigSpecV1
 */
export const ClusterMaintenanceConfigSpecV1 = new ClusterMaintenanceConfigSpecV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AgentUpgradeWindow$Type extends MessageType<AgentUpgradeWindow> {
    constructor() {
        super("types.AgentUpgradeWindow", [
            { no: 1, name: "UTCStartHour", kind: "scalar", jsonName: "UTCStartHour", T: 13 /*ScalarType.UINT32*/, options: { "gogoproto.jsontag": "utc_start_hour" } },
            { no: 2, name: "Weekdays", kind: "scalar", jsonName: "Weekdays", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "weekdays,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<AgentUpgradeWindow>): AgentUpgradeWindow {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uTCStartHour = 0;
        message.weekdays = [];
        if (value !== undefined)
            reflectionMergePartial<AgentUpgradeWindow>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AgentUpgradeWindow): AgentUpgradeWindow {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 UTCStartHour = 1 [json_name = "UTCStartHour"];*/ 1:
                    message.uTCStartHour = reader.uint32();
                    break;
                case /* repeated string Weekdays = 2 [json_name = "Weekdays"];*/ 2:
                    message.weekdays.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AgentUpgradeWindow, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 UTCStartHour = 1 [json_name = "UTCStartHour"]; */
        if (message.uTCStartHour !== 0)
            writer.tag(1, WireType.Varint).uint32(message.uTCStartHour);
        /* repeated string Weekdays = 2 [json_name = "Weekdays"]; */
        for (let i = 0; i < message.weekdays.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.weekdays[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AgentUpgradeWindow
 */
export const AgentUpgradeWindow = new AgentUpgradeWindow$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScheduledAgentUpgradeWindow$Type extends MessageType<ScheduledAgentUpgradeWindow> {
    constructor() {
        super("types.ScheduledAgentUpgradeWindow", [
            { no: 1, name: "Start", kind: "message", jsonName: "Start", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "start", "gogoproto.stdtime": true } },
            { no: 2, name: "Stop", kind: "message", jsonName: "Stop", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "stop", "gogoproto.stdtime": true } }
        ]);
    }
    create(value?: PartialMessage<ScheduledAgentUpgradeWindow>): ScheduledAgentUpgradeWindow {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ScheduledAgentUpgradeWindow>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScheduledAgentUpgradeWindow): ScheduledAgentUpgradeWindow {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Timestamp Start = 1 [json_name = "Start"];*/ 1:
                    message.start = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.start);
                    break;
                case /* google.protobuf.Timestamp Stop = 2 [json_name = "Stop"];*/ 2:
                    message.stop = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.stop);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScheduledAgentUpgradeWindow, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Timestamp Start = 1 [json_name = "Start"]; */
        if (message.start)
            Timestamp.internalBinaryWrite(message.start, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp Stop = 2 [json_name = "Stop"]; */
        if (message.stop)
            Timestamp.internalBinaryWrite(message.stop, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ScheduledAgentUpgradeWindow
 */
export const ScheduledAgentUpgradeWindow = new ScheduledAgentUpgradeWindow$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AgentUpgradeSchedule$Type extends MessageType<AgentUpgradeSchedule> {
    constructor() {
        super("types.AgentUpgradeSchedule", [
            { no: 1, name: "Windows", kind: "message", jsonName: "Windows", repeat: 1 /*RepeatType.PACKED*/, T: () => ScheduledAgentUpgradeWindow, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "windows" } }
        ]);
    }
    create(value?: PartialMessage<AgentUpgradeSchedule>): AgentUpgradeSchedule {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.windows = [];
        if (value !== undefined)
            reflectionMergePartial<AgentUpgradeSchedule>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AgentUpgradeSchedule): AgentUpgradeSchedule {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.ScheduledAgentUpgradeWindow Windows = 1 [json_name = "Windows"];*/ 1:
                    message.windows.push(ScheduledAgentUpgradeWindow.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AgentUpgradeSchedule, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.ScheduledAgentUpgradeWindow Windows = 1 [json_name = "Windows"]; */
        for (let i = 0; i < message.windows.length; i++)
            ScheduledAgentUpgradeWindow.internalBinaryWrite(message.windows[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AgentUpgradeSchedule
 */
export const AgentUpgradeSchedule = new AgentUpgradeSchedule$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserGroupV1$Type extends MessageType<UserGroupV1> {
    constructor() {
        super("types.UserGroupV1", [
            { no: 1, name: "Header", kind: "message", jsonName: "Header", T: () => ResourceHeader, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Spec", kind: "message", jsonName: "Spec", T: () => UserGroupSpecV1, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ], { "gogoproto.goproto_stringer": false, "gogoproto.stringer": false });
    }
    create(value?: PartialMessage<UserGroupV1>): UserGroupV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UserGroupV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserGroupV1): UserGroupV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.ResourceHeader Header = 1 [json_name = "Header"];*/ 1:
                    message.header = ResourceHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* types.UserGroupSpecV1 Spec = 2 [json_name = "Spec"];*/ 2:
                    message.spec = UserGroupSpecV1.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserGroupV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.ResourceHeader Header = 1 [json_name = "Header"]; */
        if (message.header)
            ResourceHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* types.UserGroupSpecV1 Spec = 2 [json_name = "Spec"]; */
        if (message.spec)
            UserGroupSpecV1.internalBinaryWrite(message.spec, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.UserGroupV1
 */
export const UserGroupV1 = new UserGroupV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserGroupSpecV1$Type extends MessageType<UserGroupSpecV1> {
    constructor() {
        super("types.UserGroupSpecV1", [
            { no: 1, name: "Applications", kind: "scalar", jsonName: "Applications", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UserGroupSpecV1>): UserGroupSpecV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.applications = [];
        if (value !== undefined)
            reflectionMergePartial<UserGroupSpecV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserGroupSpecV1): UserGroupSpecV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string Applications = 1 [json_name = "Applications"];*/ 1:
                    message.applications.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserGroupSpecV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string Applications = 1 [json_name = "Applications"]; */
        for (let i = 0; i < message.applications.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.applications[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.UserGroupSpecV1
 */
export const UserGroupSpecV1 = new UserGroupSpecV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OktaImportRuleSpecV1$Type extends MessageType<OktaImportRuleSpecV1> {
    constructor() {
        super("types.OktaImportRuleSpecV1", [
            { no: 1, name: "Priority", kind: "scalar", jsonName: "Priority", T: 5 /*ScalarType.INT32*/, options: { "gogoproto.jsontag": "priority" } },
            { no: 2, name: "Mappings", kind: "message", jsonName: "Mappings", repeat: 1 /*RepeatType.PACKED*/, T: () => OktaImportRuleMappingV1, options: { "gogoproto.jsontag": "mappings" } }
        ]);
    }
    create(value?: PartialMessage<OktaImportRuleSpecV1>): OktaImportRuleSpecV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.priority = 0;
        message.mappings = [];
        if (value !== undefined)
            reflectionMergePartial<OktaImportRuleSpecV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OktaImportRuleSpecV1): OktaImportRuleSpecV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 Priority = 1 [json_name = "Priority"];*/ 1:
                    message.priority = reader.int32();
                    break;
                case /* repeated types.OktaImportRuleMappingV1 Mappings = 2 [json_name = "Mappings"];*/ 2:
                    message.mappings.push(OktaImportRuleMappingV1.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OktaImportRuleSpecV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 Priority = 1 [json_name = "Priority"]; */
        if (message.priority !== 0)
            writer.tag(1, WireType.Varint).int32(message.priority);
        /* repeated types.OktaImportRuleMappingV1 Mappings = 2 [json_name = "Mappings"]; */
        for (let i = 0; i < message.mappings.length; i++)
            OktaImportRuleMappingV1.internalBinaryWrite(message.mappings[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.OktaImportRuleSpecV1
 */
export const OktaImportRuleSpecV1 = new OktaImportRuleSpecV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OktaImportRuleMappingV1$Type extends MessageType<OktaImportRuleMappingV1> {
    constructor() {
        super("types.OktaImportRuleMappingV1", [
            { no: 1, name: "Match", kind: "message", jsonName: "Match", repeat: 1 /*RepeatType.PACKED*/, T: () => OktaImportRuleMatchV1, options: { "gogoproto.jsontag": "match" } },
            { no: 2, name: "AddLabels", kind: "map", jsonName: "AddLabels", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ }, options: { "gogoproto.jsontag": "add_labels" } }
        ]);
    }
    create(value?: PartialMessage<OktaImportRuleMappingV1>): OktaImportRuleMappingV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.match = [];
        message.addLabels = {};
        if (value !== undefined)
            reflectionMergePartial<OktaImportRuleMappingV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OktaImportRuleMappingV1): OktaImportRuleMappingV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.OktaImportRuleMatchV1 Match = 1 [json_name = "Match"];*/ 1:
                    message.match.push(OktaImportRuleMatchV1.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* map<string, string> AddLabels = 2 [json_name = "AddLabels"];*/ 2:
                    this.binaryReadMap2(message.addLabels, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: OktaImportRuleMappingV1["addLabels"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof OktaImportRuleMappingV1["addLabels"] | undefined, val: OktaImportRuleMappingV1["addLabels"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field types.OktaImportRuleMappingV1.AddLabels");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: OktaImportRuleMappingV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.OktaImportRuleMatchV1 Match = 1 [json_name = "Match"]; */
        for (let i = 0; i < message.match.length; i++)
            OktaImportRuleMatchV1.internalBinaryWrite(message.match[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* map<string, string> AddLabels = 2 [json_name = "AddLabels"]; */
        for (let k of globalThis.Object.keys(message.addLabels))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.addLabels[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.OktaImportRuleMappingV1
 */
export const OktaImportRuleMappingV1 = new OktaImportRuleMappingV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OktaImportRuleV1$Type extends MessageType<OktaImportRuleV1> {
    constructor() {
        super("types.OktaImportRuleV1", [
            { no: 1, name: "Header", kind: "message", jsonName: "Header", T: () => ResourceHeader, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Spec", kind: "message", jsonName: "Spec", T: () => OktaImportRuleSpecV1, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ], { "gogoproto.goproto_stringer": false, "gogoproto.stringer": false });
    }
    create(value?: PartialMessage<OktaImportRuleV1>): OktaImportRuleV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<OktaImportRuleV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OktaImportRuleV1): OktaImportRuleV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.ResourceHeader Header = 1 [json_name = "Header"];*/ 1:
                    message.header = ResourceHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* types.OktaImportRuleSpecV1 Spec = 2 [json_name = "Spec"];*/ 2:
                    message.spec = OktaImportRuleSpecV1.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OktaImportRuleV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.ResourceHeader Header = 1 [json_name = "Header"]; */
        if (message.header)
            ResourceHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* types.OktaImportRuleSpecV1 Spec = 2 [json_name = "Spec"]; */
        if (message.spec)
            OktaImportRuleSpecV1.internalBinaryWrite(message.spec, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.OktaImportRuleV1
 */
export const OktaImportRuleV1 = new OktaImportRuleV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OktaImportRuleMatchV1$Type extends MessageType<OktaImportRuleMatchV1> {
    constructor() {
        super("types.OktaImportRuleMatchV1", [
            { no: 1, name: "AppIDs", kind: "scalar", jsonName: "AppIDs", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "app_ids,omitempty" } },
            { no: 2, name: "GroupIDs", kind: "scalar", jsonName: "GroupIDs", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "group_ids,omitempty" } },
            { no: 3, name: "AppNameRegexes", kind: "scalar", jsonName: "AppNameRegexes", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "app_name_regexes,omitempty" } },
            { no: 4, name: "GroupNameRegexes", kind: "scalar", jsonName: "GroupNameRegexes", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "group_name_regexes,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<OktaImportRuleMatchV1>): OktaImportRuleMatchV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.appIDs = [];
        message.groupIDs = [];
        message.appNameRegexes = [];
        message.groupNameRegexes = [];
        if (value !== undefined)
            reflectionMergePartial<OktaImportRuleMatchV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OktaImportRuleMatchV1): OktaImportRuleMatchV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string AppIDs = 1 [json_name = "AppIDs"];*/ 1:
                    message.appIDs.push(reader.string());
                    break;
                case /* repeated string GroupIDs = 2 [json_name = "GroupIDs"];*/ 2:
                    message.groupIDs.push(reader.string());
                    break;
                case /* repeated string AppNameRegexes = 3 [json_name = "AppNameRegexes"];*/ 3:
                    message.appNameRegexes.push(reader.string());
                    break;
                case /* repeated string GroupNameRegexes = 4 [json_name = "GroupNameRegexes"];*/ 4:
                    message.groupNameRegexes.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OktaImportRuleMatchV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string AppIDs = 1 [json_name = "AppIDs"]; */
        for (let i = 0; i < message.appIDs.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.appIDs[i]);
        /* repeated string GroupIDs = 2 [json_name = "GroupIDs"]; */
        for (let i = 0; i < message.groupIDs.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.groupIDs[i]);
        /* repeated string AppNameRegexes = 3 [json_name = "AppNameRegexes"]; */
        for (let i = 0; i < message.appNameRegexes.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.appNameRegexes[i]);
        /* repeated string GroupNameRegexes = 4 [json_name = "GroupNameRegexes"]; */
        for (let i = 0; i < message.groupNameRegexes.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.groupNameRegexes[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.OktaImportRuleMatchV1
 */
export const OktaImportRuleMatchV1 = new OktaImportRuleMatchV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OktaAssignmentV1$Type extends MessageType<OktaAssignmentV1> {
    constructor() {
        super("types.OktaAssignmentV1", [
            { no: 1, name: "Header", kind: "message", jsonName: "Header", T: () => ResourceHeader, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Spec", kind: "message", jsonName: "Spec", T: () => OktaAssignmentSpecV1, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ], { "gogoproto.goproto_stringer": false, "gogoproto.stringer": false });
    }
    create(value?: PartialMessage<OktaAssignmentV1>): OktaAssignmentV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<OktaAssignmentV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OktaAssignmentV1): OktaAssignmentV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.ResourceHeader Header = 1 [json_name = "Header"];*/ 1:
                    message.header = ResourceHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* types.OktaAssignmentSpecV1 Spec = 2 [json_name = "Spec"];*/ 2:
                    message.spec = OktaAssignmentSpecV1.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OktaAssignmentV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.ResourceHeader Header = 1 [json_name = "Header"]; */
        if (message.header)
            ResourceHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* types.OktaAssignmentSpecV1 Spec = 2 [json_name = "Spec"]; */
        if (message.spec)
            OktaAssignmentSpecV1.internalBinaryWrite(message.spec, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.OktaAssignmentV1
 */
export const OktaAssignmentV1 = new OktaAssignmentV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OktaAssignmentSpecV1$Type extends MessageType<OktaAssignmentSpecV1> {
    constructor() {
        super("types.OktaAssignmentSpecV1", [
            { no: 1, name: "User", kind: "scalar", jsonName: "User", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "user" } },
            { no: 2, name: "Targets", kind: "message", jsonName: "Targets", repeat: 1 /*RepeatType.PACKED*/, T: () => OktaAssignmentTargetV1, options: { "gogoproto.jsontag": "targets" } },
            { no: 3, name: "CleanupTime", kind: "message", jsonName: "CleanupTime", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "cleanup_time", "gogoproto.stdtime": true } },
            { no: 4, name: "status", kind: "enum", T: () => ["types.OktaAssignmentSpecV1.OktaAssignmentStatus", OktaAssignmentSpecV1_OktaAssignmentStatus], options: { "gogoproto.jsontag": "status" } },
            { no: 5, name: "LastTransition", kind: "message", jsonName: "LastTransition", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "last_transition", "gogoproto.stdtime": true } },
            { no: 6, name: "Finalized", kind: "scalar", jsonName: "Finalized", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "finalized" } }
        ]);
    }
    create(value?: PartialMessage<OktaAssignmentSpecV1>): OktaAssignmentSpecV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.user = "";
        message.targets = [];
        message.status = 0;
        message.finalized = false;
        if (value !== undefined)
            reflectionMergePartial<OktaAssignmentSpecV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OktaAssignmentSpecV1): OktaAssignmentSpecV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string User = 1 [json_name = "User"];*/ 1:
                    message.user = reader.string();
                    break;
                case /* repeated types.OktaAssignmentTargetV1 Targets = 2 [json_name = "Targets"];*/ 2:
                    message.targets.push(OktaAssignmentTargetV1.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.Timestamp CleanupTime = 3 [json_name = "CleanupTime"];*/ 3:
                    message.cleanupTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.cleanupTime);
                    break;
                case /* types.OktaAssignmentSpecV1.OktaAssignmentStatus status */ 4:
                    message.status = reader.int32();
                    break;
                case /* google.protobuf.Timestamp LastTransition = 5 [json_name = "LastTransition"];*/ 5:
                    message.lastTransition = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastTransition);
                    break;
                case /* bool Finalized = 6 [json_name = "Finalized"];*/ 6:
                    message.finalized = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OktaAssignmentSpecV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string User = 1 [json_name = "User"]; */
        if (message.user !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.user);
        /* repeated types.OktaAssignmentTargetV1 Targets = 2 [json_name = "Targets"]; */
        for (let i = 0; i < message.targets.length; i++)
            OktaAssignmentTargetV1.internalBinaryWrite(message.targets[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp CleanupTime = 3 [json_name = "CleanupTime"]; */
        if (message.cleanupTime)
            Timestamp.internalBinaryWrite(message.cleanupTime, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* types.OktaAssignmentSpecV1.OktaAssignmentStatus status = 4; */
        if (message.status !== 0)
            writer.tag(4, WireType.Varint).int32(message.status);
        /* google.protobuf.Timestamp LastTransition = 5 [json_name = "LastTransition"]; */
        if (message.lastTransition)
            Timestamp.internalBinaryWrite(message.lastTransition, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* bool Finalized = 6 [json_name = "Finalized"]; */
        if (message.finalized !== false)
            writer.tag(6, WireType.Varint).bool(message.finalized);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.OktaAssignmentSpecV1
 */
export const OktaAssignmentSpecV1 = new OktaAssignmentSpecV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OktaAssignmentTargetV1$Type extends MessageType<OktaAssignmentTargetV1> {
    constructor() {
        super("types.OktaAssignmentTargetV1", [
            { no: 1, name: "type", kind: "enum", T: () => ["types.OktaAssignmentTargetV1.OktaAssignmentTargetType", OktaAssignmentTargetV1_OktaAssignmentTargetType], options: { "gogoproto.jsontag": "type" } },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "id" } }
        ]);
    }
    create(value?: PartialMessage<OktaAssignmentTargetV1>): OktaAssignmentTargetV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<OktaAssignmentTargetV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OktaAssignmentTargetV1): OktaAssignmentTargetV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.OktaAssignmentTargetV1.OktaAssignmentTargetType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OktaAssignmentTargetV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.OktaAssignmentTargetV1.OktaAssignmentTargetType type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.OktaAssignmentTargetV1
 */
export const OktaAssignmentTargetV1 = new OktaAssignmentTargetV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IntegrationV1$Type extends MessageType<IntegrationV1> {
    constructor() {
        super("types.IntegrationV1", [
            { no: 1, name: "Header", kind: "message", jsonName: "Header", T: () => ResourceHeader, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } },
            { no: 2, name: "Spec", kind: "message", jsonName: "Spec", T: () => IntegrationSpecV1, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ], { "gogoproto.goproto_stringer": false, "gogoproto.stringer": false });
    }
    create(value?: PartialMessage<IntegrationV1>): IntegrationV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<IntegrationV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IntegrationV1): IntegrationV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.ResourceHeader Header = 1 [json_name = "Header"];*/ 1:
                    message.header = ResourceHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* types.IntegrationSpecV1 Spec = 2 [json_name = "Spec"];*/ 2:
                    message.spec = IntegrationSpecV1.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IntegrationV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.ResourceHeader Header = 1 [json_name = "Header"]; */
        if (message.header)
            ResourceHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* types.IntegrationSpecV1 Spec = 2 [json_name = "Spec"]; */
        if (message.spec)
            IntegrationSpecV1.internalBinaryWrite(message.spec, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.IntegrationV1
 */
export const IntegrationV1 = new IntegrationV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IntegrationSpecV1$Type extends MessageType<IntegrationSpecV1> {
    constructor() {
        super("types.IntegrationSpecV1", [
            { no: 1, name: "AWSOIDC", kind: "message", jsonName: "AWSOIDC", oneof: "subKindSpec", T: () => AWSOIDCIntegrationSpecV1, options: { "gogoproto.jsontag": "aws_oidc,omitempty" } },
            { no: 2, name: "AzureOIDC", kind: "message", jsonName: "AzureOIDC", oneof: "subKindSpec", T: () => AzureOIDCIntegrationSpecV1, options: { "gogoproto.jsontag": "azure_oidc,omitempty" } },
            { no: 3, name: "GitHub", kind: "message", jsonName: "GitHub", oneof: "subKindSpec", T: () => GitHubIntegrationSpecV1, options: { "gogoproto.jsontag": "github,omitempty" } },
            { no: 5, name: "AWSRA", kind: "message", jsonName: "AWSRA", oneof: "subKindSpec", T: () => AWSRAIntegrationSpecV1, options: { "gogoproto.jsontag": "aws_ra,omitempty" } },
            { no: 4, name: "credentials", kind: "message", T: () => PluginCredentialsV1 }
        ]);
    }
    create(value?: PartialMessage<IntegrationSpecV1>): IntegrationSpecV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subKindSpec = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<IntegrationSpecV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IntegrationSpecV1): IntegrationSpecV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.AWSOIDCIntegrationSpecV1 AWSOIDC = 1 [json_name = "AWSOIDC"];*/ 1:
                    message.subKindSpec = {
                        oneofKind: "aWSOIDC",
                        aWSOIDC: AWSOIDCIntegrationSpecV1.internalBinaryRead(reader, reader.uint32(), options, (message.subKindSpec as any).aWSOIDC)
                    };
                    break;
                case /* types.AzureOIDCIntegrationSpecV1 AzureOIDC = 2 [json_name = "AzureOIDC"];*/ 2:
                    message.subKindSpec = {
                        oneofKind: "azureOIDC",
                        azureOIDC: AzureOIDCIntegrationSpecV1.internalBinaryRead(reader, reader.uint32(), options, (message.subKindSpec as any).azureOIDC)
                    };
                    break;
                case /* types.GitHubIntegrationSpecV1 GitHub = 3 [json_name = "GitHub"];*/ 3:
                    message.subKindSpec = {
                        oneofKind: "gitHub",
                        gitHub: GitHubIntegrationSpecV1.internalBinaryRead(reader, reader.uint32(), options, (message.subKindSpec as any).gitHub)
                    };
                    break;
                case /* types.AWSRAIntegrationSpecV1 AWSRA = 5 [json_name = "AWSRA"];*/ 5:
                    message.subKindSpec = {
                        oneofKind: "aWSRA",
                        aWSRA: AWSRAIntegrationSpecV1.internalBinaryRead(reader, reader.uint32(), options, (message.subKindSpec as any).aWSRA)
                    };
                    break;
                case /* types.PluginCredentialsV1 credentials */ 4:
                    message.credentials = PluginCredentialsV1.internalBinaryRead(reader, reader.uint32(), options, message.credentials);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IntegrationSpecV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.AWSOIDCIntegrationSpecV1 AWSOIDC = 1 [json_name = "AWSOIDC"]; */
        if (message.subKindSpec.oneofKind === "aWSOIDC")
            AWSOIDCIntegrationSpecV1.internalBinaryWrite(message.subKindSpec.aWSOIDC, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* types.AzureOIDCIntegrationSpecV1 AzureOIDC = 2 [json_name = "AzureOIDC"]; */
        if (message.subKindSpec.oneofKind === "azureOIDC")
            AzureOIDCIntegrationSpecV1.internalBinaryWrite(message.subKindSpec.azureOIDC, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* types.GitHubIntegrationSpecV1 GitHub = 3 [json_name = "GitHub"]; */
        if (message.subKindSpec.oneofKind === "gitHub")
            GitHubIntegrationSpecV1.internalBinaryWrite(message.subKindSpec.gitHub, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* types.AWSRAIntegrationSpecV1 AWSRA = 5 [json_name = "AWSRA"]; */
        if (message.subKindSpec.oneofKind === "aWSRA")
            AWSRAIntegrationSpecV1.internalBinaryWrite(message.subKindSpec.aWSRA, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* types.PluginCredentialsV1 credentials = 4; */
        if (message.credentials)
            PluginCredentialsV1.internalBinaryWrite(message.credentials, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.IntegrationSpecV1
 */
export const IntegrationSpecV1 = new IntegrationSpecV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AWSOIDCIntegrationSpecV1$Type extends MessageType<AWSOIDCIntegrationSpecV1> {
    constructor() {
        super("types.AWSOIDCIntegrationSpecV1", [
            { no: 1, name: "RoleARN", kind: "scalar", jsonName: "RoleARN", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "role_arn,omitempty" } },
            { no: 2, name: "IssuerS3URI", kind: "scalar", jsonName: "IssuerS3URI", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "issuer_s3_uri,omitempty" } },
            { no: 3, name: "audience", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "audience,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<AWSOIDCIntegrationSpecV1>): AWSOIDCIntegrationSpecV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.roleARN = "";
        message.issuerS3URI = "";
        message.audience = "";
        if (value !== undefined)
            reflectionMergePartial<AWSOIDCIntegrationSpecV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AWSOIDCIntegrationSpecV1): AWSOIDCIntegrationSpecV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string RoleARN = 1 [json_name = "RoleARN"];*/ 1:
                    message.roleARN = reader.string();
                    break;
                case /* string IssuerS3URI = 2 [deprecated = true, json_name = "IssuerS3URI"];*/ 2:
                    message.issuerS3URI = reader.string();
                    break;
                case /* string audience */ 3:
                    message.audience = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AWSOIDCIntegrationSpecV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string RoleARN = 1 [json_name = "RoleARN"]; */
        if (message.roleARN !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.roleARN);
        /* string IssuerS3URI = 2 [deprecated = true, json_name = "IssuerS3URI"]; */
        if (message.issuerS3URI !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.issuerS3URI);
        /* string audience = 3; */
        if (message.audience !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.audience);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AWSOIDCIntegrationSpecV1
 */
export const AWSOIDCIntegrationSpecV1 = new AWSOIDCIntegrationSpecV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AzureOIDCIntegrationSpecV1$Type extends MessageType<AzureOIDCIntegrationSpecV1> {
    constructor() {
        super("types.AzureOIDCIntegrationSpecV1", [
            { no: 1, name: "TenantID", kind: "scalar", jsonName: "TenantID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "tenant_id,omitempty" } },
            { no: 2, name: "ClientID", kind: "scalar", jsonName: "ClientID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "client_id,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<AzureOIDCIntegrationSpecV1>): AzureOIDCIntegrationSpecV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tenantID = "";
        message.clientID = "";
        if (value !== undefined)
            reflectionMergePartial<AzureOIDCIntegrationSpecV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AzureOIDCIntegrationSpecV1): AzureOIDCIntegrationSpecV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string TenantID = 1 [json_name = "TenantID"];*/ 1:
                    message.tenantID = reader.string();
                    break;
                case /* string ClientID = 2 [json_name = "ClientID"];*/ 2:
                    message.clientID = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AzureOIDCIntegrationSpecV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string TenantID = 1 [json_name = "TenantID"]; */
        if (message.tenantID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tenantID);
        /* string ClientID = 2 [json_name = "ClientID"]; */
        if (message.clientID !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.clientID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AzureOIDCIntegrationSpecV1
 */
export const AzureOIDCIntegrationSpecV1 = new AzureOIDCIntegrationSpecV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GitHubIntegrationSpecV1$Type extends MessageType<GitHubIntegrationSpecV1> {
    constructor() {
        super("types.GitHubIntegrationSpecV1", [
            { no: 1, name: "Organization", kind: "scalar", jsonName: "Organization", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "organization,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<GitHubIntegrationSpecV1>): GitHubIntegrationSpecV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.organization = "";
        if (value !== undefined)
            reflectionMergePartial<GitHubIntegrationSpecV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GitHubIntegrationSpecV1): GitHubIntegrationSpecV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Organization = 1 [json_name = "Organization"];*/ 1:
                    message.organization = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GitHubIntegrationSpecV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Organization = 1 [json_name = "Organization"]; */
        if (message.organization !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.organization);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.GitHubIntegrationSpecV1
 */
export const GitHubIntegrationSpecV1 = new GitHubIntegrationSpecV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AWSRAIntegrationSpecV1$Type extends MessageType<AWSRAIntegrationSpecV1> {
    constructor() {
        super("types.AWSRAIntegrationSpecV1", [
            { no: 1, name: "TrustAnchorARN", kind: "scalar", jsonName: "TrustAnchorARN", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "trust_anchor_arn,omitempty" } },
            { no: 2, name: "ProfileSyncConfig", kind: "message", jsonName: "ProfileSyncConfig", T: () => AWSRolesAnywhereProfileSyncConfig, options: { "gogoproto.jsontag": "profile_sync_config" } }
        ]);
    }
    create(value?: PartialMessage<AWSRAIntegrationSpecV1>): AWSRAIntegrationSpecV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.trustAnchorARN = "";
        if (value !== undefined)
            reflectionMergePartial<AWSRAIntegrationSpecV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AWSRAIntegrationSpecV1): AWSRAIntegrationSpecV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string TrustAnchorARN = 1 [json_name = "TrustAnchorARN"];*/ 1:
                    message.trustAnchorARN = reader.string();
                    break;
                case /* types.AWSRolesAnywhereProfileSyncConfig ProfileSyncConfig = 2 [json_name = "ProfileSyncConfig"];*/ 2:
                    message.profileSyncConfig = AWSRolesAnywhereProfileSyncConfig.internalBinaryRead(reader, reader.uint32(), options, message.profileSyncConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AWSRAIntegrationSpecV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string TrustAnchorARN = 1 [json_name = "TrustAnchorARN"]; */
        if (message.trustAnchorARN !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.trustAnchorARN);
        /* types.AWSRolesAnywhereProfileSyncConfig ProfileSyncConfig = 2 [json_name = "ProfileSyncConfig"]; */
        if (message.profileSyncConfig)
            AWSRolesAnywhereProfileSyncConfig.internalBinaryWrite(message.profileSyncConfig, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AWSRAIntegrationSpecV1
 */
export const AWSRAIntegrationSpecV1 = new AWSRAIntegrationSpecV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AWSRolesAnywhereProfileSyncConfig$Type extends MessageType<AWSRolesAnywhereProfileSyncConfig> {
    constructor() {
        super("types.AWSRolesAnywhereProfileSyncConfig", [
            { no: 1, name: "Enabled", kind: "scalar", jsonName: "Enabled", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "enabled" } },
            { no: 2, name: "ProfileARN", kind: "scalar", jsonName: "ProfileARN", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "profile_arn" } },
            { no: 3, name: "ProfileAcceptsRoleSessionName", kind: "scalar", jsonName: "ProfileAcceptsRoleSessionName", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "profile_accepts_role_session_name" } },
            { no: 4, name: "RoleARN", kind: "scalar", jsonName: "RoleARN", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "role_arn" } }
        ]);
    }
    create(value?: PartialMessage<AWSRolesAnywhereProfileSyncConfig>): AWSRolesAnywhereProfileSyncConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.enabled = false;
        message.profileARN = "";
        message.profileAcceptsRoleSessionName = false;
        message.roleARN = "";
        if (value !== undefined)
            reflectionMergePartial<AWSRolesAnywhereProfileSyncConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AWSRolesAnywhereProfileSyncConfig): AWSRolesAnywhereProfileSyncConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool Enabled = 1 [json_name = "Enabled"];*/ 1:
                    message.enabled = reader.bool();
                    break;
                case /* string ProfileARN = 2 [json_name = "ProfileARN"];*/ 2:
                    message.profileARN = reader.string();
                    break;
                case /* bool ProfileAcceptsRoleSessionName = 3 [json_name = "ProfileAcceptsRoleSessionName"];*/ 3:
                    message.profileAcceptsRoleSessionName = reader.bool();
                    break;
                case /* string RoleARN = 4 [json_name = "RoleARN"];*/ 4:
                    message.roleARN = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AWSRolesAnywhereProfileSyncConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool Enabled = 1 [json_name = "Enabled"]; */
        if (message.enabled !== false)
            writer.tag(1, WireType.Varint).bool(message.enabled);
        /* string ProfileARN = 2 [json_name = "ProfileARN"]; */
        if (message.profileARN !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.profileARN);
        /* bool ProfileAcceptsRoleSessionName = 3 [json_name = "ProfileAcceptsRoleSessionName"]; */
        if (message.profileAcceptsRoleSessionName !== false)
            writer.tag(3, WireType.Varint).bool(message.profileAcceptsRoleSessionName);
        /* string RoleARN = 4 [json_name = "RoleARN"]; */
        if (message.roleARN !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.roleARN);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AWSRolesAnywhereProfileSyncConfig
 */
export const AWSRolesAnywhereProfileSyncConfig = new AWSRolesAnywhereProfileSyncConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeadlessAuthentication$Type extends MessageType<HeadlessAuthentication> {
    constructor() {
        super("types.HeadlessAuthentication", [
            { no: 1, name: "header", kind: "message", T: () => ResourceHeader, options: { "gogoproto.nullable": false, "gogoproto.embed": true } },
            { no: 2, name: "user", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "public_key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "state", kind: "enum", T: () => ["types.HeadlessAuthenticationState", HeadlessAuthenticationState, "HEADLESS_AUTHENTICATION_STATE_"] },
            { no: 5, name: "mfa_device", kind: "message", T: () => MFADevice },
            { no: 6, name: "client_ip_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "ssh_public_key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 8, name: "tls_public_key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<HeadlessAuthentication>): HeadlessAuthentication {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.user = "";
        message.publicKey = new Uint8Array(0);
        message.state = 0;
        message.clientIpAddress = "";
        message.sshPublicKey = new Uint8Array(0);
        message.tlsPublicKey = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<HeadlessAuthentication>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeadlessAuthentication): HeadlessAuthentication {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.ResourceHeader header */ 1:
                    message.header = ResourceHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* string user */ 2:
                    message.user = reader.string();
                    break;
                case /* bytes public_key = 3 [deprecated = true];*/ 3:
                    message.publicKey = reader.bytes();
                    break;
                case /* types.HeadlessAuthenticationState state */ 4:
                    message.state = reader.int32();
                    break;
                case /* types.MFADevice mfa_device */ 5:
                    message.mfaDevice = MFADevice.internalBinaryRead(reader, reader.uint32(), options, message.mfaDevice);
                    break;
                case /* string client_ip_address */ 6:
                    message.clientIpAddress = reader.string();
                    break;
                case /* bytes ssh_public_key */ 7:
                    message.sshPublicKey = reader.bytes();
                    break;
                case /* bytes tls_public_key */ 8:
                    message.tlsPublicKey = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeadlessAuthentication, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.ResourceHeader header = 1; */
        if (message.header)
            ResourceHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string user = 2; */
        if (message.user !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.user);
        /* bytes public_key = 3 [deprecated = true]; */
        if (message.publicKey.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.publicKey);
        /* types.HeadlessAuthenticationState state = 4; */
        if (message.state !== 0)
            writer.tag(4, WireType.Varint).int32(message.state);
        /* types.MFADevice mfa_device = 5; */
        if (message.mfaDevice)
            MFADevice.internalBinaryWrite(message.mfaDevice, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string client_ip_address = 6; */
        if (message.clientIpAddress !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.clientIpAddress);
        /* bytes ssh_public_key = 7; */
        if (message.sshPublicKey.length)
            writer.tag(7, WireType.LengthDelimited).bytes(message.sshPublicKey);
        /* bytes tls_public_key = 8; */
        if (message.tlsPublicKey.length)
            writer.tag(8, WireType.LengthDelimited).bytes(message.tlsPublicKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.HeadlessAuthentication
 */
export const HeadlessAuthentication = new HeadlessAuthentication$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WatchKind$Type extends MessageType<WatchKind> {
    constructor() {
        super("types.WatchKind", [
            { no: 1, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 2, name: "LoadSecrets", kind: "scalar", jsonName: "LoadSecrets", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "load_secrets" } },
            { no: 3, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "name" } },
            { no: 4, name: "Filter", kind: "map", jsonName: "Filter", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ }, options: { "gogoproto.jsontag": "filter,omitempty" } },
            { no: 5, name: "SubKind", kind: "scalar", jsonName: "SubKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub_kind,omitempty" } },
            { no: 6, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<WatchKind>): WatchKind {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.loadSecrets = false;
        message.name = "";
        message.filter = {};
        message.subKind = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<WatchKind>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WatchKind): WatchKind {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Kind = 1 [json_name = "Kind"];*/ 1:
                    message.kind = reader.string();
                    break;
                case /* bool LoadSecrets = 2 [json_name = "LoadSecrets"];*/ 2:
                    message.loadSecrets = reader.bool();
                    break;
                case /* string Name = 3 [json_name = "Name"];*/ 3:
                    message.name = reader.string();
                    break;
                case /* map<string, string> Filter = 4 [json_name = "Filter"];*/ 4:
                    this.binaryReadMap4(message.filter, reader, options);
                    break;
                case /* string SubKind = 5 [json_name = "SubKind"];*/ 5:
                    message.subKind = reader.string();
                    break;
                case /* string Version = 6 [json_name = "Version"];*/ 6:
                    message.version = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap4(map: WatchKind["filter"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof WatchKind["filter"] | undefined, val: WatchKind["filter"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field types.WatchKind.Filter");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: WatchKind, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Kind = 1 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* bool LoadSecrets = 2 [json_name = "LoadSecrets"]; */
        if (message.loadSecrets !== false)
            writer.tag(2, WireType.Varint).bool(message.loadSecrets);
        /* string Name = 3 [json_name = "Name"]; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* map<string, string> Filter = 4 [json_name = "Filter"]; */
        for (let k of globalThis.Object.keys(message.filter))
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.filter[k]).join();
        /* string SubKind = 5 [json_name = "SubKind"]; */
        if (message.subKind !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.subKind);
        /* string Version = 6 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.version);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.WatchKind
 */
export const WatchKind = new WatchKind$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WatchStatusV1$Type extends MessageType<WatchStatusV1> {
    constructor() {
        super("types.WatchStatusV1", [
            { no: 1, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 2, name: "SubKind", kind: "scalar", jsonName: "SubKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub_kind,omitempty" } },
            { no: 3, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version" } },
            { no: 4, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "metadata" } },
            { no: 5, name: "Spec", kind: "message", jsonName: "Spec", T: () => WatchStatusSpecV1, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ]);
    }
    create(value?: PartialMessage<WatchStatusV1>): WatchStatusV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.subKind = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<WatchStatusV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WatchStatusV1): WatchStatusV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Kind = 1 [json_name = "Kind"];*/ 1:
                    message.kind = reader.string();
                    break;
                case /* string SubKind = 2 [json_name = "SubKind"];*/ 2:
                    message.subKind = reader.string();
                    break;
                case /* string Version = 3 [json_name = "Version"];*/ 3:
                    message.version = reader.string();
                    break;
                case /* types.Metadata Metadata = 4 [json_name = "Metadata"];*/ 4:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* types.WatchStatusSpecV1 Spec = 5 [json_name = "Spec"];*/ 5:
                    message.spec = WatchStatusSpecV1.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WatchStatusV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Kind = 1 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string SubKind = 2 [json_name = "SubKind"]; */
        if (message.subKind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subKind);
        /* string Version = 3 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* types.Metadata Metadata = 4 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.WatchStatusSpecV1 Spec = 5 [json_name = "Spec"]; */
        if (message.spec)
            WatchStatusSpecV1.internalBinaryWrite(message.spec, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.WatchStatusV1
 */
export const WatchStatusV1 = new WatchStatusV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WatchStatusSpecV1$Type extends MessageType<WatchStatusSpecV1> {
    constructor() {
        super("types.WatchStatusSpecV1", [
            { no: 1, name: "Kinds", kind: "message", jsonName: "Kinds", repeat: 1 /*RepeatType.PACKED*/, T: () => WatchKind, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "kinds" } }
        ]);
    }
    create(value?: PartialMessage<WatchStatusSpecV1>): WatchStatusSpecV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kinds = [];
        if (value !== undefined)
            reflectionMergePartial<WatchStatusSpecV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WatchStatusSpecV1): WatchStatusSpecV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.WatchKind Kinds = 1 [json_name = "Kinds"];*/ 1:
                    message.kinds.push(WatchKind.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WatchStatusSpecV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.WatchKind Kinds = 1 [json_name = "Kinds"]; */
        for (let i = 0; i < message.kinds.length; i++)
            WatchKind.internalBinaryWrite(message.kinds[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.WatchStatusSpecV1
 */
export const WatchStatusSpecV1 = new WatchStatusSpecV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServerInfoV1$Type extends MessageType<ServerInfoV1> {
    constructor() {
        super("types.ServerInfoV1", [
            { no: 1, name: "Kind", kind: "scalar", jsonName: "Kind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "kind" } },
            { no: 2, name: "SubKind", kind: "scalar", jsonName: "SubKind", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sub_kind" } },
            { no: 3, name: "Version", kind: "scalar", jsonName: "Version", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "version" } },
            { no: 4, name: "Metadata", kind: "message", jsonName: "Metadata", T: () => Metadata, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "metadata" } },
            { no: 5, name: "Spec", kind: "message", jsonName: "Spec", T: () => ServerInfoSpecV1, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "spec" } }
        ]);
    }
    create(value?: PartialMessage<ServerInfoV1>): ServerInfoV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = "";
        message.subKind = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<ServerInfoV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServerInfoV1): ServerInfoV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Kind = 1 [json_name = "Kind"];*/ 1:
                    message.kind = reader.string();
                    break;
                case /* string SubKind = 2 [json_name = "SubKind"];*/ 2:
                    message.subKind = reader.string();
                    break;
                case /* string Version = 3 [json_name = "Version"];*/ 3:
                    message.version = reader.string();
                    break;
                case /* types.Metadata Metadata = 4 [json_name = "Metadata"];*/ 4:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* types.ServerInfoSpecV1 Spec = 5 [json_name = "Spec"];*/ 5:
                    message.spec = ServerInfoSpecV1.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServerInfoV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Kind = 1 [json_name = "Kind"]; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string SubKind = 2 [json_name = "SubKind"]; */
        if (message.subKind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subKind);
        /* string Version = 3 [json_name = "Version"]; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* types.Metadata Metadata = 4 [json_name = "Metadata"]; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.ServerInfoSpecV1 Spec = 5 [json_name = "Spec"]; */
        if (message.spec)
            ServerInfoSpecV1.internalBinaryWrite(message.spec, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ServerInfoV1
 */
export const ServerInfoV1 = new ServerInfoV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServerInfoSpecV1$Type extends MessageType<ServerInfoSpecV1> {
    constructor() {
        super("types.ServerInfoSpecV1", [
            { no: 2, name: "NewLabels", kind: "map", jsonName: "NewLabels", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ }, options: { "gogoproto.jsontag": "new_labels,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ServerInfoSpecV1>): ServerInfoSpecV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.newLabels = {};
        if (value !== undefined)
            reflectionMergePartial<ServerInfoSpecV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServerInfoSpecV1): ServerInfoSpecV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, string> NewLabels = 2 [json_name = "NewLabels"];*/ 2:
                    this.binaryReadMap2(message.newLabels, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: ServerInfoSpecV1["newLabels"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ServerInfoSpecV1["newLabels"] | undefined, val: ServerInfoSpecV1["newLabels"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field types.ServerInfoSpecV1.NewLabels");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: ServerInfoSpecV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, string> NewLabels = 2 [json_name = "NewLabels"]; */
        for (let k of globalThis.Object.keys(message.newLabels))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.newLabels[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ServerInfoSpecV1
 */
export const ServerInfoSpecV1 = new ServerInfoSpecV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JamfSpecV1$Type extends MessageType<JamfSpecV1> {
    constructor() {
        super("types.JamfSpecV1", [
            { no: 1, name: "enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "enabled,omitempty" } },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "name,omitempty" } },
            { no: 3, name: "sync_delay", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "sync_delay,omitempty", "gogoproto.casttype": "Duration" } },
            { no: 4, name: "api_endpoint", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "api_endpoint,omitempty" } },
            { no: 7, name: "inventory", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => JamfInventoryEntry, options: { "gogoproto.jsontag": "inventory,omitempty" } }
        ], { "gogoproto.equal": true });
    }
    create(value?: PartialMessage<JamfSpecV1>): JamfSpecV1 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.enabled = false;
        message.name = "";
        message.syncDelay = 0n;
        message.apiEndpoint = "";
        message.inventory = [];
        if (value !== undefined)
            reflectionMergePartial<JamfSpecV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JamfSpecV1): JamfSpecV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool enabled */ 1:
                    message.enabled = reader.bool();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* int64 sync_delay */ 3:
                    message.syncDelay = reader.int64().toBigInt();
                    break;
                case /* string api_endpoint */ 4:
                    message.apiEndpoint = reader.string();
                    break;
                case /* repeated types.JamfInventoryEntry inventory */ 7:
                    message.inventory.push(JamfInventoryEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JamfSpecV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool enabled = 1; */
        if (message.enabled !== false)
            writer.tag(1, WireType.Varint).bool(message.enabled);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* int64 sync_delay = 3; */
        if (message.syncDelay !== 0n)
            writer.tag(3, WireType.Varint).int64(message.syncDelay);
        /* string api_endpoint = 4; */
        if (message.apiEndpoint !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.apiEndpoint);
        /* repeated types.JamfInventoryEntry inventory = 7; */
        for (let i = 0; i < message.inventory.length; i++)
            JamfInventoryEntry.internalBinaryWrite(message.inventory[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.JamfSpecV1
 */
export const JamfSpecV1 = new JamfSpecV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JamfInventoryEntry$Type extends MessageType<JamfInventoryEntry> {
    constructor() {
        super("types.JamfInventoryEntry", [
            { no: 1, name: "filter_rsql", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "filter_rsql,omitempty" } },
            { no: 2, name: "sync_period_partial", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "sync_period_partial,omitempty", "gogoproto.casttype": "Duration" } },
            { no: 3, name: "sync_period_full", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "sync_period_full,omitempty", "gogoproto.casttype": "Duration" } },
            { no: 4, name: "on_missing", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "on_missing,omitempty" } },
            { no: 5, name: "page_size", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "gogoproto.jsontag": "page_size,omitempty" } }
        ], { "gogoproto.equal": true });
    }
    create(value?: PartialMessage<JamfInventoryEntry>): JamfInventoryEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.filterRsql = "";
        message.syncPeriodPartial = 0n;
        message.syncPeriodFull = 0n;
        message.onMissing = "";
        message.pageSize = 0;
        if (value !== undefined)
            reflectionMergePartial<JamfInventoryEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JamfInventoryEntry): JamfInventoryEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string filter_rsql */ 1:
                    message.filterRsql = reader.string();
                    break;
                case /* int64 sync_period_partial */ 2:
                    message.syncPeriodPartial = reader.int64().toBigInt();
                    break;
                case /* int64 sync_period_full */ 3:
                    message.syncPeriodFull = reader.int64().toBigInt();
                    break;
                case /* string on_missing */ 4:
                    message.onMissing = reader.string();
                    break;
                case /* int32 page_size */ 5:
                    message.pageSize = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JamfInventoryEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string filter_rsql = 1; */
        if (message.filterRsql !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.filterRsql);
        /* int64 sync_period_partial = 2; */
        if (message.syncPeriodPartial !== 0n)
            writer.tag(2, WireType.Varint).int64(message.syncPeriodPartial);
        /* int64 sync_period_full = 3; */
        if (message.syncPeriodFull !== 0n)
            writer.tag(3, WireType.Varint).int64(message.syncPeriodFull);
        /* string on_missing = 4; */
        if (message.onMissing !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.onMissing);
        /* int32 page_size = 5; */
        if (message.pageSize !== 0)
            writer.tag(5, WireType.Varint).int32(message.pageSize);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.JamfInventoryEntry
 */
export const JamfInventoryEntry = new JamfInventoryEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MessageWithHeader$Type extends MessageType<MessageWithHeader> {
    constructor() {
        super("types.MessageWithHeader", [
            { no: 1, name: "Header", kind: "message", jsonName: "Header", T: () => ResourceHeader, options: { "gogoproto.nullable": false, "gogoproto.embed": true, "gogoproto.jsontag": "" } }
        ], { "gogoproto.goproto_stringer": false, "gogoproto.stringer": false });
    }
    create(value?: PartialMessage<MessageWithHeader>): MessageWithHeader {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MessageWithHeader>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MessageWithHeader): MessageWithHeader {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.ResourceHeader Header = 1 [json_name = "Header"];*/ 1:
                    message.header = ResourceHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MessageWithHeader, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.ResourceHeader Header = 1 [json_name = "Header"]; */
        if (message.header)
            ResourceHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.MessageWithHeader
 */
export const MessageWithHeader = new MessageWithHeader$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AWSMatcher$Type extends MessageType<AWSMatcher> {
    constructor() {
        super("types.AWSMatcher", [
            { no: 1, name: "Types", kind: "scalar", jsonName: "Types", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "types,omitempty" } },
            { no: 2, name: "Regions", kind: "scalar", jsonName: "Regions", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "regions,omitempty" } },
            { no: 3, name: "AssumeRole", kind: "message", jsonName: "AssumeRole", T: () => AssumeRole, options: { "gogoproto.jsontag": "assume_role,omitempty" } },
            { no: 4, name: "Tags", kind: "message", jsonName: "Tags", T: () => LabelValues, options: { "gogoproto.nullable": false, "gogoproto.customtype": "Labels", "gogoproto.jsontag": "tags,omitempty" } },
            { no: 5, name: "Params", kind: "message", jsonName: "Params", T: () => InstallerParams, options: { "gogoproto.jsontag": "install,omitempty" } },
            { no: 6, name: "SSM", kind: "message", jsonName: "SSM", T: () => AWSSSM, options: { "gogoproto.jsontag": "ssm,omitempty" } },
            { no: 7, name: "Integration", kind: "scalar", jsonName: "Integration", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "integration,omitempty" } },
            { no: 8, name: "KubeAppDiscovery", kind: "scalar", jsonName: "KubeAppDiscovery", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "kube_app_discovery,omitempty" } },
            { no: 9, name: "SetupAccessForARN", kind: "scalar", jsonName: "SetupAccessForARN", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "setup_access_for_arn,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<AWSMatcher>): AWSMatcher {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.types = [];
        message.regions = [];
        message.integration = "";
        message.kubeAppDiscovery = false;
        message.setupAccessForARN = "";
        if (value !== undefined)
            reflectionMergePartial<AWSMatcher>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AWSMatcher): AWSMatcher {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string Types = 1 [json_name = "Types"];*/ 1:
                    message.types.push(reader.string());
                    break;
                case /* repeated string Regions = 2 [json_name = "Regions"];*/ 2:
                    message.regions.push(reader.string());
                    break;
                case /* types.AssumeRole AssumeRole = 3 [json_name = "AssumeRole"];*/ 3:
                    message.assumeRole = AssumeRole.internalBinaryRead(reader, reader.uint32(), options, message.assumeRole);
                    break;
                case /* wrappers.LabelValues Tags = 4 [json_name = "Tags"];*/ 4:
                    message.tags = LabelValues.internalBinaryRead(reader, reader.uint32(), options, message.tags);
                    break;
                case /* types.InstallerParams Params = 5 [json_name = "Params"];*/ 5:
                    message.params = InstallerParams.internalBinaryRead(reader, reader.uint32(), options, message.params);
                    break;
                case /* types.AWSSSM SSM = 6 [json_name = "SSM"];*/ 6:
                    message.sSM = AWSSSM.internalBinaryRead(reader, reader.uint32(), options, message.sSM);
                    break;
                case /* string Integration = 7 [json_name = "Integration"];*/ 7:
                    message.integration = reader.string();
                    break;
                case /* bool KubeAppDiscovery = 8 [json_name = "KubeAppDiscovery"];*/ 8:
                    message.kubeAppDiscovery = reader.bool();
                    break;
                case /* string SetupAccessForARN = 9 [json_name = "SetupAccessForARN"];*/ 9:
                    message.setupAccessForARN = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AWSMatcher, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string Types = 1 [json_name = "Types"]; */
        for (let i = 0; i < message.types.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.types[i]);
        /* repeated string Regions = 2 [json_name = "Regions"]; */
        for (let i = 0; i < message.regions.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.regions[i]);
        /* types.AssumeRole AssumeRole = 3 [json_name = "AssumeRole"]; */
        if (message.assumeRole)
            AssumeRole.internalBinaryWrite(message.assumeRole, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* wrappers.LabelValues Tags = 4 [json_name = "Tags"]; */
        if (message.tags)
            LabelValues.internalBinaryWrite(message.tags, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* types.InstallerParams Params = 5 [json_name = "Params"]; */
        if (message.params)
            InstallerParams.internalBinaryWrite(message.params, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* types.AWSSSM SSM = 6 [json_name = "SSM"]; */
        if (message.sSM)
            AWSSSM.internalBinaryWrite(message.sSM, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* string Integration = 7 [json_name = "Integration"]; */
        if (message.integration !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.integration);
        /* bool KubeAppDiscovery = 8 [json_name = "KubeAppDiscovery"]; */
        if (message.kubeAppDiscovery !== false)
            writer.tag(8, WireType.Varint).bool(message.kubeAppDiscovery);
        /* string SetupAccessForARN = 9 [json_name = "SetupAccessForARN"]; */
        if (message.setupAccessForARN !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.setupAccessForARN);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AWSMatcher
 */
export const AWSMatcher = new AWSMatcher$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AssumeRole$Type extends MessageType<AssumeRole> {
    constructor() {
        super("types.AssumeRole", [
            { no: 1, name: "RoleARN", kind: "scalar", jsonName: "RoleARN", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "role_arn" } },
            { no: 2, name: "ExternalID", kind: "scalar", jsonName: "ExternalID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "external_id" } }
        ]);
    }
    create(value?: PartialMessage<AssumeRole>): AssumeRole {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.roleARN = "";
        message.externalID = "";
        if (value !== undefined)
            reflectionMergePartial<AssumeRole>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AssumeRole): AssumeRole {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string RoleARN = 1 [json_name = "RoleARN"];*/ 1:
                    message.roleARN = reader.string();
                    break;
                case /* string ExternalID = 2 [json_name = "ExternalID"];*/ 2:
                    message.externalID = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AssumeRole, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string RoleARN = 1 [json_name = "RoleARN"]; */
        if (message.roleARN !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.roleARN);
        /* string ExternalID = 2 [json_name = "ExternalID"]; */
        if (message.externalID !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.externalID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AssumeRole
 */
export const AssumeRole = new AssumeRole$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InstallerParams$Type extends MessageType<InstallerParams> {
    constructor() {
        super("types.InstallerParams", [
            { no: 1, name: "JoinMethod", kind: "scalar", jsonName: "JoinMethod", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "join_method", "gogoproto.casttype": "JoinMethod" } },
            { no: 2, name: "JoinToken", kind: "scalar", jsonName: "JoinToken", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "join_token" } },
            { no: 3, name: "ScriptName", kind: "scalar", jsonName: "ScriptName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "script_name,omitempty" } },
            { no: 4, name: "InstallTeleport", kind: "scalar", jsonName: "InstallTeleport", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "install_teleport,omitempty" } },
            { no: 5, name: "SSHDConfig", kind: "scalar", jsonName: "SSHDConfig", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sshd_config,omitempty" } },
            { no: 6, name: "PublicProxyAddr", kind: "scalar", jsonName: "PublicProxyAddr", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "proxy_addr,omitempty" } },
            { no: 7, name: "Azure", kind: "message", jsonName: "Azure", T: () => AzureInstallerParams, options: { "gogoproto.jsontag": "azure,omitempty" } },
            { no: 8, name: "EnrollMode", kind: "enum", jsonName: "EnrollMode", T: () => ["types.InstallParamEnrollMode", InstallParamEnrollMode, "INSTALL_PARAM_ENROLL_MODE_"], options: { "gogoproto.jsontag": "enroll_mode,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<InstallerParams>): InstallerParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.joinMethod = "";
        message.joinToken = "";
        message.scriptName = "";
        message.installTeleport = false;
        message.sSHDConfig = "";
        message.publicProxyAddr = "";
        message.enrollMode = 0;
        if (value !== undefined)
            reflectionMergePartial<InstallerParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InstallerParams): InstallerParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string JoinMethod = 1 [json_name = "JoinMethod"];*/ 1:
                    message.joinMethod = reader.string();
                    break;
                case /* string JoinToken = 2 [json_name = "JoinToken"];*/ 2:
                    message.joinToken = reader.string();
                    break;
                case /* string ScriptName = 3 [json_name = "ScriptName"];*/ 3:
                    message.scriptName = reader.string();
                    break;
                case /* bool InstallTeleport = 4 [json_name = "InstallTeleport"];*/ 4:
                    message.installTeleport = reader.bool();
                    break;
                case /* string SSHDConfig = 5 [json_name = "SSHDConfig"];*/ 5:
                    message.sSHDConfig = reader.string();
                    break;
                case /* string PublicProxyAddr = 6 [json_name = "PublicProxyAddr"];*/ 6:
                    message.publicProxyAddr = reader.string();
                    break;
                case /* types.AzureInstallerParams Azure = 7 [json_name = "Azure"];*/ 7:
                    message.azure = AzureInstallerParams.internalBinaryRead(reader, reader.uint32(), options, message.azure);
                    break;
                case /* types.InstallParamEnrollMode EnrollMode = 8 [json_name = "EnrollMode"];*/ 8:
                    message.enrollMode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InstallerParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string JoinMethod = 1 [json_name = "JoinMethod"]; */
        if (message.joinMethod !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.joinMethod);
        /* string JoinToken = 2 [json_name = "JoinToken"]; */
        if (message.joinToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.joinToken);
        /* string ScriptName = 3 [json_name = "ScriptName"]; */
        if (message.scriptName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.scriptName);
        /* bool InstallTeleport = 4 [json_name = "InstallTeleport"]; */
        if (message.installTeleport !== false)
            writer.tag(4, WireType.Varint).bool(message.installTeleport);
        /* string SSHDConfig = 5 [json_name = "SSHDConfig"]; */
        if (message.sSHDConfig !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.sSHDConfig);
        /* string PublicProxyAddr = 6 [json_name = "PublicProxyAddr"]; */
        if (message.publicProxyAddr !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.publicProxyAddr);
        /* types.AzureInstallerParams Azure = 7 [json_name = "Azure"]; */
        if (message.azure)
            AzureInstallerParams.internalBinaryWrite(message.azure, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* types.InstallParamEnrollMode EnrollMode = 8 [json_name = "EnrollMode"]; */
        if (message.enrollMode !== 0)
            writer.tag(8, WireType.Varint).int32(message.enrollMode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.InstallerParams
 */
export const InstallerParams = new InstallerParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AWSSSM$Type extends MessageType<AWSSSM> {
    constructor() {
        super("types.AWSSSM", [
            { no: 1, name: "DocumentName", kind: "scalar", jsonName: "DocumentName", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "document_name,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<AWSSSM>): AWSSSM {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.documentName = "";
        if (value !== undefined)
            reflectionMergePartial<AWSSSM>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AWSSSM): AWSSSM {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string DocumentName = 1 [json_name = "DocumentName"];*/ 1:
                    message.documentName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AWSSSM, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string DocumentName = 1 [json_name = "DocumentName"]; */
        if (message.documentName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.documentName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AWSSSM
 */
export const AWSSSM = new AWSSSM$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AzureInstallerParams$Type extends MessageType<AzureInstallerParams> {
    constructor() {
        super("types.AzureInstallerParams", [
            { no: 1, name: "ClientID", kind: "scalar", jsonName: "ClientID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "client_id,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<AzureInstallerParams>): AzureInstallerParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clientID = "";
        if (value !== undefined)
            reflectionMergePartial<AzureInstallerParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AzureInstallerParams): AzureInstallerParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ClientID = 1 [json_name = "ClientID"];*/ 1:
                    message.clientID = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AzureInstallerParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ClientID = 1 [json_name = "ClientID"]; */
        if (message.clientID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clientID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AzureInstallerParams
 */
export const AzureInstallerParams = new AzureInstallerParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AzureMatcher$Type extends MessageType<AzureMatcher> {
    constructor() {
        super("types.AzureMatcher", [
            { no: 1, name: "Subscriptions", kind: "scalar", jsonName: "Subscriptions", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "subscriptions,omitempty" } },
            { no: 2, name: "ResourceGroups", kind: "scalar", jsonName: "ResourceGroups", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "resource_groups,omitempty" } },
            { no: 3, name: "Types", kind: "scalar", jsonName: "Types", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "types,omitempty" } },
            { no: 4, name: "Regions", kind: "scalar", jsonName: "Regions", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "regions,omitempty" } },
            { no: 5, name: "ResourceTags", kind: "message", jsonName: "ResourceTags", T: () => LabelValues, options: { "gogoproto.nullable": false, "gogoproto.customtype": "Labels", "gogoproto.jsontag": "tags,omitempty" } },
            { no: 6, name: "Params", kind: "message", jsonName: "Params", T: () => InstallerParams, options: { "gogoproto.jsontag": "install_params,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<AzureMatcher>): AzureMatcher {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subscriptions = [];
        message.resourceGroups = [];
        message.types = [];
        message.regions = [];
        if (value !== undefined)
            reflectionMergePartial<AzureMatcher>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AzureMatcher): AzureMatcher {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string Subscriptions = 1 [json_name = "Subscriptions"];*/ 1:
                    message.subscriptions.push(reader.string());
                    break;
                case /* repeated string ResourceGroups = 2 [json_name = "ResourceGroups"];*/ 2:
                    message.resourceGroups.push(reader.string());
                    break;
                case /* repeated string Types = 3 [json_name = "Types"];*/ 3:
                    message.types.push(reader.string());
                    break;
                case /* repeated string Regions = 4 [json_name = "Regions"];*/ 4:
                    message.regions.push(reader.string());
                    break;
                case /* wrappers.LabelValues ResourceTags = 5 [json_name = "ResourceTags"];*/ 5:
                    message.resourceTags = LabelValues.internalBinaryRead(reader, reader.uint32(), options, message.resourceTags);
                    break;
                case /* types.InstallerParams Params = 6 [json_name = "Params"];*/ 6:
                    message.params = InstallerParams.internalBinaryRead(reader, reader.uint32(), options, message.params);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AzureMatcher, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string Subscriptions = 1 [json_name = "Subscriptions"]; */
        for (let i = 0; i < message.subscriptions.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.subscriptions[i]);
        /* repeated string ResourceGroups = 2 [json_name = "ResourceGroups"]; */
        for (let i = 0; i < message.resourceGroups.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.resourceGroups[i]);
        /* repeated string Types = 3 [json_name = "Types"]; */
        for (let i = 0; i < message.types.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.types[i]);
        /* repeated string Regions = 4 [json_name = "Regions"]; */
        for (let i = 0; i < message.regions.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.regions[i]);
        /* wrappers.LabelValues ResourceTags = 5 [json_name = "ResourceTags"]; */
        if (message.resourceTags)
            LabelValues.internalBinaryWrite(message.resourceTags, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* types.InstallerParams Params = 6 [json_name = "Params"]; */
        if (message.params)
            InstallerParams.internalBinaryWrite(message.params, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AzureMatcher
 */
export const AzureMatcher = new AzureMatcher$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCPMatcher$Type extends MessageType<GCPMatcher> {
    constructor() {
        super("types.GCPMatcher", [
            { no: 1, name: "Types", kind: "scalar", jsonName: "Types", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "types,omitempty" } },
            { no: 2, name: "Locations", kind: "scalar", jsonName: "Locations", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "locations,omitempty" } },
            { no: 3, name: "Tags", kind: "message", jsonName: "Tags", T: () => LabelValues, options: { "gogoproto.nullable": false, "gogoproto.customtype": "Labels", "gogoproto.jsontag": "tags,omitempty" } },
            { no: 4, name: "ProjectIDs", kind: "scalar", jsonName: "ProjectIDs", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "project_ids,omitempty" } },
            { no: 5, name: "ServiceAccounts", kind: "scalar", jsonName: "ServiceAccounts", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "service_accounts,omitempty" } },
            { no: 6, name: "Params", kind: "message", jsonName: "Params", T: () => InstallerParams, options: { "gogoproto.jsontag": "install_params,omitempty" } },
            { no: 7, name: "Labels", kind: "message", jsonName: "Labels", T: () => LabelValues, options: { "gogoproto.nullable": false, "gogoproto.customtype": "Labels", "gogoproto.jsontag": "labels,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<GCPMatcher>): GCPMatcher {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.types = [];
        message.locations = [];
        message.projectIDs = [];
        message.serviceAccounts = [];
        if (value !== undefined)
            reflectionMergePartial<GCPMatcher>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCPMatcher): GCPMatcher {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string Types = 1 [json_name = "Types"];*/ 1:
                    message.types.push(reader.string());
                    break;
                case /* repeated string Locations = 2 [json_name = "Locations"];*/ 2:
                    message.locations.push(reader.string());
                    break;
                case /* wrappers.LabelValues Tags = 3 [json_name = "Tags"];*/ 3:
                    message.tags = LabelValues.internalBinaryRead(reader, reader.uint32(), options, message.tags);
                    break;
                case /* repeated string ProjectIDs = 4 [json_name = "ProjectIDs"];*/ 4:
                    message.projectIDs.push(reader.string());
                    break;
                case /* repeated string ServiceAccounts = 5 [json_name = "ServiceAccounts"];*/ 5:
                    message.serviceAccounts.push(reader.string());
                    break;
                case /* types.InstallerParams Params = 6 [json_name = "Params"];*/ 6:
                    message.params = InstallerParams.internalBinaryRead(reader, reader.uint32(), options, message.params);
                    break;
                case /* wrappers.LabelValues Labels = 7 [json_name = "Labels"];*/ 7:
                    message.labels = LabelValues.internalBinaryRead(reader, reader.uint32(), options, message.labels);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCPMatcher, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string Types = 1 [json_name = "Types"]; */
        for (let i = 0; i < message.types.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.types[i]);
        /* repeated string Locations = 2 [json_name = "Locations"]; */
        for (let i = 0; i < message.locations.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.locations[i]);
        /* wrappers.LabelValues Tags = 3 [json_name = "Tags"]; */
        if (message.tags)
            LabelValues.internalBinaryWrite(message.tags, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated string ProjectIDs = 4 [json_name = "ProjectIDs"]; */
        for (let i = 0; i < message.projectIDs.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.projectIDs[i]);
        /* repeated string ServiceAccounts = 5 [json_name = "ServiceAccounts"]; */
        for (let i = 0; i < message.serviceAccounts.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.serviceAccounts[i]);
        /* types.InstallerParams Params = 6 [json_name = "Params"]; */
        if (message.params)
            InstallerParams.internalBinaryWrite(message.params, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* wrappers.LabelValues Labels = 7 [json_name = "Labels"]; */
        if (message.labels)
            LabelValues.internalBinaryWrite(message.labels, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.GCPMatcher
 */
export const GCPMatcher = new GCPMatcher$Type();
// @generated message type with reflection information, may provide speed optimized methods
class KubernetesMatcher$Type extends MessageType<KubernetesMatcher> {
    constructor() {
        super("types.KubernetesMatcher", [
            { no: 1, name: "Types", kind: "scalar", jsonName: "Types", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "types,omitempty" } },
            { no: 2, name: "Namespaces", kind: "scalar", jsonName: "Namespaces", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "namespaces,omitempty" } },
            { no: 3, name: "Labels", kind: "message", jsonName: "Labels", T: () => LabelValues, options: { "gogoproto.nullable": false, "gogoproto.customtype": "Labels", "gogoproto.jsontag": "labels,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<KubernetesMatcher>): KubernetesMatcher {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.types = [];
        message.namespaces = [];
        if (value !== undefined)
            reflectionMergePartial<KubernetesMatcher>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KubernetesMatcher): KubernetesMatcher {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string Types = 1 [json_name = "Types"];*/ 1:
                    message.types.push(reader.string());
                    break;
                case /* repeated string Namespaces = 2 [json_name = "Namespaces"];*/ 2:
                    message.namespaces.push(reader.string());
                    break;
                case /* wrappers.LabelValues Labels = 3 [json_name = "Labels"];*/ 3:
                    message.labels = LabelValues.internalBinaryRead(reader, reader.uint32(), options, message.labels);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: KubernetesMatcher, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string Types = 1 [json_name = "Types"]; */
        for (let i = 0; i < message.types.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.types[i]);
        /* repeated string Namespaces = 2 [json_name = "Namespaces"]; */
        for (let i = 0; i < message.namespaces.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.namespaces[i]);
        /* wrappers.LabelValues Labels = 3 [json_name = "Labels"]; */
        if (message.labels)
            LabelValues.internalBinaryWrite(message.labels, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.KubernetesMatcher
 */
export const KubernetesMatcher = new KubernetesMatcher$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OktaOptions$Type extends MessageType<OktaOptions> {
    constructor() {
        super("types.OktaOptions", [
            { no: 1, name: "SyncPeriod", kind: "scalar", jsonName: "SyncPeriod", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.jsontag": "sync_period,omitempty", "gogoproto.casttype": "Duration" } }
        ]);
    }
    create(value?: PartialMessage<OktaOptions>): OktaOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.syncPeriod = 0n;
        if (value !== undefined)
            reflectionMergePartial<OktaOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OktaOptions): OktaOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 SyncPeriod = 1 [json_name = "SyncPeriod"];*/ 1:
                    message.syncPeriod = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OktaOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 SyncPeriod = 1 [json_name = "SyncPeriod"]; */
        if (message.syncPeriod !== 0n)
            writer.tag(1, WireType.Varint).int64(message.syncPeriod);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.OktaOptions
 */
export const OktaOptions = new OktaOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessGraphSync$Type extends MessageType<AccessGraphSync> {
    constructor() {
        super("types.AccessGraphSync", [
            { no: 1, name: "AWS", kind: "message", jsonName: "AWS", repeat: 1 /*RepeatType.PACKED*/, T: () => AccessGraphAWSSync, options: { "gogoproto.jsontag": "aws,omitempty" } },
            { no: 2, name: "PollInterval", kind: "message", jsonName: "PollInterval", T: () => Duration, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "poll_interval,omitempty", "gogoproto.stdduration": true } },
            { no: 3, name: "Azure", kind: "message", jsonName: "Azure", repeat: 1 /*RepeatType.PACKED*/, T: () => AccessGraphAzureSync, options: { "gogoproto.jsontag": "azure,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<AccessGraphSync>): AccessGraphSync {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.aWS = [];
        message.azure = [];
        if (value !== undefined)
            reflectionMergePartial<AccessGraphSync>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessGraphSync): AccessGraphSync {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.AccessGraphAWSSync AWS = 1 [json_name = "AWS"];*/ 1:
                    message.aWS.push(AccessGraphAWSSync.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.Duration PollInterval = 2 [json_name = "PollInterval"];*/ 2:
                    message.pollInterval = Duration.internalBinaryRead(reader, reader.uint32(), options, message.pollInterval);
                    break;
                case /* repeated types.AccessGraphAzureSync Azure = 3 [json_name = "Azure"];*/ 3:
                    message.azure.push(AccessGraphAzureSync.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessGraphSync, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.AccessGraphAWSSync AWS = 1 [json_name = "AWS"]; */
        for (let i = 0; i < message.aWS.length; i++)
            AccessGraphAWSSync.internalBinaryWrite(message.aWS[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration PollInterval = 2 [json_name = "PollInterval"]; */
        if (message.pollInterval)
            Duration.internalBinaryWrite(message.pollInterval, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated types.AccessGraphAzureSync Azure = 3 [json_name = "Azure"]; */
        for (let i = 0; i < message.azure.length; i++)
            AccessGraphAzureSync.internalBinaryWrite(message.azure[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AccessGraphSync
 */
export const AccessGraphSync = new AccessGraphSync$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessGraphAWSSyncCloudTrailLogs$Type extends MessageType<AccessGraphAWSSyncCloudTrailLogs> {
    constructor() {
        super("types.AccessGraphAWSSyncCloudTrailLogs", [
            { no: 1, name: "Region", kind: "scalar", jsonName: "Region", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "region,omitempty" } },
            { no: 2, name: "SQSQueue", kind: "scalar", jsonName: "SQSQueue", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "sqs_queue,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<AccessGraphAWSSyncCloudTrailLogs>): AccessGraphAWSSyncCloudTrailLogs {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.region = "";
        message.sQSQueue = "";
        if (value !== undefined)
            reflectionMergePartial<AccessGraphAWSSyncCloudTrailLogs>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessGraphAWSSyncCloudTrailLogs): AccessGraphAWSSyncCloudTrailLogs {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Region = 1 [json_name = "Region"];*/ 1:
                    message.region = reader.string();
                    break;
                case /* string SQSQueue = 2 [json_name = "SQSQueue"];*/ 2:
                    message.sQSQueue = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessGraphAWSSyncCloudTrailLogs, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Region = 1 [json_name = "Region"]; */
        if (message.region !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.region);
        /* string SQSQueue = 2 [json_name = "SQSQueue"]; */
        if (message.sQSQueue !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sQSQueue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AccessGraphAWSSyncCloudTrailLogs
 */
export const AccessGraphAWSSyncCloudTrailLogs = new AccessGraphAWSSyncCloudTrailLogs$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessGraphAWSSync$Type extends MessageType<AccessGraphAWSSync> {
    constructor() {
        super("types.AccessGraphAWSSync", [
            { no: 1, name: "Regions", kind: "scalar", jsonName: "Regions", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "regions,omitempty" } },
            { no: 3, name: "AssumeRole", kind: "message", jsonName: "AssumeRole", T: () => AssumeRole, options: { "gogoproto.jsontag": "assume_role,omitempty" } },
            { no: 4, name: "Integration", kind: "scalar", jsonName: "Integration", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "integration,omitempty" } },
            { no: 5, name: "cloud_trail_logs", kind: "message", T: () => AccessGraphAWSSyncCloudTrailLogs, options: { "gogoproto.jsontag": "cloud_trail_logs,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<AccessGraphAWSSync>): AccessGraphAWSSync {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.regions = [];
        message.integration = "";
        if (value !== undefined)
            reflectionMergePartial<AccessGraphAWSSync>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessGraphAWSSync): AccessGraphAWSSync {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string Regions = 1 [json_name = "Regions"];*/ 1:
                    message.regions.push(reader.string());
                    break;
                case /* types.AssumeRole AssumeRole = 3 [json_name = "AssumeRole"];*/ 3:
                    message.assumeRole = AssumeRole.internalBinaryRead(reader, reader.uint32(), options, message.assumeRole);
                    break;
                case /* string Integration = 4 [json_name = "Integration"];*/ 4:
                    message.integration = reader.string();
                    break;
                case /* types.AccessGraphAWSSyncCloudTrailLogs cloud_trail_logs */ 5:
                    message.cloudTrailLogs = AccessGraphAWSSyncCloudTrailLogs.internalBinaryRead(reader, reader.uint32(), options, message.cloudTrailLogs);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessGraphAWSSync, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string Regions = 1 [json_name = "Regions"]; */
        for (let i = 0; i < message.regions.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.regions[i]);
        /* types.AssumeRole AssumeRole = 3 [json_name = "AssumeRole"]; */
        if (message.assumeRole)
            AssumeRole.internalBinaryWrite(message.assumeRole, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string Integration = 4 [json_name = "Integration"]; */
        if (message.integration !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.integration);
        /* types.AccessGraphAWSSyncCloudTrailLogs cloud_trail_logs = 5; */
        if (message.cloudTrailLogs)
            AccessGraphAWSSyncCloudTrailLogs.internalBinaryWrite(message.cloudTrailLogs, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AccessGraphAWSSync
 */
export const AccessGraphAWSSync = new AccessGraphAWSSync$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessGraphAzureSync$Type extends MessageType<AccessGraphAzureSync> {
    constructor() {
        super("types.AccessGraphAzureSync", [
            { no: 1, name: "SubscriptionID", kind: "scalar", jsonName: "SubscriptionID", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "subscription_id,omitempty" } },
            { no: 2, name: "Integration", kind: "scalar", jsonName: "Integration", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "integration,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<AccessGraphAzureSync>): AccessGraphAzureSync {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subscriptionID = "";
        message.integration = "";
        if (value !== undefined)
            reflectionMergePartial<AccessGraphAzureSync>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessGraphAzureSync): AccessGraphAzureSync {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string SubscriptionID = 1 [json_name = "SubscriptionID"];*/ 1:
                    message.subscriptionID = reader.string();
                    break;
                case /* string Integration = 2 [json_name = "Integration"];*/ 2:
                    message.integration = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessGraphAzureSync, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string SubscriptionID = 1 [json_name = "SubscriptionID"]; */
        if (message.subscriptionID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subscriptionID);
        /* string Integration = 2 [json_name = "Integration"]; */
        if (message.integration !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.integration);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AccessGraphAzureSync
 */
export const AccessGraphAzureSync = new AccessGraphAzureSync$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TargetHealth$Type extends MessageType<TargetHealth> {
    constructor() {
        super("types.TargetHealth", [
            { no: 1, name: "Address", kind: "scalar", jsonName: "Address", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "address,omitempty" } },
            { no: 2, name: "Protocol", kind: "scalar", jsonName: "Protocol", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "protocol,omitempty" } },
            { no: 3, name: "Status", kind: "scalar", jsonName: "Status", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "status,omitempty" } },
            { no: 4, name: "TransitionTimestamp", kind: "message", jsonName: "TransitionTimestamp", T: () => Timestamp, options: { "gogoproto.nullable": true, "gogoproto.jsontag": "transition_timestamp,omitempty", "gogoproto.stdtime": true } },
            { no: 5, name: "TransitionReason", kind: "scalar", jsonName: "TransitionReason", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "transition_reason,omitempty" } },
            { no: 6, name: "TransitionError", kind: "scalar", jsonName: "TransitionError", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "transition_error,omitempty" } },
            { no: 7, name: "Message", kind: "scalar", jsonName: "Message", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "message,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<TargetHealth>): TargetHealth {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.address = "";
        message.protocol = "";
        message.status = "";
        message.transitionReason = "";
        message.transitionError = "";
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<TargetHealth>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TargetHealth): TargetHealth {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Address = 1 [json_name = "Address"];*/ 1:
                    message.address = reader.string();
                    break;
                case /* string Protocol = 2 [json_name = "Protocol"];*/ 2:
                    message.protocol = reader.string();
                    break;
                case /* string Status = 3 [json_name = "Status"];*/ 3:
                    message.status = reader.string();
                    break;
                case /* google.protobuf.Timestamp TransitionTimestamp = 4 [json_name = "TransitionTimestamp"];*/ 4:
                    message.transitionTimestamp = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.transitionTimestamp);
                    break;
                case /* string TransitionReason = 5 [json_name = "TransitionReason"];*/ 5:
                    message.transitionReason = reader.string();
                    break;
                case /* string TransitionError = 6 [json_name = "TransitionError"];*/ 6:
                    message.transitionError = reader.string();
                    break;
                case /* string Message = 7 [json_name = "Message"];*/ 7:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TargetHealth, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Address = 1 [json_name = "Address"]; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        /* string Protocol = 2 [json_name = "Protocol"]; */
        if (message.protocol !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.protocol);
        /* string Status = 3 [json_name = "Status"]; */
        if (message.status !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.status);
        /* google.protobuf.Timestamp TransitionTimestamp = 4 [json_name = "TransitionTimestamp"]; */
        if (message.transitionTimestamp)
            Timestamp.internalBinaryWrite(message.transitionTimestamp, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string TransitionReason = 5 [json_name = "TransitionReason"]; */
        if (message.transitionReason !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.transitionReason);
        /* string TransitionError = 6 [json_name = "TransitionError"]; */
        if (message.transitionError !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.transitionError);
        /* string Message = 7 [json_name = "Message"]; */
        if (message.message !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.TargetHealth
 */
export const TargetHealth = new TargetHealth$Type();
