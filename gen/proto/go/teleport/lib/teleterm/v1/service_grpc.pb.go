//
// Teleport
// Copyright (C) 2023  Gravitational, Inc.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: teleport/lib/teleterm/v1/service.proto

package teletermv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	TerminalService_UpdateTshdEventsServerAddress_FullMethodName       = "/teleport.lib.teleterm.v1.TerminalService/UpdateTshdEventsServerAddress"
	TerminalService_ListRootClusters_FullMethodName                    = "/teleport.lib.teleterm.v1.TerminalService/ListRootClusters"
	TerminalService_ListLeafClusters_FullMethodName                    = "/teleport.lib.teleterm.v1.TerminalService/ListLeafClusters"
	TerminalService_StartHeadlessWatcher_FullMethodName                = "/teleport.lib.teleterm.v1.TerminalService/StartHeadlessWatcher"
	TerminalService_ListDatabaseUsers_FullMethodName                   = "/teleport.lib.teleterm.v1.TerminalService/ListDatabaseUsers"
	TerminalService_ListDatabaseServers_FullMethodName                 = "/teleport.lib.teleterm.v1.TerminalService/ListDatabaseServers"
	TerminalService_GetAccessRequests_FullMethodName                   = "/teleport.lib.teleterm.v1.TerminalService/GetAccessRequests"
	TerminalService_GetAccessRequest_FullMethodName                    = "/teleport.lib.teleterm.v1.TerminalService/GetAccessRequest"
	TerminalService_DeleteAccessRequest_FullMethodName                 = "/teleport.lib.teleterm.v1.TerminalService/DeleteAccessRequest"
	TerminalService_CreateAccessRequest_FullMethodName                 = "/teleport.lib.teleterm.v1.TerminalService/CreateAccessRequest"
	TerminalService_ReviewAccessRequest_FullMethodName                 = "/teleport.lib.teleterm.v1.TerminalService/ReviewAccessRequest"
	TerminalService_GetRequestableRoles_FullMethodName                 = "/teleport.lib.teleterm.v1.TerminalService/GetRequestableRoles"
	TerminalService_AssumeRole_FullMethodName                          = "/teleport.lib.teleterm.v1.TerminalService/AssumeRole"
	TerminalService_PromoteAccessRequest_FullMethodName                = "/teleport.lib.teleterm.v1.TerminalService/PromoteAccessRequest"
	TerminalService_GetSuggestedAccessLists_FullMethodName             = "/teleport.lib.teleterm.v1.TerminalService/GetSuggestedAccessLists"
	TerminalService_ListKubernetesResources_FullMethodName             = "/teleport.lib.teleterm.v1.TerminalService/ListKubernetesResources"
	TerminalService_AddCluster_FullMethodName                          = "/teleport.lib.teleterm.v1.TerminalService/AddCluster"
	TerminalService_RemoveCluster_FullMethodName                       = "/teleport.lib.teleterm.v1.TerminalService/RemoveCluster"
	TerminalService_ListGateways_FullMethodName                        = "/teleport.lib.teleterm.v1.TerminalService/ListGateways"
	TerminalService_CreateGateway_FullMethodName                       = "/teleport.lib.teleterm.v1.TerminalService/CreateGateway"
	TerminalService_RemoveGateway_FullMethodName                       = "/teleport.lib.teleterm.v1.TerminalService/RemoveGateway"
	TerminalService_SetGatewayTargetSubresourceName_FullMethodName     = "/teleport.lib.teleterm.v1.TerminalService/SetGatewayTargetSubresourceName"
	TerminalService_SetGatewayLocalPort_FullMethodName                 = "/teleport.lib.teleterm.v1.TerminalService/SetGatewayLocalPort"
	TerminalService_GetAuthSettings_FullMethodName                     = "/teleport.lib.teleterm.v1.TerminalService/GetAuthSettings"
	TerminalService_GetCluster_FullMethodName                          = "/teleport.lib.teleterm.v1.TerminalService/GetCluster"
	TerminalService_Login_FullMethodName                               = "/teleport.lib.teleterm.v1.TerminalService/Login"
	TerminalService_LoginPasswordless_FullMethodName                   = "/teleport.lib.teleterm.v1.TerminalService/LoginPasswordless"
	TerminalService_Logout_FullMethodName                              = "/teleport.lib.teleterm.v1.TerminalService/Logout"
	TerminalService_TransferFile_FullMethodName                        = "/teleport.lib.teleterm.v1.TerminalService/TransferFile"
	TerminalService_ReportUsageEvent_FullMethodName                    = "/teleport.lib.teleterm.v1.TerminalService/ReportUsageEvent"
	TerminalService_UpdateHeadlessAuthenticationState_FullMethodName   = "/teleport.lib.teleterm.v1.TerminalService/UpdateHeadlessAuthenticationState"
	TerminalService_CreateConnectMyComputerRole_FullMethodName         = "/teleport.lib.teleterm.v1.TerminalService/CreateConnectMyComputerRole"
	TerminalService_CreateConnectMyComputerNodeToken_FullMethodName    = "/teleport.lib.teleterm.v1.TerminalService/CreateConnectMyComputerNodeToken"
	TerminalService_WaitForConnectMyComputerNodeJoin_FullMethodName    = "/teleport.lib.teleterm.v1.TerminalService/WaitForConnectMyComputerNodeJoin"
	TerminalService_DeleteConnectMyComputerNode_FullMethodName         = "/teleport.lib.teleterm.v1.TerminalService/DeleteConnectMyComputerNode"
	TerminalService_GetConnectMyComputerNodeName_FullMethodName        = "/teleport.lib.teleterm.v1.TerminalService/GetConnectMyComputerNodeName"
	TerminalService_ListUnifiedResources_FullMethodName                = "/teleport.lib.teleterm.v1.TerminalService/ListUnifiedResources"
	TerminalService_GetUserPreferences_FullMethodName                  = "/teleport.lib.teleterm.v1.TerminalService/GetUserPreferences"
	TerminalService_UpdateUserPreferences_FullMethodName               = "/teleport.lib.teleterm.v1.TerminalService/UpdateUserPreferences"
	TerminalService_AuthenticateWebDevice_FullMethodName               = "/teleport.lib.teleterm.v1.TerminalService/AuthenticateWebDevice"
	TerminalService_GetApp_FullMethodName                              = "/teleport.lib.teleterm.v1.TerminalService/GetApp"
	TerminalService_ConnectToDesktop_FullMethodName                    = "/teleport.lib.teleterm.v1.TerminalService/ConnectToDesktop"
	TerminalService_SetSharedDirectoryForDesktopSession_FullMethodName = "/teleport.lib.teleterm.v1.TerminalService/SetSharedDirectoryForDesktopSession"
)

// TerminalServiceClient is the client API for TerminalService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// TerminalService is used by the Electron app to communicate with the tsh daemon.
//
// While we aim to preserve backwards compatibility in order to satisfy CI checks and follow the
// proto practices used within the company, this service is not guaranteed to be stable across
// versions. The packaging process of Teleport Connect ensures that the server and the client use
// the same version of the service.
type TerminalServiceClient interface {
	// UpdateTshdEventsServerAddress lets the Electron app update the address the tsh daemon is
	// supposed to use when connecting to the tshd events gRPC service. This RPC needs to be made
	// before any other from this service.
	//
	// The service is supposed to return a response from this call only after the client is ready.
	UpdateTshdEventsServerAddress(ctx context.Context, in *UpdateTshdEventsServerAddressRequest, opts ...grpc.CallOption) (*UpdateTshdEventsServerAddressResponse, error)
	// ListRootClusters lists root clusters
	// Does not include detailed cluster information that would require a network request.
	ListRootClusters(ctx context.Context, in *ListClustersRequest, opts ...grpc.CallOption) (*ListClustersResponse, error)
	// ListLeafClusters lists leaf clusters
	// Does not include detailed cluster information that would require a network request.
	ListLeafClusters(ctx context.Context, in *ListLeafClustersRequest, opts ...grpc.CallOption) (*ListClustersResponse, error)
	// StartHeadlessWatcher starts a headless watcher.
	// If the watcher is already running, it is restarted.
	StartHeadlessWatcher(ctx context.Context, in *StartHeadlessWatcherRequest, opts ...grpc.CallOption) (*StartHeadlessWatcherResponse, error)
	// ListDatabaseUsers lists allowed users for the given database based on the role set.
	ListDatabaseUsers(ctx context.Context, in *ListDatabaseUsersRequest, opts ...grpc.CallOption) (*ListDatabaseUsersResponse, error)
	// ListDatabaseServers lists allowed users for the given database based on the role set.
	ListDatabaseServers(ctx context.Context, in *ListDatabaseServersRequest, opts ...grpc.CallOption) (*ListDatabaseServersResponse, error)
	// GetAccessRequests lists filtered AccessRequests
	GetAccessRequests(ctx context.Context, in *GetAccessRequestsRequest, opts ...grpc.CallOption) (*GetAccessRequestsResponse, error)
	// GetAccessRequest retreives a single Access Request
	GetAccessRequest(ctx context.Context, in *GetAccessRequestRequest, opts ...grpc.CallOption) (*GetAccessRequestResponse, error)
	// DeleteAccessRequest deletes the access request by id
	DeleteAccessRequest(ctx context.Context, in *DeleteAccessRequestRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// CreateAccessRequest creates an access request
	CreateAccessRequest(ctx context.Context, in *CreateAccessRequestRequest, opts ...grpc.CallOption) (*CreateAccessRequestResponse, error)
	// ReviewAccessRequest submits a review for an Access Request
	ReviewAccessRequest(ctx context.Context, in *ReviewAccessRequestRequest, opts ...grpc.CallOption) (*ReviewAccessRequestResponse, error)
	// GetRequestableRoles gets all requestable roles
	GetRequestableRoles(ctx context.Context, in *GetRequestableRolesRequest, opts ...grpc.CallOption) (*GetRequestableRolesResponse, error)
	// AssumeRole assumes the role of the given access request
	AssumeRole(ctx context.Context, in *AssumeRoleRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// PromoteAccessRequest promotes an access request to an access list.
	PromoteAccessRequest(ctx context.Context, in *PromoteAccessRequestRequest, opts ...grpc.CallOption) (*PromoteAccessRequestResponse, error)
	// GetSuggestedAccessLists returns suggested access lists for an access request.
	GetSuggestedAccessLists(ctx context.Context, in *GetSuggestedAccessListsRequest, opts ...grpc.CallOption) (*GetSuggestedAccessListsResponse, error)
	// ListKubernetesResourcesRequest defines a request to retrieve kube resources paginated.
	// Only one type of kube resource can be retrieved per request (eg: namespace, pods, secrets, etc.)
	ListKubernetesResources(ctx context.Context, in *ListKubernetesResourcesRequest, opts ...grpc.CallOption) (*ListKubernetesResourcesResponse, error)
	// AddCluster adds a cluster to profile
	AddCluster(ctx context.Context, in *AddClusterRequest, opts ...grpc.CallOption) (*Cluster, error)
	// RemoveCluster removes a cluster from profile
	RemoveCluster(ctx context.Context, in *RemoveClusterRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// ListGateways lists gateways
	ListGateways(ctx context.Context, in *ListGatewaysRequest, opts ...grpc.CallOption) (*ListGatewaysResponse, error)
	// CreateGateway creates a gateway
	CreateGateway(ctx context.Context, in *CreateGatewayRequest, opts ...grpc.CallOption) (*Gateway, error)
	// RemoveGateway removes a gateway
	RemoveGateway(ctx context.Context, in *RemoveGatewayRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// SetGatewayTargetSubresourceName changes the TargetSubresourceName field of gateway.Gateway
	// and returns the updated version of gateway.Gateway.
	//
	// In Connect this is used to update the db name of a db connection along with the CLI command.
	SetGatewayTargetSubresourceName(ctx context.Context, in *SetGatewayTargetSubresourceNameRequest, opts ...grpc.CallOption) (*Gateway, error)
	// SetGatewayLocalPort starts a new gateway on the new port, stops the old gateway and then
	// assigns the URI of the old gateway to the new one. It does so without fetching a new db cert.
	SetGatewayLocalPort(ctx context.Context, in *SetGatewayLocalPortRequest, opts ...grpc.CallOption) (*Gateway, error)
	// GetAuthSettings returns cluster auth settigns
	GetAuthSettings(ctx context.Context, in *GetAuthSettingsRequest, opts ...grpc.CallOption) (*AuthSettings, error)
	// GetCluster returns cluster. Makes a network request and includes detailed
	// information about enterprise features availabed on the connected auth server
	GetCluster(ctx context.Context, in *GetClusterRequest, opts ...grpc.CallOption) (*Cluster, error)
	// Login logs in a user to a cluster
	Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// LoginPasswordless logs in a user to a cluster passwordlessly.
	//
	// The RPC is streaming both ways and the message sequence example for hardware keys are:
	// (-> means client-to-server, <- means server-to-client)
	//
	// Hardware keys:
	// -> Init
	// <- Send PasswordlessPrompt enum TAP to choose a device
	// -> Receive TAP device response
	// <- Send PasswordlessPrompt enum PIN
	// -> Receive PIN response
	// <- Send PasswordlessPrompt enum RETAP to confirm
	// -> Receive RETAP device response
	// <- Send list of credentials (e.g. usernames) associated with device
	// -> Receive the index number associated with the selected credential in list
	// <- End
	LoginPasswordless(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[LoginPasswordlessRequest, LoginPasswordlessResponse], error)
	// ClusterLogin logs out a user from cluster
	Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// TransferFile sends a request to download/upload a file
	TransferFile(ctx context.Context, in *FileTransferRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[FileTransferProgress], error)
	// ReportUsageEvent allows to send usage events that are then anonymized and forwarded to prehog
	ReportUsageEvent(ctx context.Context, in *ReportUsageEventRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// UpdateHeadlessAuthenticationState updates a headless authentication resource's state.
	// An MFA challenge will be prompted when approving a headless authentication.
	UpdateHeadlessAuthenticationState(ctx context.Context, in *UpdateHeadlessAuthenticationStateRequest, opts ...grpc.CallOption) (*UpdateHeadlessAuthenticationStateResponse, error)
	// CreateConnectMyComputerRole creates a role which allows access to nodes with the label
	// teleport.dev/connect-my-computer/owner: <cluster user> and allows logging in to those nodes as
	// the current system user.
	CreateConnectMyComputerRole(ctx context.Context, in *CreateConnectMyComputerRoleRequest, opts ...grpc.CallOption) (*CreateConnectMyComputerRoleResponse, error)
	// CreateConnectMyComputerNodeToken creates a node join token that is valid for 5 minutes
	CreateConnectMyComputerNodeToken(ctx context.Context, in *CreateConnectMyComputerNodeTokenRequest, opts ...grpc.CallOption) (*CreateConnectMyComputerNodeTokenResponse, error)
	// WaitForConnectMyComputerNodeJoin sets up a watcher and returns a response only after detecting
	// that the Connect My Computer node for the particular cluster has joined the cluster (the
	// OpPut event).
	//
	// This RPC times out by itself after a minute to prevent the request from hanging forever, in
	// case the client didn't set a deadline or doesn't abort the request.
	WaitForConnectMyComputerNodeJoin(ctx context.Context, in *WaitForConnectMyComputerNodeJoinRequest, opts ...grpc.CallOption) (*WaitForConnectMyComputerNodeJoinResponse, error)
	// DeleteConnectMyComputerNode deletes the Connect My Computer node.
	DeleteConnectMyComputerNode(ctx context.Context, in *DeleteConnectMyComputerNodeRequest, opts ...grpc.CallOption) (*DeleteConnectMyComputerNodeResponse, error)
	// GetConnectMyComputerNodeName reads the Connect My Computer node name (UUID) from a disk.
	GetConnectMyComputerNodeName(ctx context.Context, in *GetConnectMyComputerNodeNameRequest, opts ...grpc.CallOption) (*GetConnectMyComputerNodeNameResponse, error)
	// ListUnifiedResources retrieves a paginated list of all resource types displayable in the UI.
	ListUnifiedResources(ctx context.Context, in *ListUnifiedResourcesRequest, opts ...grpc.CallOption) (*ListUnifiedResourcesResponse, error)
	// GetUserPreferences returns the combined (root + leaf cluster) preferences for a given user.
	GetUserPreferences(ctx context.Context, in *GetUserPreferencesRequest, opts ...grpc.CallOption) (*GetUserPreferencesResponse, error)
	// UpdateUserPreferences updates the preferences for a given user in appropriate root and leaf clusters.
	// Only the properties that are set (cluster_preferences, unified_resource_preferences) will be updated.
	UpdateUserPreferences(ctx context.Context, in *UpdateUserPreferencesRequest, opts ...grpc.CallOption) (*UpdateUserPreferencesResponse, error)
	// AuthenticateWebDevice blesses a web session with device trust by performing
	// the on-behalf-of device authentication ceremony.
	//
	// See
	// https://github.com/gravitational/teleport.e/blob/master/rfd/0009e-device-trust-web-support.md#device-web-authentication.
	AuthenticateWebDevice(ctx context.Context, in *AuthenticateWebDeviceRequest, opts ...grpc.CallOption) (*AuthenticateWebDeviceResponse, error)
	// GetApp returns details of an app resource. It does not include information about AWS roles and
	// FQDN.
	GetApp(ctx context.Context, in *GetAppRequest, opts ...grpc.CallOption) (*GetAppResponse, error)
	// ConnectToDesktop is a bidirectional stream for the desktop connection.
	ConnectToDesktop(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ConnectToDesktopRequest, ConnectToDesktopResponse], error)
	// SetSharedDirectoryForDesktopSession opens a directory for a desktop session and enables file system operations for it.
	// If there is no active desktop session associated with the specified desktop_uri and login,
	// the RPC returns an error.
	//
	// This RPC does not automatically share the directory with the server (it does not send a SharedDirectoryAnnounce message).
	// It only registers file system handlers for processing file system-related TDP events.
	SetSharedDirectoryForDesktopSession(ctx context.Context, in *SetSharedDirectoryForDesktopSessionRequest, opts ...grpc.CallOption) (*SetSharedDirectoryForDesktopSessionResponse, error)
}

type terminalServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTerminalServiceClient(cc grpc.ClientConnInterface) TerminalServiceClient {
	return &terminalServiceClient{cc}
}

func (c *terminalServiceClient) UpdateTshdEventsServerAddress(ctx context.Context, in *UpdateTshdEventsServerAddressRequest, opts ...grpc.CallOption) (*UpdateTshdEventsServerAddressResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateTshdEventsServerAddressResponse)
	err := c.cc.Invoke(ctx, TerminalService_UpdateTshdEventsServerAddress_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) ListRootClusters(ctx context.Context, in *ListClustersRequest, opts ...grpc.CallOption) (*ListClustersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListClustersResponse)
	err := c.cc.Invoke(ctx, TerminalService_ListRootClusters_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) ListLeafClusters(ctx context.Context, in *ListLeafClustersRequest, opts ...grpc.CallOption) (*ListClustersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListClustersResponse)
	err := c.cc.Invoke(ctx, TerminalService_ListLeafClusters_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) StartHeadlessWatcher(ctx context.Context, in *StartHeadlessWatcherRequest, opts ...grpc.CallOption) (*StartHeadlessWatcherResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartHeadlessWatcherResponse)
	err := c.cc.Invoke(ctx, TerminalService_StartHeadlessWatcher_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) ListDatabaseUsers(ctx context.Context, in *ListDatabaseUsersRequest, opts ...grpc.CallOption) (*ListDatabaseUsersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListDatabaseUsersResponse)
	err := c.cc.Invoke(ctx, TerminalService_ListDatabaseUsers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) ListDatabaseServers(ctx context.Context, in *ListDatabaseServersRequest, opts ...grpc.CallOption) (*ListDatabaseServersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListDatabaseServersResponse)
	err := c.cc.Invoke(ctx, TerminalService_ListDatabaseServers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) GetAccessRequests(ctx context.Context, in *GetAccessRequestsRequest, opts ...grpc.CallOption) (*GetAccessRequestsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAccessRequestsResponse)
	err := c.cc.Invoke(ctx, TerminalService_GetAccessRequests_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) GetAccessRequest(ctx context.Context, in *GetAccessRequestRequest, opts ...grpc.CallOption) (*GetAccessRequestResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAccessRequestResponse)
	err := c.cc.Invoke(ctx, TerminalService_GetAccessRequest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) DeleteAccessRequest(ctx context.Context, in *DeleteAccessRequestRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, TerminalService_DeleteAccessRequest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) CreateAccessRequest(ctx context.Context, in *CreateAccessRequestRequest, opts ...grpc.CallOption) (*CreateAccessRequestResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateAccessRequestResponse)
	err := c.cc.Invoke(ctx, TerminalService_CreateAccessRequest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) ReviewAccessRequest(ctx context.Context, in *ReviewAccessRequestRequest, opts ...grpc.CallOption) (*ReviewAccessRequestResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReviewAccessRequestResponse)
	err := c.cc.Invoke(ctx, TerminalService_ReviewAccessRequest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) GetRequestableRoles(ctx context.Context, in *GetRequestableRolesRequest, opts ...grpc.CallOption) (*GetRequestableRolesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRequestableRolesResponse)
	err := c.cc.Invoke(ctx, TerminalService_GetRequestableRoles_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) AssumeRole(ctx context.Context, in *AssumeRoleRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, TerminalService_AssumeRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) PromoteAccessRequest(ctx context.Context, in *PromoteAccessRequestRequest, opts ...grpc.CallOption) (*PromoteAccessRequestResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PromoteAccessRequestResponse)
	err := c.cc.Invoke(ctx, TerminalService_PromoteAccessRequest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) GetSuggestedAccessLists(ctx context.Context, in *GetSuggestedAccessListsRequest, opts ...grpc.CallOption) (*GetSuggestedAccessListsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSuggestedAccessListsResponse)
	err := c.cc.Invoke(ctx, TerminalService_GetSuggestedAccessLists_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) ListKubernetesResources(ctx context.Context, in *ListKubernetesResourcesRequest, opts ...grpc.CallOption) (*ListKubernetesResourcesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListKubernetesResourcesResponse)
	err := c.cc.Invoke(ctx, TerminalService_ListKubernetesResources_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) AddCluster(ctx context.Context, in *AddClusterRequest, opts ...grpc.CallOption) (*Cluster, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Cluster)
	err := c.cc.Invoke(ctx, TerminalService_AddCluster_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) RemoveCluster(ctx context.Context, in *RemoveClusterRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, TerminalService_RemoveCluster_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) ListGateways(ctx context.Context, in *ListGatewaysRequest, opts ...grpc.CallOption) (*ListGatewaysResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListGatewaysResponse)
	err := c.cc.Invoke(ctx, TerminalService_ListGateways_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) CreateGateway(ctx context.Context, in *CreateGatewayRequest, opts ...grpc.CallOption) (*Gateway, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Gateway)
	err := c.cc.Invoke(ctx, TerminalService_CreateGateway_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) RemoveGateway(ctx context.Context, in *RemoveGatewayRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, TerminalService_RemoveGateway_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) SetGatewayTargetSubresourceName(ctx context.Context, in *SetGatewayTargetSubresourceNameRequest, opts ...grpc.CallOption) (*Gateway, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Gateway)
	err := c.cc.Invoke(ctx, TerminalService_SetGatewayTargetSubresourceName_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) SetGatewayLocalPort(ctx context.Context, in *SetGatewayLocalPortRequest, opts ...grpc.CallOption) (*Gateway, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Gateway)
	err := c.cc.Invoke(ctx, TerminalService_SetGatewayLocalPort_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) GetAuthSettings(ctx context.Context, in *GetAuthSettingsRequest, opts ...grpc.CallOption) (*AuthSettings, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AuthSettings)
	err := c.cc.Invoke(ctx, TerminalService_GetAuthSettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) GetCluster(ctx context.Context, in *GetClusterRequest, opts ...grpc.CallOption) (*Cluster, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Cluster)
	err := c.cc.Invoke(ctx, TerminalService_GetCluster_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, TerminalService_Login_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) LoginPasswordless(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[LoginPasswordlessRequest, LoginPasswordlessResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &TerminalService_ServiceDesc.Streams[0], TerminalService_LoginPasswordless_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[LoginPasswordlessRequest, LoginPasswordlessResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type TerminalService_LoginPasswordlessClient = grpc.BidiStreamingClient[LoginPasswordlessRequest, LoginPasswordlessResponse]

func (c *terminalServiceClient) Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, TerminalService_Logout_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) TransferFile(ctx context.Context, in *FileTransferRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[FileTransferProgress], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &TerminalService_ServiceDesc.Streams[1], TerminalService_TransferFile_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[FileTransferRequest, FileTransferProgress]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type TerminalService_TransferFileClient = grpc.ServerStreamingClient[FileTransferProgress]

func (c *terminalServiceClient) ReportUsageEvent(ctx context.Context, in *ReportUsageEventRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, TerminalService_ReportUsageEvent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) UpdateHeadlessAuthenticationState(ctx context.Context, in *UpdateHeadlessAuthenticationStateRequest, opts ...grpc.CallOption) (*UpdateHeadlessAuthenticationStateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateHeadlessAuthenticationStateResponse)
	err := c.cc.Invoke(ctx, TerminalService_UpdateHeadlessAuthenticationState_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) CreateConnectMyComputerRole(ctx context.Context, in *CreateConnectMyComputerRoleRequest, opts ...grpc.CallOption) (*CreateConnectMyComputerRoleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateConnectMyComputerRoleResponse)
	err := c.cc.Invoke(ctx, TerminalService_CreateConnectMyComputerRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) CreateConnectMyComputerNodeToken(ctx context.Context, in *CreateConnectMyComputerNodeTokenRequest, opts ...grpc.CallOption) (*CreateConnectMyComputerNodeTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateConnectMyComputerNodeTokenResponse)
	err := c.cc.Invoke(ctx, TerminalService_CreateConnectMyComputerNodeToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) WaitForConnectMyComputerNodeJoin(ctx context.Context, in *WaitForConnectMyComputerNodeJoinRequest, opts ...grpc.CallOption) (*WaitForConnectMyComputerNodeJoinResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WaitForConnectMyComputerNodeJoinResponse)
	err := c.cc.Invoke(ctx, TerminalService_WaitForConnectMyComputerNodeJoin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) DeleteConnectMyComputerNode(ctx context.Context, in *DeleteConnectMyComputerNodeRequest, opts ...grpc.CallOption) (*DeleteConnectMyComputerNodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteConnectMyComputerNodeResponse)
	err := c.cc.Invoke(ctx, TerminalService_DeleteConnectMyComputerNode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) GetConnectMyComputerNodeName(ctx context.Context, in *GetConnectMyComputerNodeNameRequest, opts ...grpc.CallOption) (*GetConnectMyComputerNodeNameResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetConnectMyComputerNodeNameResponse)
	err := c.cc.Invoke(ctx, TerminalService_GetConnectMyComputerNodeName_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) ListUnifiedResources(ctx context.Context, in *ListUnifiedResourcesRequest, opts ...grpc.CallOption) (*ListUnifiedResourcesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListUnifiedResourcesResponse)
	err := c.cc.Invoke(ctx, TerminalService_ListUnifiedResources_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) GetUserPreferences(ctx context.Context, in *GetUserPreferencesRequest, opts ...grpc.CallOption) (*GetUserPreferencesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserPreferencesResponse)
	err := c.cc.Invoke(ctx, TerminalService_GetUserPreferences_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) UpdateUserPreferences(ctx context.Context, in *UpdateUserPreferencesRequest, opts ...grpc.CallOption) (*UpdateUserPreferencesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateUserPreferencesResponse)
	err := c.cc.Invoke(ctx, TerminalService_UpdateUserPreferences_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) AuthenticateWebDevice(ctx context.Context, in *AuthenticateWebDeviceRequest, opts ...grpc.CallOption) (*AuthenticateWebDeviceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AuthenticateWebDeviceResponse)
	err := c.cc.Invoke(ctx, TerminalService_AuthenticateWebDevice_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) GetApp(ctx context.Context, in *GetAppRequest, opts ...grpc.CallOption) (*GetAppResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAppResponse)
	err := c.cc.Invoke(ctx, TerminalService_GetApp_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) ConnectToDesktop(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ConnectToDesktopRequest, ConnectToDesktopResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &TerminalService_ServiceDesc.Streams[2], TerminalService_ConnectToDesktop_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ConnectToDesktopRequest, ConnectToDesktopResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type TerminalService_ConnectToDesktopClient = grpc.BidiStreamingClient[ConnectToDesktopRequest, ConnectToDesktopResponse]

func (c *terminalServiceClient) SetSharedDirectoryForDesktopSession(ctx context.Context, in *SetSharedDirectoryForDesktopSessionRequest, opts ...grpc.CallOption) (*SetSharedDirectoryForDesktopSessionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetSharedDirectoryForDesktopSessionResponse)
	err := c.cc.Invoke(ctx, TerminalService_SetSharedDirectoryForDesktopSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TerminalServiceServer is the server API for TerminalService service.
// All implementations must embed UnimplementedTerminalServiceServer
// for forward compatibility.
//
// TerminalService is used by the Electron app to communicate with the tsh daemon.
//
// While we aim to preserve backwards compatibility in order to satisfy CI checks and follow the
// proto practices used within the company, this service is not guaranteed to be stable across
// versions. The packaging process of Teleport Connect ensures that the server and the client use
// the same version of the service.
type TerminalServiceServer interface {
	// UpdateTshdEventsServerAddress lets the Electron app update the address the tsh daemon is
	// supposed to use when connecting to the tshd events gRPC service. This RPC needs to be made
	// before any other from this service.
	//
	// The service is supposed to return a response from this call only after the client is ready.
	UpdateTshdEventsServerAddress(context.Context, *UpdateTshdEventsServerAddressRequest) (*UpdateTshdEventsServerAddressResponse, error)
	// ListRootClusters lists root clusters
	// Does not include detailed cluster information that would require a network request.
	ListRootClusters(context.Context, *ListClustersRequest) (*ListClustersResponse, error)
	// ListLeafClusters lists leaf clusters
	// Does not include detailed cluster information that would require a network request.
	ListLeafClusters(context.Context, *ListLeafClustersRequest) (*ListClustersResponse, error)
	// StartHeadlessWatcher starts a headless watcher.
	// If the watcher is already running, it is restarted.
	StartHeadlessWatcher(context.Context, *StartHeadlessWatcherRequest) (*StartHeadlessWatcherResponse, error)
	// ListDatabaseUsers lists allowed users for the given database based on the role set.
	ListDatabaseUsers(context.Context, *ListDatabaseUsersRequest) (*ListDatabaseUsersResponse, error)
	// ListDatabaseServers lists allowed users for the given database based on the role set.
	ListDatabaseServers(context.Context, *ListDatabaseServersRequest) (*ListDatabaseServersResponse, error)
	// GetAccessRequests lists filtered AccessRequests
	GetAccessRequests(context.Context, *GetAccessRequestsRequest) (*GetAccessRequestsResponse, error)
	// GetAccessRequest retreives a single Access Request
	GetAccessRequest(context.Context, *GetAccessRequestRequest) (*GetAccessRequestResponse, error)
	// DeleteAccessRequest deletes the access request by id
	DeleteAccessRequest(context.Context, *DeleteAccessRequestRequest) (*EmptyResponse, error)
	// CreateAccessRequest creates an access request
	CreateAccessRequest(context.Context, *CreateAccessRequestRequest) (*CreateAccessRequestResponse, error)
	// ReviewAccessRequest submits a review for an Access Request
	ReviewAccessRequest(context.Context, *ReviewAccessRequestRequest) (*ReviewAccessRequestResponse, error)
	// GetRequestableRoles gets all requestable roles
	GetRequestableRoles(context.Context, *GetRequestableRolesRequest) (*GetRequestableRolesResponse, error)
	// AssumeRole assumes the role of the given access request
	AssumeRole(context.Context, *AssumeRoleRequest) (*EmptyResponse, error)
	// PromoteAccessRequest promotes an access request to an access list.
	PromoteAccessRequest(context.Context, *PromoteAccessRequestRequest) (*PromoteAccessRequestResponse, error)
	// GetSuggestedAccessLists returns suggested access lists for an access request.
	GetSuggestedAccessLists(context.Context, *GetSuggestedAccessListsRequest) (*GetSuggestedAccessListsResponse, error)
	// ListKubernetesResourcesRequest defines a request to retrieve kube resources paginated.
	// Only one type of kube resource can be retrieved per request (eg: namespace, pods, secrets, etc.)
	ListKubernetesResources(context.Context, *ListKubernetesResourcesRequest) (*ListKubernetesResourcesResponse, error)
	// AddCluster adds a cluster to profile
	AddCluster(context.Context, *AddClusterRequest) (*Cluster, error)
	// RemoveCluster removes a cluster from profile
	RemoveCluster(context.Context, *RemoveClusterRequest) (*EmptyResponse, error)
	// ListGateways lists gateways
	ListGateways(context.Context, *ListGatewaysRequest) (*ListGatewaysResponse, error)
	// CreateGateway creates a gateway
	CreateGateway(context.Context, *CreateGatewayRequest) (*Gateway, error)
	// RemoveGateway removes a gateway
	RemoveGateway(context.Context, *RemoveGatewayRequest) (*EmptyResponse, error)
	// SetGatewayTargetSubresourceName changes the TargetSubresourceName field of gateway.Gateway
	// and returns the updated version of gateway.Gateway.
	//
	// In Connect this is used to update the db name of a db connection along with the CLI command.
	SetGatewayTargetSubresourceName(context.Context, *SetGatewayTargetSubresourceNameRequest) (*Gateway, error)
	// SetGatewayLocalPort starts a new gateway on the new port, stops the old gateway and then
	// assigns the URI of the old gateway to the new one. It does so without fetching a new db cert.
	SetGatewayLocalPort(context.Context, *SetGatewayLocalPortRequest) (*Gateway, error)
	// GetAuthSettings returns cluster auth settigns
	GetAuthSettings(context.Context, *GetAuthSettingsRequest) (*AuthSettings, error)
	// GetCluster returns cluster. Makes a network request and includes detailed
	// information about enterprise features availabed on the connected auth server
	GetCluster(context.Context, *GetClusterRequest) (*Cluster, error)
	// Login logs in a user to a cluster
	Login(context.Context, *LoginRequest) (*EmptyResponse, error)
	// LoginPasswordless logs in a user to a cluster passwordlessly.
	//
	// The RPC is streaming both ways and the message sequence example for hardware keys are:
	// (-> means client-to-server, <- means server-to-client)
	//
	// Hardware keys:
	// -> Init
	// <- Send PasswordlessPrompt enum TAP to choose a device
	// -> Receive TAP device response
	// <- Send PasswordlessPrompt enum PIN
	// -> Receive PIN response
	// <- Send PasswordlessPrompt enum RETAP to confirm
	// -> Receive RETAP device response
	// <- Send list of credentials (e.g. usernames) associated with device
	// -> Receive the index number associated with the selected credential in list
	// <- End
	LoginPasswordless(grpc.BidiStreamingServer[LoginPasswordlessRequest, LoginPasswordlessResponse]) error
	// ClusterLogin logs out a user from cluster
	Logout(context.Context, *LogoutRequest) (*EmptyResponse, error)
	// TransferFile sends a request to download/upload a file
	TransferFile(*FileTransferRequest, grpc.ServerStreamingServer[FileTransferProgress]) error
	// ReportUsageEvent allows to send usage events that are then anonymized and forwarded to prehog
	ReportUsageEvent(context.Context, *ReportUsageEventRequest) (*EmptyResponse, error)
	// UpdateHeadlessAuthenticationState updates a headless authentication resource's state.
	// An MFA challenge will be prompted when approving a headless authentication.
	UpdateHeadlessAuthenticationState(context.Context, *UpdateHeadlessAuthenticationStateRequest) (*UpdateHeadlessAuthenticationStateResponse, error)
	// CreateConnectMyComputerRole creates a role which allows access to nodes with the label
	// teleport.dev/connect-my-computer/owner: <cluster user> and allows logging in to those nodes as
	// the current system user.
	CreateConnectMyComputerRole(context.Context, *CreateConnectMyComputerRoleRequest) (*CreateConnectMyComputerRoleResponse, error)
	// CreateConnectMyComputerNodeToken creates a node join token that is valid for 5 minutes
	CreateConnectMyComputerNodeToken(context.Context, *CreateConnectMyComputerNodeTokenRequest) (*CreateConnectMyComputerNodeTokenResponse, error)
	// WaitForConnectMyComputerNodeJoin sets up a watcher and returns a response only after detecting
	// that the Connect My Computer node for the particular cluster has joined the cluster (the
	// OpPut event).
	//
	// This RPC times out by itself after a minute to prevent the request from hanging forever, in
	// case the client didn't set a deadline or doesn't abort the request.
	WaitForConnectMyComputerNodeJoin(context.Context, *WaitForConnectMyComputerNodeJoinRequest) (*WaitForConnectMyComputerNodeJoinResponse, error)
	// DeleteConnectMyComputerNode deletes the Connect My Computer node.
	DeleteConnectMyComputerNode(context.Context, *DeleteConnectMyComputerNodeRequest) (*DeleteConnectMyComputerNodeResponse, error)
	// GetConnectMyComputerNodeName reads the Connect My Computer node name (UUID) from a disk.
	GetConnectMyComputerNodeName(context.Context, *GetConnectMyComputerNodeNameRequest) (*GetConnectMyComputerNodeNameResponse, error)
	// ListUnifiedResources retrieves a paginated list of all resource types displayable in the UI.
	ListUnifiedResources(context.Context, *ListUnifiedResourcesRequest) (*ListUnifiedResourcesResponse, error)
	// GetUserPreferences returns the combined (root + leaf cluster) preferences for a given user.
	GetUserPreferences(context.Context, *GetUserPreferencesRequest) (*GetUserPreferencesResponse, error)
	// UpdateUserPreferences updates the preferences for a given user in appropriate root and leaf clusters.
	// Only the properties that are set (cluster_preferences, unified_resource_preferences) will be updated.
	UpdateUserPreferences(context.Context, *UpdateUserPreferencesRequest) (*UpdateUserPreferencesResponse, error)
	// AuthenticateWebDevice blesses a web session with device trust by performing
	// the on-behalf-of device authentication ceremony.
	//
	// See
	// https://github.com/gravitational/teleport.e/blob/master/rfd/0009e-device-trust-web-support.md#device-web-authentication.
	AuthenticateWebDevice(context.Context, *AuthenticateWebDeviceRequest) (*AuthenticateWebDeviceResponse, error)
	// GetApp returns details of an app resource. It does not include information about AWS roles and
	// FQDN.
	GetApp(context.Context, *GetAppRequest) (*GetAppResponse, error)
	// ConnectToDesktop is a bidirectional stream for the desktop connection.
	ConnectToDesktop(grpc.BidiStreamingServer[ConnectToDesktopRequest, ConnectToDesktopResponse]) error
	// SetSharedDirectoryForDesktopSession opens a directory for a desktop session and enables file system operations for it.
	// If there is no active desktop session associated with the specified desktop_uri and login,
	// the RPC returns an error.
	//
	// This RPC does not automatically share the directory with the server (it does not send a SharedDirectoryAnnounce message).
	// It only registers file system handlers for processing file system-related TDP events.
	SetSharedDirectoryForDesktopSession(context.Context, *SetSharedDirectoryForDesktopSessionRequest) (*SetSharedDirectoryForDesktopSessionResponse, error)
	mustEmbedUnimplementedTerminalServiceServer()
}

// UnimplementedTerminalServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTerminalServiceServer struct{}

func (UnimplementedTerminalServiceServer) UpdateTshdEventsServerAddress(context.Context, *UpdateTshdEventsServerAddressRequest) (*UpdateTshdEventsServerAddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTshdEventsServerAddress not implemented")
}
func (UnimplementedTerminalServiceServer) ListRootClusters(context.Context, *ListClustersRequest) (*ListClustersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRootClusters not implemented")
}
func (UnimplementedTerminalServiceServer) ListLeafClusters(context.Context, *ListLeafClustersRequest) (*ListClustersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListLeafClusters not implemented")
}
func (UnimplementedTerminalServiceServer) StartHeadlessWatcher(context.Context, *StartHeadlessWatcherRequest) (*StartHeadlessWatcherResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartHeadlessWatcher not implemented")
}
func (UnimplementedTerminalServiceServer) ListDatabaseUsers(context.Context, *ListDatabaseUsersRequest) (*ListDatabaseUsersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListDatabaseUsers not implemented")
}
func (UnimplementedTerminalServiceServer) ListDatabaseServers(context.Context, *ListDatabaseServersRequest) (*ListDatabaseServersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListDatabaseServers not implemented")
}
func (UnimplementedTerminalServiceServer) GetAccessRequests(context.Context, *GetAccessRequestsRequest) (*GetAccessRequestsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAccessRequests not implemented")
}
func (UnimplementedTerminalServiceServer) GetAccessRequest(context.Context, *GetAccessRequestRequest) (*GetAccessRequestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAccessRequest not implemented")
}
func (UnimplementedTerminalServiceServer) DeleteAccessRequest(context.Context, *DeleteAccessRequestRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAccessRequest not implemented")
}
func (UnimplementedTerminalServiceServer) CreateAccessRequest(context.Context, *CreateAccessRequestRequest) (*CreateAccessRequestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAccessRequest not implemented")
}
func (UnimplementedTerminalServiceServer) ReviewAccessRequest(context.Context, *ReviewAccessRequestRequest) (*ReviewAccessRequestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReviewAccessRequest not implemented")
}
func (UnimplementedTerminalServiceServer) GetRequestableRoles(context.Context, *GetRequestableRolesRequest) (*GetRequestableRolesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRequestableRoles not implemented")
}
func (UnimplementedTerminalServiceServer) AssumeRole(context.Context, *AssumeRoleRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AssumeRole not implemented")
}
func (UnimplementedTerminalServiceServer) PromoteAccessRequest(context.Context, *PromoteAccessRequestRequest) (*PromoteAccessRequestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PromoteAccessRequest not implemented")
}
func (UnimplementedTerminalServiceServer) GetSuggestedAccessLists(context.Context, *GetSuggestedAccessListsRequest) (*GetSuggestedAccessListsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSuggestedAccessLists not implemented")
}
func (UnimplementedTerminalServiceServer) ListKubernetesResources(context.Context, *ListKubernetesResourcesRequest) (*ListKubernetesResourcesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListKubernetesResources not implemented")
}
func (UnimplementedTerminalServiceServer) AddCluster(context.Context, *AddClusterRequest) (*Cluster, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddCluster not implemented")
}
func (UnimplementedTerminalServiceServer) RemoveCluster(context.Context, *RemoveClusterRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveCluster not implemented")
}
func (UnimplementedTerminalServiceServer) ListGateways(context.Context, *ListGatewaysRequest) (*ListGatewaysResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListGateways not implemented")
}
func (UnimplementedTerminalServiceServer) CreateGateway(context.Context, *CreateGatewayRequest) (*Gateway, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateGateway not implemented")
}
func (UnimplementedTerminalServiceServer) RemoveGateway(context.Context, *RemoveGatewayRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveGateway not implemented")
}
func (UnimplementedTerminalServiceServer) SetGatewayTargetSubresourceName(context.Context, *SetGatewayTargetSubresourceNameRequest) (*Gateway, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetGatewayTargetSubresourceName not implemented")
}
func (UnimplementedTerminalServiceServer) SetGatewayLocalPort(context.Context, *SetGatewayLocalPortRequest) (*Gateway, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetGatewayLocalPort not implemented")
}
func (UnimplementedTerminalServiceServer) GetAuthSettings(context.Context, *GetAuthSettingsRequest) (*AuthSettings, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAuthSettings not implemented")
}
func (UnimplementedTerminalServiceServer) GetCluster(context.Context, *GetClusterRequest) (*Cluster, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCluster not implemented")
}
func (UnimplementedTerminalServiceServer) Login(context.Context, *LoginRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}
func (UnimplementedTerminalServiceServer) LoginPasswordless(grpc.BidiStreamingServer[LoginPasswordlessRequest, LoginPasswordlessResponse]) error {
	return status.Errorf(codes.Unimplemented, "method LoginPasswordless not implemented")
}
func (UnimplementedTerminalServiceServer) Logout(context.Context, *LogoutRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Logout not implemented")
}
func (UnimplementedTerminalServiceServer) TransferFile(*FileTransferRequest, grpc.ServerStreamingServer[FileTransferProgress]) error {
	return status.Errorf(codes.Unimplemented, "method TransferFile not implemented")
}
func (UnimplementedTerminalServiceServer) ReportUsageEvent(context.Context, *ReportUsageEventRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportUsageEvent not implemented")
}
func (UnimplementedTerminalServiceServer) UpdateHeadlessAuthenticationState(context.Context, *UpdateHeadlessAuthenticationStateRequest) (*UpdateHeadlessAuthenticationStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateHeadlessAuthenticationState not implemented")
}
func (UnimplementedTerminalServiceServer) CreateConnectMyComputerRole(context.Context, *CreateConnectMyComputerRoleRequest) (*CreateConnectMyComputerRoleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateConnectMyComputerRole not implemented")
}
func (UnimplementedTerminalServiceServer) CreateConnectMyComputerNodeToken(context.Context, *CreateConnectMyComputerNodeTokenRequest) (*CreateConnectMyComputerNodeTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateConnectMyComputerNodeToken not implemented")
}
func (UnimplementedTerminalServiceServer) WaitForConnectMyComputerNodeJoin(context.Context, *WaitForConnectMyComputerNodeJoinRequest) (*WaitForConnectMyComputerNodeJoinResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WaitForConnectMyComputerNodeJoin not implemented")
}
func (UnimplementedTerminalServiceServer) DeleteConnectMyComputerNode(context.Context, *DeleteConnectMyComputerNodeRequest) (*DeleteConnectMyComputerNodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteConnectMyComputerNode not implemented")
}
func (UnimplementedTerminalServiceServer) GetConnectMyComputerNodeName(context.Context, *GetConnectMyComputerNodeNameRequest) (*GetConnectMyComputerNodeNameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConnectMyComputerNodeName not implemented")
}
func (UnimplementedTerminalServiceServer) ListUnifiedResources(context.Context, *ListUnifiedResourcesRequest) (*ListUnifiedResourcesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListUnifiedResources not implemented")
}
func (UnimplementedTerminalServiceServer) GetUserPreferences(context.Context, *GetUserPreferencesRequest) (*GetUserPreferencesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserPreferences not implemented")
}
func (UnimplementedTerminalServiceServer) UpdateUserPreferences(context.Context, *UpdateUserPreferencesRequest) (*UpdateUserPreferencesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserPreferences not implemented")
}
func (UnimplementedTerminalServiceServer) AuthenticateWebDevice(context.Context, *AuthenticateWebDeviceRequest) (*AuthenticateWebDeviceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthenticateWebDevice not implemented")
}
func (UnimplementedTerminalServiceServer) GetApp(context.Context, *GetAppRequest) (*GetAppResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetApp not implemented")
}
func (UnimplementedTerminalServiceServer) ConnectToDesktop(grpc.BidiStreamingServer[ConnectToDesktopRequest, ConnectToDesktopResponse]) error {
	return status.Errorf(codes.Unimplemented, "method ConnectToDesktop not implemented")
}
func (UnimplementedTerminalServiceServer) SetSharedDirectoryForDesktopSession(context.Context, *SetSharedDirectoryForDesktopSessionRequest) (*SetSharedDirectoryForDesktopSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetSharedDirectoryForDesktopSession not implemented")
}
func (UnimplementedTerminalServiceServer) mustEmbedUnimplementedTerminalServiceServer() {}
func (UnimplementedTerminalServiceServer) testEmbeddedByValue()                         {}

// UnsafeTerminalServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TerminalServiceServer will
// result in compilation errors.
type UnsafeTerminalServiceServer interface {
	mustEmbedUnimplementedTerminalServiceServer()
}

func RegisterTerminalServiceServer(s grpc.ServiceRegistrar, srv TerminalServiceServer) {
	// If the following call pancis, it indicates UnimplementedTerminalServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TerminalService_ServiceDesc, srv)
}

func _TerminalService_UpdateTshdEventsServerAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTshdEventsServerAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).UpdateTshdEventsServerAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TerminalService_UpdateTshdEventsServerAddress_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).UpdateTshdEventsServerAddress(ctx, req.(*UpdateTshdEventsServerAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_ListRootClusters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListClustersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).ListRootClusters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TerminalService_ListRootClusters_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).ListRootClusters(ctx, req.(*ListClustersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_ListLeafClusters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListLeafClustersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).ListLeafClusters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TerminalService_ListLeafClusters_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).ListLeafClusters(ctx, req.(*ListLeafClustersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_StartHeadlessWatcher_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartHeadlessWatcherRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).StartHeadlessWatcher(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TerminalService_StartHeadlessWatcher_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).StartHeadlessWatcher(ctx, req.(*StartHeadlessWatcherRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_ListDatabaseUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDatabaseUsersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).ListDatabaseUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TerminalService_ListDatabaseUsers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).ListDatabaseUsers(ctx, req.(*ListDatabaseUsersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_ListDatabaseServers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDatabaseServersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).ListDatabaseServers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TerminalService_ListDatabaseServers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).ListDatabaseServers(ctx, req.(*ListDatabaseServersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_GetAccessRequests_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAccessRequestsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).GetAccessRequests(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TerminalService_GetAccessRequests_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).GetAccessRequests(ctx, req.(*GetAccessRequestsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_GetAccessRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAccessRequestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).GetAccessRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TerminalService_GetAccessRequest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).GetAccessRequest(ctx, req.(*GetAccessRequestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_DeleteAccessRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAccessRequestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).DeleteAccessRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TerminalService_DeleteAccessRequest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).DeleteAccessRequest(ctx, req.(*DeleteAccessRequestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_CreateAccessRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAccessRequestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).CreateAccessRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TerminalService_CreateAccessRequest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).CreateAccessRequest(ctx, req.(*CreateAccessRequestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_ReviewAccessRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReviewAccessRequestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).ReviewAccessRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TerminalService_ReviewAccessRequest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).ReviewAccessRequest(ctx, req.(*ReviewAccessRequestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_GetRequestableRoles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRequestableRolesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).GetRequestableRoles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TerminalService_GetRequestableRoles_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).GetRequestableRoles(ctx, req.(*GetRequestableRolesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_AssumeRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssumeRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).AssumeRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TerminalService_AssumeRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).AssumeRole(ctx, req.(*AssumeRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_PromoteAccessRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PromoteAccessRequestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).PromoteAccessRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TerminalService_PromoteAccessRequest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).PromoteAccessRequest(ctx, req.(*PromoteAccessRequestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_GetSuggestedAccessLists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSuggestedAccessListsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).GetSuggestedAccessLists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TerminalService_GetSuggestedAccessLists_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).GetSuggestedAccessLists(ctx, req.(*GetSuggestedAccessListsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_ListKubernetesResources_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListKubernetesResourcesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).ListKubernetesResources(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TerminalService_ListKubernetesResources_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).ListKubernetesResources(ctx, req.(*ListKubernetesResourcesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_AddCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddClusterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).AddCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TerminalService_AddCluster_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).AddCluster(ctx, req.(*AddClusterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_RemoveCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveClusterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).RemoveCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TerminalService_RemoveCluster_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).RemoveCluster(ctx, req.(*RemoveClusterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_ListGateways_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListGatewaysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).ListGateways(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TerminalService_ListGateways_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).ListGateways(ctx, req.(*ListGatewaysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_CreateGateway_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateGatewayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).CreateGateway(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TerminalService_CreateGateway_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).CreateGateway(ctx, req.(*CreateGatewayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_RemoveGateway_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveGatewayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).RemoveGateway(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TerminalService_RemoveGateway_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).RemoveGateway(ctx, req.(*RemoveGatewayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_SetGatewayTargetSubresourceName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetGatewayTargetSubresourceNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).SetGatewayTargetSubresourceName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TerminalService_SetGatewayTargetSubresourceName_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).SetGatewayTargetSubresourceName(ctx, req.(*SetGatewayTargetSubresourceNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_SetGatewayLocalPort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetGatewayLocalPortRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).SetGatewayLocalPort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TerminalService_SetGatewayLocalPort_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).SetGatewayLocalPort(ctx, req.(*SetGatewayLocalPortRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_GetAuthSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAuthSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).GetAuthSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TerminalService_GetAuthSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).GetAuthSettings(ctx, req.(*GetAuthSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_GetCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClusterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).GetCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TerminalService_GetCluster_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).GetCluster(ctx, req.(*GetClusterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TerminalService_Login_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).Login(ctx, req.(*LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_LoginPasswordless_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TerminalServiceServer).LoginPasswordless(&grpc.GenericServerStream[LoginPasswordlessRequest, LoginPasswordlessResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type TerminalService_LoginPasswordlessServer = grpc.BidiStreamingServer[LoginPasswordlessRequest, LoginPasswordlessResponse]

func _TerminalService_Logout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).Logout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TerminalService_Logout_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).Logout(ctx, req.(*LogoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_TransferFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FileTransferRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TerminalServiceServer).TransferFile(m, &grpc.GenericServerStream[FileTransferRequest, FileTransferProgress]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type TerminalService_TransferFileServer = grpc.ServerStreamingServer[FileTransferProgress]

func _TerminalService_ReportUsageEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportUsageEventRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).ReportUsageEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TerminalService_ReportUsageEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).ReportUsageEvent(ctx, req.(*ReportUsageEventRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_UpdateHeadlessAuthenticationState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateHeadlessAuthenticationStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).UpdateHeadlessAuthenticationState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TerminalService_UpdateHeadlessAuthenticationState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).UpdateHeadlessAuthenticationState(ctx, req.(*UpdateHeadlessAuthenticationStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_CreateConnectMyComputerRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateConnectMyComputerRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).CreateConnectMyComputerRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TerminalService_CreateConnectMyComputerRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).CreateConnectMyComputerRole(ctx, req.(*CreateConnectMyComputerRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_CreateConnectMyComputerNodeToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateConnectMyComputerNodeTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).CreateConnectMyComputerNodeToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TerminalService_CreateConnectMyComputerNodeToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).CreateConnectMyComputerNodeToken(ctx, req.(*CreateConnectMyComputerNodeTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_WaitForConnectMyComputerNodeJoin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WaitForConnectMyComputerNodeJoinRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).WaitForConnectMyComputerNodeJoin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TerminalService_WaitForConnectMyComputerNodeJoin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).WaitForConnectMyComputerNodeJoin(ctx, req.(*WaitForConnectMyComputerNodeJoinRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_DeleteConnectMyComputerNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteConnectMyComputerNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).DeleteConnectMyComputerNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TerminalService_DeleteConnectMyComputerNode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).DeleteConnectMyComputerNode(ctx, req.(*DeleteConnectMyComputerNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_GetConnectMyComputerNodeName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConnectMyComputerNodeNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).GetConnectMyComputerNodeName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TerminalService_GetConnectMyComputerNodeName_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).GetConnectMyComputerNodeName(ctx, req.(*GetConnectMyComputerNodeNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_ListUnifiedResources_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUnifiedResourcesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).ListUnifiedResources(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TerminalService_ListUnifiedResources_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).ListUnifiedResources(ctx, req.(*ListUnifiedResourcesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_GetUserPreferences_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserPreferencesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).GetUserPreferences(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TerminalService_GetUserPreferences_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).GetUserPreferences(ctx, req.(*GetUserPreferencesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_UpdateUserPreferences_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserPreferencesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).UpdateUserPreferences(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TerminalService_UpdateUserPreferences_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).UpdateUserPreferences(ctx, req.(*UpdateUserPreferencesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_AuthenticateWebDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthenticateWebDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).AuthenticateWebDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TerminalService_AuthenticateWebDevice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).AuthenticateWebDevice(ctx, req.(*AuthenticateWebDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_GetApp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAppRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).GetApp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TerminalService_GetApp_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).GetApp(ctx, req.(*GetAppRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_ConnectToDesktop_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TerminalServiceServer).ConnectToDesktop(&grpc.GenericServerStream[ConnectToDesktopRequest, ConnectToDesktopResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type TerminalService_ConnectToDesktopServer = grpc.BidiStreamingServer[ConnectToDesktopRequest, ConnectToDesktopResponse]

func _TerminalService_SetSharedDirectoryForDesktopSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetSharedDirectoryForDesktopSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).SetSharedDirectoryForDesktopSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TerminalService_SetSharedDirectoryForDesktopSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).SetSharedDirectoryForDesktopSession(ctx, req.(*SetSharedDirectoryForDesktopSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TerminalService_ServiceDesc is the grpc.ServiceDesc for TerminalService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TerminalService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "teleport.lib.teleterm.v1.TerminalService",
	HandlerType: (*TerminalServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateTshdEventsServerAddress",
			Handler:    _TerminalService_UpdateTshdEventsServerAddress_Handler,
		},
		{
			MethodName: "ListRootClusters",
			Handler:    _TerminalService_ListRootClusters_Handler,
		},
		{
			MethodName: "ListLeafClusters",
			Handler:    _TerminalService_ListLeafClusters_Handler,
		},
		{
			MethodName: "StartHeadlessWatcher",
			Handler:    _TerminalService_StartHeadlessWatcher_Handler,
		},
		{
			MethodName: "ListDatabaseUsers",
			Handler:    _TerminalService_ListDatabaseUsers_Handler,
		},
		{
			MethodName: "ListDatabaseServers",
			Handler:    _TerminalService_ListDatabaseServers_Handler,
		},
		{
			MethodName: "GetAccessRequests",
			Handler:    _TerminalService_GetAccessRequests_Handler,
		},
		{
			MethodName: "GetAccessRequest",
			Handler:    _TerminalService_GetAccessRequest_Handler,
		},
		{
			MethodName: "DeleteAccessRequest",
			Handler:    _TerminalService_DeleteAccessRequest_Handler,
		},
		{
			MethodName: "CreateAccessRequest",
			Handler:    _TerminalService_CreateAccessRequest_Handler,
		},
		{
			MethodName: "ReviewAccessRequest",
			Handler:    _TerminalService_ReviewAccessRequest_Handler,
		},
		{
			MethodName: "GetRequestableRoles",
			Handler:    _TerminalService_GetRequestableRoles_Handler,
		},
		{
			MethodName: "AssumeRole",
			Handler:    _TerminalService_AssumeRole_Handler,
		},
		{
			MethodName: "PromoteAccessRequest",
			Handler:    _TerminalService_PromoteAccessRequest_Handler,
		},
		{
			MethodName: "GetSuggestedAccessLists",
			Handler:    _TerminalService_GetSuggestedAccessLists_Handler,
		},
		{
			MethodName: "ListKubernetesResources",
			Handler:    _TerminalService_ListKubernetesResources_Handler,
		},
		{
			MethodName: "AddCluster",
			Handler:    _TerminalService_AddCluster_Handler,
		},
		{
			MethodName: "RemoveCluster",
			Handler:    _TerminalService_RemoveCluster_Handler,
		},
		{
			MethodName: "ListGateways",
			Handler:    _TerminalService_ListGateways_Handler,
		},
		{
			MethodName: "CreateGateway",
			Handler:    _TerminalService_CreateGateway_Handler,
		},
		{
			MethodName: "RemoveGateway",
			Handler:    _TerminalService_RemoveGateway_Handler,
		},
		{
			MethodName: "SetGatewayTargetSubresourceName",
			Handler:    _TerminalService_SetGatewayTargetSubresourceName_Handler,
		},
		{
			MethodName: "SetGatewayLocalPort",
			Handler:    _TerminalService_SetGatewayLocalPort_Handler,
		},
		{
			MethodName: "GetAuthSettings",
			Handler:    _TerminalService_GetAuthSettings_Handler,
		},
		{
			MethodName: "GetCluster",
			Handler:    _TerminalService_GetCluster_Handler,
		},
		{
			MethodName: "Login",
			Handler:    _TerminalService_Login_Handler,
		},
		{
			MethodName: "Logout",
			Handler:    _TerminalService_Logout_Handler,
		},
		{
			MethodName: "ReportUsageEvent",
			Handler:    _TerminalService_ReportUsageEvent_Handler,
		},
		{
			MethodName: "UpdateHeadlessAuthenticationState",
			Handler:    _TerminalService_UpdateHeadlessAuthenticationState_Handler,
		},
		{
			MethodName: "CreateConnectMyComputerRole",
			Handler:    _TerminalService_CreateConnectMyComputerRole_Handler,
		},
		{
			MethodName: "CreateConnectMyComputerNodeToken",
			Handler:    _TerminalService_CreateConnectMyComputerNodeToken_Handler,
		},
		{
			MethodName: "WaitForConnectMyComputerNodeJoin",
			Handler:    _TerminalService_WaitForConnectMyComputerNodeJoin_Handler,
		},
		{
			MethodName: "DeleteConnectMyComputerNode",
			Handler:    _TerminalService_DeleteConnectMyComputerNode_Handler,
		},
		{
			MethodName: "GetConnectMyComputerNodeName",
			Handler:    _TerminalService_GetConnectMyComputerNodeName_Handler,
		},
		{
			MethodName: "ListUnifiedResources",
			Handler:    _TerminalService_ListUnifiedResources_Handler,
		},
		{
			MethodName: "GetUserPreferences",
			Handler:    _TerminalService_GetUserPreferences_Handler,
		},
		{
			MethodName: "UpdateUserPreferences",
			Handler:    _TerminalService_UpdateUserPreferences_Handler,
		},
		{
			MethodName: "AuthenticateWebDevice",
			Handler:    _TerminalService_AuthenticateWebDevice_Handler,
		},
		{
			MethodName: "GetApp",
			Handler:    _TerminalService_GetApp_Handler,
		},
		{
			MethodName: "SetSharedDirectoryForDesktopSession",
			Handler:    _TerminalService_SetSharedDirectoryForDesktopSession_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "LoginPasswordless",
			Handler:       _TerminalService_LoginPasswordless_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "TransferFile",
			Handler:       _TerminalService_TransferFile_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ConnectToDesktop",
			Handler:       _TerminalService_ConnectToDesktop_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "teleport/lib/teleterm/v1/service.proto",
}
